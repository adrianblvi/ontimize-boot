(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/platform-browser'), require('@angular/platform-browser/animations'), require('@angular/animations'), require('@angular/forms'), require('moment'), require('@angular/router'), require('@angular/common/http'), require('@angular/material'), require('@angular/material-moment-adapter'), require('@angular/flex-layout'), require('@ngx-translate/core'), require('@ngx-translate/http-loader'), require('@angular/http'), require('@angular/platform-browser-dynamic')) :
	typeof define === 'function' && define.amd ? define('ontimize-web-ngx', ['exports', '@angular/core', '@angular/common', '@angular/platform-browser', '@angular/platform-browser/animations', '@angular/animations', '@angular/forms', 'moment', '@angular/router', '@angular/common/http', '@angular/material', '@angular/material-moment-adapter', '@angular/flex-layout', '@ngx-translate/core', '@ngx-translate/http-loader', '@angular/http', '@angular/platform-browser-dynamic'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.ontimizeWeb = {}),global.ng.core,global.ng.common,global.ng.platformBrowser,global.ng.platformBrowser.animations,global.ng.animations,global.ng.forms,global.moment,global.ng.router,global.ng.common.http,global.ng.material,global.ng.materialMomentAdapter,global.ng.flexLayout,global.ng.translateCore,global.ng.translateHttpLoader,global.ng.http,global.ng.platformBrowserDynamic));
}(this, (function (exports,core,common,platformBrowser,animations,animations$1,forms,moment__default,router,http,material,materialMomentAdapter,flexLayout,core$1,httpLoader,http$1,platformBrowserDynamic) { 'use strict';

var moment__default__default = moment__default['default'];

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
    return typeof x === 'function';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
    setTimeout(function () { throw err; });
}

/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError(err);
        }
    },
    complete: function () { }
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
    return x != null && typeof x === 'object';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var errorObject = { e: {} };

/** PURE_IMPORTS_START _errorObject PURE_IMPORTS_END */
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject.e = e;
        return errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function UnsubscriptionErrorImpl(errors) {
    Error.call(this);
    this.message = errors ?
        errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
    this.name = 'UnsubscriptionError';
    this.errors = errors;
    return this;
}
UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
var UnsubscriptionError = UnsubscriptionErrorImpl;

/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_tryCatch,_util_errorObject,_util_UnsubscriptionError PURE_IMPORTS_END */
var Subscription = /*@__PURE__*/ (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        while (_parent) {
            _parent.remove(this);
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction(_unsubscribe)) {
            var trial = tryCatch(_unsubscribe).call(this);
            if (trial === errorObject) {
                hasErrors = true;
                errors = errors || (errorObject.e instanceof UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]);
            }
        }
        if (isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject(sub)) {
                    var trial = tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject.e;
                        if (err instanceof UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function') {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            this._parent = parent;
        }
        else if (!_parents) {
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = typeof Symbol === 'function'
    ? /*@__PURE__*/ Symbol('rxSubscriber')
    : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();

/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
var Subscriber = /*@__PURE__*/ (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        _this._parentSubscription = null;
        switch (arguments.length) {
            case 0:
                _this.destination = empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        this._parentSubscription = null;
        return this;
    };
    return Subscriber;
}(Subscription));
var SafeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== empty) {
                context = Object.create(observerOrNext);
                if (isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}

/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber]) {
            return nextOrObserver[rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber(empty);
    }
    return new Subscriber(nextOrObserver, error, complete);
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() { }

/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */
function pipeFromArray(fns) {
    if (!fns) {
        return noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}

/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
var Observable = /*@__PURE__*/ (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable$$1 = new Observable();
        observable$$1.source = this;
        observable$$1.operator = operator;
        return observable$$1;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function ObjectUnsubscribedErrorImpl() {
    Error.call(this);
    this.message = 'object unsubscribed';
    this.name = 'ObjectUnsubscribedError';
    return this;
}
ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var SubjectSubscription = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber));
var Subject = /*@__PURE__*/ (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable));
var AnonymousSubject = /*@__PURE__*/ (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
var ConnectableObservable = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription.EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount()(this);
    };
    return ConnectableObservable;
}(Observable));
var connectableProto = ConnectableObservable.prototype;
var connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
};
var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(SubjectSubscriber));
var RefCountSubscriber$1 = /*@__PURE__*/ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount$$1 = connectable._refCount;
        if (refCount$$1 <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount$$1 - 1;
        if (refCount$$1 > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */
var GroupBySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber));
var GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber));
var GroupedObservable = /*@__PURE__*/ (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable));
var InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */
var BehaviorSubject = /*@__PURE__*/ (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject));

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var Action = /*@__PURE__*/ (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
var AsyncAction = /*@__PURE__*/ (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action));

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var QueueAction = /*@__PURE__*/ (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction));

var Scheduler = /*@__PURE__*/ (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());

/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
var AsyncScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var QueueScheduler = /*@__PURE__*/ (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
var queue = /*@__PURE__*/ new QueueScheduler(QueueAction);

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });
function empty$1(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
    return function (subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        if (!subscriber.closed) {
            subscriber.complete();
        }
    };
};

/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */
function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToArray(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var i = 0;
            sub.add(scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                    return;
                }
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    sub.add(this.schedule());
                }
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function scalar(value) {
    var result = new Observable(function (subscriber) {
        subscriber.next(value);
        subscriber.complete();
    });
    result._isScalar = true;
    result.value = value;
    return result;
}

/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */
function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler(scheduler)) {
        args.pop();
    }
    else {
        scheduler = undefined;
    }
    switch (args.length) {
        case 0:
            return empty$1(scheduler);
        case 1:
            return scheduler ? fromArray(args, scheduler) : scalar(args[0]);
        default:
            return fromArray(args, scheduler);
    }
}

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}

/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */
var Notification = /*@__PURE__*/ (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return of(this.value);
            case 'E':
                return throwError(this.error);
            case 'C':
                return empty$1();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());

/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
var ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification.createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification.createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber));
var ObserveOnMessage = /*@__PURE__*/ (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());

/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
var ReplaySubject = /*@__PURE__*/ (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
            bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime === void 0) {
            windowTime = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject));
var ReplayEvent = /*@__PURE__*/ (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */
var AsyncSubject = /*@__PURE__*/ (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;
var tasksByHandle = {};
function runIfPresent(handle) {
    var cb = tasksByHandle[handle];
    if (cb) {
        cb();
    }
}
var Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        tasksByHandle[handle] = cb;
        Promise.resolve().then(function () { return runIfPresent(handle); });
        return handle;
    },
    clearImmediate: function (handle) {
        delete tasksByHandle[handle];
    },
};

/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */
var AsapAction = /*@__PURE__*/ (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(AsyncAction));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AsapScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
var asap = /*@__PURE__*/ new AsapScheduler(AsapAction);

/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var async = /*@__PURE__*/ new AsyncScheduler(AsyncAction);

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var AnimationFrameAction = /*@__PURE__*/ (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
var animationFrame = /*@__PURE__*/ new AnimationFrameScheduler(AnimationFrameAction);

/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
            SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
            maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler));
var VirtualAction = /*@__PURE__*/ (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) {
            index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function identity(x) {
    return x;
}

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function ArgumentOutOfRangeErrorImpl() {
    Error.call(this);
    this.message = 'argument out of range';
    this.name = 'ArgumentOutOfRangeError';
    return this;
}
ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function EmptyErrorImpl() {
    Error.call(this);
    this.message = 'no elements in sequence';
    this.name = 'EmptyError';
    return this;
}
EmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
var EmptyError = EmptyErrorImpl;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
var MapOperator = /*@__PURE__*/ (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
var MapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var OuterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var InnerSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
var subscribeToPromise = function (promise) {
    return function (subscriber) {
        promise.then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, hostReportError);
        return subscriber;
    };
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = /*@__PURE__*/ getSymbolIterator();

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
var subscribeToIterable = function (iterable) {
    return function (subscriber) {
        var iterator$$1 = iterable[iterator]();
        do {
            var item = iterator$$1.next();
            if (item.done) {
                subscriber.complete();
                break;
            }
            subscriber.next(item.value);
            if (subscriber.closed) {
                break;
            }
        } while (true);
        if (typeof iterator$$1.return === 'function') {
            subscriber.add(function () {
                if (iterator$$1.return) {
                    iterator$$1.return();
                }
            });
        }
        return subscriber;
    };
};

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
var subscribeToObservable = function (obj) {
    return function (subscriber) {
        var obs = obj[observable]();
        if (typeof obs.subscribe !== 'function') {
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        }
        else {
            return obs.subscribe(subscriber);
        }
    };
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}

/** PURE_IMPORTS_START _Observable,_subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
var subscribeTo = function (result) {
    if (result instanceof Observable) {
        return function (subscriber) {
            if (result._isScalar) {
                subscriber.next(result.value);
                subscriber.complete();
                return undefined;
            }
            else {
                return result.subscribe(subscriber);
            }
        };
    }
    else if (result && typeof result[observable] === 'function') {
        return subscribeToObservable(result);
    }
    else if (isArrayLike(result)) {
        return subscribeToArray(result);
    }
    else if (isPromise(result)) {
        return subscribeToPromise(result);
    }
    else if (result && typeof result[iterator] === 'function') {
        return subscribeToIterable(result);
    }
    else {
        var value = isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};

/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
    if (destination === void 0) {
        destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    }
    if (destination.closed) {
        return;
    }
    return subscribeTo(result)(destination);
}

/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */
var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = null;
    var scheduler = null;
    if (isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && isArray(observables[0])) {
        observables = observables[0];
    }
    return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /*@__PURE__*/ (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
var CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
function isInteropObservable(input) {
    return input && typeof input[observable] === 'function';
}

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
function isIterable(input) {
    return input && typeof input[iterator] === 'function';
}

/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */
function fromPromise(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToPromise(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                return input.then(function (value) {
                    sub.add(scheduler.schedule(function () {
                        subscriber.next(value);
                        sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                    }));
                }, function (err) {
                    sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
                });
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */
function fromIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    if (!scheduler) {
        return new Observable(subscribeToIterable(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var iterator$$1;
            sub.add(function () {
                if (iterator$$1 && typeof iterator$$1.return === 'function') {
                    iterator$$1.return();
                }
            });
            sub.add(scheduler.schedule(function () {
                iterator$$1 = input[iterator]();
                sub.add(scheduler.schedule(function () {
                    if (subscriber.closed) {
                        return;
                    }
                    var value;
                    var done;
                    try {
                        var result = iterator$$1.next();
                        value = result.value;
                        done = result.done;
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(value);
                        this.schedule();
                    }
                }));
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */
function fromObservable(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToObservable(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                var observable$$1 = input[observable]();
                sub.add(observable$$1.subscribe({
                    next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                    error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                    complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
                }));
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */
function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable) {
            return input;
        }
        return new Observable(subscribeTo(input));
    }
    if (input != null) {
        if (isInteropObservable(input)) {
            return fromObservable(input, scheduler);
        }
        else if (isPromise(input)) {
            return fromPromise(input, scheduler);
        }
        else if (isArrayLike(input)) {
            return fromArray(input, scheduler);
        }
        else if (isIterable(input) || typeof input === 'string') {
            return fromIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}

/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
var MergeMapOperator = /*@__PURE__*/ (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        subscribeToResult(this, ish, value, index, innerSubscriber);
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return mergeMap(identity, concurrent);
}

/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */
function concatAll() {
    return mergeAll(1);
}

/** PURE_IMPORTS_START _util_isScheduler,_of,_from,_operators_concatAll PURE_IMPORTS_END */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1 || (observables.length === 2 && isScheduler(observables[1]))) {
        return from(observables[0]);
    }
    return concatAll()(of.apply(void 0, observables));
}

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Observable,_util_isArray,_empty,_util_subscribeToResult,_OuterSubscriber,_operators_map PURE_IMPORTS_END */
var ForkJoinSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ForkJoinSubscriber, _super);
    function ForkJoinSubscriber(destination, sources) {
        var _this = _super.call(this, destination) || this;
        _this.sources = sources;
        _this.completed = 0;
        _this.haveValues = 0;
        var len = sources.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            var source = sources[i];
            var innerSubscription = subscribeToResult(_this, source, null, i);
            if (innerSubscription) {
                _this.add(innerSubscription);
            }
        }
        return _this;
    }
    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        if (!innerSub._hasValue) {
            innerSub._hasValue = true;
            this.haveValues++;
        }
    };
    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
        var _a = this, destination = _a.destination, haveValues = _a.haveValues, values = _a.values;
        var len = values.length;
        if (!innerSub._hasValue) {
            destination.complete();
            return;
        }
        this.completed++;
        if (this.completed !== len) {
            return;
        }
        if (haveValues === len) {
            destination.next(values);
        }
        destination.complete();
    };
    return ForkJoinSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */

/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */

/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
function isNumeric(val) {
    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;
}

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
        return observables[0];
    }
    return mergeAll(concurrent)(fromArray(observables, scheduler));
}

/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var RaceSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) {
        dueTime = 0;
    }
    var period = -1;
    if (isNumeric(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!isScheduler(scheduler)) {
        scheduler = async;
    }
    return new Observable(function (subscriber) {
        var due = isNumeric(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch$7, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
function dispatch$7(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */
var ZipSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
        _this.values = values;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            if (iterator$$1.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator$$1.subscribe(iterator$$1, i));
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            var result = iterator$$1.next();
            if (iterator$$1.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber));
var StaticIterator = /*@__PURE__*/ (function () {
    function StaticIterator(iterator$$1) {
        this.iterator = iterator$$1;
        this.nextResult = iterator$$1.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = /*@__PURE__*/ (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = /*@__PURE__*/ (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[iterator] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function audit(durationSelector) {
    return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
    };
}
var AuditOperator = /*@__PURE__*/ (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
var AuditSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = tryCatch(this.durationSelector)(value);
            if (duration === errorObject) {
                this.destination.error(errorObject.e);
            }
            else {
                var innerSubscription = subscribeToResult(this, duration);
                if (!innerSubscription || innerSubscription.closed) {
                    this.clearThrottle();
                }
                else {
                    this.add(this.throttled = innerSubscription);
                }
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */
function auditTime(duration, scheduler) {
    if (scheduler === void 0) {
        scheduler = async;
    }
    return audit(function () { return timer(duration, scheduler); });
}

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var BufferSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(subscribeToResult(_this, closingNotifier));
        return _this;
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var BufferCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber));
var BufferSkipCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */
var Context = /*@__PURE__*/ (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
var BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}

/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */
var BufferToggleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult(_this, openings));
        return _this;
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_1 = contexts.shift();
            context_1.subscription.unsubscribe();
            context_1.buffer = null;
            context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            this.destination.next(context_2.buffer);
            context_2.subscription.unsubscribe();
            context_2.buffer = null;
            context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscription,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var BufferWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier = tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject) {
            this.error(errorObject.e);
        }
        else {
            closingSubscription = new Subscription();
            this.closingSubscription = closingSubscription;
            this.add(closingSubscription);
            this.subscribing = true;
            closingSubscription.add(subscribeToResult(this, closingNotifier));
            this.subscribing = false;
        }
    };
    return BufferWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var CatchSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
            this.add(innerSubscriber);
            subscribeToResult(this, result, undefined, undefined, innerSubscriber);
        }
    };
    return CatchSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */

/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var CountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var DebounceSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        _this.durationSubscription = null;
        return _this;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = subscribeToResult(this, duration);
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = async;
    }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
var DebounceTimeOperator = /*@__PURE__*/ (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$2, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber));
function dispatchNext$2(subscriber) {
    subscriber.debouncedNext();
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}

/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */
function delay(delay, scheduler) {
    if (scheduler === void 0) {
        scheduler = async;
    }
    var absoluteDelay = isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
var DelayOperator = /*@__PURE__*/ (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var DelaySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification.createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(Subscriber));
var DelayMessage = /*@__PURE__*/ (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());

/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        var index = this.index++;
        try {
            var delayNotifier = this.delayDurationSelector(value, index);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            var destination = this.destination;
            destination.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber));
var SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {
    __extends(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable));
var SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.unsubscribe();
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var DeMaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var DistinctSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
            _this.add(subscribeToResult(_this, flushes));
        }
        return _this;
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */
function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch(this.keySelector)(value);
            if (key === errorObject) {
                return this.destination.error(errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch(this.compare)(this.key, key);
            if (result === errorObject) {
                return this.destination.error(errorObject.e);
            }
        }
        else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var FilterOperator = /*@__PURE__*/ (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
var DoOperator = /*@__PURE__*/ (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop;
        _this._tapError = noop;
        _this._tapComplete = noop;
        _this._tapError = error || noop;
        _this._tapComplete = complete || noop;
        if (isFunction(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || noop;
            _this._tapError = observerOrNext.error || noop;
            _this._tapComplete = observerOrNext.complete || noop;
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _tap,_util_EmptyError PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
function take(count) {
    return function (source) {
        if (count === 0) {
            return empty$1();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
var TakeOperator = /*@__PURE__*/ (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var EverySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var SwitchFirstSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(subscribeToResult(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
var ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.hasSubscription = true;
        this._innerSub(result, value, index);
    };
    ExhaustMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        subscribeToResult(this, result, value, index, innerSubscriber);
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var ExpandSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            _this.buffer = [];
        }
        return _this;
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            var result = tryCatch(this.project)(value, index);
            if (result === errorObject) {
                destination.error(errorObject.e);
            }
            else if (!this.scheduler) {
                this.subscribeToProjection(result, value, index);
            }
            else {
                var state = { subscriber: this, result: result, value: value, index: index };
                var destination_1 = this.destination;
                destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add(subscribeToResult(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        var destination = this.destination;
        destination.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */
var FinallySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription(callback));
        return _this;
    }
    return FinallySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var FindValueSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var IsEmptySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
var TakeLastSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var MapToSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
var MaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var ScanSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */

/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber PURE_IMPORTS_END */
var MergeScanSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var ish = tryCatch(this.accumulator)(this.acc, value);
            var destination = this.destination;
            if (ish === errorObject) {
                destination.error(errorObject.e);
            }
            else {
                this.active++;
                this._innerSub(ish, value, index);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        subscribeToResult(this, ish, value, index, innerSubscriber);
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        var destination = this.destination;
        destination.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
var MulticastOperator = /*@__PURE__*/ (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());

/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var OnErrorResumeNextSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (next) {
            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
            var destination = this.destination;
            destination.add(innerSubscriber);
            subscribeToResult(this, next, undefined, undefined, innerSubscriber);
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */

/** PURE_IMPORTS_START _map PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */

/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */

/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */

/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */
var RepeatSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var RepeatWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next();
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject();
        var retries = tryCatch(this.notifier)(this.notifications);
        if (retries === errorObject) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = subscribeToResult(this, retries);
    };
    return RepeatWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var RetrySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var RetryWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject();
                retries = tryCatch(this.notifier)(errors);
                if (retries === errorObject) {
                    return _super.prototype.error.call(this, errorObject.e);
                }
                retriesSubscription = subscribeToResult(this, retries);
            }
            else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var SampleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
var SampleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
        return _this;
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}

/** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */
var SequenceEqualSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparor) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparor = comparor;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
        this.unsubscribe();
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            if (comparor) {
                areEqual = tryCatch(comparor)(a, b);
                if (areEqual === errorObject) {
                    this.destination.error(errorObject.e);
                }
            }
            else {
                areEqual = a === b;
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype.completeB = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber));
var SequenceEqualCompareToSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
        this.unsubscribe();
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent.completeB();
        this.unsubscribe();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
function shareSubjectFactory() {
    return new Subject();
}
function share() {
    return function (source) { return refCount()(multicast(shareSubjectFactory)(source)); };
}

/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */
var SingleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var SkipSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */
var SkipLastSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var SkipUntilSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new InnerSubscriber(_this, undefined, undefined);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        subscribeToResult(_this, notifier, undefined, undefined, innerSubscriber);
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
    };
    return SkipUntilSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    return function (source) {
        var scheduler = array[array.length - 1];
        if (isScheduler(scheduler)) {
            array.pop();
        }
        else {
            scheduler = null;
        }
        var len = array.length;
        if (len === 1 && !scheduler) {
            return concat(scalar(array[0]), source);
        }
        else if (len > 0) {
            return concat(fromArray(array, scheduler), source);
        }
        else {
            return concat(empty$1(scheduler), source);
        }
    };
}

/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */
var SubscribeOnObservable = /*@__PURE__*/ (function (_super) {
    __extends(SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) {
            delayTime = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap;
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = asap;
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) {
            delay = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap;
        }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable));

/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
var SwitchMapOperator = /*@__PURE__*/ (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = subscribeToResult(this, result, value, index, innerSubscriber);
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */

/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
var TakeUntilOperator = /*@__PURE__*/ (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier);
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = null;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (duration) {
            this.add(this._throttled = subscribeToResult(this, duration));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = null;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */
var ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext$3, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber));
function dispatchNext$3(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.action = null;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(subscribeToResult(subscriber, withObservable));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */

/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var WindowSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject();
        destination.next(_this.window);
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */
var WindowCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
var CountedSubject = /*@__PURE__*/ (function (_super) {
    __extends(CountedSubject, _super);
    function CountedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject));
var WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: _this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}

/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var WindowToggleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
        return _this;
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingSelector = this.closingSelector;
            var closingNotifier = tryCatch(closingSelector)(innerValue);
            if (closingNotifier === errorObject) {
                return this.error(errorObject.e);
            }
            else {
                var window_1 = new Subject();
                var subscription = new Subscription();
                var context_4 = { window: window_1, subscription: subscription };
                this.contexts.push(context_4);
                var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
                if (innerSubscription.closed) {
                    this.closeWindow(this.contexts.length - 1);
                }
                else {
                    innerSubscription.context = context_4;
                    subscription.add(innerSubscription);
                }
                this.destination.next(window_1);
            }
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var WindowSubscriber$1 = /*@__PURE__*/ (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) {
            innerSub = null;
        }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject();
        this.destination.next(window);
        var closingNotifier = tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject) {
            var err = errorObject.e;
            this.destination.error(err);
            this.window.error(err);
        }
        else {
            this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
        }
    };
    return WindowSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
var WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(subscribeToResult(_this, observable, observable, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * Coerces a data-bound value (typically a string) to a boolean.
 * @param {?} value
 * @return {?}
 */
function coerceBooleanProperty(value) {
    return value != null && "" + value !== 'false';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @param {?} value
 * @param {?=} fallbackValue
 * @return {?}
 */
function coerceNumberProperty(value, fallbackValue) {
    if (fallbackValue === void 0) { fallbackValue = 0; }
    return _isNumberValue(value) ? Number(value) : fallbackValue;
}
/**
 * Whether the provided value is considered a number.
 * \@docs-private
 * @param {?} value
 * @return {?}
 */
function _isNumberValue(value) {
    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,
    // and other non-number values as NaN, where Number just uses 0) but it considers the string
    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.
    return !isNaN(parseFloat(/** @type {?} */ (value))) && !isNaN(Number(value));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * Wraps the provided value in an array, unless the provided value is an array.
 * @template T
 * @param {?} value
 * @return {?}
 */
function coerceArray(value) {
    return Array.isArray(value) ? value : [value];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * Coerces a value to a CSS pixel value.
 * @param {?} value
 * @return {?}
 */
function coerceCssPixelValue(value) {
    if (value == null) {
        return '';
    }
    return typeof value === 'string' ? value : value + "px";
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Whether the current platform supports the V8 Break Iterator. The V8 check
// is necessary to detect all Blink based browsers.
var /** @type {?} */ hasV8BreakIterator = (typeof Intl !== 'undefined' && (/** @type {?} */ (Intl)).v8BreakIterator);
/**
 * Service to detect the current platform by comparing the userAgent strings and
 * checking browser-specific global properties.
 */
var Platform = /** @class */ (function () {
    /**
     * @breaking-change v7.0.0 remove optional decorator
     */
    function Platform(_platformId) {
        this._platformId = _platformId;
        /**
         * Whether the Angular application is being rendered in the browser.
         * We want to use the Angular platform check because if the Document is shimmed
         * without the navigator, the following checks will fail. This is preferred because
         * sometimes the Document may be shimmed without the user's knowledge or intention
         */
        this.isBrowser = this._platformId ?
            common.isPlatformBrowser(this._platformId) : typeof document === 'object' && !!document;
        /**
         * Whether the current browser is Microsoft Edge.
         */
        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
        /**
         * Whether the current rendering engine is Microsoft Trident.
         */
        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
        /**
         * Whether the current rendering engine is Blink.
         */
        this.BLINK = this.isBrowser && (!!((/** @type {?} */ (window)).chrome || hasV8BreakIterator) &&
            typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);
        /**
         * Whether the current rendering engine is WebKit.
         */
        this.WEBKIT = this.isBrowser &&
            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
        /**
         * Whether the current platform is Apple iOS.
         */
        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&
            !(/** @type {?} */ (window)).MSStream;
        /**
         * Whether the current browser is Firefox.
         */
        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
        /**
         * Whether the current platform is Android.
         */
        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
        /**
         * Whether the current browser is Safari.
         */
        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
    }
    Platform.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    Platform.ctorParameters = function () { return [
        { type: Object, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.PLATFORM_ID,] },] },
    ]; };
    /** @nocollapse */ Platform.ngInjectableDef = core.defineInjectable({ factory: function Platform_Factory() { return new Platform(core.inject(core.PLATFORM_ID, 8)); }, token: Platform, providedIn: "root" });
    return Platform;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * Cached result of whether the user's browser supports passive event listeners.
 */
var /** @type {?} */ supportsPassiveEvents;
/**
 * Checks whether the user's browser supports passive event listeners.
 * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
 * @return {?}
 */
function supportsPassiveEventListeners() {
    if (supportsPassiveEvents == null && typeof window !== 'undefined') {
        try {
            window.addEventListener('test', /** @type {?} */ ((null)), Object.defineProperty({}, 'passive', {
                get: function () { return supportsPassiveEvents = true; }
            }));
        }
        finally {
            supportsPassiveEvents = supportsPassiveEvents || false;
        }
    }
    return supportsPassiveEvents;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PlatformModule = /** @class */ (function () {
    function PlatformModule() {
    }
    PlatformModule.decorators = [
        { type: core.NgModule },
    ];
    return PlatformModule;
}());

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Time in ms to throttle the scrolling events by default.
 */
var /** @type {?} */ DEFAULT_SCROLL_TIME = 20;
/**
 * Service contained all registered Scrollable references and emits an event when any one of the
 * Scrollable references emit a scrolled event.
 */
var ScrollDispatcher = /** @class */ (function () {
    function ScrollDispatcher(_ngZone, _platform) {
        this._ngZone = _ngZone;
        this._platform = _platform;
        /**
         * Subject for notifying that a registered scrollable reference element has been scrolled.
         */
        this._scrolled = new Subject();
        /**
         * Keeps track of the global `scroll` and `resize` subscriptions.
         */
        this._globalSubscription = null;
        /**
         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.
         */
        this._scrolledCount = 0;
        /**
         * Map of all the scrollable references that are registered with the service and their
         * scroll event subscriptions.
         */
        this.scrollContainers = new Map();
    }
    /**
     * Registers a scrollable instance with the service and listens for its scrolled events. When the
     * scrollable is scrolled, the service emits the event to its scrolled observable.
     * @param scrollable Scrollable instance to be registered.
     */
    /**
     * Registers a scrollable instance with the service and listens for its scrolled events. When the
     * scrollable is scrolled, the service emits the event to its scrolled observable.
     * @param {?} scrollable Scrollable instance to be registered.
     * @return {?}
     */
    ScrollDispatcher.prototype.register = /**
     * Registers a scrollable instance with the service and listens for its scrolled events. When the
     * scrollable is scrolled, the service emits the event to its scrolled observable.
     * @param {?} scrollable Scrollable instance to be registered.
     * @return {?}
     */
    function (scrollable) {
        var _this = this;
        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled()
            .subscribe(function () { return _this._scrolled.next(scrollable); });
        this.scrollContainers.set(scrollable, scrollSubscription);
    };
    /**
     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
     * @param scrollable Scrollable instance to be deregistered.
     */
    /**
     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
     * @param {?} scrollable Scrollable instance to be deregistered.
     * @return {?}
     */
    ScrollDispatcher.prototype.deregister = /**
     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
     * @param {?} scrollable Scrollable instance to be deregistered.
     * @return {?}
     */
    function (scrollable) {
        var /** @type {?} */ scrollableReference = this.scrollContainers.get(scrollable);
        if (scrollableReference) {
            scrollableReference.unsubscribe();
            this.scrollContainers.delete(scrollable);
        }
    };
    /**
     * Returns an observable that emits an event whenever any of the registered Scrollable
     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
     * to override the default "throttle" time.
     *
     * **Note:** in order to avoid hitting change detection for every scroll event,
     * all of the events emitted from this stream will be run outside the Angular zone.
     * If you need to update any data bindings as a result of a scroll event, you have
     * to run the callback using `NgZone.run`.
     */
    /**
     * Returns an observable that emits an event whenever any of the registered Scrollable
     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
     * to override the default "throttle" time.
     *
     * **Note:** in order to avoid hitting change detection for every scroll event,
     * all of the events emitted from this stream will be run outside the Angular zone.
     * If you need to update any data bindings as a result of a scroll event, you have
     * to run the callback using `NgZone.run`.
     * @param {?=} auditTimeInMs
     * @return {?}
     */
    ScrollDispatcher.prototype.scrolled = /**
     * Returns an observable that emits an event whenever any of the registered Scrollable
     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
     * to override the default "throttle" time.
     *
     * **Note:** in order to avoid hitting change detection for every scroll event,
     * all of the events emitted from this stream will be run outside the Angular zone.
     * If you need to update any data bindings as a result of a scroll event, you have
     * to run the callback using `NgZone.run`.
     * @param {?=} auditTimeInMs
     * @return {?}
     */
    function (auditTimeInMs) {
        var _this = this;
        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }
        return this._platform.isBrowser ? Observable.create(function (observer) {
            if (!_this._globalSubscription) {
                _this._addGlobalListener();
            }
            // In the case of a 0ms delay, use an observable without auditTime
            // since it does add a perceptible delay in processing overhead.
            var /** @type {?} */ subscription = auditTimeInMs > 0 ?
                _this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :
                _this._scrolled.subscribe(observer);
            _this._scrolledCount++;
            return function () {
                subscription.unsubscribe();
                _this._scrolledCount--;
                if (!_this._scrolledCount) {
                    _this._removeGlobalListener();
                }
            };
        }) : of();
    };
    /**
     * @return {?}
     */
    ScrollDispatcher.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._removeGlobalListener();
        this.scrollContainers.forEach(function (_, container) { return _this.deregister(container); });
        this._scrolled.complete();
    };
    /**
     * Returns an observable that emits whenever any of the
     * scrollable ancestors of an element are scrolled.
     * @param elementRef Element whose ancestors to listen for.
     * @param auditTimeInMs Time to throttle the scroll events.
     */
    /**
     * Returns an observable that emits whenever any of the
     * scrollable ancestors of an element are scrolled.
     * @param {?} elementRef Element whose ancestors to listen for.
     * @param {?=} auditTimeInMs Time to throttle the scroll events.
     * @return {?}
     */
    ScrollDispatcher.prototype.ancestorScrolled = /**
     * Returns an observable that emits whenever any of the
     * scrollable ancestors of an element are scrolled.
     * @param {?} elementRef Element whose ancestors to listen for.
     * @param {?=} auditTimeInMs Time to throttle the scroll events.
     * @return {?}
     */
    function (elementRef, auditTimeInMs) {
        var /** @type {?} */ ancestors = this.getAncestorScrollContainers(elementRef);
        return this.scrolled(auditTimeInMs).pipe(filter(function (target) {
            return !target || ancestors.indexOf(target) > -1;
        }));
    };
    /** Returns all registered Scrollables that contain the provided element. */
    /**
     * Returns all registered Scrollables that contain the provided element.
     * @param {?} elementRef
     * @return {?}
     */
    ScrollDispatcher.prototype.getAncestorScrollContainers = /**
     * Returns all registered Scrollables that contain the provided element.
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        var _this = this;
        var /** @type {?} */ scrollingContainers = [];
        this.scrollContainers.forEach(function (_subscription, scrollable) {
            if (_this._scrollableContainsElement(scrollable, elementRef)) {
                scrollingContainers.push(scrollable);
            }
        });
        return scrollingContainers;
    };
    /**
     * Returns true if the element is contained within the provided Scrollable.
     * @param {?} scrollable
     * @param {?} elementRef
     * @return {?}
     */
    ScrollDispatcher.prototype._scrollableContainsElement = /**
     * Returns true if the element is contained within the provided Scrollable.
     * @param {?} scrollable
     * @param {?} elementRef
     * @return {?}
     */
    function (scrollable, elementRef) {
        var /** @type {?} */ element = elementRef.nativeElement;
        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;
        // Traverse through the element parents until we reach null, checking if any of the elements
        // are the scrollable's element.
        do {
            if (element == scrollableElement) {
                return true;
            }
        } while (element = /** @type {?} */ ((element)).parentElement);
        return false;
    };
    /**
     * Sets up the global scroll listeners.
     * @return {?}
     */
    ScrollDispatcher.prototype._addGlobalListener = /**
     * Sets up the global scroll listeners.
     * @return {?}
     */
    function () {
        var _this = this;
        this._globalSubscription = this._ngZone.runOutsideAngular(function () {
            return fromEvent(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });
        });
    };
    /**
     * Cleans up the global scroll listener.
     * @return {?}
     */
    ScrollDispatcher.prototype._removeGlobalListener = /**
     * Cleans up the global scroll listener.
     * @return {?}
     */
    function () {
        if (this._globalSubscription) {
            this._globalSubscription.unsubscribe();
            this._globalSubscription = null;
        }
    };
    ScrollDispatcher.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    ScrollDispatcher.ctorParameters = function () { return [
        { type: core.NgZone, },
        { type: Platform, },
    ]; };
    /** @nocollapse */ ScrollDispatcher.ngInjectableDef = core.defineInjectable({ factory: function ScrollDispatcher_Factory() { return new ScrollDispatcher(core.inject(core.NgZone), core.inject(Platform)); }, token: ScrollDispatcher, providedIn: "root" });
    return ScrollDispatcher;
}());
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 * @param {?} parentDispatcher
 * @param {?} ngZone
 * @param {?} platform
 * @return {?}
 */
function SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {
    return parentDispatcher || new ScrollDispatcher(ngZone, platform);
}
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 */
var /** @type {?} */ SCROLL_DISPATCHER_PROVIDER = {
    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.
    provide: ScrollDispatcher,
    deps: [[new core.Optional(), new core.SkipSelf(), ScrollDispatcher], core.NgZone, Platform],
    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Sends an event when the directive's element is scrolled. Registers itself with the
 * ScrollDispatcher service to include itself as part of its collection of scrolling events that it
 * can be listened to through the service.
 */
var CdkScrollable = /** @class */ (function () {
    function CdkScrollable(_elementRef, _scroll, _ngZone) {
        var _this = this;
        this._elementRef = _elementRef;
        this._scroll = _scroll;
        this._ngZone = _ngZone;
        this._elementScrolled = new Subject();
        this._scrollListener = function (event) { return _this._elementScrolled.next(event); };
    }
    /**
     * @return {?}
     */
    CdkScrollable.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._ngZone.runOutsideAngular(function () {
            _this.getElementRef().nativeElement.addEventListener('scroll', _this._scrollListener);
        });
        this._scroll.register(this);
    };
    /**
     * @return {?}
     */
    CdkScrollable.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._scroll.deregister(this);
        if (this._scrollListener) {
            this.getElementRef().nativeElement.removeEventListener('scroll', this._scrollListener);
        }
        this._elementScrolled.complete();
    };
    /**
     * Returns observable that emits when a scroll event is fired on the host element.
     */
    /**
     * Returns observable that emits when a scroll event is fired on the host element.
     * @return {?}
     */
    CdkScrollable.prototype.elementScrolled = /**
     * Returns observable that emits when a scroll event is fired on the host element.
     * @return {?}
     */
    function () {
        return this._elementScrolled.asObservable();
    };
    /**
     * @return {?}
     */
    CdkScrollable.prototype.getElementRef = /**
     * @return {?}
     */
    function () {
        return this._elementRef;
    };
    CdkScrollable.decorators = [
        { type: core.Directive, args: [{
                    selector: '[cdk-scrollable], [cdkScrollable]'
                },] },
    ];
    /** @nocollapse */
    CdkScrollable.ctorParameters = function () { return [
        { type: core.ElementRef, },
        { type: ScrollDispatcher, },
        { type: core.NgZone, },
    ]; };
    return CdkScrollable;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Time in ms to throttle the resize events by default.
 */
var /** @type {?} */ DEFAULT_RESIZE_TIME = 20;
/**
 * Simple utility for getting the bounds of the browser viewport.
 * \@docs-private
 */
var ViewportRuler = /** @class */ (function () {
    function ViewportRuler(_platform, ngZone) {
        var _this = this;
        this._platform = _platform;
        this._change = _platform.isBrowser ? ngZone.runOutsideAngular(function () {
            return merge(fromEvent(window, 'resize'), fromEvent(window, 'orientationchange'));
        }) : of();
        this._invalidateCache = this.change().subscribe(function () { return _this._updateViewportSize(); });
    }
    /**
     * @return {?}
     */
    ViewportRuler.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._invalidateCache.unsubscribe();
    };
    /** Returns the viewport's width and height. */
    /**
     * Returns the viewport's width and height.
     * @return {?}
     */
    ViewportRuler.prototype.getViewportSize = /**
     * Returns the viewport's width and height.
     * @return {?}
     */
    function () {
        if (!this._viewportSize) {
            this._updateViewportSize();
        }
        var /** @type {?} */ output = { width: this._viewportSize.width, height: this._viewportSize.height };
        // If we're not on a browser, don't cache the size since it'll be mocked out anyway.
        if (!this._platform.isBrowser) {
            this._viewportSize = /** @type {?} */ ((null));
        }
        return output;
    };
    /** Gets a ClientRect for the viewport's bounds. */
    /**
     * Gets a ClientRect for the viewport's bounds.
     * @return {?}
     */
    ViewportRuler.prototype.getViewportRect = /**
     * Gets a ClientRect for the viewport's bounds.
     * @return {?}
     */
    function () {
        // Use the document element's bounding rect rather than the window scroll properties
        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll
        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different
        // conceptual viewports. Under most circumstances these viewports are equivalent, but they
        // can disagree when the page is pinch-zoomed (on devices that support touch).
        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4
        // We use the documentElement instead of the body because, by default (without a css reset)
        // browsers typically give the document body an 8px margin, which is not included in
        // getBoundingClientRect().
        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition();
        var _a = this.getViewportSize(), width = _a.width, height = _a.height;
        return {
            top: scrollPosition.top,
            left: scrollPosition.left,
            bottom: scrollPosition.top + height,
            right: scrollPosition.left + width,
            height: height,
            width: width,
        };
    };
    /** Gets the (top, left) scroll position of the viewport. */
    /**
     * Gets the (top, left) scroll position of the viewport.
     * @return {?}
     */
    ViewportRuler.prototype.getViewportScrollPosition = /**
     * Gets the (top, left) scroll position of the viewport.
     * @return {?}
     */
    function () {
        // While we can get a reference to the fake document
        // during SSR, it doesn't have getBoundingClientRect.
        if (!this._platform.isBrowser) {
            return { top: 0, left: 0 };
        }
        // The top-left-corner of the viewport is determined by the scroll position of the document
        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about
        // whether `document.body` or `document.documentElement` is the scrolled element, so reading
        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of
        // `document.documentElement` works consistently, where the `top` and `left` values will
        // equal negative the scroll position.
        var /** @type {?} */ documentRect = document.documentElement.getBoundingClientRect();
        var /** @type {?} */ top = -documentRect.top || document.body.scrollTop || window.scrollY ||
            document.documentElement.scrollTop || 0;
        var /** @type {?} */ left = -documentRect.left || document.body.scrollLeft || window.scrollX ||
            document.documentElement.scrollLeft || 0;
        return { top: top, left: left };
    };
    /**
     * Returns a stream that emits whenever the size of the viewport changes.
     * @param throttleTime Time in milliseconds to throttle the stream.
     */
    /**
     * Returns a stream that emits whenever the size of the viewport changes.
     * @param {?=} throttleTime Time in milliseconds to throttle the stream.
     * @return {?}
     */
    ViewportRuler.prototype.change = /**
     * Returns a stream that emits whenever the size of the viewport changes.
     * @param {?=} throttleTime Time in milliseconds to throttle the stream.
     * @return {?}
     */
    function (throttleTime$$1) {
        if (throttleTime$$1 === void 0) { throttleTime$$1 = DEFAULT_RESIZE_TIME; }
        return throttleTime$$1 > 0 ? this._change.pipe(auditTime(throttleTime$$1)) : this._change;
    };
    /**
     * Updates the cached viewport size.
     * @return {?}
     */
    ViewportRuler.prototype._updateViewportSize = /**
     * Updates the cached viewport size.
     * @return {?}
     */
    function () {
        this._viewportSize = this._platform.isBrowser ?
            { width: window.innerWidth, height: window.innerHeight } :
            { width: 0, height: 0 };
    };
    ViewportRuler.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    ViewportRuler.ctorParameters = function () { return [
        { type: Platform, },
        { type: core.NgZone, },
    ]; };
    /** @nocollapse */ ViewportRuler.ngInjectableDef = core.defineInjectable({ factory: function ViewportRuler_Factory() { return new ViewportRuler(core.inject(Platform), core.inject(core.NgZone)); }, token: ViewportRuler, providedIn: "root" });
    return ViewportRuler;
}());
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 * @param {?} parentRuler
 * @param {?} platform
 * @param {?} ngZone
 * @return {?}
 */
function VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {
    return parentRuler || new ViewportRuler(platform, ngZone);
}
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 */
var /** @type {?} */ VIEWPORT_RULER_PROVIDER = {
    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.
    provide: ViewportRuler,
    deps: [[new core.Optional(), new core.SkipSelf(), ViewportRuler], Platform, core.NgZone],
    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ScrollDispatchModule = /** @class */ (function () {
    function ScrollDispatchModule() {
    }
    ScrollDispatchModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [PlatformModule],
                    exports: [CdkScrollable],
                    declarations: [CdkScrollable],
                },] },
    ];
    return ScrollDispatchModule;
}());

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Injection token used to inject the document into Directionality.
 * This is used so that the value can be faked in tests.
 *
 * We can't use the real document in tests because changing the real `dir` causes geometry-based
 * tests in Safari to fail.
 *
 * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests
 * themselves use things like `querySelector` in test code.
 *
 * This token is defined in a separate file from Directionality as a workaround for
 * https://github.com/angular/angular/issues/22559
 *
 * \@docs-private
 */
var /** @type {?} */ DIR_DOCUMENT = new core.InjectionToken('cdk-dir-doc', {
    providedIn: 'root',
    factory: DIR_DOCUMENT_FACTORY,
});
/**
 * \@docs-private
 * @return {?}
 */
function DIR_DOCUMENT_FACTORY() {
    return core.inject(common.DOCUMENT);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * The directionality (LTR / RTL) context for the application (or a subtree of it).
 * Exposes the current direction and a stream of direction changes.
 */
var Directionality = /** @class */ (function () {
    function Directionality(_document) {
        /**
         * The current 'ltr' or 'rtl' value.
         */
        this.value = 'ltr';
        /**
         * Stream that emits whenever the 'ltr' / 'rtl' state changes.
         */
        this.change = new core.EventEmitter();
        if (_document) {
            // TODO: handle 'auto' value -
            // We still need to account for dir="auto".
            // It looks like HTMLElemenet.dir is also "auto" when that's set to the attribute,
            // but getComputedStyle return either "ltr" or "rtl". avoiding getComputedStyle for now
            var /** @type {?} */ bodyDir = _document.body ? _document.body.dir : null;
            var /** @type {?} */ htmlDir = _document.documentElement ? _document.documentElement.dir : null;
            var /** @type {?} */ value = bodyDir || htmlDir;
            this.value = (value === 'ltr' || value === 'rtl') ? value : 'ltr';
        }
    }
    /**
     * @return {?}
     */
    Directionality.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.change.complete();
    };
    Directionality.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    Directionality.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DIR_DOCUMENT,] },] },
    ]; };
    /** @nocollapse */ Directionality.ngInjectableDef = core.defineInjectable({ factory: function Directionality_Factory() { return new Directionality(core.inject(DIR_DOCUMENT, 8)); }, token: Directionality, providedIn: "root" });
    return Directionality;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Directive to listen for changes of direction of part of the DOM.
 *
 * Provides itself as Directionality such that descendant directives only need to ever inject
 * Directionality to get the closest direction.
 */
var Dir = /** @class */ (function () {
    function Dir() {
        this._dir = 'ltr';
        /**
         * Whether the `value` has been set to its initial value.
         */
        this._isInitialized = false;
        /**
         * Event emitted when the direction changes.
         */
        this.change = new core.EventEmitter();
    }
    Object.defineProperty(Dir.prototype, "dir", {
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () { return this._dir; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var /** @type {?} */ old = this._dir;
            this._dir = (value === 'ltr' || value === 'rtl') ? value : 'ltr';
            if (old !== this._dir && this._isInitialized) {
                this.change.emit(this._dir);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dir.prototype, "value", {
        /** Current layout direction of the element. */
        get: /**
         * Current layout direction of the element.
         * @return {?}
         */
        function () { return this.dir; },
        enumerable: true,
        configurable: true
    });
    /** Initialize once default value has been set. */
    /**
     * Initialize once default value has been set.
     * @return {?}
     */
    Dir.prototype.ngAfterContentInit = /**
     * Initialize once default value has been set.
     * @return {?}
     */
    function () {
        this._isInitialized = true;
    };
    /**
     * @return {?}
     */
    Dir.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.change.complete();
    };
    Dir.decorators = [
        { type: core.Directive, args: [{
                    selector: '[dir]',
                    providers: [{ provide: Directionality, useExisting: Dir }],
                    host: { '[dir]': 'dir' },
                    exportAs: 'dir',
                },] },
    ];
    /** @nocollapse */
    Dir.propDecorators = {
        "change": [{ type: core.Output, args: ['dirChange',] },],
        "dir": [{ type: core.Input },],
    };
    return Dir;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var BidiModule = /** @class */ (function () {
    function BidiModule() {
    }
    BidiModule.decorators = [
        { type: core.NgModule, args: [{
                    exports: [Dir],
                    declarations: [Dir],
                },] },
    ];
    return BidiModule;
}());

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * Throws an exception when attempting to attach a null portal to a host.
 * \@docs-private
 * @return {?}
 */
function throwNullPortalError() {
    throw Error('Must provide a portal to attach');
}
/**
 * Throws an exception when attempting to attach a portal to a host that is already attached.
 * \@docs-private
 * @return {?}
 */
function throwPortalAlreadyAttachedError() {
    throw Error('Host already has a portal attached');
}
/**
 * Throws an exception when attempting to attach a portal to an already-disposed host.
 * \@docs-private
 * @return {?}
 */
function throwPortalOutletAlreadyDisposedError() {
    throw Error('This PortalOutlet has already been disposed');
}
/**
 * Throws an exception when attempting to attach an unknown portal type.
 * \@docs-private
 * @return {?}
 */
function throwUnknownPortalTypeError() {
    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +
        'a ComponentPortal or a TemplatePortal.');
}
/**
 * Throws an exception when attempting to attach a portal to a null host.
 * \@docs-private
 * @return {?}
 */
function throwNullPortalOutletError() {
    throw Error('Attempting to attach a portal to a null PortalOutlet');
}
/**
 * Throws an exception when attempting to detach a portal that is not attached.
 * \@docs-private
 * @return {?}
 */
function throwNoPortalAttachedError() {
    throw Error('Attempting to detach a portal that is not attached to a host');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A `Portal` is something that you want to render somewhere else.
 * It can be attach to / detached from a `PortalOutlet`.
 * @abstract
 * @template T
 */
var  /**
 * A `Portal` is something that you want to render somewhere else.
 * It can be attach to / detached from a `PortalOutlet`.
 * @abstract
 * @template T
 */
Portal = /** @class */ (function () {
    function Portal() {
    }
    /** Attach this portal to a host. */
    /**
     * Attach this portal to a host.
     * @param {?} host
     * @return {?}
     */
    Portal.prototype.attach = /**
     * Attach this portal to a host.
     * @param {?} host
     * @return {?}
     */
    function (host) {
        if (host == null) {
            throwNullPortalOutletError();
        }
        if (host.hasAttached()) {
            throwPortalAlreadyAttachedError();
        }
        this._attachedHost = host;
        return /** @type {?} */ (host.attach(this));
    };
    /** Detach this portal from its host */
    /**
     * Detach this portal from its host
     * @return {?}
     */
    Portal.prototype.detach = /**
     * Detach this portal from its host
     * @return {?}
     */
    function () {
        var /** @type {?} */ host = this._attachedHost;
        if (host == null) {
            throwNoPortalAttachedError();
        }
        else {
            this._attachedHost = null;
            host.detach();
        }
    };
    Object.defineProperty(Portal.prototype, "isAttached", {
        /** Whether this portal is attached to a host. */
        get: /**
         * Whether this portal is attached to a host.
         * @return {?}
         */
        function () {
            return this._attachedHost != null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
     * the PortalOutlet when it is performing an `attach()` or `detach()`.
     */
    /**
     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
     * the PortalOutlet when it is performing an `attach()` or `detach()`.
     * @param {?} host
     * @return {?}
     */
    Portal.prototype.setAttachedHost = /**
     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
     * the PortalOutlet when it is performing an `attach()` or `detach()`.
     * @param {?} host
     * @return {?}
     */
    function (host) {
        this._attachedHost = host;
    };
    return Portal;
}());
/**
 * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
 * @template T
 */
var  /**
 * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
 * @template T
 */
ComponentPortal = /** @class */ (function (_super) {
    __extends(ComponentPortal, _super);
    function ComponentPortal(component, viewContainerRef, injector) {
        var _this = _super.call(this) || this;
        _this.component = component;
        _this.viewContainerRef = viewContainerRef;
        _this.injector = injector;
        return _this;
    }
    return ComponentPortal;
}(Portal));
/**
 * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
 * @template C
 */
var  /**
 * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
 * @template C
 */
TemplatePortal = /** @class */ (function (_super) {
    __extends(TemplatePortal, _super);
    function TemplatePortal(template, viewContainerRef, context) {
        var _this = _super.call(this) || this;
        _this.templateRef = template;
        _this.viewContainerRef = viewContainerRef;
        _this.context = context;
        return _this;
    }
    Object.defineProperty(TemplatePortal.prototype, "origin", {
        get: /**
         * @return {?}
         */
        function () {
            return this.templateRef.elementRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Attach the the portal to the provided `PortalOutlet`.
     * When a context is provided it will override the `context` property of the `TemplatePortal`
     * instance.
     */
    /**
     * Attach the the portal to the provided `PortalOutlet`.
     * When a context is provided it will override the `context` property of the `TemplatePortal`
     * instance.
     * @param {?} host
     * @param {?=} context
     * @return {?}
     */
    TemplatePortal.prototype.attach = /**
     * Attach the the portal to the provided `PortalOutlet`.
     * When a context is provided it will override the `context` property of the `TemplatePortal`
     * instance.
     * @param {?} host
     * @param {?=} context
     * @return {?}
     */
    function (host, context) {
        if (context === void 0) { context = this.context; }
        this.context = context;
        return _super.prototype.attach.call(this, host);
    };
    /**
     * @return {?}
     */
    TemplatePortal.prototype.detach = /**
     * @return {?}
     */
    function () {
        this.context = undefined;
        return _super.prototype.detach.call(this);
    };
    return TemplatePortal;
}(Portal));
/**
 * Partial implementation of PortalOutlet that handles attaching
 * ComponentPortal and TemplatePortal.
 * @abstract
 */
var  /**
 * Partial implementation of PortalOutlet that handles attaching
 * ComponentPortal and TemplatePortal.
 * @abstract
 */
BasePortalOutlet = /** @class */ (function () {
    function BasePortalOutlet() {
        /**
         * Whether this host has already been permanently disposed.
         */
        this._isDisposed = false;
    }
    /** Whether this host has an attached portal. */
    /**
     * Whether this host has an attached portal.
     * @return {?}
     */
    BasePortalOutlet.prototype.hasAttached = /**
     * Whether this host has an attached portal.
     * @return {?}
     */
    function () {
        return !!this._attachedPortal;
    };
    /** Attaches a portal. */
    /**
     * Attaches a portal.
     * @param {?} portal
     * @return {?}
     */
    BasePortalOutlet.prototype.attach = /**
     * Attaches a portal.
     * @param {?} portal
     * @return {?}
     */
    function (portal) {
        if (!portal) {
            throwNullPortalError();
        }
        if (this.hasAttached()) {
            throwPortalAlreadyAttachedError();
        }
        if (this._isDisposed) {
            throwPortalOutletAlreadyDisposedError();
        }
        if (portal instanceof ComponentPortal) {
            this._attachedPortal = portal;
            return this.attachComponentPortal(portal);
        }
        else if (portal instanceof TemplatePortal) {
            this._attachedPortal = portal;
            return this.attachTemplatePortal(portal);
        }
        throwUnknownPortalTypeError();
    };
    /** Detaches a previously attached portal. */
    /**
     * Detaches a previously attached portal.
     * @return {?}
     */
    BasePortalOutlet.prototype.detach = /**
     * Detaches a previously attached portal.
     * @return {?}
     */
    function () {
        if (this._attachedPortal) {
            this._attachedPortal.setAttachedHost(null);
            this._attachedPortal = null;
        }
        this._invokeDisposeFn();
    };
    /** Permanently dispose of this portal host. */
    /**
     * Permanently dispose of this portal host.
     * @return {?}
     */
    BasePortalOutlet.prototype.dispose = /**
     * Permanently dispose of this portal host.
     * @return {?}
     */
    function () {
        if (this.hasAttached()) {
            this.detach();
        }
        this._invokeDisposeFn();
        this._isDisposed = true;
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    BasePortalOutlet.prototype.setDisposeFn = /**
     * \@docs-private
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._disposeFn = fn;
    };
    /**
     * @return {?}
     */
    BasePortalOutlet.prototype._invokeDisposeFn = /**
     * @return {?}
     */
    function () {
        if (this._disposeFn) {
            this._disposeFn();
            this._disposeFn = null;
        }
    };
    return BasePortalOutlet;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
 * application context.
 */
var  /**
 * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
 * application context.
 */
DomPortalOutlet = /** @class */ (function (_super) {
    __extends(DomPortalOutlet, _super);
    function DomPortalOutlet(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {
        var _this = _super.call(this) || this;
        _this.outletElement = outletElement;
        _this._componentFactoryResolver = _componentFactoryResolver;
        _this._appRef = _appRef;
        _this._defaultInjector = _defaultInjector;
        return _this;
    }
    /**
     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
     * @param portal Portal to be attached
     * @returns Reference to the created component.
     */
    /**
     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
     * @template T
     * @param {?} portal Portal to be attached
     * @return {?} Reference to the created component.
     */
    DomPortalOutlet.prototype.attachComponentPortal = /**
     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
     * @template T
     * @param {?} portal Portal to be attached
     * @return {?} Reference to the created component.
     */
    function (portal) {
        var _this = this;
        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);
        var /** @type {?} */ componentRef;
        // If the portal specifies a ViewContainerRef, we will use that as the attachment point
        // for the component (in terms of Angular's component tree, not rendering).
        // When the ViewContainerRef is missing, we use the factory to create the component directly
        // and then manually attach the view to the application.
        if (portal.viewContainerRef) {
            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);
            this.setDisposeFn(function () { return componentRef.destroy(); });
        }
        else {
            componentRef = componentFactory.create(portal.injector || this._defaultInjector);
            this._appRef.attachView(componentRef.hostView);
            this.setDisposeFn(function () {
                _this._appRef.detachView(componentRef.hostView);
                componentRef.destroy();
            });
        }
        // At this point the component has been instantiated, so we move it to the location in the DOM
        // where we want it to be rendered.
        this.outletElement.appendChild(this._getComponentRootNode(componentRef));
        return componentRef;
    };
    /**
     * Attaches a template portal to the DOM as an embedded view.
     * @param portal Portal to be attached.
     * @returns Reference to the created embedded view.
     */
    /**
     * Attaches a template portal to the DOM as an embedded view.
     * @template C
     * @param {?} portal Portal to be attached.
     * @return {?} Reference to the created embedded view.
     */
    DomPortalOutlet.prototype.attachTemplatePortal = /**
     * Attaches a template portal to the DOM as an embedded view.
     * @template C
     * @param {?} portal Portal to be attached.
     * @return {?} Reference to the created embedded view.
     */
    function (portal) {
        var _this = this;
        var /** @type {?} */ viewContainer = portal.viewContainerRef;
        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);
        viewRef.detectChanges();
        // The method `createEmbeddedView` will add the view as a child of the viewContainer.
        // But for the DomPortalOutlet the view can be added everywhere in the DOM
        // (e.g Overlay Container) To move the view to the specified host element. We just
        // re-append the existing root nodes.
        viewRef.rootNodes.forEach(function (rootNode) { return _this.outletElement.appendChild(rootNode); });
        this.setDisposeFn((function () {
            var /** @type {?} */ index = viewContainer.indexOf(viewRef);
            if (index !== -1) {
                viewContainer.remove(index);
            }
        }));
        // TODO(jelbourn): Return locals from view.
        return viewRef;
    };
    /**
     * Clears out a portal from the DOM.
     */
    /**
     * Clears out a portal from the DOM.
     * @return {?}
     */
    DomPortalOutlet.prototype.dispose = /**
     * Clears out a portal from the DOM.
     * @return {?}
     */
    function () {
        _super.prototype.dispose.call(this);
        if (this.outletElement.parentNode != null) {
            this.outletElement.parentNode.removeChild(this.outletElement);
        }
    };
    /**
     * Gets the root HTMLElement for an instantiated component.
     * @param {?} componentRef
     * @return {?}
     */
    DomPortalOutlet.prototype._getComponentRootNode = /**
     * Gets the root HTMLElement for an instantiated component.
     * @param {?} componentRef
     * @return {?}
     */
    function (componentRef) {
        return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);
    };
    return DomPortalOutlet;
}(BasePortalOutlet));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,
 * the directive instance itself can be attached to a host, enabling declarative use of portals.
 */
var CdkPortal = /** @class */ (function (_super) {
    __extends(CdkPortal, _super);
    function CdkPortal(templateRef, viewContainerRef) {
        return _super.call(this, templateRef, viewContainerRef) || this;
    }
    CdkPortal.decorators = [
        { type: core.Directive, args: [{
                    selector: '[cdk-portal], [cdkPortal], [portal]',
                    exportAs: 'cdkPortal',
                },] },
    ];
    /** @nocollapse */
    CdkPortal.ctorParameters = function () { return [
        { type: core.TemplateRef, },
        { type: core.ViewContainerRef, },
    ]; };
    return CdkPortal;
}(TemplatePortal));
/**
 * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be
 * directly attached to it, enabling declarative use.
 *
 * Usage:
 * `<ng-template [cdkPortalOutlet]="greeting"></ng-template>`
 */
var CdkPortalOutlet = /** @class */ (function (_super) {
    __extends(CdkPortalOutlet, _super);
    function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {
        var _this = _super.call(this) || this;
        _this._componentFactoryResolver = _componentFactoryResolver;
        _this._viewContainerRef = _viewContainerRef;
        /**
         * Whether the portal component is initialized.
         */
        _this._isInitialized = false;
        _this.attached = new core.EventEmitter();
        return _this;
    }
    Object.defineProperty(CdkPortalOutlet.prototype, "portal", {
        /** Portal associated with the Portal outlet. */
        get: /**
         * Portal associated with the Portal outlet.
         * @return {?}
         */
        function () {
            return this._attachedPortal;
        },
        set: /**
         * @param {?} portal
         * @return {?}
         */
        function (portal) {
            // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have
            // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`
            // and attach a portal programmatically in the parent component. When Angular does the first CD
            // round, it will fire the setter with empty string, causing the user's content to be cleared.
            if (this.hasAttached() && !portal && !this._isInitialized) {
                return;
            }
            if (this.hasAttached()) {
                _super.prototype.detach.call(this);
            }
            if (portal) {
                _super.prototype.attach.call(this, portal);
            }
            this._attachedPortal = portal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkPortalOutlet.prototype, "attachedRef", {
        /** Component or view reference that is attached to the portal. */
        get: /**
         * Component or view reference that is attached to the portal.
         * @return {?}
         */
        function () {
            return this._attachedRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CdkPortalOutlet.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._isInitialized = true;
    };
    /**
     * @return {?}
     */
    CdkPortalOutlet.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.dispose.call(this);
        this._attachedPortal = null;
        this._attachedRef = null;
    };
    /**
     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
     *
     * @param portal Portal to be attached to the portal outlet.
     * @returns Reference to the created component.
     */
    /**
     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
     *
     * @template T
     * @param {?} portal Portal to be attached to the portal outlet.
     * @return {?} Reference to the created component.
     */
    CdkPortalOutlet.prototype.attachComponentPortal = /**
     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
     *
     * @template T
     * @param {?} portal Portal to be attached to the portal outlet.
     * @return {?} Reference to the created component.
     */
    function (portal) {
        portal.setAttachedHost(this);
        // If the portal specifies an origin, use that as the logical location of the component
        // in the application tree. Otherwise use the location of this PortalOutlet.
        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?
            portal.viewContainerRef :
            this._viewContainerRef;
        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);
        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);
        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });
        this._attachedPortal = portal;
        this._attachedRef = ref;
        this.attached.emit(ref);
        return ref;
    };
    /**
     * Attach the given TemplatePortal to this PortlHost as an embedded View.
     * @param portal Portal to be attached.
     * @returns Reference to the created embedded view.
     */
    /**
     * Attach the given TemplatePortal to this PortlHost as an embedded View.
     * @template C
     * @param {?} portal Portal to be attached.
     * @return {?} Reference to the created embedded view.
     */
    CdkPortalOutlet.prototype.attachTemplatePortal = /**
     * Attach the given TemplatePortal to this PortlHost as an embedded View.
     * @template C
     * @param {?} portal Portal to be attached.
     * @return {?} Reference to the created embedded view.
     */
    function (portal) {
        var _this = this;
        portal.setAttachedHost(this);
        var /** @type {?} */ viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);
        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });
        this._attachedPortal = portal;
        this._attachedRef = viewRef;
        this.attached.emit(viewRef);
        return viewRef;
    };
    CdkPortalOutlet.decorators = [
        { type: core.Directive, args: [{
                    selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',
                    exportAs: 'cdkPortalOutlet, cdkPortalHost',
                    inputs: ['portal: cdkPortalOutlet']
                },] },
    ];
    /** @nocollapse */
    CdkPortalOutlet.ctorParameters = function () { return [
        { type: core.ComponentFactoryResolver, },
        { type: core.ViewContainerRef, },
    ]; };
    CdkPortalOutlet.propDecorators = {
        "attached": [{ type: core.Output },],
    };
    return CdkPortalOutlet;
}(BasePortalOutlet));
var PortalModule = /** @class */ (function () {
    function PortalModule() {
    }
    PortalModule.decorators = [
        { type: core.NgModule, args: [{
                    exports: [CdkPortal, CdkPortalOutlet],
                    declarations: [CdkPortal, CdkPortalOutlet],
                },] },
    ];
    return PortalModule;
}());

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var /** @type {?} */ TAB = 9;
var /** @type {?} */ ENTER = 13;
var /** @type {?} */ ESCAPE = 27;
var /** @type {?} */ SPACE = 32;
var /** @type {?} */ LEFT_ARROW = 37;
var /** @type {?} */ UP_ARROW = 38;
var /** @type {?} */ RIGHT_ARROW = 39;
var /** @type {?} */ DOWN_ARROW = 40;
var /** @type {?} */ ZERO = 48;
var /** @type {?} */ NINE = 57;
var /** @type {?} */ A = 65;
var /** @type {?} */ Z = 90;

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * Scroll strategy that doesn't do anything.
 */
var  /**
 * Scroll strategy that doesn't do anything.
 */
NoopScrollStrategy = /** @class */ (function () {
    function NoopScrollStrategy() {
    }
    /** Does nothing, as this scroll strategy is a no-op. */
    /**
     * Does nothing, as this scroll strategy is a no-op.
     * @return {?}
     */
    NoopScrollStrategy.prototype.enable = /**
     * Does nothing, as this scroll strategy is a no-op.
     * @return {?}
     */
    function () { };
    /** Does nothing, as this scroll strategy is a no-op. */
    /**
     * Does nothing, as this scroll strategy is a no-op.
     * @return {?}
     */
    NoopScrollStrategy.prototype.disable = /**
     * Does nothing, as this scroll strategy is a no-op.
     * @return {?}
     */
    function () { };
    /** Does nothing, as this scroll strategy is a no-op. */
    /**
     * Does nothing, as this scroll strategy is a no-op.
     * @return {?}
     */
    NoopScrollStrategy.prototype.attach = /**
     * Does nothing, as this scroll strategy is a no-op.
     * @return {?}
     */
    function () { };
    return NoopScrollStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Initial configuration used when creating an overlay.
 */
var  /**
 * Initial configuration used when creating an overlay.
 */
OverlayConfig = /** @class */ (function () {
    function OverlayConfig(config$$1) {
        var _this = this;
        /**
         * Strategy to be used when handling scroll events while the overlay is open.
         */
        this.scrollStrategy = new NoopScrollStrategy();
        /**
         * Custom class to add to the overlay pane.
         */
        this.panelClass = '';
        /**
         * Whether the overlay has a backdrop.
         */
        this.hasBackdrop = false;
        /**
         * Custom class to add to the backdrop
         */
        this.backdropClass = 'cdk-overlay-dark-backdrop';
        if (config$$1) {
            Object.keys(config$$1)
                .filter(function (key) { return typeof config$$1[key] !== 'undefined'; })
                .forEach(function (key) { return _this[key] = config$$1[key]; });
        }
    }
    return OverlayConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * The points of the origin element and the overlay element to connect.
 */
var  /**
 * The points of the origin element and the overlay element to connect.
 */
ConnectionPositionPair = /** @class */ (function () {
    function ConnectionPositionPair(origin, overlay, offsetX, offsetY) {
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.originX = origin.originX;
        this.originY = origin.originY;
        this.overlayX = overlay.overlayX;
        this.overlayY = overlay.overlayY;
    }
    return ConnectionPositionPair;
}());
/**
 * Set of properties regarding the position of the origin and overlay relative to the viewport
 * with respect to the containing Scrollable elements.
 *
 * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the
 * bounds of any one of the strategy's Scrollable's bounding client rectangle.
 *
 * The overlay and origin are outside view if there is no overlap between their bounding client
 * rectangle and any one of the strategy's Scrollable's bounding client rectangle.
 *
 *       -----------                    -----------
 *       | outside |                    | clipped |
 *       |  view   |              --------------------------
 *       |         |              |     |         |        |
 *       ----------               |     -----------        |
 *  --------------------------    |                        |
 *  |                        |    |      Scrollable        |
 *  |                        |    |                        |
 *  |                        |     --------------------------
 *  |      Scrollable        |
 *  |                        |
 *  --------------------------
 *
 *  \@docs-private
 */
var  /**
 * Set of properties regarding the position of the origin and overlay relative to the viewport
 * with respect to the containing Scrollable elements.
 *
 * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the
 * bounds of any one of the strategy's Scrollable's bounding client rectangle.
 *
 * The overlay and origin are outside view if there is no overlap between their bounding client
 * rectangle and any one of the strategy's Scrollable's bounding client rectangle.
 *
 *       -----------                    -----------
 *       | outside |                    | clipped |
 *       |  view   |              --------------------------
 *       |         |              |     |         |        |
 *       ----------               |     -----------        |
 *  --------------------------    |                        |
 *  |                        |    |      Scrollable        |
 *  |                        |    |                        |
 *  |                        |     --------------------------
 *  |      Scrollable        |
 *  |                        |
 *  --------------------------
 *
 *  \@docs-private
 */
ScrollingVisibility = /** @class */ (function () {
    function ScrollingVisibility() {
    }
    return ScrollingVisibility;
}());
/**
 * The change event emitted by the strategy when a fallback position is used.
 */
var ConnectedOverlayPositionChange = /** @class */ (function () {
    function ConnectedOverlayPositionChange(connectionPair, /** @docs-private */
    scrollableViewProperties) {
        this.connectionPair = connectionPair;
        this.scrollableViewProperties = scrollableViewProperties;
    }
    /** @nocollapse */
    ConnectedOverlayPositionChange.ctorParameters = function () { return [
        { type: ConnectionPositionPair, },
        { type: ScrollingVisibility, decorators: [{ type: core.Optional },] },
    ]; };
    return ConnectedOverlayPositionChange;
}());
/**
 * Validates whether a vertical position property matches the expected values.
 * \@docs-private
 * @param {?} property Name of the property being validated.
 * @param {?} value Value of the property being validated.
 * @return {?}
 */
function validateVerticalPosition(property, value) {
    if (value !== 'top' && value !== 'bottom' && value !== 'center') {
        throw Error("ConnectedPosition: Invalid " + property + " \"" + value + "\". " +
            "Expected \"top\", \"bottom\" or \"center\".");
    }
}
/**
 * Validates whether a horizontal position property matches the expected values.
 * \@docs-private
 * @param {?} property Name of the property being validated.
 * @param {?} value Value of the property being validated.
 * @return {?}
 */
function validateHorizontalPosition(property, value) {
    if (value !== 'start' && value !== 'end' && value !== 'center') {
        throw Error("ConnectedPosition: Invalid " + property + " \"" + value + "\". " +
            "Expected \"start\", \"end\" or \"center\".");
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Strategy that will prevent the user from scrolling while the overlay is visible.
 */
var  /**
 * Strategy that will prevent the user from scrolling while the overlay is visible.
 */
BlockScrollStrategy = /** @class */ (function () {
    function BlockScrollStrategy(_viewportRuler, document) {
        this._viewportRuler = _viewportRuler;
        this._previousHTMLStyles = { top: '', left: '' };
        this._isEnabled = false;
        this._document = document;
    }
    /** Attaches this scroll strategy to an overlay. */
    /**
     * Attaches this scroll strategy to an overlay.
     * @return {?}
     */
    BlockScrollStrategy.prototype.attach = /**
     * Attaches this scroll strategy to an overlay.
     * @return {?}
     */
    function () { };
    /** Blocks page-level scroll while the attached overlay is open. */
    /**
     * Blocks page-level scroll while the attached overlay is open.
     * @return {?}
     */
    BlockScrollStrategy.prototype.enable = /**
     * Blocks page-level scroll while the attached overlay is open.
     * @return {?}
     */
    function () {
        if (this._canBeEnabled()) {
            var /** @type {?} */ root = this._document.documentElement;
            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();
            // Cache the previous inline styles in case the user had set them.
            this._previousHTMLStyles.left = root.style.left || '';
            this._previousHTMLStyles.top = root.style.top || '';
            // Note: we're using the `html` node, instead of the `body`, because the `body` may
            // have the user agent margin, whereas the `html` is guaranteed not to have one.
            root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);
            root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);
            root.classList.add('cdk-global-scrollblock');
            this._isEnabled = true;
        }
    };
    /** Unblocks page-level scroll while the attached overlay is open. */
    /**
     * Unblocks page-level scroll while the attached overlay is open.
     * @return {?}
     */
    BlockScrollStrategy.prototype.disable = /**
     * Unblocks page-level scroll while the attached overlay is open.
     * @return {?}
     */
    function () {
        if (this._isEnabled) {
            var /** @type {?} */ html = this._document.documentElement;
            var /** @type {?} */ body = this._document.body;
            var /** @type {?} */ previousHtmlScrollBehavior = html.style['scrollBehavior'] || '';
            var /** @type {?} */ previousBodyScrollBehavior = body.style['scrollBehavior'] || '';
            this._isEnabled = false;
            html.style.left = this._previousHTMLStyles.left;
            html.style.top = this._previousHTMLStyles.top;
            html.classList.remove('cdk-global-scrollblock');
            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.
            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior
            html.style['scrollBehavior'] = body.style['scrollBehavior'] = 'auto';
            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);
            html.style['scrollBehavior'] = previousHtmlScrollBehavior;
            body.style['scrollBehavior'] = previousBodyScrollBehavior;
        }
    };
    /**
     * @return {?}
     */
    BlockScrollStrategy.prototype._canBeEnabled = /**
     * @return {?}
     */
    function () {
        // Since the scroll strategies can't be singletons, we have to use a global CSS class
        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global
        // scrolling multiple times.
        var /** @type {?} */ html = this._document.documentElement;
        if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {
            return false;
        }
        var /** @type {?} */ body = this._document.body;
        var /** @type {?} */ viewport = this._viewportRuler.getViewportSize();
        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;
    };
    return BlockScrollStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.
 * @return {?}
 */
function getMatScrollStrategyAlreadyAttachedError() {
    return Error("Scroll strategy has already been attached.");
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Strategy that will close the overlay as soon as the user starts scrolling.
 */
var  /**
 * Strategy that will close the overlay as soon as the user starts scrolling.
 */
CloseScrollStrategy = /** @class */ (function () {
    function CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {
        var _this = this;
        this._scrollDispatcher = _scrollDispatcher;
        this._ngZone = _ngZone;
        this._viewportRuler = _viewportRuler;
        this._config = _config;
        this._scrollSubscription = null;
        /**
         * Detaches the overlay ref and disables the scroll strategy.
         */
        this._detach = function () {
            _this.disable();
            if (_this._overlayRef.hasAttached()) {
                _this._ngZone.run(function () { return _this._overlayRef.detach(); });
            }
        };
    }
    /** Attaches this scroll strategy to an overlay. */
    /**
     * Attaches this scroll strategy to an overlay.
     * @param {?} overlayRef
     * @return {?}
     */
    CloseScrollStrategy.prototype.attach = /**
     * Attaches this scroll strategy to an overlay.
     * @param {?} overlayRef
     * @return {?}
     */
    function (overlayRef) {
        if (this._overlayRef) {
            throw getMatScrollStrategyAlreadyAttachedError();
        }
        this._overlayRef = overlayRef;
    };
    /** Enables the closing of the attached overlay on scroll. */
    /**
     * Enables the closing of the attached overlay on scroll.
     * @return {?}
     */
    CloseScrollStrategy.prototype.enable = /**
     * Enables the closing of the attached overlay on scroll.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._scrollSubscription) {
            return;
        }
        var /** @type {?} */ stream = this._scrollDispatcher.scrolled(0);
        if (this._config && this._config.threshold && this._config.threshold > 1) {
            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;
            this._scrollSubscription = stream.subscribe(function () {
                var /** @type {?} */ scrollPosition = _this._viewportRuler.getViewportScrollPosition().top;
                if (Math.abs(scrollPosition - _this._initialScrollPosition) > /** @type {?} */ ((/** @type {?} */ ((_this._config)).threshold))) {
                    _this._detach();
                }
                else {
                    _this._overlayRef.updatePosition();
                }
            });
        }
        else {
            this._scrollSubscription = stream.subscribe(this._detach);
        }
    };
    /** Disables the closing the attached overlay on scroll. */
    /**
     * Disables the closing the attached overlay on scroll.
     * @return {?}
     */
    CloseScrollStrategy.prototype.disable = /**
     * Disables the closing the attached overlay on scroll.
     * @return {?}
     */
    function () {
        if (this._scrollSubscription) {
            this._scrollSubscription.unsubscribe();
            this._scrollSubscription = null;
        }
    };
    return CloseScrollStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

// TODO(jelbourn): move this to live with the rest of the scrolling code
// TODO(jelbourn): someday replace this with IntersectionObservers
/**
 * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.
 * \@docs-private
 * @param {?} element Dimensions of the element (from getBoundingClientRect)
 * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)
 * @return {?} Whether the element is scrolled out of view
 */
function isElementScrolledOutsideView(element, scrollContainers) {
    return scrollContainers.some(function (containerBounds) {
        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;
        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;
        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;
        var /** @type {?} */ outsideRight = element.left > containerBounds.right;
        return outsideAbove || outsideBelow || outsideLeft || outsideRight;
    });
}
/**
 * Gets whether an element is clipped by any of its scrolling containers.
 * \@docs-private
 * @param {?} element Dimensions of the element (from getBoundingClientRect)
 * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)
 * @return {?} Whether the element is clipped
 */
function isElementClippedByScrolling(element, scrollContainers) {
    return scrollContainers.some(function (scrollContainerRect) {
        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;
        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;
        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;
        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;
        return clippedAbove || clippedBelow || clippedLeft || clippedRight;
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Strategy that will update the element position as the user is scrolling.
 */
var  /**
 * Strategy that will update the element position as the user is scrolling.
 */
RepositionScrollStrategy = /** @class */ (function () {
    function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {
        this._scrollDispatcher = _scrollDispatcher;
        this._viewportRuler = _viewportRuler;
        this._ngZone = _ngZone;
        this._config = _config;
        this._scrollSubscription = null;
    }
    /** Attaches this scroll strategy to an overlay. */
    /**
     * Attaches this scroll strategy to an overlay.
     * @param {?} overlayRef
     * @return {?}
     */
    RepositionScrollStrategy.prototype.attach = /**
     * Attaches this scroll strategy to an overlay.
     * @param {?} overlayRef
     * @return {?}
     */
    function (overlayRef) {
        if (this._overlayRef) {
            throw getMatScrollStrategyAlreadyAttachedError();
        }
        this._overlayRef = overlayRef;
    };
    /** Enables repositioning of the attached overlay on scroll. */
    /**
     * Enables repositioning of the attached overlay on scroll.
     * @return {?}
     */
    RepositionScrollStrategy.prototype.enable = /**
     * Enables repositioning of the attached overlay on scroll.
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._scrollSubscription) {
            var /** @type {?} */ throttle$$1 = this._config ? this._config.scrollThrottle : 0;
            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle$$1).subscribe(function () {
                _this._overlayRef.updatePosition();
                // TODO(crisbeto): make `close` on by default once all components can handle it.
                if (_this._config && _this._config.autoClose) {
                    var /** @type {?} */ overlayRect = _this._overlayRef.overlayElement.getBoundingClientRect();
                    var _a = _this._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;
                    // TODO(crisbeto): include all ancestor scroll containers here once
                    // we have a way of exposing the trigger element to the scroll strategy.
                    var /** @type {?} */ parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];
                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {
                        _this.disable();
                        _this._ngZone.run(function () { return _this._overlayRef.detach(); });
                    }
                }
            });
        }
    };
    /** Disables repositioning of the attached overlay on scroll. */
    /**
     * Disables repositioning of the attached overlay on scroll.
     * @return {?}
     */
    RepositionScrollStrategy.prototype.disable = /**
     * Disables repositioning of the attached overlay on scroll.
     * @return {?}
     */
    function () {
        if (this._scrollSubscription) {
            this._scrollSubscription.unsubscribe();
            this._scrollSubscription = null;
        }
    };
    return RepositionScrollStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Options for how an overlay will handle scrolling.
 *
 * Users can provide a custom value for `ScrollStrategyOptions` to replace the default
 * behaviors. This class primarily acts as a factory for ScrollStrategy instances.
 */
var ScrollStrategyOptions = /** @class */ (function () {
    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone, document) {
        var _this = this;
        this._scrollDispatcher = _scrollDispatcher;
        this._viewportRuler = _viewportRuler;
        this._ngZone = _ngZone;
        /**
         * Do nothing on scroll.
         */
        this.noop = function () { return new NoopScrollStrategy(); };
        /**
         * Close the overlay as soon as the user scrolls.
         * @param config Configuration to be used inside the scroll strategy.
         */
        this.close = function (config$$1) {
            return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone, _this._viewportRuler, config$$1);
        };
        /**
         * Block scrolling.
         */
        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler, _this._document); };
        /**
         * Update the overlay's position on scroll.
         * @param config Configuration to be used inside the scroll strategy.
         * Allows debouncing the reposition calls.
         */
        this.reposition = function (config$$1) {
            return new RepositionScrollStrategy(_this._scrollDispatcher, _this._viewportRuler, _this._ngZone, config$$1);
        };
        this._document = document;
    }
    ScrollStrategyOptions.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    ScrollStrategyOptions.ctorParameters = function () { return [
        { type: ScrollDispatcher, },
        { type: ViewportRuler, },
        { type: core.NgZone, },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
    ]; };
    /** @nocollapse */ ScrollStrategyOptions.ngInjectableDef = core.defineInjectable({ factory: function ScrollStrategyOptions_Factory() { return new ScrollStrategyOptions(core.inject(ScrollDispatcher), core.inject(ViewportRuler), core.inject(core.NgZone), core.inject(common.DOCUMENT)); }, token: ScrollStrategyOptions, providedIn: "root" });
    return ScrollStrategyOptions;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Service for dispatching keyboard events that land on the body to appropriate overlay ref,
 * if any. It maintains a list of attached overlays to determine best suited overlay based
 * on event target and order of overlay opens.
 */
var OverlayKeyboardDispatcher = /** @class */ (function () {
    function OverlayKeyboardDispatcher(document) {
        var _this = this;
        /**
         * Currently attached overlays in the order they were attached.
         */
        this._attachedOverlays = [];
        /**
         * Keyboard event listener that will be attached to the body.
         */
        this._keydownListener = function (event) {
            var /** @type {?} */ overlays = _this._attachedOverlays;
            for (var /** @type {?} */ i = overlays.length - 1; i > -1; i--) {
                // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.
                // We want to target the most recent overlay, rather than trying to match where the event came
                // from, because some components might open an overlay, but keep focus on a trigger element
                // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,
                // because we don't want overlays that don't handle keyboard events to block the ones below
                // them that do.
                if (overlays[i]._keydownEventSubscriptions > 0) {
                    overlays[i]._keydownEvents.next(event);
                    break;
                }
            }
        };
        this._document = document;
    }
    /**
     * @return {?}
     */
    OverlayKeyboardDispatcher.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._detach();
    };
    /** Add a new overlay to the list of attached overlay refs. */
    /**
     * Add a new overlay to the list of attached overlay refs.
     * @param {?} overlayRef
     * @return {?}
     */
    OverlayKeyboardDispatcher.prototype.add = /**
     * Add a new overlay to the list of attached overlay refs.
     * @param {?} overlayRef
     * @return {?}
     */
    function (overlayRef) {
        // Ensure that we don't get the same overlay multiple times.
        this.remove(overlayRef);
        // Lazily start dispatcher once first overlay is added
        if (!this._isAttached) {
            this._document.body.addEventListener('keydown', this._keydownListener, true);
            this._isAttached = true;
        }
        this._attachedOverlays.push(overlayRef);
    };
    /** Remove an overlay from the list of attached overlay refs. */
    /**
     * Remove an overlay from the list of attached overlay refs.
     * @param {?} overlayRef
     * @return {?}
     */
    OverlayKeyboardDispatcher.prototype.remove = /**
     * Remove an overlay from the list of attached overlay refs.
     * @param {?} overlayRef
     * @return {?}
     */
    function (overlayRef) {
        var /** @type {?} */ index = this._attachedOverlays.indexOf(overlayRef);
        if (index > -1) {
            this._attachedOverlays.splice(index, 1);
        }
        // Remove the global listener once there are no more overlays.
        if (this._attachedOverlays.length === 0) {
            this._detach();
        }
    };
    /**
     * Detaches the global keyboard event listener.
     * @return {?}
     */
    OverlayKeyboardDispatcher.prototype._detach = /**
     * Detaches the global keyboard event listener.
     * @return {?}
     */
    function () {
        if (this._isAttached) {
            this._document.body.removeEventListener('keydown', this._keydownListener, true);
            this._isAttached = false;
        }
    };
    OverlayKeyboardDispatcher.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    OverlayKeyboardDispatcher.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
    ]; };
    /** @nocollapse */ OverlayKeyboardDispatcher.ngInjectableDef = core.defineInjectable({ factory: function OverlayKeyboardDispatcher_Factory() { return new OverlayKeyboardDispatcher(core.inject(common.DOCUMENT)); }, token: OverlayKeyboardDispatcher, providedIn: "root" });
    return OverlayKeyboardDispatcher;
}());
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 * @param {?} dispatcher
 * @param {?} _document
 * @return {?}
 */
function OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {
    return dispatcher || new OverlayKeyboardDispatcher(_document);
}
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 */
var /** @type {?} */ OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {
    // If there is already an OverlayKeyboardDispatcher available, use that.
    // Otherwise, provide a new one.
    provide: OverlayKeyboardDispatcher,
    deps: [
        [new core.Optional(), new core.SkipSelf(), OverlayKeyboardDispatcher],
        /** @type {?} */ (
        // Coerce to `InjectionToken` so that the `deps` match the "shape"
        // of the type expected by Angular
        common.DOCUMENT)
    ],
    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Container inside which all overlays will render.
 */
var OverlayContainer = /** @class */ (function () {
    function OverlayContainer(_document) {
        this._document = _document;
    }
    /**
     * @return {?}
     */
    OverlayContainer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._containerElement && this._containerElement.parentNode) {
            this._containerElement.parentNode.removeChild(this._containerElement);
        }
    };
    /**
     * This method returns the overlay container element. It will lazily
     * create the element the first time  it is called to facilitate using
     * the container in non-browser environments.
     * @returns the container element
     */
    /**
     * This method returns the overlay container element. It will lazily
     * create the element the first time  it is called to facilitate using
     * the container in non-browser environments.
     * @return {?} the container element
     */
    OverlayContainer.prototype.getContainerElement = /**
     * This method returns the overlay container element. It will lazily
     * create the element the first time  it is called to facilitate using
     * the container in non-browser environments.
     * @return {?} the container element
     */
    function () {
        if (!this._containerElement) {
            this._createContainer();
        }
        return this._containerElement;
    };
    /**
     * Create the overlay container element, which is simply a div
     * with the 'cdk-overlay-container' class on the document body.
     */
    /**
     * Create the overlay container element, which is simply a div
     * with the 'cdk-overlay-container' class on the document body.
     * @return {?}
     */
    OverlayContainer.prototype._createContainer = /**
     * Create the overlay container element, which is simply a div
     * with the 'cdk-overlay-container' class on the document body.
     * @return {?}
     */
    function () {
        var /** @type {?} */ container = this._document.createElement('div');
        container.classList.add('cdk-overlay-container');
        this._document.body.appendChild(container);
        this._containerElement = container;
    };
    OverlayContainer.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    OverlayContainer.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
    ]; };
    /** @nocollapse */ OverlayContainer.ngInjectableDef = core.defineInjectable({ factory: function OverlayContainer_Factory() { return new OverlayContainer(core.inject(common.DOCUMENT)); }, token: OverlayContainer, providedIn: "root" });
    return OverlayContainer;
}());
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 * @param {?} parentContainer
 * @param {?} _document
 * @return {?}
 */
function OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {
    return parentContainer || new OverlayContainer(_document);
}
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 */
var /** @type {?} */ OVERLAY_CONTAINER_PROVIDER = {
    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.
    provide: OverlayContainer,
    deps: [
        [new core.Optional(), new core.SkipSelf(), OverlayContainer],
        /** @type {?} */ (common.DOCUMENT // We need to use the InjectionToken somewhere to keep TS happy
        ) // We need to use the InjectionToken somewhere to keep TS happy
    ],
    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Reference to an overlay that has been created with the Overlay service.
 * Used to manipulate or dispose of said overlay.
 */
var  /**
 * Reference to an overlay that has been created with the Overlay service.
 * Used to manipulate or dispose of said overlay.
 */
OverlayRef = /** @class */ (function () {
    function OverlayRef(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document) {
        var _this = this;
        this._portalOutlet = _portalOutlet;
        this._host = _host;
        this._pane = _pane;
        this._config = _config;
        this._ngZone = _ngZone;
        this._keyboardDispatcher = _keyboardDispatcher;
        this._document = _document;
        this._backdropElement = null;
        this._backdropClick = new Subject();
        this._attachments = new Subject();
        this._detachments = new Subject();
        this._keydownEventsObservable = Observable.create(function (observer) {
            var /** @type {?} */ subscription = _this._keydownEvents.subscribe(observer);
            _this._keydownEventSubscriptions++;
            return function () {
                subscription.unsubscribe();
                _this._keydownEventSubscriptions--;
            };
        });
        /**
         * Stream of keydown events dispatched to this overlay.
         */
        this._keydownEvents = new Subject();
        /**
         * Amount of subscriptions to the keydown events.
         */
        this._keydownEventSubscriptions = 0;
        if (_config.scrollStrategy) {
            _config.scrollStrategy.attach(this);
        }
    }
    Object.defineProperty(OverlayRef.prototype, "overlayElement", {
        /** The overlay's HTML element */
        get: /**
         * The overlay's HTML element
         * @return {?}
         */
        function () {
            return this._pane;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OverlayRef.prototype, "backdropElement", {
        /** The overlay's backdrop HTML element. */
        get: /**
         * The overlay's backdrop HTML element.
         * @return {?}
         */
        function () {
            return this._backdropElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OverlayRef.prototype, "hostElement", {
        /**
         * Wrapper around the panel element. Can be used for advanced
         * positioning where a wrapper with specific styling is
         * required around the overlay pane.
         */
        get: /**
         * Wrapper around the panel element. Can be used for advanced
         * positioning where a wrapper with specific styling is
         * required around the overlay pane.
         * @return {?}
         */
        function () {
            return this._host;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Attaches content, given via a Portal, to the overlay.
     * If the overlay is configured to have a backdrop, it will be created.
     *
     * @param portal Portal instance to which to attach the overlay.
     * @returns The portal attachment result.
     */
    /**
     * Attaches content, given via a Portal, to the overlay.
     * If the overlay is configured to have a backdrop, it will be created.
     *
     * @param {?} portal Portal instance to which to attach the overlay.
     * @return {?} The portal attachment result.
     */
    OverlayRef.prototype.attach = /**
     * Attaches content, given via a Portal, to the overlay.
     * If the overlay is configured to have a backdrop, it will be created.
     *
     * @param {?} portal Portal instance to which to attach the overlay.
     * @return {?} The portal attachment result.
     */
    function (portal) {
        var _this = this;
        var /** @type {?} */ attachResult = this._portalOutlet.attach(portal);
        if (this._config.positionStrategy) {
            this._config.positionStrategy.attach(this);
        }
        // Update the pane element with the given configuration.
        if (!this._host.parentElement && this._previousHostParent) {
            this._previousHostParent.appendChild(this._host);
        }
        this._updateStackingOrder();
        this._updateElementSize();
        this._updateElementDirection();
        if (this._config.scrollStrategy) {
            this._config.scrollStrategy.enable();
        }
        // Update the position once the zone is stable so that the overlay will be fully rendered
        // before attempting to position it, as the position may depend on the size of the rendered
        // content.
        this._ngZone.onStable
            .asObservable()
            .pipe(take(1))
            .subscribe(function () {
            // The overlay could've been detached before the zone has stabilized.
            if (_this.hasAttached()) {
                _this.updatePosition();
            }
        });
        // Enable pointer events for the overlay pane element.
        this._togglePointerEvents(true);
        if (this._config.hasBackdrop) {
            this._attachBackdrop();
        }
        if (this._config.panelClass) {
            this._toggleClasses(this._pane, this._config.panelClass, true);
        }
        // Only emit the `attachments` event once all other setup is done.
        this._attachments.next();
        // Track this overlay by the keyboard dispatcher
        this._keyboardDispatcher.add(this);
        return attachResult;
    };
    /**
     * Detaches an overlay from a portal.
     * @returns The portal detachment result.
     */
    /**
     * Detaches an overlay from a portal.
     * @return {?} The portal detachment result.
     */
    OverlayRef.prototype.detach = /**
     * Detaches an overlay from a portal.
     * @return {?} The portal detachment result.
     */
    function () {
        var _this = this;
        if (!this.hasAttached()) {
            return;
        }
        this.detachBackdrop();
        // When the overlay is detached, the pane element should disable pointer events.
        // This is necessary because otherwise the pane element will cover the page and disable
        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.
        this._togglePointerEvents(false);
        if (this._config.positionStrategy && this._config.positionStrategy.detach) {
            this._config.positionStrategy.detach();
        }
        if (this._config.scrollStrategy) {
            this._config.scrollStrategy.disable();
        }
        if (this._config.panelClass) {
            this._toggleClasses(this._pane, this._config.panelClass, false);
        }
        var /** @type {?} */ detachmentResult = this._portalOutlet.detach();
        // Only emit after everything is detached.
        this._detachments.next();
        // Remove this overlay from keyboard dispatcher tracking.
        this._keyboardDispatcher.remove(this);
        // Keeping the host element in DOM the can cause scroll jank, because it still gets rendered,
        // even though it's transparent and unclickable. We can't remove the host here immediately,
        // because the overlay pane's content might still be animating. This stream helps us avoid
        // interrupting the animation by waiting for the pane to become empty.
        var /** @type {?} */ subscription = this._ngZone.onStable
            .asObservable()
            .pipe(takeUntil(merge(this._attachments, this._detachments)))
            .subscribe(function () {
            // Needs a couple of checks for the pane and host, because
            // they may have been removed by the time the zone stabilizes.
            if (!_this._pane || !_this._host || _this._pane.children.length === 0) {
                if (_this._host && _this._host.parentElement) {
                    _this._previousHostParent = _this._host.parentElement;
                    _this._previousHostParent.removeChild(_this._host);
                }
                subscription.unsubscribe();
            }
        });
        return detachmentResult;
    };
    /** Cleans up the overlay from the DOM. */
    /**
     * Cleans up the overlay from the DOM.
     * @return {?}
     */
    OverlayRef.prototype.dispose = /**
     * Cleans up the overlay from the DOM.
     * @return {?}
     */
    function () {
        var /** @type {?} */ isAttached = this.hasAttached();
        if (this._config.positionStrategy) {
            this._config.positionStrategy.dispose();
        }
        if (this._config.scrollStrategy) {
            this._config.scrollStrategy.disable();
        }
        this.detachBackdrop();
        this._keyboardDispatcher.remove(this);
        this._portalOutlet.dispose();
        this._attachments.complete();
        this._backdropClick.complete();
        this._keydownEvents.complete();
        if (this._host && this._host.parentNode) {
            this._host.parentNode.removeChild(this._host);
            this._host = /** @type {?} */ ((null));
        }
        this._previousHostParent = this._pane = /** @type {?} */ ((null));
        if (isAttached) {
            this._detachments.next();
        }
        this._detachments.complete();
    };
    /** Whether the overlay has attached content. */
    /**
     * Whether the overlay has attached content.
     * @return {?}
     */
    OverlayRef.prototype.hasAttached = /**
     * Whether the overlay has attached content.
     * @return {?}
     */
    function () {
        return this._portalOutlet.hasAttached();
    };
    /** Gets an observable that emits when the backdrop has been clicked. */
    /**
     * Gets an observable that emits when the backdrop has been clicked.
     * @return {?}
     */
    OverlayRef.prototype.backdropClick = /**
     * Gets an observable that emits when the backdrop has been clicked.
     * @return {?}
     */
    function () {
        return this._backdropClick.asObservable();
    };
    /** Gets an observable that emits when the overlay has been attached. */
    /**
     * Gets an observable that emits when the overlay has been attached.
     * @return {?}
     */
    OverlayRef.prototype.attachments = /**
     * Gets an observable that emits when the overlay has been attached.
     * @return {?}
     */
    function () {
        return this._attachments.asObservable();
    };
    /** Gets an observable that emits when the overlay has been detached. */
    /**
     * Gets an observable that emits when the overlay has been detached.
     * @return {?}
     */
    OverlayRef.prototype.detachments = /**
     * Gets an observable that emits when the overlay has been detached.
     * @return {?}
     */
    function () {
        return this._detachments.asObservable();
    };
    /** Gets an observable of keydown events targeted to this overlay. */
    /**
     * Gets an observable of keydown events targeted to this overlay.
     * @return {?}
     */
    OverlayRef.prototype.keydownEvents = /**
     * Gets an observable of keydown events targeted to this overlay.
     * @return {?}
     */
    function () {
        return this._keydownEventsObservable;
    };
    /** Gets the the current overlay configuration, which is immutable. */
    /**
     * Gets the the current overlay configuration, which is immutable.
     * @return {?}
     */
    OverlayRef.prototype.getConfig = /**
     * Gets the the current overlay configuration, which is immutable.
     * @return {?}
     */
    function () {
        return this._config;
    };
    /** Updates the position of the overlay based on the position strategy. */
    /**
     * Updates the position of the overlay based on the position strategy.
     * @return {?}
     */
    OverlayRef.prototype.updatePosition = /**
     * Updates the position of the overlay based on the position strategy.
     * @return {?}
     */
    function () {
        if (this._config.positionStrategy) {
            this._config.positionStrategy.apply();
        }
    };
    /** Update the size properties of the overlay. */
    /**
     * Update the size properties of the overlay.
     * @param {?} sizeConfig
     * @return {?}
     */
    OverlayRef.prototype.updateSize = /**
     * Update the size properties of the overlay.
     * @param {?} sizeConfig
     * @return {?}
     */
    function (sizeConfig) {
        this._config = __assign({}, this._config, sizeConfig);
        this._updateElementSize();
    };
    /** Sets the LTR/RTL direction for the overlay. */
    /**
     * Sets the LTR/RTL direction for the overlay.
     * @param {?} dir
     * @return {?}
     */
    OverlayRef.prototype.setDirection = /**
     * Sets the LTR/RTL direction for the overlay.
     * @param {?} dir
     * @return {?}
     */
    function (dir) {
        this._config = __assign({}, this._config, { direction: dir });
        this._updateElementDirection();
    };
    /**
     * Returns the layout direction of the overlay panel.
     */
    /**
     * Returns the layout direction of the overlay panel.
     * @return {?}
     */
    OverlayRef.prototype.getDirection = /**
     * Returns the layout direction of the overlay panel.
     * @return {?}
     */
    function () {
        var /** @type {?} */ direction = this._config.direction;
        if (!direction) {
            return 'ltr';
        }
        return typeof direction === 'string' ? direction : direction.value;
    };
    /**
     * Updates the text direction of the overlay panel.
     * @return {?}
     */
    OverlayRef.prototype._updateElementDirection = /**
     * Updates the text direction of the overlay panel.
     * @return {?}
     */
    function () {
        this._host.setAttribute('dir', this.getDirection());
    };
    /**
     * Updates the size of the overlay element based on the overlay config.
     * @return {?}
     */
    OverlayRef.prototype._updateElementSize = /**
     * Updates the size of the overlay element based on the overlay config.
     * @return {?}
     */
    function () {
        var /** @type {?} */ style = this._pane.style;
        style.width = coerceCssPixelValue(this._config.width);
        style.height = coerceCssPixelValue(this._config.height);
        style.minWidth = coerceCssPixelValue(this._config.minWidth);
        style.minHeight = coerceCssPixelValue(this._config.minHeight);
        style.maxWidth = coerceCssPixelValue(this._config.maxWidth);
        style.maxHeight = coerceCssPixelValue(this._config.maxHeight);
    };
    /**
     * Toggles the pointer events for the overlay pane element.
     * @param {?} enablePointer
     * @return {?}
     */
    OverlayRef.prototype._togglePointerEvents = /**
     * Toggles the pointer events for the overlay pane element.
     * @param {?} enablePointer
     * @return {?}
     */
    function (enablePointer) {
        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';
    };
    /**
     * Attaches a backdrop for this overlay.
     * @return {?}
     */
    OverlayRef.prototype._attachBackdrop = /**
     * Attaches a backdrop for this overlay.
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ showingClass = 'cdk-overlay-backdrop-showing';
        this._backdropElement = this._document.createElement('div');
        this._backdropElement.classList.add('cdk-overlay-backdrop');
        if (this._config.backdropClass) {
            this._toggleClasses(this._backdropElement, this._config.backdropClass, true);
        } /** @type {?} */
        ((
        // Insert the backdrop before the pane in the DOM order,
        // in order to handle stacked overlays properly.
        this._host.parentElement)).insertBefore(this._backdropElement, this._host);
        // Forward backdrop clicks such that the consumer of the overlay can perform whatever
        // action desired when such a click occurs (usually closing the overlay).
        this._backdropElement.addEventListener('click', function (event) { return _this._backdropClick.next(event); });
        // Add class to fade-in the backdrop after one frame.
        if (typeof requestAnimationFrame !== 'undefined') {
            this._ngZone.runOutsideAngular(function () {
                requestAnimationFrame(function () {
                    if (_this._backdropElement) {
                        _this._backdropElement.classList.add(showingClass);
                    }
                });
            });
        }
        else {
            this._backdropElement.classList.add(showingClass);
        }
    };
    /**
     * Updates the stacking order of the element, moving it to the top if necessary.
     * This is required in cases where one overlay was detached, while another one,
     * that should be behind it, was destroyed. The next time both of them are opened,
     * the stacking will be wrong, because the detached element's pane will still be
     * in its original DOM position.
     * @return {?}
     */
    OverlayRef.prototype._updateStackingOrder = /**
     * Updates the stacking order of the element, moving it to the top if necessary.
     * This is required in cases where one overlay was detached, while another one,
     * that should be behind it, was destroyed. The next time both of them are opened,
     * the stacking will be wrong, because the detached element's pane will still be
     * in its original DOM position.
     * @return {?}
     */
    function () {
        if (this._host.nextSibling) {
            /** @type {?} */ ((this._host.parentNode)).appendChild(this._host);
        }
    };
    /** Detaches the backdrop (if any) associated with the overlay. */
    /**
     * Detaches the backdrop (if any) associated with the overlay.
     * @return {?}
     */
    OverlayRef.prototype.detachBackdrop = /**
     * Detaches the backdrop (if any) associated with the overlay.
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ backdropToDetach = this._backdropElement;
        if (backdropToDetach) {
            var /** @type {?} */ timeoutId_1;
            var /** @type {?} */ finishDetach_1 = function () {
                // It may not be attached to anything in certain cases (e.g. unit tests).
                if (backdropToDetach && backdropToDetach.parentNode) {
                    backdropToDetach.parentNode.removeChild(backdropToDetach);
                }
                // It is possible that a new portal has been attached to this overlay since we started
                // removing the backdrop. If that is the case, only clear the backdrop reference if it
                // is still the same instance that we started to remove.
                if (_this._backdropElement == backdropToDetach) {
                    _this._backdropElement = null;
                }
                clearTimeout(timeoutId_1);
            };
            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');
            if (this._config.backdropClass) {
                this._toggleClasses(backdropToDetach, this._config.backdropClass, false);
            }
            this._ngZone.runOutsideAngular(function () {
                /** @type {?} */ ((backdropToDetach)).addEventListener('transitionend', finishDetach_1);
            });
            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.
            // In this case we make it unclickable and we try to remove it after a delay.
            backdropToDetach.style.pointerEvents = 'none';
            // Run this outside the Angular zone because there's nothing that Angular cares about.
            // If it were to run inside the Angular zone, every test that used Overlay would have to be
            // either async or fakeAsync.
            // Run this outside the Angular zone because there's nothing that Angular cares about.
            // If it were to run inside the Angular zone, every test that used Overlay would have to be
            // either async or fakeAsync.
            timeoutId_1 = this._ngZone.runOutsideAngular(function () { return setTimeout(finishDetach_1, 500); });
        }
    };
    /**
     * Toggles a single CSS class or an array of classes on an element.
     * @param {?} element
     * @param {?} cssClasses
     * @param {?} isAdd
     * @return {?}
     */
    OverlayRef.prototype._toggleClasses = /**
     * Toggles a single CSS class or an array of classes on an element.
     * @param {?} element
     * @param {?} cssClasses
     * @param {?} isAdd
     * @return {?}
     */
    function (element, cssClasses, isAdd) {
        var /** @type {?} */ classList = element.classList;
        coerceArray(cssClasses).forEach(function (cssClass) {
            // We can't do a spread here, because IE doesn't support setting multiple classes.
            isAdd ? classList.add(cssClass) : classList.remove(cssClass);
        });
    };
    return OverlayRef;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A strategy for positioning overlays. Using this strategy, an overlay is given an
 * implicit position relative some origin element. The relative position is defined in terms of
 * a point on the origin element that is connected to a point on the overlay element. For example,
 * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
 * of the overlay.
 */
var  /**
 * A strategy for positioning overlays. Using this strategy, an overlay is given an
 * implicit position relative some origin element. The relative position is defined in terms of
 * a point on the origin element that is connected to a point on the overlay element. For example,
 * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
 * of the overlay.
 */
FlexibleConnectedPositionStrategy = /** @class */ (function () {
    function FlexibleConnectedPositionStrategy(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {
        var _this = this;
        this._viewportRuler = _viewportRuler;
        this._document = _document;
        this._platform = _platform;
        this._overlayContainer = _overlayContainer;
        /**
         * Whether we're performing the very first positioning of the overlay.
         */
        this._isInitialRender = true;
        /**
         * Last size used for the bounding box. Used to avoid resizing the overlay after open.
         */
        this._lastBoundingBoxSize = { width: 0, height: 0 };
        /**
         * Whether the overlay was pushed in a previous positioning.
         */
        this._isPushed = false;
        /**
         * Whether the overlay can be pushed on-screen on the initial open.
         */
        this._canPush = true;
        /**
         * Whether the overlay can grow via flexible width/height after the initial open.
         */
        this._growAfterOpen = false;
        /**
         * Whether the overlay's width and height can be constrained to fit within the viewport.
         */
        this._hasFlexibleDimensions = true;
        /**
         * Whether the overlay position is locked.
         */
        this._positionLocked = false;
        /**
         * Amount of space that must be maintained between the overlay and the edge of the viewport.
         */
        this._viewportMargin = 0;
        /**
         * The Scrollable containers used to check scrollable view properties on position change.
         */
        this.scrollables = [];
        /**
         * Ordered list of preferred positions, from most to least desirable.
         */
        this._preferredPositions = [];
        /**
         * Subject that emits whenever the position changes.
         */
        this._positionChanges = new Subject();
        /**
         * Subscription to viewport size changes.
         */
        this._resizeSubscription = Subscription.EMPTY;
        /**
         * Default offset for the overlay along the x axis.
         */
        this._offsetX = 0;
        /**
         * Default offset for the overlay along the y axis.
         */
        this._offsetY = 0;
        /**
         * Amount of subscribers to the `positionChanges` stream.
         */
        this._positionChangeSubscriptions = 0;
        /**
         * Observable sequence of position changes.
         */
        this.positionChanges = Observable.create(function (observer) {
            var /** @type {?} */ subscription = _this._positionChanges.subscribe(observer);
            _this._positionChangeSubscriptions++;
            return function () {
                subscription.unsubscribe();
                _this._positionChangeSubscriptions--;
            };
        });
        this.setOrigin(connectedTo);
    }
    Object.defineProperty(FlexibleConnectedPositionStrategy.prototype, "positions", {
        /** Ordered list of preferred positions, from most to least desirable. */
        get: /**
         * Ordered list of preferred positions, from most to least desirable.
         * @return {?}
         */
        function () {
            return this._preferredPositions;
        },
        enumerable: true,
        configurable: true
    });
    /** Attaches this position strategy to an overlay. */
    /**
     * Attaches this position strategy to an overlay.
     * @param {?} overlayRef
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.attach = /**
     * Attaches this position strategy to an overlay.
     * @param {?} overlayRef
     * @return {?}
     */
    function (overlayRef) {
        var _this = this;
        if (this._overlayRef && overlayRef !== this._overlayRef) {
            throw Error('This position strategy is already attached to an overlay');
        }
        this._validatePositions();
        overlayRef.hostElement.classList.add('cdk-overlay-connected-position-bounding-box');
        this._overlayRef = overlayRef;
        this._boundingBox = overlayRef.hostElement;
        this._pane = overlayRef.overlayElement;
        this._resizeSubscription.unsubscribe();
        this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });
    };
    /**
     * Updates the position of the overlay element, using whichever preferred position relative
     * to the origin best fits on-screen.
     *
     * The selection of a position goes as follows:
     *  - If any positions fit completely within the viewport as-is,
     *      choose the first position that does so.
     *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,
     *      choose the position with the greatest available size modified by the positions' weight.
     *  - If pushing is enabled, take the position that went off-screen the least and push it
     *      on-screen.
     *  - If none of the previous criteria were met, use the position that goes off-screen the least.
     * @docs-private
     */
    /**
     * Updates the position of the overlay element, using whichever preferred position relative
     * to the origin best fits on-screen.
     *
     * The selection of a position goes as follows:
     *  - If any positions fit completely within the viewport as-is,
     *      choose the first position that does so.
     *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,
     *      choose the position with the greatest available size modified by the positions' weight.
     *  - If pushing is enabled, take the position that went off-screen the least and push it
     *      on-screen.
     *  - If none of the previous criteria were met, use the position that goes off-screen the least.
     * \@docs-private
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.apply = /**
     * Updates the position of the overlay element, using whichever preferred position relative
     * to the origin best fits on-screen.
     *
     * The selection of a position goes as follows:
     *  - If any positions fit completely within the viewport as-is,
     *      choose the first position that does so.
     *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,
     *      choose the position with the greatest available size modified by the positions' weight.
     *  - If pushing is enabled, take the position that went off-screen the least and push it
     *      on-screen.
     *  - If none of the previous criteria were met, use the position that goes off-screen the least.
     * \@docs-private
     * @return {?}
     */
    function () {
        // We shouldn't do anything if the strategy was disposed or we're on the server.
        // @breaking-change 7.0.0 Remove `_platform` null check once it's guaranteed to be defined.
        if (this._isDisposed || (this._platform && !this._platform.isBrowser)) {
            return;
        }
        // If the position has been applied already (e.g. when the overlay was opened) and the
        // consumer opted into locking in the position, re-use the old position, in order to
        // prevent the overlay from jumping around.
        if (!this._isInitialRender && this._positionLocked && this._lastPosition) {
            this.reapplyLastPosition();
            return;
        }
        this._resetOverlayElementStyles();
        this._resetBoundingBoxStyles();
        // We need the bounding rects for the origin and the overlay to determine how to position
        // the overlay relative to the origin.
        // We use the viewport rect to determine whether a position would go off-screen.
        this._viewportRect = this._getNarrowedViewportRect();
        this._originRect = this._origin.getBoundingClientRect();
        this._overlayRect = this._pane.getBoundingClientRect();
        var /** @type {?} */ originRect = this._originRect;
        var /** @type {?} */ overlayRect = this._overlayRect;
        var /** @type {?} */ viewportRect = this._viewportRect;
        // Positions where the overlay will fit with flexible dimensions.
        var /** @type {?} */ flexibleFits = [];
        // Fallback if none of the preferred positions fit within the viewport.
        var /** @type {?} */ fallback;
        // Go through each of the preferred positions looking for a good fit.
        // If a good fit is found, it will be applied immediately.
        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {
            var pos = _a[_i];
            // Get the exact (x, y) coordinate for the point-of-origin on the origin element.
            var /** @type {?} */ originPoint = this._getOriginPoint(originRect, pos);
            // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the
            // overlay in this position. We use the top-left corner for calculations and later translate
            // this into an appropriate (top, left, bottom, right) style.
            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);
            // Calculate how well the overlay would fit into the viewport with this point.
            var /** @type {?} */ overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);
            // If the overlay, without any further work, fits into the viewport, use this position.
            if (overlayFit.isCompletelyWithinViewport) {
                this._isPushed = false;
                this._applyPosition(pos, originPoint);
                return;
            }
            // If the overlay has flexible dimensions, we can use this position
            // so long as there's enough space for the minimum dimensions.
            if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {
                // Save positions where the overlay will fit with flexible dimensions. We will use these
                // if none of the positions fit *without* flexible dimensions.
                flexibleFits.push({
                    position: pos,
                    origin: originPoint,
                    overlayRect: overlayRect,
                    boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)
                });
                continue;
            }
            // If the current preferred position does not fit on the screen, remember the position
            // if it has more visible area on-screen than we've seen and move onto the next preferred
            // position.
            if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {
                fallback = { overlayFit: overlayFit, overlayPoint: overlayPoint, originPoint: originPoint, position: pos, overlayRect: overlayRect };
            }
        }
        // If there are any positions where the overlay would fit with flexible dimensions, choose the
        // one that has the greatest area available modified by the position's weight
        if (flexibleFits.length) {
            var /** @type {?} */ bestFit = null;
            var /** @type {?} */ bestScore = -1;
            for (var _b = 0, flexibleFits_1 = flexibleFits; _b < flexibleFits_1.length; _b++) {
                var fit_1 = flexibleFits_1[_b];
                var /** @type {?} */ score = fit_1.boundingBoxRect.width * fit_1.boundingBoxRect.height * (fit_1.position.weight || 1);
                if (score > bestScore) {
                    bestScore = score;
                    bestFit = fit_1;
                }
            }
            this._isPushed = false;
            this._applyPosition(/** @type {?} */ ((bestFit)).position, /** @type {?} */ ((bestFit)).origin);
            return;
        }
        // When none of the preferred positions fit within the viewport, take the position
        // that went off-screen the least and attempt to push it on-screen.
        if (this._canPush) {
            // TODO(jelbourn): after pushing, the opening "direction" of the overlay might not make sense.
            this._isPushed = true;
            this._applyPosition(/** @type {?} */ ((fallback)).position, /** @type {?} */ ((fallback)).originPoint);
            return;
        }
        // All options for getting the overlay within the viewport have been exhausted, so go with the
        // position that went off-screen the least.
        this._applyPosition(/** @type {?} */ ((fallback)).position, /** @type {?} */ ((fallback)).originPoint);
    };
    /**
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.detach = /**
     * @return {?}
     */
    function () {
        this._resizeSubscription.unsubscribe();
    };
    /** Cleanup after the element gets destroyed. */
    /**
     * Cleanup after the element gets destroyed.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.dispose = /**
     * Cleanup after the element gets destroyed.
     * @return {?}
     */
    function () {
        if (!this._isDisposed) {
            this.detach();
            this._boundingBox = null;
            this._positionChanges.complete();
            this._isDisposed = true;
        }
    };
    /**
     * This re-aligns the overlay element with the trigger in its last calculated position,
     * even if a position higher in the "preferred positions" list would now fit. This
     * allows one to re-align the panel without changing the orientation of the panel.
     */
    /**
     * This re-aligns the overlay element with the trigger in its last calculated position,
     * even if a position higher in the "preferred positions" list would now fit. This
     * allows one to re-align the panel without changing the orientation of the panel.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.reapplyLastPosition = /**
     * This re-aligns the overlay element with the trigger in its last calculated position,
     * even if a position higher in the "preferred positions" list would now fit. This
     * allows one to re-align the panel without changing the orientation of the panel.
     * @return {?}
     */
    function () {
        if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {
            this._originRect = this._origin.getBoundingClientRect();
            this._overlayRect = this._pane.getBoundingClientRect();
            this._viewportRect = this._getNarrowedViewportRect();
            var /** @type {?} */ lastPosition = this._lastPosition || this._preferredPositions[0];
            var /** @type {?} */ originPoint = this._getOriginPoint(this._originRect, lastPosition);
            this._applyPosition(lastPosition, originPoint);
        }
    };
    /**
     * Sets the list of Scrollable containers that host the origin element so that
     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
     * Scrollable must be an ancestor element of the strategy's origin element.
     */
    /**
     * Sets the list of Scrollable containers that host the origin element so that
     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
     * Scrollable must be an ancestor element of the strategy's origin element.
     * @param {?} scrollables
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.withScrollableContainers = /**
     * Sets the list of Scrollable containers that host the origin element so that
     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
     * Scrollable must be an ancestor element of the strategy's origin element.
     * @param {?} scrollables
     * @return {?}
     */
    function (scrollables) {
        this.scrollables = scrollables;
    };
    /**
     * Adds new preferred positions.
     * @param positions List of positions options for this overlay.
     */
    /**
     * Adds new preferred positions.
     * @param {?} positions List of positions options for this overlay.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.withPositions = /**
     * Adds new preferred positions.
     * @param {?} positions List of positions options for this overlay.
     * @return {?}
     */
    function (positions) {
        this._preferredPositions = positions;
        // If the last calculated position object isn't part of the positions anymore, clear
        // it in order to avoid it being picked up if the consumer tries to re-apply.
        if (positions.indexOf(/** @type {?} */ ((this._lastPosition))) === -1) {
            this._lastPosition = null;
        }
        this._validatePositions();
        return this;
    };
    /**
     * Sets a minimum distance the overlay may be positioned to the edge of the viewport.
     * @param margin Required margin between the overlay and the viewport edge in pixels.
     */
    /**
     * Sets a minimum distance the overlay may be positioned to the edge of the viewport.
     * @param {?} margin Required margin between the overlay and the viewport edge in pixels.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.withViewportMargin = /**
     * Sets a minimum distance the overlay may be positioned to the edge of the viewport.
     * @param {?} margin Required margin between the overlay and the viewport edge in pixels.
     * @return {?}
     */
    function (margin) {
        this._viewportMargin = margin;
        return this;
    };
    /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */
    /**
     * Sets whether the overlay's width and height can be constrained to fit within the viewport.
     * @param {?=} flexibleDimensions
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.withFlexibleDimensions = /**
     * Sets whether the overlay's width and height can be constrained to fit within the viewport.
     * @param {?=} flexibleDimensions
     * @return {?}
     */
    function (flexibleDimensions) {
        if (flexibleDimensions === void 0) { flexibleDimensions = true; }
        this._hasFlexibleDimensions = flexibleDimensions;
        return this;
    };
    /** Sets whether the overlay can grow after the initial open via flexible width/height. */
    /**
     * Sets whether the overlay can grow after the initial open via flexible width/height.
     * @param {?=} growAfterOpen
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.withGrowAfterOpen = /**
     * Sets whether the overlay can grow after the initial open via flexible width/height.
     * @param {?=} growAfterOpen
     * @return {?}
     */
    function (growAfterOpen) {
        if (growAfterOpen === void 0) { growAfterOpen = true; }
        this._growAfterOpen = growAfterOpen;
        return this;
    };
    /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */
    /**
     * Sets whether the overlay can be pushed on-screen if none of the provided positions fit.
     * @param {?=} canPush
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.withPush = /**
     * Sets whether the overlay can be pushed on-screen if none of the provided positions fit.
     * @param {?=} canPush
     * @return {?}
     */
    function (canPush) {
        if (canPush === void 0) { canPush = true; }
        this._canPush = canPush;
        return this;
    };
    /**
     * Sets whether the overlay's position should be locked in after it is positioned
     * initially. When an overlay is locked in, it won't attempt to reposition itself
     * when the position is re-applied (e.g. when the user scrolls away).
     * @param isLocked Whether the overlay should locked in.
     */
    /**
     * Sets whether the overlay's position should be locked in after it is positioned
     * initially. When an overlay is locked in, it won't attempt to reposition itself
     * when the position is re-applied (e.g. when the user scrolls away).
     * @param {?=} isLocked Whether the overlay should locked in.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.withLockedPosition = /**
     * Sets whether the overlay's position should be locked in after it is positioned
     * initially. When an overlay is locked in, it won't attempt to reposition itself
     * when the position is re-applied (e.g. when the user scrolls away).
     * @param {?=} isLocked Whether the overlay should locked in.
     * @return {?}
     */
    function (isLocked) {
        if (isLocked === void 0) { isLocked = true; }
        this._positionLocked = isLocked;
        return this;
    };
    /**
     * Sets the origin element, relative to which to position the overlay.
     * @param origin Reference to the new origin element.
     */
    /**
     * Sets the origin element, relative to which to position the overlay.
     * @param {?} origin Reference to the new origin element.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.setOrigin = /**
     * Sets the origin element, relative to which to position the overlay.
     * @param {?} origin Reference to the new origin element.
     * @return {?}
     */
    function (origin) {
        this._origin = origin instanceof core.ElementRef ? origin.nativeElement : origin;
        return this;
    };
    /**
     * Sets the default offset for the overlay's connection point on the x-axis.
     * @param offset New offset in the X axis.
     */
    /**
     * Sets the default offset for the overlay's connection point on the x-axis.
     * @param {?} offset New offset in the X axis.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.withDefaultOffsetX = /**
     * Sets the default offset for the overlay's connection point on the x-axis.
     * @param {?} offset New offset in the X axis.
     * @return {?}
     */
    function (offset) {
        this._offsetX = offset;
        return this;
    };
    /**
     * Sets the default offset for the overlay's connection point on the y-axis.
     * @param offset New offset in the Y axis.
     */
    /**
     * Sets the default offset for the overlay's connection point on the y-axis.
     * @param {?} offset New offset in the Y axis.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.withDefaultOffsetY = /**
     * Sets the default offset for the overlay's connection point on the y-axis.
     * @param {?} offset New offset in the Y axis.
     * @return {?}
     */
    function (offset) {
        this._offsetY = offset;
        return this;
    };
    /**
     * Configures that the position strategy should set a `transform-origin` on some elements
     * inside the overlay, depending on the current position that is being applied. This is
     * useful for the cases where the origin of an animation can change depending on the
     * alignment of the overlay.
     * @param selector CSS selector that will be used to find the target
     *    elements onto which to set the transform origin.
     */
    /**
     * Configures that the position strategy should set a `transform-origin` on some elements
     * inside the overlay, depending on the current position that is being applied. This is
     * useful for the cases where the origin of an animation can change depending on the
     * alignment of the overlay.
     * @param {?} selector CSS selector that will be used to find the target
     *    elements onto which to set the transform origin.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype.withTransformOriginOn = /**
     * Configures that the position strategy should set a `transform-origin` on some elements
     * inside the overlay, depending on the current position that is being applied. This is
     * useful for the cases where the origin of an animation can change depending on the
     * alignment of the overlay.
     * @param {?} selector CSS selector that will be used to find the target
     *    elements onto which to set the transform origin.
     * @return {?}
     */
    function (selector) {
        this._transformOriginSelector = selector;
        return this;
    };
    /**
     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
     * @param {?} originRect
     * @param {?} pos
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._getOriginPoint = /**
     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
     * @param {?} originRect
     * @param {?} pos
     * @return {?}
     */
    function (originRect, pos) {
        var /** @type {?} */ x;
        if (pos.originX == 'center') {
            // Note: when centering we should always use the `left`
            // offset, otherwise the position will be wrong in RTL.
            x = originRect.left + (originRect.width / 2);
        }
        else {
            var /** @type {?} */ startX = this._isRtl() ? originRect.right : originRect.left;
            var /** @type {?} */ endX = this._isRtl() ? originRect.left : originRect.right;
            x = pos.originX == 'start' ? startX : endX;
        }
        var /** @type {?} */ y;
        if (pos.originY == 'center') {
            y = originRect.top + (originRect.height / 2);
        }
        else {
            y = pos.originY == 'top' ? originRect.top : originRect.bottom;
        }
        return { x: x, y: y };
    };
    /**
     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
     * origin point to which the overlay should be connected.
     * @param {?} originPoint
     * @param {?} overlayRect
     * @param {?} pos
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._getOverlayPoint = /**
     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
     * origin point to which the overlay should be connected.
     * @param {?} originPoint
     * @param {?} overlayRect
     * @param {?} pos
     * @return {?}
     */
    function (originPoint, overlayRect, pos) {
        // Calculate the (overlayStartX, overlayStartY), the start of the
        // potential overlay position relative to the origin point.
        var /** @type {?} */ overlayStartX;
        if (pos.overlayX == 'center') {
            overlayStartX = -overlayRect.width / 2;
        }
        else if (pos.overlayX === 'start') {
            overlayStartX = this._isRtl() ? -overlayRect.width : 0;
        }
        else {
            overlayStartX = this._isRtl() ? 0 : -overlayRect.width;
        }
        var /** @type {?} */ overlayStartY;
        if (pos.overlayY == 'center') {
            overlayStartY = -overlayRect.height / 2;
        }
        else {
            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;
        }
        // The (x, y) coordinates of the overlay.
        return {
            x: originPoint.x + overlayStartX,
            y: originPoint.y + overlayStartY,
        };
    };
    /**
     * Gets how well an overlay at the given point will fit within the viewport.
     * @param {?} point
     * @param {?} overlay
     * @param {?} viewport
     * @param {?} position
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._getOverlayFit = /**
     * Gets how well an overlay at the given point will fit within the viewport.
     * @param {?} point
     * @param {?} overlay
     * @param {?} viewport
     * @param {?} position
     * @return {?}
     */
    function (point, overlay, viewport, position) {
        var x = point.x, y = point.y;
        var /** @type {?} */ offsetX = this._getOffset(position, 'x');
        var /** @type {?} */ offsetY = this._getOffset(position, 'y');
        // Account for the offsets since they could push the overlay out of the viewport.
        if (offsetX) {
            x += offsetX;
        }
        if (offsetY) {
            y += offsetY;
        }
        // How much the overlay would overflow at this position, on each side.
        var /** @type {?} */ leftOverflow = 0 - x;
        var /** @type {?} */ rightOverflow = (x + overlay.width) - viewport.width;
        var /** @type {?} */ topOverflow = 0 - y;
        var /** @type {?} */ bottomOverflow = (y + overlay.height) - viewport.height;
        // Visible parts of the element on each axis.
        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);
        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);
        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;
        return {
            visibleArea: visibleArea,
            isCompletelyWithinViewport: (overlay.width * overlay.height) === visibleArea,
            fitsInViewportVertically: visibleHeight === overlay.height,
            fitsInViewportHorizontally: visibleWidth == overlay.width,
        };
    };
    /**
     * Whether the overlay can fit within the viewport when it may resize either its width or height.
     * @param {?} fit How well the overlay fits in the viewport at some position.
     * @param {?} point The (x, y) coordinates of the overlat at some position.
     * @param {?} viewport The geometry of the viewport.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._canFitWithFlexibleDimensions = /**
     * Whether the overlay can fit within the viewport when it may resize either its width or height.
     * @param {?} fit How well the overlay fits in the viewport at some position.
     * @param {?} point The (x, y) coordinates of the overlat at some position.
     * @param {?} viewport The geometry of the viewport.
     * @return {?}
     */
    function (fit, point, viewport) {
        if (this._hasFlexibleDimensions) {
            var /** @type {?} */ availableHeight = viewport.bottom - point.y;
            var /** @type {?} */ availableWidth = viewport.right - point.x;
            var /** @type {?} */ minHeight = this._overlayRef.getConfig().minHeight;
            var /** @type {?} */ minWidth = this._overlayRef.getConfig().minWidth;
            var /** @type {?} */ verticalFit = fit.fitsInViewportVertically ||
                (minHeight != null && minHeight <= availableHeight);
            var /** @type {?} */ horizontalFit = fit.fitsInViewportHorizontally ||
                (minWidth != null && minWidth <= availableWidth);
            return verticalFit && horizontalFit;
        }
    };
    /**
     * Gets the point at which the overlay can be "pushed" on-screen. If the overlay is larger than
     * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the
     * right and bottom).
     *
     * @param {?} start The starting point from which the overlay is pushed.
     * @param {?} overlay The overlay dimensions.
     * @return {?} The point at which to position the overlay after pushing. This is effectively a new
     *     originPoint.
     */
    FlexibleConnectedPositionStrategy.prototype._pushOverlayOnScreen = /**
     * Gets the point at which the overlay can be "pushed" on-screen. If the overlay is larger than
     * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the
     * right and bottom).
     *
     * @param {?} start The starting point from which the overlay is pushed.
     * @param {?} overlay The overlay dimensions.
     * @return {?} The point at which to position the overlay after pushing. This is effectively a new
     *     originPoint.
     */
    function (start, overlay) {
        var /** @type {?} */ viewport = this._viewportRect;
        // Determine how much the overlay goes outside the viewport on each side, which we'll use to
        // decide which direction to push it.
        var /** @type {?} */ overflowRight = Math.max(start.x + overlay.width - viewport.right, 0);
        var /** @type {?} */ overflowBottom = Math.max(start.y + overlay.height - viewport.bottom, 0);
        var /** @type {?} */ overflowTop = Math.max(viewport.top - start.y, 0);
        var /** @type {?} */ overflowLeft = Math.max(viewport.left - start.x, 0);
        // Amount by which to push the overlay in each direction such that it remains on-screen.
        var /** @type {?} */ pushX, /** @type {?} */ pushY = 0;
        // If the overlay fits completely within the bounds of the viewport, push it from whichever
        // direction is goes off-screen. Otherwise, push the top-left corner such that its in the
        // viewport and allow for the trailing end of the overlay to go out of bounds.
        if (overlay.width <= viewport.width) {
            pushX = overflowLeft || -overflowRight;
        }
        else {
            pushX = viewport.left - start.x;
        }
        if (overlay.height <= viewport.height) {
            pushY = overflowTop || -overflowBottom;
        }
        else {
            pushY = viewport.top - start.y;
        }
        return {
            x: start.x + pushX,
            y: start.y + pushY,
        };
    };
    /**
     * Applies a computed position to the overlay and emits a position change.
     * @param {?} position The position preference
     * @param {?} originPoint The point on the origin element where the overlay is connected.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._applyPosition = /**
     * Applies a computed position to the overlay and emits a position change.
     * @param {?} position The position preference
     * @param {?} originPoint The point on the origin element where the overlay is connected.
     * @return {?}
     */
    function (position, originPoint) {
        this._setTransformOrigin(position);
        this._setOverlayElementStyles(originPoint, position);
        this._setBoundingBoxStyles(originPoint, position);
        // Save the last connected position in case the position needs to be re-calculated.
        this._lastPosition = position;
        // Notify that the position has been changed along with its change properties.
        // We only emit if we've got any subscriptions, because the scroll visibility
        // calculcations can be somewhat expensive.
        if (this._positionChangeSubscriptions > 0) {
            var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility();
            var /** @type {?} */ changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);
            this._positionChanges.next(changeEvent);
        }
        this._isInitialRender = false;
    };
    /**
     * Sets the transform origin based on the configured selector and the passed-in position.
     * @param {?} position
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._setTransformOrigin = /**
     * Sets the transform origin based on the configured selector and the passed-in position.
     * @param {?} position
     * @return {?}
     */
    function (position) {
        if (!this._transformOriginSelector) {
            return;
        }
        var /** @type {?} */ elements = /** @type {?} */ ((this._boundingBox)).querySelectorAll(this._transformOriginSelector);
        var /** @type {?} */ xOrigin;
        var /** @type {?} */ yOrigin = position.overlayY;
        if (position.overlayX === 'center') {
            xOrigin = 'center';
        }
        else if (this._isRtl()) {
            xOrigin = position.overlayX === 'start' ? 'right' : 'left';
        }
        else {
            xOrigin = position.overlayX === 'start' ? 'left' : 'right';
        }
        for (var /** @type {?} */ i = 0; i < elements.length; i++) {
            elements[i].style.transformOrigin = xOrigin + " " + yOrigin;
        }
    };
    /**
     * Gets the position and size of the overlay's sizing container.
     *
     * This method does no measuring and applies no styles so that we can cheaply compute the
     * bounds for all positions and choose the best fit based on these results.
     * @param {?} origin
     * @param {?} position
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._calculateBoundingBoxRect = /**
     * Gets the position and size of the overlay's sizing container.
     *
     * This method does no measuring and applies no styles so that we can cheaply compute the
     * bounds for all positions and choose the best fit based on these results.
     * @param {?} origin
     * @param {?} position
     * @return {?}
     */
    function (origin, position) {
        var /** @type {?} */ viewport = this._viewportRect;
        var /** @type {?} */ isRtl = this._isRtl();
        var /** @type {?} */ height, /** @type {?} */ top, /** @type {?} */ bottom;
        if (position.overlayY === 'top') {
            // Overlay is opening "downward" and thus is bound by the bottom viewport edge.
            top = origin.y;
            height = viewport.bottom - origin.y;
        }
        else if (position.overlayY === 'bottom') {
            // Overlay is opening "upward" and thus is bound by the top viewport edge. We need to add
            // the viewport margin back in, because the viewport rect is narrowed down to remove the
            // margin, whereas the `origin` position is calculated based on its `ClientRect`.
            bottom = viewport.height - origin.y + this._viewportMargin * 2;
            height = viewport.height - bottom + this._viewportMargin;
        }
        else {
            // If neither top nor bottom, it means that the overlay
            // is vertically centered on the origin point.
            var /** @type {?} */ smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y, origin.y - viewport.left);
            var /** @type {?} */ previousHeight = this._lastBoundingBoxSize.height;
            height = smallestDistanceToViewportEdge * 2;
            top = origin.y - smallestDistanceToViewportEdge;
            if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {
                top = origin.y - (previousHeight / 2);
            }
        }
        // The overlay is opening 'right-ward' (the content flows to the right).
        var /** @type {?} */ isBoundedByRightViewportEdge = (position.overlayX === 'start' && !isRtl) ||
            (position.overlayX === 'end' && isRtl);
        // The overlay is opening 'left-ward' (the content flows to the left).
        var /** @type {?} */ isBoundedByLeftViewportEdge = (position.overlayX === 'end' && !isRtl) ||
            (position.overlayX === 'start' && isRtl);
        var /** @type {?} */ width, /** @type {?} */ left, /** @type {?} */ right;
        if (isBoundedByLeftViewportEdge) {
            right = viewport.right - origin.x + this._viewportMargin;
            width = origin.x - viewport.left;
        }
        else if (isBoundedByRightViewportEdge) {
            left = origin.x;
            width = viewport.right - origin.x;
        }
        else {
            // If neither start nor end, it means that the overlay
            // is horizontally centered on the origin point.
            var /** @type {?} */ smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x, origin.x - viewport.top);
            var /** @type {?} */ previousWidth = this._lastBoundingBoxSize.width;
            width = smallestDistanceToViewportEdge * 2;
            left = origin.x - smallestDistanceToViewportEdge;
            if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {
                left = origin.x - (previousWidth / 2);
            }
        }
        return { top: top, left: left, bottom: bottom, right: right, width: width, height: height };
    };
    /**
     * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the
     * origin's connection point and stetches to the bounds of the viewport.
     *
     * @param {?} origin The point on the origin element where the overlay is connected.
     * @param {?} position The position preference
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._setBoundingBoxStyles = /**
     * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the
     * origin's connection point and stetches to the bounds of the viewport.
     *
     * @param {?} origin The point on the origin element where the overlay is connected.
     * @param {?} position The position preference
     * @return {?}
     */
    function (origin, position) {
        var /** @type {?} */ boundingBoxRect = this._calculateBoundingBoxRect(origin, position);
        // It's weird if the overlay *grows* while scrolling, so we take the last size into account
        // when applying a new size.
        if (!this._isInitialRender && !this._growAfterOpen) {
            boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);
            boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);
        }
        var /** @type {?} */ styles = /** @type {?} */ ({});
        if (this._hasExactPosition()) {
            styles.top = styles.left = '0';
            styles.bottom = styles.right = '';
            styles.width = styles.height = '100%';
        }
        else {
            var /** @type {?} */ maxHeight = this._overlayRef.getConfig().maxHeight;
            var /** @type {?} */ maxWidth = this._overlayRef.getConfig().maxWidth;
            styles.height = coerceCssPixelValue(boundingBoxRect.height);
            styles.top = coerceCssPixelValue(boundingBoxRect.top);
            styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);
            styles.width = coerceCssPixelValue(boundingBoxRect.width);
            styles.left = coerceCssPixelValue(boundingBoxRect.left);
            styles.right = coerceCssPixelValue(boundingBoxRect.right);
            // Push the pane content towards the proper direction.
            if (position.overlayX === 'center') {
                styles.alignItems = 'center';
            }
            else {
                styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';
            }
            if (position.overlayY === 'center') {
                styles.justifyContent = 'center';
            }
            else {
                styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';
            }
            if (maxHeight) {
                styles.maxHeight = coerceCssPixelValue(maxHeight);
            }
            if (maxWidth) {
                styles.maxWidth = coerceCssPixelValue(maxWidth);
            }
        }
        this._lastBoundingBoxSize = boundingBoxRect;
        extendStyles(/** @type {?} */ ((this._boundingBox)).style, styles);
    };
    /**
     * Resets the styles for the bounding box so that a new positioning can be computed.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._resetBoundingBoxStyles = /**
     * Resets the styles for the bounding box so that a new positioning can be computed.
     * @return {?}
     */
    function () {
        extendStyles(/** @type {?} */ ((this._boundingBox)).style, /** @type {?} */ ({
            top: '0',
            left: '0',
            right: '0',
            bottom: '0',
            height: '',
            width: '',
            alignItems: '',
            justifyContent: '',
        }));
    };
    /**
     * Resets the styles for the overlay pane so that a new positioning can be computed.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._resetOverlayElementStyles = /**
     * Resets the styles for the overlay pane so that a new positioning can be computed.
     * @return {?}
     */
    function () {
        extendStyles(this._pane.style, /** @type {?} */ ({
            top: '',
            left: '',
            bottom: '',
            right: '',
            position: '',
        }));
    };
    /**
     * Sets positioning styles to the overlay element.
     * @param {?} originPoint
     * @param {?} position
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._setOverlayElementStyles = /**
     * Sets positioning styles to the overlay element.
     * @param {?} originPoint
     * @param {?} position
     * @return {?}
     */
    function (originPoint, position) {
        var /** @type {?} */ styles = /** @type {?} */ ({});
        if (this._hasExactPosition()) {
            extendStyles(styles, this._getExactOverlayY(position, originPoint));
            extendStyles(styles, this._getExactOverlayX(position, originPoint));
        }
        else {
            styles.position = 'static';
        }
        // Use a transform to apply the offsets. We do this because the `center` positions rely on
        // being in the normal flex flow and setting a `top` / `left` at all will completely throw
        // off the position. We also can't use margins, because they won't have an effect in some
        // cases where the element doesn't have anything to "push off of". Finally, this works
        // better both with flexible and non-flexible positioning.
        var /** @type {?} */ transformString = '';
        var /** @type {?} */ offsetX = this._getOffset(position, 'x');
        var /** @type {?} */ offsetY = this._getOffset(position, 'y');
        if (offsetX) {
            transformString += "translateX(" + offsetX + "px) ";
        }
        if (offsetY) {
            transformString += "translateY(" + offsetY + "px)";
        }
        styles.transform = transformString.trim();
        // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because
        // we need these values to both be set to "100%" for the automatic flexible sizing to work.
        // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.
        if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxHeight) {
            styles.maxHeight = '';
        }
        if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxWidth) {
            styles.maxWidth = '';
        }
        extendStyles(this._pane.style, styles);
    };
    /**
     * Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing.
     * @param {?} position
     * @param {?} originPoint
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._getExactOverlayY = /**
     * Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing.
     * @param {?} position
     * @param {?} originPoint
     * @return {?}
     */
    function (position, originPoint) {
        // Reset any existing styles. This is necessary in case the
        // preferred position has changed since the last `apply`.
        var /** @type {?} */ styles = /** @type {?} */ ({ top: null, bottom: null });
        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
        if (this._isPushed) {
            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect);
        }
        // @breaking-change 7.0.0 Currently the `_overlayContainer` is optional in order to avoid a
        // breaking change. The null check here can be removed once the `_overlayContainer` becomes
        // a required parameter.
        var /** @type {?} */ virtualKeyboardOffset = this._overlayContainer ?
            this._overlayContainer.getContainerElement().getBoundingClientRect().top : 0;
        // Normally this would be zero, however when the overlay is attached to an input (e.g. in an
        // autocomplete), mobile browsers will shift everything in order to put the input in the middle
        // of the screen and to make space for the virtual keyboard. We need to account for this offset,
        // otherwise our positioning will be thrown off.
        overlayPoint.y -= virtualKeyboardOffset;
        // We want to set either `top` or `bottom` based on whether the overlay wants to appear
        // above or below the origin and the direction in which the element will expand.
        if (position.overlayY === 'bottom') {
            // When using `bottom`, we adjust the y position such that it is the distance
            // from the bottom of the viewport rather than the top.
            var /** @type {?} */ documentHeight = this._document.documentElement.clientHeight;
            styles.bottom = documentHeight - (overlayPoint.y + this._overlayRect.height) + "px";
        }
        else {
            styles.top = coerceCssPixelValue(overlayPoint.y);
        }
        return styles;
    };
    /**
     * Gets the exact left/right for the overlay when not using flexible sizing or when pushing.
     * @param {?} position
     * @param {?} originPoint
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._getExactOverlayX = /**
     * Gets the exact left/right for the overlay when not using flexible sizing or when pushing.
     * @param {?} position
     * @param {?} originPoint
     * @return {?}
     */
    function (position, originPoint) {
        // Reset any existing styles. This is necessary in case the preferred position has
        // changed since the last `apply`.
        var /** @type {?} */ styles = /** @type {?} */ ({ left: null, right: null });
        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
        if (this._isPushed) {
            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect);
        }
        // We want to set either `left` or `right` based on whether the overlay wants to appear "before"
        // or "after" the origin, which determines the direction in which the element will expand.
        // For the horizontal axis, the meaning of "before" and "after" change based on whether the
        // page is in RTL or LTR.
        var /** @type {?} */ horizontalStyleProperty;
        if (this._isRtl()) {
            horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';
        }
        else {
            horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';
        }
        // When we're setting `right`, we adjust the x position such that it is the distance
        // from the right edge of the viewport rather than the left edge.
        if (horizontalStyleProperty === 'right') {
            var /** @type {?} */ documentWidth = this._document.documentElement.clientWidth;
            styles.right = documentWidth - (overlayPoint.x + this._overlayRect.width) + "px";
        }
        else {
            styles.left = coerceCssPixelValue(overlayPoint.x);
        }
        return styles;
    };
    /**
     * Gets the view properties of the trigger and overlay, including whether they are clipped
     * or completely outside the view of any of the strategy's scrollables.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._getScrollVisibility = /**
     * Gets the view properties of the trigger and overlay, including whether they are clipped
     * or completely outside the view of any of the strategy's scrollables.
     * @return {?}
     */
    function () {
        // Note: needs fresh rects since the position could've changed.
        var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();
        var /** @type {?} */ overlayBounds = this._pane.getBoundingClientRect();
        // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers
        // every time, we should be able to use the scrollTop of the containers if the size of those
        // containers hasn't changed.
        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (scrollable) {
            return scrollable.getElementRef().nativeElement.getBoundingClientRect();
        });
        return {
            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),
            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),
            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),
            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),
        };
    };
    /**
     * Subtracts the amount that an element is overflowing on an axis from it's length.
     * @param {?} length
     * @param {...?} overflows
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._subtractOverflows = /**
     * Subtracts the amount that an element is overflowing on an axis from it's length.
     * @param {?} length
     * @param {...?} overflows
     * @return {?}
     */
    function (length) {
        var overflows = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            overflows[_i - 1] = arguments[_i];
        }
        return overflows.reduce(function (currentValue, currentOverflow) {
            return currentValue - Math.max(currentOverflow, 0);
        }, length);
    };
    /**
     * Narrows the given viewport rect by the current _viewportMargin.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._getNarrowedViewportRect = /**
     * Narrows the given viewport rect by the current _viewportMargin.
     * @return {?}
     */
    function () {
        // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,
        // because we want to use the `clientWidth` and `clientHeight` as the base. The difference
        // being that the client properties don't include the scrollbar, as opposed to `innerWidth`
        // and `innerHeight` that do. This is necessary, because the overlay container uses
        // 100% `width` and `height` which don't include the scrollbar either.
        var /** @type {?} */ width = this._document.documentElement.clientWidth;
        var /** @type {?} */ height = this._document.documentElement.clientHeight;
        var /** @type {?} */ scrollPosition = this._viewportRuler.getViewportScrollPosition();
        return {
            top: scrollPosition.top + this._viewportMargin,
            left: scrollPosition.left + this._viewportMargin,
            right: scrollPosition.left + width - this._viewportMargin,
            bottom: scrollPosition.top + height - this._viewportMargin,
            width: width - (2 * this._viewportMargin),
            height: height - (2 * this._viewportMargin),
        };
    };
    /**
     * Whether the we're dealing with an RTL context
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._isRtl = /**
     * Whether the we're dealing with an RTL context
     * @return {?}
     */
    function () {
        return this._overlayRef.getDirection() === 'rtl';
    };
    /**
     * Determines whether the overlay uses exact or flexible positioning.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._hasExactPosition = /**
     * Determines whether the overlay uses exact or flexible positioning.
     * @return {?}
     */
    function () {
        return !this._hasFlexibleDimensions || this._isPushed;
    };
    /**
     * Retrieves the offset of a position along the x or y axis.
     * @param {?} position
     * @param {?} axis
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._getOffset = /**
     * Retrieves the offset of a position along the x or y axis.
     * @param {?} position
     * @param {?} axis
     * @return {?}
     */
    function (position, axis) {
        if (axis === 'x') {
            // We don't do something like `position['offset' + axis]` in
            // order to avoid breking minifiers that rename properties.
            return position.offsetX == null ? this._offsetX : position.offsetX;
        }
        return position.offsetY == null ? this._offsetY : position.offsetY;
    };
    /**
     * Validates that the current position match the expected values.
     * @return {?}
     */
    FlexibleConnectedPositionStrategy.prototype._validatePositions = /**
     * Validates that the current position match the expected values.
     * @return {?}
     */
    function () {
        if (!this._preferredPositions.length) {
            throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');
        }
        // TODO(crisbeto): remove these once Angular's template type
        // checking is advanced enough to catch these cases.
        this._preferredPositions.forEach(function (pair) {
            validateHorizontalPosition('originX', pair.originX);
            validateVerticalPosition('originY', pair.originY);
            validateHorizontalPosition('overlayX', pair.overlayX);
            validateVerticalPosition('overlayY', pair.overlayY);
        });
    };
    return FlexibleConnectedPositionStrategy;
}());
/**
 * Shallow-extends a stylesheet object with another stylesheet object.
 * @param {?} dest
 * @param {?} source
 * @return {?}
 */
function extendStyles(dest, source) {
    for (var /** @type {?} */ key in source) {
        if (source.hasOwnProperty(key)) {
            dest[key] = source[key];
        }
    }
    return dest;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A strategy for positioning overlays. Using this strategy, an overlay is given an
 * implicit position relative to some origin element. The relative position is defined in terms of
 * a point on the origin element that is connected to a point on the overlay element. For example,
 * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
 * of the overlay.
 * @deprecated Use `FlexibleConnectedPositionStrategy` instead.
 * \@breaking-change 7.0.0
 */
var  /**
 * A strategy for positioning overlays. Using this strategy, an overlay is given an
 * implicit position relative to some origin element. The relative position is defined in terms of
 * a point on the origin element that is connected to a point on the overlay element. For example,
 * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
 * of the overlay.
 * @deprecated Use `FlexibleConnectedPositionStrategy` instead.
 * \@breaking-change 7.0.0
 */
ConnectedPositionStrategy = /** @class */ (function () {
    function ConnectedPositionStrategy(originPos, overlayPos, connectedTo, viewportRuler, document, 
    // @breaking-change 7.0.0 `platform` parameter to be made required.
    // @breaking-change 7.0.0 `platform` parameter to be made required.
    platform) {
        /**
         * Ordered list of preferred positions, from most to least desirable.
         */
        this._preferredPositions = [];
        // Since the `ConnectedPositionStrategy` is deprecated and we don't want to maintain
        // the extra logic, we create an instance of the positioning strategy that has some
        // defaults that make it behave as the old position strategy and to which we'll
        // proxy all of the API calls.
        this._positionStrategy =
            new FlexibleConnectedPositionStrategy(connectedTo, viewportRuler, document, platform)
                .withFlexibleDimensions(false)
                .withPush(false)
                .withViewportMargin(0);
        this.withFallbackPosition(originPos, overlayPos);
    }
    Object.defineProperty(ConnectedPositionStrategy.prototype, "_isRtl", {
        /** Whether the we're dealing with an RTL context */
        get: /**
         * Whether the we're dealing with an RTL context
         * @return {?}
         */
        function () {
            return this._overlayRef.getDirection() === 'rtl';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedPositionStrategy.prototype, "onPositionChange", {
        /** Emits an event when the connection point changes. */
        get: /**
         * Emits an event when the connection point changes.
         * @return {?}
         */
        function () {
            return this._positionStrategy.positionChanges;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectedPositionStrategy.prototype, "positions", {
        /** Ordered list of preferred positions, from most to least desirable. */
        get: /**
         * Ordered list of preferred positions, from most to least desirable.
         * @return {?}
         */
        function () {
            return this._preferredPositions;
        },
        enumerable: true,
        configurable: true
    });
    /** Attach this position strategy to an overlay. */
    /**
     * Attach this position strategy to an overlay.
     * @param {?} overlayRef
     * @return {?}
     */
    ConnectedPositionStrategy.prototype.attach = /**
     * Attach this position strategy to an overlay.
     * @param {?} overlayRef
     * @return {?}
     */
    function (overlayRef) {
        this._overlayRef = overlayRef;
        this._positionStrategy.attach(overlayRef);
        if (this._direction) {
            overlayRef.setDirection(this._direction);
            this._direction = null;
        }
    };
    /** Disposes all resources used by the position strategy. */
    /**
     * Disposes all resources used by the position strategy.
     * @return {?}
     */
    ConnectedPositionStrategy.prototype.dispose = /**
     * Disposes all resources used by the position strategy.
     * @return {?}
     */
    function () {
        this._positionStrategy.dispose();
    };
    /** @docs-private */
    /**
     * \@docs-private
     * @return {?}
     */
    ConnectedPositionStrategy.prototype.detach = /**
     * \@docs-private
     * @return {?}
     */
    function () {
        this._positionStrategy.detach();
    };
    /**
     * Updates the position of the overlay element, using whichever preferred position relative
     * to the origin fits on-screen.
     * @docs-private
     */
    /**
     * Updates the position of the overlay element, using whichever preferred position relative
     * to the origin fits on-screen.
     * \@docs-private
     * @return {?}
     */
    ConnectedPositionStrategy.prototype.apply = /**
     * Updates the position of the overlay element, using whichever preferred position relative
     * to the origin fits on-screen.
     * \@docs-private
     * @return {?}
     */
    function () {
        this._positionStrategy.apply();
    };
    /**
     * Re-positions the overlay element with the trigger in its last calculated position,
     * even if a position higher in the "preferred positions" list would now fit. This
     * allows one to re-align the panel without changing the orientation of the panel.
     */
    /**
     * Re-positions the overlay element with the trigger in its last calculated position,
     * even if a position higher in the "preferred positions" list would now fit. This
     * allows one to re-align the panel without changing the orientation of the panel.
     * @return {?}
     */
    ConnectedPositionStrategy.prototype.recalculateLastPosition = /**
     * Re-positions the overlay element with the trigger in its last calculated position,
     * even if a position higher in the "preferred positions" list would now fit. This
     * allows one to re-align the panel without changing the orientation of the panel.
     * @return {?}
     */
    function () {
        this._positionStrategy.reapplyLastPosition();
    };
    /**
     * Sets the list of Scrollable containers that host the origin element so that
     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
     * Scrollable must be an ancestor element of the strategy's origin element.
     */
    /**
     * Sets the list of Scrollable containers that host the origin element so that
     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
     * Scrollable must be an ancestor element of the strategy's origin element.
     * @param {?} scrollables
     * @return {?}
     */
    ConnectedPositionStrategy.prototype.withScrollableContainers = /**
     * Sets the list of Scrollable containers that host the origin element so that
     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
     * Scrollable must be an ancestor element of the strategy's origin element.
     * @param {?} scrollables
     * @return {?}
     */
    function (scrollables) {
        this._positionStrategy.withScrollableContainers(scrollables);
    };
    /**
     * Adds a new preferred fallback position.
     * @param originPos
     * @param overlayPos
     */
    /**
     * Adds a new preferred fallback position.
     * @param {?} originPos
     * @param {?} overlayPos
     * @param {?=} offsetX
     * @param {?=} offsetY
     * @return {?}
     */
    ConnectedPositionStrategy.prototype.withFallbackPosition = /**
     * Adds a new preferred fallback position.
     * @param {?} originPos
     * @param {?} overlayPos
     * @param {?=} offsetX
     * @param {?=} offsetY
     * @return {?}
     */
    function (originPos, overlayPos, offsetX, offsetY) {
        var /** @type {?} */ position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);
        this._preferredPositions.push(position);
        this._positionStrategy.withPositions(this._preferredPositions);
        return this;
    };
    /**
     * Sets the layout direction so the overlay's position can be adjusted to match.
     * @param dir New layout direction.
     */
    /**
     * Sets the layout direction so the overlay's position can be adjusted to match.
     * @param {?} dir New layout direction.
     * @return {?}
     */
    ConnectedPositionStrategy.prototype.withDirection = /**
     * Sets the layout direction so the overlay's position can be adjusted to match.
     * @param {?} dir New layout direction.
     * @return {?}
     */
    function (dir) {
        // Since the direction might be declared before the strategy is attached,
        // we save the value in a temporary property and we'll transfer it to the
        // overlay ref on attachment.
        if (this._overlayRef) {
            this._overlayRef.setDirection(dir);
        }
        else {
            this._direction = dir;
        }
        return this;
    };
    /**
     * Sets an offset for the overlay's connection point on the x-axis
     * @param offset New offset in the X axis.
     */
    /**
     * Sets an offset for the overlay's connection point on the x-axis
     * @param {?} offset New offset in the X axis.
     * @return {?}
     */
    ConnectedPositionStrategy.prototype.withOffsetX = /**
     * Sets an offset for the overlay's connection point on the x-axis
     * @param {?} offset New offset in the X axis.
     * @return {?}
     */
    function (offset) {
        this._positionStrategy.withDefaultOffsetX(offset);
        return this;
    };
    /**
     * Sets an offset for the overlay's connection point on the y-axis
     * @param  offset New offset in the Y axis.
     */
    /**
     * Sets an offset for the overlay's connection point on the y-axis
     * @param {?} offset New offset in the Y axis.
     * @return {?}
     */
    ConnectedPositionStrategy.prototype.withOffsetY = /**
     * Sets an offset for the overlay's connection point on the y-axis
     * @param {?} offset New offset in the Y axis.
     * @return {?}
     */
    function (offset) {
        this._positionStrategy.withDefaultOffsetY(offset);
        return this;
    };
    /**
     * Sets whether the overlay's position should be locked in after it is positioned
     * initially. When an overlay is locked in, it won't attempt to reposition itself
     * when the position is re-applied (e.g. when the user scrolls away).
     * @param isLocked Whether the overlay should locked in.
     */
    /**
     * Sets whether the overlay's position should be locked in after it is positioned
     * initially. When an overlay is locked in, it won't attempt to reposition itself
     * when the position is re-applied (e.g. when the user scrolls away).
     * @param {?} isLocked Whether the overlay should locked in.
     * @return {?}
     */
    ConnectedPositionStrategy.prototype.withLockedPosition = /**
     * Sets whether the overlay's position should be locked in after it is positioned
     * initially. When an overlay is locked in, it won't attempt to reposition itself
     * when the position is re-applied (e.g. when the user scrolls away).
     * @param {?} isLocked Whether the overlay should locked in.
     * @return {?}
     */
    function (isLocked) {
        this._positionStrategy.withLockedPosition(isLocked);
        return this;
    };
    /**
     * Overwrites the current set of positions with an array of new ones.
     * @param positions Position pairs to be set on the strategy.
     */
    /**
     * Overwrites the current set of positions with an array of new ones.
     * @param {?} positions Position pairs to be set on the strategy.
     * @return {?}
     */
    ConnectedPositionStrategy.prototype.withPositions = /**
     * Overwrites the current set of positions with an array of new ones.
     * @param {?} positions Position pairs to be set on the strategy.
     * @return {?}
     */
    function (positions) {
        this._preferredPositions = positions.slice();
        this._positionStrategy.withPositions(this._preferredPositions);
        return this;
    };
    /**
     * Sets the origin element, relative to which to position the overlay.
     * @param origin Reference to the new origin element.
     */
    /**
     * Sets the origin element, relative to which to position the overlay.
     * @param {?} origin Reference to the new origin element.
     * @return {?}
     */
    ConnectedPositionStrategy.prototype.setOrigin = /**
     * Sets the origin element, relative to which to position the overlay.
     * @param {?} origin Reference to the new origin element.
     * @return {?}
     */
    function (origin) {
        this._positionStrategy.setOrigin(origin);
        return this;
    };
    return ConnectedPositionStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * A strategy for positioning overlays. Using this strategy, an overlay is given an
 * explicit position relative to the browser's viewport. We use flexbox, instead of
 * transforms, in order to avoid issues with subpixel rendering which can cause the
 * element to become blurry.
 */
var  /**
 * A strategy for positioning overlays. Using this strategy, an overlay is given an
 * explicit position relative to the browser's viewport. We use flexbox, instead of
 * transforms, in order to avoid issues with subpixel rendering which can cause the
 * element to become blurry.
 */
GlobalPositionStrategy = /** @class */ (function () {
    function GlobalPositionStrategy() {
        this._cssPosition = 'static';
        this._topOffset = '';
        this._bottomOffset = '';
        this._leftOffset = '';
        this._rightOffset = '';
        this._alignItems = '';
        this._justifyContent = '';
        this._width = '';
        this._height = '';
    }
    /**
     * @param {?} overlayRef
     * @return {?}
     */
    GlobalPositionStrategy.prototype.attach = /**
     * @param {?} overlayRef
     * @return {?}
     */
    function (overlayRef) {
        var /** @type {?} */ config$$1 = overlayRef.getConfig();
        this._overlayRef = overlayRef;
        if (this._width && !config$$1.width) {
            overlayRef.updateSize({ width: this._width });
        }
        if (this._height && !config$$1.height) {
            overlayRef.updateSize({ height: this._height });
        }
        overlayRef.hostElement.classList.add('cdk-global-overlay-wrapper');
    };
    /**
     * Sets the top position of the overlay. Clears any previously set vertical position.
     * @param value New top offset.
     */
    /**
     * Sets the top position of the overlay. Clears any previously set vertical position.
     * @param {?=} value New top offset.
     * @return {?}
     */
    GlobalPositionStrategy.prototype.top = /**
     * Sets the top position of the overlay. Clears any previously set vertical position.
     * @param {?=} value New top offset.
     * @return {?}
     */
    function (value) {
        if (value === void 0) { value = ''; }
        this._bottomOffset = '';
        this._topOffset = value;
        this._alignItems = 'flex-start';
        return this;
    };
    /**
     * Sets the left position of the overlay. Clears any previously set horizontal position.
     * @param value New left offset.
     */
    /**
     * Sets the left position of the overlay. Clears any previously set horizontal position.
     * @param {?=} value New left offset.
     * @return {?}
     */
    GlobalPositionStrategy.prototype.left = /**
     * Sets the left position of the overlay. Clears any previously set horizontal position.
     * @param {?=} value New left offset.
     * @return {?}
     */
    function (value) {
        if (value === void 0) { value = ''; }
        this._rightOffset = '';
        this._leftOffset = value;
        this._justifyContent = 'flex-start';
        return this;
    };
    /**
     * Sets the bottom position of the overlay. Clears any previously set vertical position.
     * @param value New bottom offset.
     */
    /**
     * Sets the bottom position of the overlay. Clears any previously set vertical position.
     * @param {?=} value New bottom offset.
     * @return {?}
     */
    GlobalPositionStrategy.prototype.bottom = /**
     * Sets the bottom position of the overlay. Clears any previously set vertical position.
     * @param {?=} value New bottom offset.
     * @return {?}
     */
    function (value) {
        if (value === void 0) { value = ''; }
        this._topOffset = '';
        this._bottomOffset = value;
        this._alignItems = 'flex-end';
        return this;
    };
    /**
     * Sets the right position of the overlay. Clears any previously set horizontal position.
     * @param value New right offset.
     */
    /**
     * Sets the right position of the overlay. Clears any previously set horizontal position.
     * @param {?=} value New right offset.
     * @return {?}
     */
    GlobalPositionStrategy.prototype.right = /**
     * Sets the right position of the overlay. Clears any previously set horizontal position.
     * @param {?=} value New right offset.
     * @return {?}
     */
    function (value) {
        if (value === void 0) { value = ''; }
        this._leftOffset = '';
        this._rightOffset = value;
        this._justifyContent = 'flex-end';
        return this;
    };
    /**
     * Sets the overlay width and clears any previously set width.
     * @param value New width for the overlay
     * @deprecated Pass the `width` through the `OverlayConfig`.
     * @breaking-change 7.0.0
     */
    /**
     * Sets the overlay width and clears any previously set width.
     * @deprecated Pass the `width` through the `OverlayConfig`.
     * \@breaking-change 7.0.0
     * @param {?=} value New width for the overlay
     * @return {?}
     */
    GlobalPositionStrategy.prototype.width = /**
     * Sets the overlay width and clears any previously set width.
     * @deprecated Pass the `width` through the `OverlayConfig`.
     * \@breaking-change 7.0.0
     * @param {?=} value New width for the overlay
     * @return {?}
     */
    function (value) {
        if (value === void 0) { value = ''; }
        if (this._overlayRef) {
            this._overlayRef.updateSize({ width: value });
        }
        else {
            this._width = value;
        }
        return this;
    };
    /**
     * Sets the overlay height and clears any previously set height.
     * @param value New height for the overlay
     * @deprecated Pass the `height` through the `OverlayConfig`.
     * @breaking-change 7.0.0
     */
    /**
     * Sets the overlay height and clears any previously set height.
     * @deprecated Pass the `height` through the `OverlayConfig`.
     * \@breaking-change 7.0.0
     * @param {?=} value New height for the overlay
     * @return {?}
     */
    GlobalPositionStrategy.prototype.height = /**
     * Sets the overlay height and clears any previously set height.
     * @deprecated Pass the `height` through the `OverlayConfig`.
     * \@breaking-change 7.0.0
     * @param {?=} value New height for the overlay
     * @return {?}
     */
    function (value) {
        if (value === void 0) { value = ''; }
        if (this._overlayRef) {
            this._overlayRef.updateSize({ height: value });
        }
        else {
            this._height = value;
        }
        return this;
    };
    /**
     * Centers the overlay horizontally with an optional offset.
     * Clears any previously set horizontal position.
     *
     * @param offset Overlay offset from the horizontal center.
     */
    /**
     * Centers the overlay horizontally with an optional offset.
     * Clears any previously set horizontal position.
     *
     * @param {?=} offset Overlay offset from the horizontal center.
     * @return {?}
     */
    GlobalPositionStrategy.prototype.centerHorizontally = /**
     * Centers the overlay horizontally with an optional offset.
     * Clears any previously set horizontal position.
     *
     * @param {?=} offset Overlay offset from the horizontal center.
     * @return {?}
     */
    function (offset) {
        if (offset === void 0) { offset = ''; }
        this.left(offset);
        this._justifyContent = 'center';
        return this;
    };
    /**
     * Centers the overlay vertically with an optional offset.
     * Clears any previously set vertical position.
     *
     * @param offset Overlay offset from the vertical center.
     */
    /**
     * Centers the overlay vertically with an optional offset.
     * Clears any previously set vertical position.
     *
     * @param {?=} offset Overlay offset from the vertical center.
     * @return {?}
     */
    GlobalPositionStrategy.prototype.centerVertically = /**
     * Centers the overlay vertically with an optional offset.
     * Clears any previously set vertical position.
     *
     * @param {?=} offset Overlay offset from the vertical center.
     * @return {?}
     */
    function (offset) {
        if (offset === void 0) { offset = ''; }
        this.top(offset);
        this._alignItems = 'center';
        return this;
    };
    /**
     * Apply the position to the element.
     * @docs-private
     */
    /**
     * Apply the position to the element.
     * \@docs-private
     * @return {?}
     */
    GlobalPositionStrategy.prototype.apply = /**
     * Apply the position to the element.
     * \@docs-private
     * @return {?}
     */
    function () {
        // Since the overlay ref applies the strategy asynchronously, it could
        // have been disposed before it ends up being applied. If that is the
        // case, we shouldn't do anything.
        if (!this._overlayRef.hasAttached()) {
            return;
        }
        var /** @type {?} */ styles = this._overlayRef.overlayElement.style;
        var /** @type {?} */ parentStyles = this._overlayRef.hostElement.style;
        var /** @type {?} */ config$$1 = this._overlayRef.getConfig();
        styles.position = this._cssPosition;
        styles.marginLeft = config$$1.width === '100%' ? '0' : this._leftOffset;
        styles.marginTop = config$$1.height === '100%' ? '0' : this._topOffset;
        styles.marginBottom = this._bottomOffset;
        styles.marginRight = this._rightOffset;
        if (config$$1.width === '100%') {
            parentStyles.justifyContent = 'flex-start';
        }
        else if (this._justifyContent === 'center') {
            parentStyles.justifyContent = 'center';
        }
        else if (this._overlayRef.getConfig().direction === 'rtl') {
            // In RTL the browser will invert `flex-start` and `flex-end` automatically, but we
            // don't want that because our positioning is explicitly `left` and `right`, hence
            // why we do another inversion to ensure that the overlay stays in the same position.
            // TODO: reconsider this if we add `start` and `end` methods.
            if (this._justifyContent === 'flex-start') {
                parentStyles.justifyContent = 'flex-end';
            }
            else if (this._justifyContent === 'flex-end') {
                parentStyles.justifyContent = 'flex-start';
            }
        }
        else {
            parentStyles.justifyContent = this._justifyContent;
        }
        parentStyles.alignItems = config$$1.height === '100%' ? 'flex-start' : this._alignItems;
    };
    /**
     * Noop implemented as a part of the PositionStrategy interface.
     * @docs-private
     */
    /**
     * Noop implemented as a part of the PositionStrategy interface.
     * \@docs-private
     * @return {?}
     */
    GlobalPositionStrategy.prototype.dispose = /**
     * Noop implemented as a part of the PositionStrategy interface.
     * \@docs-private
     * @return {?}
     */
    function () { };
    return GlobalPositionStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Builder for overlay position strategy.
 */
var OverlayPositionBuilder = /** @class */ (function () {
    function OverlayPositionBuilder(_viewportRuler, _document, 
    // @breaking-change 7.0.0 `_platform` and `_overlayContainer` parameters to be made required.
    _platform, _overlayContainer) {
        this._viewportRuler = _viewportRuler;
        this._document = _document;
        this._platform = _platform;
        this._overlayContainer = _overlayContainer;
    }
    /**
     * Creates a global position strategy.
     */
    /**
     * Creates a global position strategy.
     * @return {?}
     */
    OverlayPositionBuilder.prototype.global = /**
     * Creates a global position strategy.
     * @return {?}
     */
    function () {
        return new GlobalPositionStrategy();
    };
    /**
     * Creates a relative position strategy.
     * @param elementRef
     * @param originPos
     * @param overlayPos
     * @deprecated Use `flexibleConnectedTo` instead.
     * @breaking-change 7.0.0
     */
    /**
     * Creates a relative position strategy.
     * @deprecated Use `flexibleConnectedTo` instead.
     * \@breaking-change 7.0.0
     * @param {?} elementRef
     * @param {?} originPos
     * @param {?} overlayPos
     * @return {?}
     */
    OverlayPositionBuilder.prototype.connectedTo = /**
     * Creates a relative position strategy.
     * @deprecated Use `flexibleConnectedTo` instead.
     * \@breaking-change 7.0.0
     * @param {?} elementRef
     * @param {?} originPos
     * @param {?} overlayPos
     * @return {?}
     */
    function (elementRef, originPos, overlayPos) {
        return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document);
    };
    /**
     * Creates a flexible position strategy.
     * @param elementRef
     */
    /**
     * Creates a flexible position strategy.
     * @param {?} elementRef
     * @return {?}
     */
    OverlayPositionBuilder.prototype.flexibleConnectedTo = /**
     * Creates a flexible position strategy.
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        return new FlexibleConnectedPositionStrategy(elementRef, this._viewportRuler, this._document, this._platform, this._overlayContainer);
    };
    OverlayPositionBuilder.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    OverlayPositionBuilder.ctorParameters = function () { return [
        { type: ViewportRuler, },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
        { type: Platform, decorators: [{ type: core.Optional },] },
        { type: OverlayContainer, decorators: [{ type: core.Optional },] },
    ]; };
    /** @nocollapse */ OverlayPositionBuilder.ngInjectableDef = core.defineInjectable({ factory: function OverlayPositionBuilder_Factory() { return new OverlayPositionBuilder(core.inject(ViewportRuler), core.inject(common.DOCUMENT), core.inject(Platform, 8), core.inject(OverlayContainer, 8)); }, token: OverlayPositionBuilder, providedIn: "root" });
    return OverlayPositionBuilder;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Next overlay unique ID.
 */
var /** @type {?} */ nextUniqueId = 0;
/**
 * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be
 * used as a low-level building block for other components. Dialogs, tooltips, menus,
 * selects, etc. can all be built using overlays. The service should primarily be used by authors
 * of re-usable components rather than developers building end-user applications.
 *
 * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.
 */
var Overlay = /** @class */ (function () {
    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality) {
        this.scrollStrategies = scrollStrategies;
        this._overlayContainer = _overlayContainer;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._positionBuilder = _positionBuilder;
        this._keyboardDispatcher = _keyboardDispatcher;
        this._injector = _injector;
        this._ngZone = _ngZone;
        this._document = _document;
        this._directionality = _directionality;
    }
    /**
     * Creates an overlay.
     * @param config Configuration applied to the overlay.
     * @returns Reference to the created overlay.
     */
    /**
     * Creates an overlay.
     * @param {?=} config Configuration applied to the overlay.
     * @return {?} Reference to the created overlay.
     */
    Overlay.prototype.create = /**
     * Creates an overlay.
     * @param {?=} config Configuration applied to the overlay.
     * @return {?} Reference to the created overlay.
     */
    function (config$$1) {
        var /** @type {?} */ host = this._createHostElement();
        var /** @type {?} */ pane = this._createPaneElement(host);
        var /** @type {?} */ portalOutlet = this._createPortalOutlet(pane);
        var /** @type {?} */ overlayConfig = new OverlayConfig(config$$1);
        overlayConfig.direction = overlayConfig.direction || this._directionality.value;
        return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document);
    };
    /**
     * Gets a position builder that can be used, via fluent API,
     * to construct and configure a position strategy.
     * @returns An overlay position builder.
     */
    /**
     * Gets a position builder that can be used, via fluent API,
     * to construct and configure a position strategy.
     * @return {?} An overlay position builder.
     */
    Overlay.prototype.position = /**
     * Gets a position builder that can be used, via fluent API,
     * to construct and configure a position strategy.
     * @return {?} An overlay position builder.
     */
    function () {
        return this._positionBuilder;
    };
    /**
     * Creates the DOM element for an overlay and appends it to the overlay container.
     * @param {?} host
     * @return {?} Newly-created pane element
     */
    Overlay.prototype._createPaneElement = /**
     * Creates the DOM element for an overlay and appends it to the overlay container.
     * @param {?} host
     * @return {?} Newly-created pane element
     */
    function (host) {
        var /** @type {?} */ pane = this._document.createElement('div');
        pane.id = "cdk-overlay-" + nextUniqueId++;
        pane.classList.add('cdk-overlay-pane');
        host.appendChild(pane);
        return pane;
    };
    /**
     * Creates the host element that wraps around an overlay
     * and can be used for advanced positioning.
     * @return {?} Newly-create host element.
     */
    Overlay.prototype._createHostElement = /**
     * Creates the host element that wraps around an overlay
     * and can be used for advanced positioning.
     * @return {?} Newly-create host element.
     */
    function () {
        var /** @type {?} */ host = this._document.createElement('div');
        this._overlayContainer.getContainerElement().appendChild(host);
        return host;
    };
    /**
     * Create a DomPortalOutlet into which the overlay content can be loaded.
     * @param {?} pane The DOM element to turn into a portal outlet.
     * @return {?} A portal outlet for the given DOM element.
     */
    Overlay.prototype._createPortalOutlet = /**
     * Create a DomPortalOutlet into which the overlay content can be loaded.
     * @param {?} pane The DOM element to turn into a portal outlet.
     * @return {?} A portal outlet for the given DOM element.
     */
    function (pane) {
        // We have to resolve the ApplicationRef later in order to allow people
        // to use overlay-based providers during app initialization.
        if (!this._appRef) {
            this._appRef = this._injector.get(core.ApplicationRef);
        }
        return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);
    };
    Overlay.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    Overlay.ctorParameters = function () { return [
        { type: ScrollStrategyOptions, },
        { type: OverlayContainer, },
        { type: core.ComponentFactoryResolver, },
        { type: OverlayPositionBuilder, },
        { type: OverlayKeyboardDispatcher, },
        { type: core.Injector, },
        { type: core.NgZone, },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
        { type: Directionality, },
    ]; };
    return Overlay;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Default set of positions for the overlay. Follows the behavior of a dropdown.
 */
var /** @type {?} */ defaultPositionList = [
    {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'top'
    },
    {
        originX: 'start',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'bottom'
    },
    {
        originX: 'end',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'bottom'
    },
    {
        originX: 'end',
        originY: 'bottom',
        overlayX: 'end',
        overlayY: 'top'
    }
];
/**
 * Injection token that determines the scroll handling while the connected overlay is open.
 */
var /** @type {?} */ CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new core.InjectionToken('cdk-connected-overlay-scroll-strategy');
/**
 * Directive applied to an element to make it usable as an origin for an Overlay using a
 * ConnectedPositionStrategy.
 */
var CdkOverlayOrigin = /** @class */ (function () {
    function CdkOverlayOrigin(elementRef) {
        this.elementRef = elementRef;
    }
    CdkOverlayOrigin.decorators = [
        { type: core.Directive, args: [{
                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',
                    exportAs: 'cdkOverlayOrigin',
                },] },
    ];
    /** @nocollapse */
    CdkOverlayOrigin.ctorParameters = function () { return [
        { type: core.ElementRef, },
    ]; };
    return CdkOverlayOrigin;
}());
/**
 * Directive to facilitate declarative creation of an
 * Overlay using a FlexibleConnectedPositionStrategy.
 */
var CdkConnectedOverlay = /** @class */ (function () {
    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.
    function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, _scrollStrategy, _dir) {
        this._overlay = _overlay;
        this._scrollStrategy = _scrollStrategy;
        this._dir = _dir;
        this._hasBackdrop = false;
        this._lockPosition = false;
        this._growAfterOpen = false;
        this._flexibleDimensions = false;
        this._push = false;
        this._backdropSubscription = Subscription.EMPTY;
        /**
         * Margin between the overlay and the viewport edges.
         */
        this.viewportMargin = 0;
        /**
         * Strategy to be used when handling scroll events while the overlay is open.
         */
        this.scrollStrategy = this._scrollStrategy();
        /**
         * Whether the overlay is open.
         */
        this.open = false;
        /**
         * Event emitted when the backdrop is clicked.
         */
        this.backdropClick = new core.EventEmitter();
        /**
         * Event emitted when the position has changed.
         */
        this.positionChange = new core.EventEmitter();
        /**
         * Event emitted when the overlay has been attached.
         */
        this.attach = new core.EventEmitter();
        /**
         * Event emitted when the overlay has been detached.
         */
        this.detach = new core.EventEmitter();
        /**
         * Emits when there are keyboard events that are targeted at the overlay.
         */
        this.overlayKeydown = new core.EventEmitter();
        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);
    }
    Object.defineProperty(CdkConnectedOverlay.prototype, "offsetX", {
        get: /**
         * The offset in pixels for the overlay connection point on the x-axis
         * @return {?}
         */
        function () { return this._offsetX; },
        set: /**
         * @param {?} offsetX
         * @return {?}
         */
        function (offsetX) {
            this._offsetX = offsetX;
            if (this._position) {
                this._setPositions(this._position);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkConnectedOverlay.prototype, "offsetY", {
        get: /**
         * The offset in pixels for the overlay connection point on the y-axis
         * @return {?}
         */
        function () { return this._offsetY; },
        set: /**
         * @param {?} offsetY
         * @return {?}
         */
        function (offsetY) {
            this._offsetY = offsetY;
            if (this._position) {
                this._setPositions(this._position);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkConnectedOverlay.prototype, "hasBackdrop", {
        get: /**
         * Whether or not the overlay should attach a backdrop.
         * @return {?}
         */
        function () { return this._hasBackdrop; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._hasBackdrop = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkConnectedOverlay.prototype, "lockPosition", {
        get: /**
         * Whether or not the overlay should be locked when scrolling.
         * @return {?}
         */
        function () { return this._lockPosition; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._lockPosition = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkConnectedOverlay.prototype, "flexibleDiemsions", {
        get: /**
         * Whether the overlay's width and height can be constrained to fit within the viewport.
         * @return {?}
         */
        function () { return this._flexibleDimensions; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._flexibleDimensions = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkConnectedOverlay.prototype, "growAfterOpen", {
        get: /**
         * Whether the overlay can grow after the initial open when flexible positioning is turned on.
         * @return {?}
         */
        function () { return this._growAfterOpen; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._growAfterOpen = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkConnectedOverlay.prototype, "push", {
        get: /**
         * Whether the overlay can be pushed on-screen if none of the provided positions fit.
         * @return {?}
         */
        function () { return this._push; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._push = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkConnectedOverlay.prototype, "overlayRef", {
        /** The associated overlay reference. */
        get: /**
         * The associated overlay reference.
         * @return {?}
         */
        function () {
            return this._overlayRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkConnectedOverlay.prototype, "dir", {
        /** The element's layout direction. */
        get: /**
         * The element's layout direction.
         * @return {?}
         */
        function () {
            return this._dir ? this._dir.value : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CdkConnectedOverlay.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroyOverlay();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    CdkConnectedOverlay.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (this._position) {
            if (changes['positions']) {
                this._position.withPositions(this.positions);
            }
            if (changes['lockPosition']) {
                this._position.withLockedPosition(this.lockPosition);
            }
            if (changes['origin']) {
                this._position.setOrigin(this.origin.elementRef);
                if (this.open) {
                    this._position.apply();
                }
            }
        }
        if (changes['open']) {
            this.open ? this._attachOverlay() : this._detachOverlay();
        }
    };
    /**
     * Creates an overlay
     * @return {?}
     */
    CdkConnectedOverlay.prototype._createOverlay = /**
     * Creates an overlay
     * @return {?}
     */
    function () {
        if (!this.positions || !this.positions.length) {
            this.positions = defaultPositionList;
        }
        this._overlayRef = this._overlay.create(this._buildConfig());
    };
    /**
     * Builds the overlay config based on the directive's inputs
     * @return {?}
     */
    CdkConnectedOverlay.prototype._buildConfig = /**
     * Builds the overlay config based on the directive's inputs
     * @return {?}
     */
    function () {
        var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();
        var /** @type {?} */ overlayConfig = new OverlayConfig({
            direction: this._dir,
            positionStrategy: positionStrategy,
            scrollStrategy: this.scrollStrategy,
            hasBackdrop: this.hasBackdrop
        });
        if (this.width || this.width === 0) {
            overlayConfig.width = this.width;
        }
        if (this.height || this.height === 0) {
            overlayConfig.height = this.height;
        }
        if (this.minWidth || this.minWidth === 0) {
            overlayConfig.minWidth = this.minWidth;
        }
        if (this.minHeight || this.minHeight === 0) {
            overlayConfig.minHeight = this.minHeight;
        }
        if (this.backdropClass) {
            overlayConfig.backdropClass = this.backdropClass;
        }
        return overlayConfig;
    };
    /**
     * Returns the position strategy of the overlay to be set on the overlay config
     * @return {?}
     */
    CdkConnectedOverlay.prototype._createPositionStrategy = /**
     * Returns the position strategy of the overlay to be set on the overlay config
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ strategy = this._overlay.position()
            .flexibleConnectedTo(this.origin.elementRef)
            .withFlexibleDimensions(this.flexibleDiemsions)
            .withPush(this.push)
            .withGrowAfterOpen(this.growAfterOpen)
            .withViewportMargin(this.viewportMargin)
            .withLockedPosition(this.lockPosition);
        this._setPositions(strategy);
        strategy.positionChanges.subscribe(function (p) { return _this.positionChange.emit(p); });
        return strategy;
    };
    /**
     * Sets the primary and fallback positions of a positions strategy,
     * based on the current directive inputs.
     * @param {?} positionStrategy
     * @return {?}
     */
    CdkConnectedOverlay.prototype._setPositions = /**
     * Sets the primary and fallback positions of a positions strategy,
     * based on the current directive inputs.
     * @param {?} positionStrategy
     * @return {?}
     */
    function (positionStrategy) {
        var _this = this;
        var /** @type {?} */ positions = this.positions.map(function (pos) {
            return ({
                originX: pos.originX,
                originY: pos.originY,
                overlayX: pos.overlayX,
                overlayY: pos.overlayY,
                offsetX: pos.offsetX || _this.offsetX,
                offsetY: pos.offsetY || _this.offsetY
            });
        });
        positionStrategy.withPositions(positions);
    };
    /**
     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists
     * @return {?}
     */
    CdkConnectedOverlay.prototype._attachOverlay = /**
     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._overlayRef) {
            this._createOverlay(); /** @type {?} */
            ((this._overlayRef)).keydownEvents().subscribe(function (event) {
                _this.overlayKeydown.next(event);
                if (event.keyCode === ESCAPE) {
                    _this._detachOverlay();
                }
            });
        }
        else {
            // Update the overlay size, in case the directive's inputs have changed
            this._overlayRef.updateSize({
                width: this.width,
                minWidth: this.minWidth,
                height: this.height,
                minHeight: this.minHeight,
            });
        }
        if (!this._overlayRef.hasAttached()) {
            this._overlayRef.attach(this._templatePortal);
            this.attach.emit();
        }
        if (this.hasBackdrop) {
            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function (event) {
                _this.backdropClick.emit(event);
            });
        }
    };
    /**
     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists
     * @return {?}
     */
    CdkConnectedOverlay.prototype._detachOverlay = /**
     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.detach();
            this.detach.emit();
        }
        this._backdropSubscription.unsubscribe();
    };
    /**
     * Destroys the overlay created by this directive.
     * @return {?}
     */
    CdkConnectedOverlay.prototype._destroyOverlay = /**
     * Destroys the overlay created by this directive.
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.dispose();
        }
        this._backdropSubscription.unsubscribe();
    };
    CdkConnectedOverlay.decorators = [
        { type: core.Directive, args: [{
                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',
                    exportAs: 'cdkConnectedOverlay'
                },] },
    ];
    /** @nocollapse */
    CdkConnectedOverlay.ctorParameters = function () { return [
        { type: Overlay, },
        { type: core.TemplateRef, },
        { type: core.ViewContainerRef, },
        { type: undefined, decorators: [{ type: core.Inject, args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },
        { type: Directionality, decorators: [{ type: core.Optional },] },
    ]; };
    CdkConnectedOverlay.propDecorators = {
        "origin": [{ type: core.Input, args: ['cdkConnectedOverlayOrigin',] },],
        "positions": [{ type: core.Input, args: ['cdkConnectedOverlayPositions',] },],
        "offsetX": [{ type: core.Input, args: ['cdkConnectedOverlayOffsetX',] },],
        "offsetY": [{ type: core.Input, args: ['cdkConnectedOverlayOffsetY',] },],
        "width": [{ type: core.Input, args: ['cdkConnectedOverlayWidth',] },],
        "height": [{ type: core.Input, args: ['cdkConnectedOverlayHeight',] },],
        "minWidth": [{ type: core.Input, args: ['cdkConnectedOverlayMinWidth',] },],
        "minHeight": [{ type: core.Input, args: ['cdkConnectedOverlayMinHeight',] },],
        "backdropClass": [{ type: core.Input, args: ['cdkConnectedOverlayBackdropClass',] },],
        "viewportMargin": [{ type: core.Input, args: ['cdkConnectedOverlayViewportMargin',] },],
        "scrollStrategy": [{ type: core.Input, args: ['cdkConnectedOverlayScrollStrategy',] },],
        "open": [{ type: core.Input, args: ['cdkConnectedOverlayOpen',] },],
        "hasBackdrop": [{ type: core.Input, args: ['cdkConnectedOverlayHasBackdrop',] },],
        "lockPosition": [{ type: core.Input, args: ['cdkConnectedOverlayLockPosition',] },],
        "flexibleDiemsions": [{ type: core.Input, args: ['cdkConnectedOverlayFlexibleDimensions',] },],
        "growAfterOpen": [{ type: core.Input, args: ['cdkConnectedOverlayGrowAfterOpen',] },],
        "push": [{ type: core.Input, args: ['cdkConnectedOverlayPush',] },],
        "backdropClick": [{ type: core.Output },],
        "positionChange": [{ type: core.Output },],
        "attach": [{ type: core.Output },],
        "detach": [{ type: core.Output },],
        "overlayKeydown": [{ type: core.Output },],
    };
    return CdkConnectedOverlay;
}());
/**
 * \@docs-private
 * @param {?} overlay
 * @return {?}
 */
function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return function () { return overlay.scrollStrategies.reposition(); };
}
/**
 * \@docs-private
 */
var /** @type {?} */ CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {
    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,
    deps: [Overlay],
    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var OverlayModule = /** @class */ (function () {
    function OverlayModule() {
    }
    OverlayModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [BidiModule, PortalModule, ScrollDispatchModule],
                    exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollDispatchModule],
                    declarations: [CdkConnectedOverlay, CdkOverlayOrigin],
                    providers: [
                        Overlay,
                        CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,
                    ],
                },] },
    ];
    return OverlayModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Alternative to OverlayContainer that supports correct displaying of overlay elements in
 * Fullscreen mode
 * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen
 *
 * Should be provided in the root component.
 */
var FullscreenOverlayContainer = /** @class */ (function (_super) {
    __extends(FullscreenOverlayContainer, _super);
    function FullscreenOverlayContainer(_document) {
        return _super.call(this, _document) || this;
    }
    /**
     * @return {?}
     */
    FullscreenOverlayContainer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
        if (this._fullScreenEventName && this._fullScreenListener) {
            this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);
        }
    };
    /**
     * @return {?}
     */
    FullscreenOverlayContainer.prototype._createContainer = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype._createContainer.call(this);
        this._adjustParentForFullscreenChange();
        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });
    };
    /**
     * @return {?}
     */
    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**
     * @return {?}
     */
    function () {
        if (!this._containerElement) {
            return;
        }
        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();
        var /** @type {?} */ parent = fullscreenElement || this._document.body;
        parent.appendChild(this._containerElement);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        var /** @type {?} */ eventName = this._getEventName();
        if (eventName) {
            if (this._fullScreenListener) {
                this._document.removeEventListener(eventName, this._fullScreenListener);
            }
            this._document.addEventListener(eventName, fn);
            this._fullScreenListener = fn;
        }
    };
    /**
     * @return {?}
     */
    FullscreenOverlayContainer.prototype._getEventName = /**
     * @return {?}
     */
    function () {
        if (!this._fullScreenEventName) {
            if (this._document.fullscreenEnabled) {
                this._fullScreenEventName = 'fullscreenchange';
            }
            else if (this._document.webkitFullscreenEnabled) {
                this._fullScreenEventName = 'webkitfullscreenchange';
            }
            else if ((/** @type {?} */ (this._document)).mozFullScreenEnabled) {
                this._fullScreenEventName = 'mozfullscreenchange';
            }
            else if ((/** @type {?} */ (this._document)).msFullscreenEnabled) {
                this._fullScreenEventName = 'MSFullscreenChange';
            }
        }
        return this._fullScreenEventName;
    };
    /**
     * When the page is put into fullscreen mode, a specific element is specified.
     * Only that element and its children are visible when in fullscreen mode.
     */
    /**
     * When the page is put into fullscreen mode, a specific element is specified.
     * Only that element and its children are visible when in fullscreen mode.
     * @return {?}
     */
    FullscreenOverlayContainer.prototype.getFullscreenElement = /**
     * When the page is put into fullscreen mode, a specific element is specified.
     * Only that element and its children are visible when in fullscreen mode.
     * @return {?}
     */
    function () {
        return this._document.fullscreenElement ||
            this._document.webkitFullscreenElement ||
            (/** @type {?} */ (this._document)).mozFullScreenElement ||
            (/** @type {?} */ (this._document)).msFullscreenElement ||
            null;
    };
    FullscreenOverlayContainer.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    FullscreenOverlayContainer.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
    ]; };
    return FullscreenOverlayContainer;
}(OverlayContainer));

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect$1;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof commonjsGlobal === "object" ? commonjsGlobal :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122  4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect$1 || (Reflect$1 = {}));

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @abstract
 * @template T
 */
var  /**
 * @abstract
 * @template T
 */
DataSource = /** @class */ (function () {
    function DataSource() {
    }
    return DataSource;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * DataSource wrapper for a native array.
 * @template T
 */
var  /**
 * DataSource wrapper for a native array.
 * @template T
 */
ArrayDataSource = /** @class */ (function (_super) {
    __extends(ArrayDataSource, _super);
    function ArrayDataSource(_data) {
        var _this = _super.call(this) || this;
        _this._data = _data;
        return _this;
    }
    /**
     * @return {?}
     */
    ArrayDataSource.prototype.connect = /**
     * @return {?}
     */
    function () {
        return this._data instanceof Observable ? this._data : of(this._data);
    };
    /**
     * @return {?}
     */
    ArrayDataSource.prototype.disconnect = /**
     * @return {?}
     */
    function () { };
    return ArrayDataSource;
}(DataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Class to be used to power selecting one or more options from a list.
 * @template T
 */
var  /**
 * Class to be used to power selecting one or more options from a list.
 * @template T
 */
SelectionModel = /** @class */ (function () {
    function SelectionModel(_multiple, initiallySelectedValues, _emitChanges) {
        if (_multiple === void 0) { _multiple = false; }
        if (_emitChanges === void 0) { _emitChanges = true; }
        var _this = this;
        this._multiple = _multiple;
        this._emitChanges = _emitChanges;
        /**
         * Currently-selected values.
         */
        this._selection = new Set();
        /**
         * Keeps track of the deselected options that haven't been emitted by the change event.
         */
        this._deselectedToEmit = [];
        /**
         * Keeps track of the selected options that haven't been emitted by the change event.
         */
        this._selectedToEmit = [];
        /**
         * Event emitted when the value has changed.
         */
        this.changed = this._emitChanges ? new Subject() : null;
        /**
         * Event emitted when the value has changed.
         * @deprecated Use `changed` instead.
         * \@breaking-change 8.0.0 To be changed to `changed`
         */
        this.onChange = this.changed;
        if (initiallySelectedValues && initiallySelectedValues.length) {
            if (_multiple) {
                initiallySelectedValues.forEach(function (value) { return _this._markSelected(value); });
            }
            else {
                this._markSelected(initiallySelectedValues[0]);
            }
            // Clear the array in order to avoid firing the change event for preselected values.
            this._selectedToEmit.length = 0;
        }
    }
    Object.defineProperty(SelectionModel.prototype, "selected", {
        /** Selected values. */
        get: /**
         * Selected values.
         * @return {?}
         */
        function () {
            if (!this._selected) {
                this._selected = Array.from(this._selection.values());
            }
            return this._selected;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Selects a value or an array of values.
     */
    /**
     * Selects a value or an array of values.
     * @param {...?} values
     * @return {?}
     */
    SelectionModel.prototype.select = /**
     * Selects a value or an array of values.
     * @param {...?} values
     * @return {?}
     */
    function () {
        var _this = this;
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        this._verifyValueAssignment(values);
        values.forEach(function (value) { return _this._markSelected(value); });
        this._emitChangeEvent();
    };
    /**
     * Deselects a value or an array of values.
     */
    /**
     * Deselects a value or an array of values.
     * @param {...?} values
     * @return {?}
     */
    SelectionModel.prototype.deselect = /**
     * Deselects a value or an array of values.
     * @param {...?} values
     * @return {?}
     */
    function () {
        var _this = this;
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        this._verifyValueAssignment(values);
        values.forEach(function (value) { return _this._unmarkSelected(value); });
        this._emitChangeEvent();
    };
    /**
     * Toggles a value between selected and deselected.
     */
    /**
     * Toggles a value between selected and deselected.
     * @param {?} value
     * @return {?}
     */
    SelectionModel.prototype.toggle = /**
     * Toggles a value between selected and deselected.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.isSelected(value) ? this.deselect(value) : this.select(value);
    };
    /**
     * Clears all of the selected values.
     */
    /**
     * Clears all of the selected values.
     * @return {?}
     */
    SelectionModel.prototype.clear = /**
     * Clears all of the selected values.
     * @return {?}
     */
    function () {
        this._unmarkAll();
        this._emitChangeEvent();
    };
    /**
     * Determines whether a value is selected.
     */
    /**
     * Determines whether a value is selected.
     * @param {?} value
     * @return {?}
     */
    SelectionModel.prototype.isSelected = /**
     * Determines whether a value is selected.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this._selection.has(value);
    };
    /**
     * Determines whether the model does not have a value.
     */
    /**
     * Determines whether the model does not have a value.
     * @return {?}
     */
    SelectionModel.prototype.isEmpty = /**
     * Determines whether the model does not have a value.
     * @return {?}
     */
    function () {
        return this._selection.size === 0;
    };
    /**
     * Determines whether the model has a value.
     */
    /**
     * Determines whether the model has a value.
     * @return {?}
     */
    SelectionModel.prototype.hasValue = /**
     * Determines whether the model has a value.
     * @return {?}
     */
    function () {
        return !this.isEmpty();
    };
    /**
     * Sorts the selected values based on a predicate function.
     */
    /**
     * Sorts the selected values based on a predicate function.
     * @param {?=} predicate
     * @return {?}
     */
    SelectionModel.prototype.sort = /**
     * Sorts the selected values based on a predicate function.
     * @param {?=} predicate
     * @return {?}
     */
    function (predicate) {
        if (this._multiple && this.selected) {
            /** @type {?} */ ((this._selected)).sort(predicate);
        }
    };
    /**
     * Gets whether multiple values can be selected.
     */
    /**
     * Gets whether multiple values can be selected.
     * @return {?}
     */
    SelectionModel.prototype.isMultipleSelection = /**
     * Gets whether multiple values can be selected.
     * @return {?}
     */
    function () {
        return this._multiple;
    };
    /**
     * Emits a change event and clears the records of selected and deselected values.
     * @return {?}
     */
    SelectionModel.prototype._emitChangeEvent = /**
     * Emits a change event and clears the records of selected and deselected values.
     * @return {?}
     */
    function () {
        // Clear the selected values so they can be re-cached.
        this._selected = null;
        if (this._selectedToEmit.length || this._deselectedToEmit.length) {
            if (this.changed) {
                this.changed.next({
                    source: this,
                    added: this._selectedToEmit,
                    removed: this._deselectedToEmit
                });
            }
            this._deselectedToEmit = [];
            this._selectedToEmit = [];
        }
    };
    /**
     * Selects a value.
     * @param {?} value
     * @return {?}
     */
    SelectionModel.prototype._markSelected = /**
     * Selects a value.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!this.isSelected(value)) {
            if (!this._multiple) {
                this._unmarkAll();
            }
            this._selection.add(value);
            if (this._emitChanges) {
                this._selectedToEmit.push(value);
            }
        }
    };
    /**
     * Deselects a value.
     * @param {?} value
     * @return {?}
     */
    SelectionModel.prototype._unmarkSelected = /**
     * Deselects a value.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.isSelected(value)) {
            this._selection.delete(value);
            if (this._emitChanges) {
                this._deselectedToEmit.push(value);
            }
        }
    };
    /**
     * Clears out the selected values.
     * @return {?}
     */
    SelectionModel.prototype._unmarkAll = /**
     * Clears out the selected values.
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.isEmpty()) {
            this._selection.forEach(function (value) { return _this._unmarkSelected(value); });
        }
    };
    /**
     * Verifies the value assignment and throws an error if the specified value array is
     * including multiple values while the selection model is not supporting multiple values.
     * @param {?} values
     * @return {?}
     */
    SelectionModel.prototype._verifyValueAssignment = /**
     * Verifies the value assignment and throws an error if the specified value array is
     * including multiple values while the selection model is not supporting multiple values.
     * @param {?} values
     * @return {?}
     */
    function (values) {
        if (values.length > 1 && !this._multiple) {
            throw getMultipleValuesInSingleSelectionError();
        }
    };
    return SelectionModel;
}());
/**
 * Returns an error that reports that multiple values are passed into a selection model
 * with a single value.
 * @return {?}
 */
function getMultipleValuesInSingleSelectionError() {
    return Error('Cannot pass multiple values into SelectionModel with single-value mode.');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Class to coordinate unique selection based on name.
 * Intended to be consumed as an Angular service.
 * This service is needed because native radio change events are only fired on the item currently
 * being selected, and we still need to uncheck the previous selection.
 *
 * This service does not *store* any IDs and names because they may change at any time, so it is
 * less error-prone if they are simply passed through when the events occur.
 */
var UniqueSelectionDispatcher = /** @class */ (function () {
    function UniqueSelectionDispatcher() {
        this._listeners = [];
    }
    /**
     * Notify other items that selection for the given name has been set.
     * @param id ID of the item.
     * @param name Name of the item.
     */
    /**
     * Notify other items that selection for the given name has been set.
     * @param {?} id ID of the item.
     * @param {?} name Name of the item.
     * @return {?}
     */
    UniqueSelectionDispatcher.prototype.notify = /**
     * Notify other items that selection for the given name has been set.
     * @param {?} id ID of the item.
     * @param {?} name Name of the item.
     * @return {?}
     */
    function (id, name) {
        for (var _i = 0, _a = this._listeners; _i < _a.length; _i++) {
            var listener = _a[_i];
            listener(id, name);
        }
    };
    /**
     * Listen for future changes to item selection.
     * @return Function used to deregister listener
     */
    /**
     * Listen for future changes to item selection.
     * @param {?} listener
     * @return {?} Function used to deregister listener
     */
    UniqueSelectionDispatcher.prototype.listen = /**
     * Listen for future changes to item selection.
     * @param {?} listener
     * @return {?} Function used to deregister listener
     */
    function (listener) {
        var _this = this;
        this._listeners.push(listener);
        return function () {
            _this._listeners = _this._listeners.filter(function (registered) {
                return listener !== registered;
            });
        };
    };
    /**
     * @return {?}
     */
    UniqueSelectionDispatcher.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._listeners = [];
    };
    UniqueSelectionDispatcher.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */ UniqueSelectionDispatcher.ngInjectableDef = core.defineInjectable({ factory: function UniqueSelectionDispatcher_Factory() { return new UniqueSelectionDispatcher(); }, token: UniqueSelectionDispatcher, providedIn: "root" });
    return UniqueSelectionDispatcher;
}());

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.
 * \@docs-private
 */
var MutationObserverFactory = /** @class */ (function () {
    function MutationObserverFactory() {
    }
    /**
     * @param {?} callback
     * @return {?}
     */
    MutationObserverFactory.prototype.create = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);
    };
    MutationObserverFactory.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */ MutationObserverFactory.ngInjectableDef = core.defineInjectable({ factory: function MutationObserverFactory_Factory() { return new MutationObserverFactory(); }, token: MutationObserverFactory, providedIn: "root" });
    return MutationObserverFactory;
}());
/**
 * An injectable service that allows watching elements for changes to their content.
 */
var ContentObserver = /** @class */ (function () {
    function ContentObserver(_mutationObserverFactory) {
        this._mutationObserverFactory = _mutationObserverFactory;
        /**
         * Keeps track of the existing MutationObservers so they can be reused.
         */
        this._observedElements = new Map();
    }
    /**
     * @return {?}
     */
    ContentObserver.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._observedElements.forEach(function (_, element) { return _this._cleanupObserver(element); });
    };
    /**
     * @param {?} elementOrRef
     * @return {?}
     */
    ContentObserver.prototype.observe = /**
     * @param {?} elementOrRef
     * @return {?}
     */
    function (elementOrRef) {
        var _this = this;
        var /** @type {?} */ element = elementOrRef instanceof core.ElementRef ? elementOrRef.nativeElement : elementOrRef;
        return Observable.create(function (observer) {
            var /** @type {?} */ stream = _this._observeElement(element);
            var /** @type {?} */ subscription = stream.subscribe(observer);
            return function () {
                subscription.unsubscribe();
                _this._unobserveElement(element);
            };
        });
    };
    /**
     * Observes the given element by using the existing MutationObserver if available, or creating a
     * new one if not.
     * @param {?} element
     * @return {?}
     */
    ContentObserver.prototype._observeElement = /**
     * Observes the given element by using the existing MutationObserver if available, or creating a
     * new one if not.
     * @param {?} element
     * @return {?}
     */
    function (element) {
        if (!this._observedElements.has(element)) {
            var /** @type {?} */ stream_1 = new Subject();
            var /** @type {?} */ observer = this._mutationObserverFactory.create(function (mutations) { return stream_1.next(mutations); });
            if (observer) {
                observer.observe(element, {
                    characterData: true,
                    childList: true,
                    subtree: true
                });
            }
            this._observedElements.set(element, { observer: observer, stream: stream_1, count: 1 });
        }
        else {
            /** @type {?} */ ((this._observedElements.get(element))).count++;
        }
        return /** @type {?} */ ((this._observedElements.get(element))).stream;
    };
    /**
     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is
     * observing this element.
     * @param {?} element
     * @return {?}
     */
    ContentObserver.prototype._unobserveElement = /**
     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is
     * observing this element.
     * @param {?} element
     * @return {?}
     */
    function (element) {
        if (this._observedElements.has(element)) {
            /** @type {?} */ ((this._observedElements.get(element))).count--;
            if (!/** @type {?} */ ((this._observedElements.get(element))).count) {
                this._cleanupObserver(element);
            }
        }
    };
    /**
     * Clean up the underlying MutationObserver for the specified element.
     * @param {?} element
     * @return {?}
     */
    ContentObserver.prototype._cleanupObserver = /**
     * Clean up the underlying MutationObserver for the specified element.
     * @param {?} element
     * @return {?}
     */
    function (element) {
        if (this._observedElements.has(element)) {
            var _a = /** @type {?} */ ((this._observedElements.get(element))), observer = _a.observer, stream = _a.stream;
            if (observer) {
                observer.disconnect();
            }
            stream.complete();
            this._observedElements.delete(element);
        }
    };
    ContentObserver.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    ContentObserver.ctorParameters = function () { return [
        { type: MutationObserverFactory, },
    ]; };
    /** @nocollapse */ ContentObserver.ngInjectableDef = core.defineInjectable({ factory: function ContentObserver_Factory() { return new ContentObserver(core.inject(MutationObserverFactory)); }, token: ContentObserver, providedIn: "root" });
    return ContentObserver;
}());
/**
 * Directive that triggers a callback whenever the content of
 * its associated element has changed.
 */
var CdkObserveContent = /** @class */ (function () {
    function CdkObserveContent(_contentObserver, _elementRef, _ngZone) {
        this._contentObserver = _contentObserver;
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        /**
         * Event emitted for each change in the element's content.
         */
        this.event = new core.EventEmitter();
        this._disabled = false;
        this._currentSubscription = null;
    }
    Object.defineProperty(CdkObserveContent.prototype, "disabled", {
        get: /**
         * Whether observing content is disabled. This option can be used
         * to disconnect the underlying MutationObserver until it is needed.
         * @return {?}
         */
        function () { return this._disabled; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = coerceBooleanProperty(value);
            if (this._disabled) {
                this._unsubscribe();
            }
            else {
                this._subscribe();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkObserveContent.prototype, "debounce", {
        get: /**
         * Debounce interval for emitting the changes.
         * @return {?}
         */
        function () { return this._debounce; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._debounce = coerceNumberProperty(value);
            this._subscribe();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CdkObserveContent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (!this._currentSubscription && !this.disabled) {
            this._subscribe();
        }
    };
    /**
     * @return {?}
     */
    CdkObserveContent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._unsubscribe();
    };
    /**
     * @return {?}
     */
    CdkObserveContent.prototype._subscribe = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._unsubscribe();
        var /** @type {?} */ stream = this._contentObserver.observe(this._elementRef);
        // TODO(mmalerba): We shouldn't be emitting on this @Output() outside the zone.
        // Consider brining it back inside the zone next time we're making breaking changes.
        // Bringing it back inside can cause things like infinite change detection loops and changed
        // after checked errors if people's code isn't handling it properly.
        this._ngZone.runOutsideAngular(function () {
            _this._currentSubscription =
                (_this.debounce ? stream.pipe(debounceTime(_this.debounce)) : stream).subscribe(_this.event);
        });
    };
    /**
     * @return {?}
     */
    CdkObserveContent.prototype._unsubscribe = /**
     * @return {?}
     */
    function () {
        if (this._currentSubscription) {
            this._currentSubscription.unsubscribe();
        }
    };
    CdkObserveContent.decorators = [
        { type: core.Directive, args: [{
                    selector: '[cdkObserveContent]',
                    exportAs: 'cdkObserveContent',
                },] },
    ];
    /** @nocollapse */
    CdkObserveContent.ctorParameters = function () { return [
        { type: ContentObserver, },
        { type: core.ElementRef, },
        { type: core.NgZone, },
    ]; };
    CdkObserveContent.propDecorators = {
        "event": [{ type: core.Output, args: ['cdkObserveContent',] },],
        "disabled": [{ type: core.Input, args: ['cdkObserveContentDisabled',] },],
        "debounce": [{ type: core.Input },],
    };
    return CdkObserveContent;
}());
var ObserversModule = /** @class */ (function () {
    function ObserversModule() {
    }
    ObserversModule.decorators = [
        { type: core.NgModule, args: [{
                    exports: [CdkObserveContent],
                    declarations: [CdkObserveContent],
                    providers: [MutationObserverFactory]
                },] },
    ];
    return ObserversModule;
}());

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * IDs are deliminated by an empty space, as per the spec.
 */
var /** @type {?} */ ID_DELIMINATOR = ' ';
/**
 * Adds the given ID to the specified ARIA attribute on an element.
 * Used for attributes such as aria-labelledby, aria-owns, etc.
 * @param {?} el
 * @param {?} attr
 * @param {?} id
 * @return {?}
 */
function addAriaReferencedId(el, attr, id) {
    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);
    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {
        return;
    }
    ids.push(id.trim());
    el.setAttribute(attr, ids.join(ID_DELIMINATOR));
}
/**
 * Removes the given ID from the specified ARIA attribute on an element.
 * Used for attributes such as aria-labelledby, aria-owns, etc.
 * @param {?} el
 * @param {?} attr
 * @param {?} id
 * @return {?}
 */
function removeAriaReferencedId(el, attr, id) {
    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);
    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });
    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));
}
/**
 * Gets the list of IDs referenced by the given ARIA attribute on an element.
 * Used for attributes such as aria-labelledby, aria-owns, etc.
 * @param {?} el
 * @param {?} attr
 * @return {?}
 */
function getAriaReferenceIds(el, attr) {
    // Get string array of all individual ids (whitespace deliminated) in the attribute value
    return (el.getAttribute(attr) || '').match(/\S+/g) || [];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * ID used for the body container where all messages are appended.
 */
var /** @type {?} */ MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';
/**
 * ID prefix used for each created message element.
 */
var /** @type {?} */ CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';
/**
 * Attribute given to each host element that is described by a message element.
 */
var /** @type {?} */ CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';
/**
 * Global incremental identifier for each registered message element.
 */
var /** @type {?} */ nextId = 0;
/**
 * Global map of all registered message elements that have been placed into the document.
 */
var /** @type {?} */ messageRegistry = new Map();
/**
 * Container for all registered messages.
 */
var /** @type {?} */ messagesContainer = null;
/**
 * Utility that creates visually hidden elements with a message content. Useful for elements that
 * want to use aria-describedby to further describe themselves without adding additional visual
 * content.
 * \@docs-private
 */
var AriaDescriber = /** @class */ (function () {
    function AriaDescriber(_document) {
        this._document = _document;
    }
    /**
     * Adds to the host element an aria-describedby reference to a hidden element that contains
     * the message. If the same message has already been registered, then it will reuse the created
     * message element.
     */
    /**
     * Adds to the host element an aria-describedby reference to a hidden element that contains
     * the message. If the same message has already been registered, then it will reuse the created
     * message element.
     * @param {?} hostElement
     * @param {?} message
     * @return {?}
     */
    AriaDescriber.prototype.describe = /**
     * Adds to the host element an aria-describedby reference to a hidden element that contains
     * the message. If the same message has already been registered, then it will reuse the created
     * message element.
     * @param {?} hostElement
     * @param {?} message
     * @return {?}
     */
    function (hostElement, message) {
        if (!this._canBeDescribed(hostElement, message)) {
            return;
        }
        if (!messageRegistry.has(message)) {
            this._createMessageElement(message);
        }
        if (!this._isElementDescribedByMessage(hostElement, message)) {
            this._addMessageReference(hostElement, message);
        }
    };
    /** Removes the host element's aria-describedby reference to the message element. */
    /**
     * Removes the host element's aria-describedby reference to the message element.
     * @param {?} hostElement
     * @param {?} message
     * @return {?}
     */
    AriaDescriber.prototype.removeDescription = /**
     * Removes the host element's aria-describedby reference to the message element.
     * @param {?} hostElement
     * @param {?} message
     * @return {?}
     */
    function (hostElement, message) {
        if (!this._canBeDescribed(hostElement, message)) {
            return;
        }
        if (this._isElementDescribedByMessage(hostElement, message)) {
            this._removeMessageReference(hostElement, message);
        }
        var /** @type {?} */ registeredMessage = messageRegistry.get(message);
        if (registeredMessage && registeredMessage.referenceCount === 0) {
            this._deleteMessageElement(message);
        }
        if (messagesContainer && messagesContainer.childNodes.length === 0) {
            this._deleteMessagesContainer();
        }
    };
    /** Unregisters all created message elements and removes the message container. */
    /**
     * Unregisters all created message elements and removes the message container.
     * @return {?}
     */
    AriaDescriber.prototype.ngOnDestroy = /**
     * Unregisters all created message elements and removes the message container.
     * @return {?}
     */
    function () {
        var /** @type {?} */ describedElements = this._document.querySelectorAll("[" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + "]");
        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {
            this._removeCdkDescribedByReferenceIds(describedElements[i]);
            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
        }
        if (messagesContainer) {
            this._deleteMessagesContainer();
        }
        messageRegistry.clear();
    };
    /**
     * Creates a new element in the visually hidden message container element with the message
     * as its content and adds it to the message registry.
     * @param {?} message
     * @return {?}
     */
    AriaDescriber.prototype._createMessageElement = /**
     * Creates a new element in the visually hidden message container element with the message
     * as its content and adds it to the message registry.
     * @param {?} message
     * @return {?}
     */
    function (message) {
        var /** @type {?} */ messageElement = this._document.createElement('div');
        messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + "-" + nextId++);
        messageElement.appendChild(/** @type {?} */ ((this._document.createTextNode(message))));
        this._createMessagesContainer(); /** @type {?} */
        ((messagesContainer)).appendChild(messageElement);
        messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });
    };
    /**
     * Deletes the message element from the global messages container.
     * @param {?} message
     * @return {?}
     */
    AriaDescriber.prototype._deleteMessageElement = /**
     * Deletes the message element from the global messages container.
     * @param {?} message
     * @return {?}
     */
    function (message) {
        var /** @type {?} */ registeredMessage = messageRegistry.get(message);
        var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;
        if (messagesContainer && messageElement) {
            messagesContainer.removeChild(messageElement);
        }
        messageRegistry.delete(message);
    };
    /**
     * Creates the global container for all aria-describedby messages.
     * @return {?}
     */
    AriaDescriber.prototype._createMessagesContainer = /**
     * Creates the global container for all aria-describedby messages.
     * @return {?}
     */
    function () {
        if (!messagesContainer) {
            var /** @type {?} */ preExistingContainer = this._document.getElementById(MESSAGES_CONTAINER_ID);
            // When going from the server to the client, we may end up in a situation where there's
            // already a container on the page, but we don't have a reference to it. Clear the
            // old container so we don't get duplicates. Doing this, instead of emptying the previous
            // container, should be slightly faster.
            if (preExistingContainer) {
                /** @type {?} */ ((preExistingContainer.parentNode)).removeChild(preExistingContainer);
            }
            messagesContainer = this._document.createElement('div');
            messagesContainer.id = MESSAGES_CONTAINER_ID;
            messagesContainer.setAttribute('aria-hidden', 'true');
            messagesContainer.style.display = 'none';
            this._document.body.appendChild(messagesContainer);
        }
    };
    /**
     * Deletes the global messages container.
     * @return {?}
     */
    AriaDescriber.prototype._deleteMessagesContainer = /**
     * Deletes the global messages container.
     * @return {?}
     */
    function () {
        if (messagesContainer && messagesContainer.parentNode) {
            messagesContainer.parentNode.removeChild(messagesContainer);
            messagesContainer = null;
        }
    };
    /**
     * Removes all cdk-describedby messages that are hosted through the element.
     * @param {?} element
     * @return {?}
     */
    AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**
     * Removes all cdk-describedby messages that are hosted through the element.
     * @param {?} element
     * @return {?}
     */
    function (element) {
        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX
        var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')
            .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });
        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));
    };
    /**
     * Adds a message reference to the element using aria-describedby and increments the registered
     * message's reference count.
     * @param {?} element
     * @param {?} message
     * @return {?}
     */
    AriaDescriber.prototype._addMessageReference = /**
     * Adds a message reference to the element using aria-describedby and increments the registered
     * message's reference count.
     * @param {?} element
     * @param {?} message
     * @return {?}
     */
    function (element, message) {
        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));
        // Add the aria-describedby reference and set the
        // describedby_host attribute to mark the element.
        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);
        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');
        registeredMessage.referenceCount++;
    };
    /**
     * Removes a message reference from the element using aria-describedby
     * and decrements the registered message's reference count.
     * @param {?} element
     * @param {?} message
     * @return {?}
     */
    AriaDescriber.prototype._removeMessageReference = /**
     * Removes a message reference from the element using aria-describedby
     * and decrements the registered message's reference count.
     * @param {?} element
     * @param {?} message
     * @return {?}
     */
    function (element, message) {
        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));
        registeredMessage.referenceCount--;
        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);
        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
    };
    /**
     * Returns true if the element has been described by the provided message ID.
     * @param {?} element
     * @param {?} message
     * @return {?}
     */
    AriaDescriber.prototype._isElementDescribedByMessage = /**
     * Returns true if the element has been described by the provided message ID.
     * @param {?} element
     * @param {?} message
     * @return {?}
     */
    function (element, message) {
        var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');
        var /** @type {?} */ registeredMessage = messageRegistry.get(message);
        var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;
        return !!messageId && referenceIds.indexOf(messageId) != -1;
    };
    /**
     * Determines whether a message can be described on a particular element.
     * @param {?} element
     * @param {?} message
     * @return {?}
     */
    AriaDescriber.prototype._canBeDescribed = /**
     * Determines whether a message can be described on a particular element.
     * @param {?} element
     * @param {?} message
     * @return {?}
     */
    function (element, message) {
        return element.nodeType === this._document.ELEMENT_NODE && message != null &&
            !!("" + message).trim();
    };
    AriaDescriber.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    AriaDescriber.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
    ]; };
    /** @nocollapse */ AriaDescriber.ngInjectableDef = core.defineInjectable({ factory: function AriaDescriber_Factory() { return new AriaDescriber(core.inject(common.DOCUMENT)); }, token: AriaDescriber, providedIn: "root" });
    return AriaDescriber;
}());
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 * @param {?} parentDispatcher
 * @param {?} _document
 * @return {?}
 */
function ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {
    return parentDispatcher || new AriaDescriber(_document);
}
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 */
var /** @type {?} */ ARIA_DESCRIBER_PROVIDER = {
    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.
    provide: AriaDescriber,
    deps: [
        [new core.Optional(), new core.SkipSelf(), AriaDescriber],
        /** @type {?} */ (common.DOCUMENT)
    ],
    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// unsupported: template constraints.
/**
 * This class manages keyboard events for selectable lists. If you pass it a query list
 * of items, it will set the active item correctly when arrow events occur.
 * @template T
 */
var  
// unsupported: template constraints.
/**
 * This class manages keyboard events for selectable lists. If you pass it a query list
 * of items, it will set the active item correctly when arrow events occur.
 * @template T
 */
ListKeyManager = /** @class */ (function () {
    function ListKeyManager(_items) {
        var _this = this;
        this._items = _items;
        this._activeItemIndex = -1;
        this._wrap = false;
        this._letterKeyStream = new Subject();
        this._typeaheadSubscription = Subscription.EMPTY;
        this._vertical = true;
        /**
         * Predicate function that can be used to check whether an item should be skipped
         * by the key manager. By default, disabled items are skipped.
         */
        this._skipPredicateFn = function (item) { return item.disabled; };
        this._pressedLetters = [];
        /**
         * Stream that emits any time the TAB key is pressed, so components can react
         * when focus is shifted off of the list.
         */
        this.tabOut = new Subject();
        /**
         * Stream that emits whenever the active item of the list manager changes.
         */
        this.change = new Subject();
        // We allow for the items to be an array because, in some cases, the consumer may
        // not have access to a QueryList of the items they want to manage (e.g. when the
        // items aren't being collected via `ViewChildren` or `ContentChildren`).
        if (_items instanceof core.QueryList) {
            _items.changes.subscribe(function (newItems) {
                if (_this._activeItem) {
                    var /** @type {?} */ itemArray = newItems.toArray();
                    var /** @type {?} */ newIndex = itemArray.indexOf(_this._activeItem);
                    if (newIndex > -1 && newIndex !== _this._activeItemIndex) {
                        _this._activeItemIndex = newIndex;
                    }
                }
            });
        }
    }
    /**
     * Sets the predicate function that determines which items should be skipped by the
     * list key manager.
     * @param predicate Function that determines whether the given item should be skipped.
     */
    /**
     * Sets the predicate function that determines which items should be skipped by the
     * list key manager.
     * @param {?} predicate Function that determines whether the given item should be skipped.
     * @return {?}
     */
    ListKeyManager.prototype.skipPredicate = /**
     * Sets the predicate function that determines which items should be skipped by the
     * list key manager.
     * @param {?} predicate Function that determines whether the given item should be skipped.
     * @return {?}
     */
    function (predicate) {
        this._skipPredicateFn = predicate;
        return this;
    };
    /**
     * Configures wrapping mode, which determines whether the active item will wrap to
     * the other end of list when there are no more items in the given direction.
     * @param shouldWrap Whether the list should wrap when reaching the end.
     */
    /**
     * Configures wrapping mode, which determines whether the active item will wrap to
     * the other end of list when there are no more items in the given direction.
     * @param {?=} shouldWrap Whether the list should wrap when reaching the end.
     * @return {?}
     */
    ListKeyManager.prototype.withWrap = /**
     * Configures wrapping mode, which determines whether the active item will wrap to
     * the other end of list when there are no more items in the given direction.
     * @param {?=} shouldWrap Whether the list should wrap when reaching the end.
     * @return {?}
     */
    function (shouldWrap) {
        if (shouldWrap === void 0) { shouldWrap = true; }
        this._wrap = shouldWrap;
        return this;
    };
    /**
     * Configures whether the key manager should be able to move the selection vertically.
     * @param enabled Whether vertical selection should be enabled.
     */
    /**
     * Configures whether the key manager should be able to move the selection vertically.
     * @param {?=} enabled Whether vertical selection should be enabled.
     * @return {?}
     */
    ListKeyManager.prototype.withVerticalOrientation = /**
     * Configures whether the key manager should be able to move the selection vertically.
     * @param {?=} enabled Whether vertical selection should be enabled.
     * @return {?}
     */
    function (enabled) {
        if (enabled === void 0) { enabled = true; }
        this._vertical = enabled;
        return this;
    };
    /**
     * Configures the key manager to move the selection horizontally.
     * Passing in `null` will disable horizontal movement.
     * @param direction Direction in which the selection can be moved.
     */
    /**
     * Configures the key manager to move the selection horizontally.
     * Passing in `null` will disable horizontal movement.
     * @param {?} direction Direction in which the selection can be moved.
     * @return {?}
     */
    ListKeyManager.prototype.withHorizontalOrientation = /**
     * Configures the key manager to move the selection horizontally.
     * Passing in `null` will disable horizontal movement.
     * @param {?} direction Direction in which the selection can be moved.
     * @return {?}
     */
    function (direction) {
        this._horizontal = direction;
        return this;
    };
    /**
     * Turns on typeahead mode which allows users to set the active item by typing.
     * @param debounceInterval Time to wait after the last keystroke before setting the active item.
     */
    /**
     * Turns on typeahead mode which allows users to set the active item by typing.
     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.
     * @return {?}
     */
    ListKeyManager.prototype.withTypeAhead = /**
     * Turns on typeahead mode which allows users to set the active item by typing.
     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.
     * @return {?}
     */
    function (debounceInterval) {
        var _this = this;
        if (debounceInterval === void 0) { debounceInterval = 200; }
        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {
            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');
        }
        this._typeaheadSubscription.unsubscribe();
        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters
        // and convert those letters back into a string. Afterwards find the first item that starts
        // with that string and select it.
        this._typeaheadSubscription = this._letterKeyStream.pipe(tap(function (keyCode) { return _this._pressedLetters.push(keyCode); }), debounceTime(debounceInterval), filter(function () { return _this._pressedLetters.length > 0; }), map(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {
            var /** @type {?} */ items = _this._getItemsArray();
            // Start at 1 because we want to start searching at the item immediately
            // following the current active item.
            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {
                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;
                var /** @type {?} */ item = items[index];
                if (!_this._skipPredicateFn(item) && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {
                    _this.setActiveItem(index);
                    break;
                }
            }
            _this._pressedLetters = [];
        });
        return this;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    ListKeyManager.prototype.setActiveItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ previousIndex = this._activeItemIndex;
        this.updateActiveItem(item);
        if (this._activeItemIndex !== previousIndex) {
            this.change.next(this._activeItemIndex);
        }
    };
    /**
     * Sets the active item depending on the key event passed in.
     * @param event Keyboard event to be used for determining which element should be active.
     */
    /**
     * Sets the active item depending on the key event passed in.
     * @param {?} event Keyboard event to be used for determining which element should be active.
     * @return {?}
     */
    ListKeyManager.prototype.onKeydown = /**
     * Sets the active item depending on the key event passed in.
     * @param {?} event Keyboard event to be used for determining which element should be active.
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ keyCode = event.keyCode;
        switch (keyCode) {
            case TAB:
                this.tabOut.next();
                return;
            case DOWN_ARROW:
                if (this._vertical) {
                    this.setNextItemActive();
                    break;
                }
                else {
                    return;
                }
            case UP_ARROW:
                if (this._vertical) {
                    this.setPreviousItemActive();
                    break;
                }
                else {
                    return;
                }
            case RIGHT_ARROW:
                if (this._horizontal === 'ltr') {
                    this.setNextItemActive();
                    break;
                }
                else if (this._horizontal === 'rtl') {
                    this.setPreviousItemActive();
                    break;
                }
                else {
                    return;
                }
            case LEFT_ARROW:
                if (this._horizontal === 'ltr') {
                    this.setPreviousItemActive();
                    break;
                }
                else if (this._horizontal === 'rtl') {
                    this.setNextItemActive();
                    break;
                }
                else {
                    return;
                }
            default:
                // Attempt to use the `event.key` which also maps it to the user's keyboard language,
                // otherwise fall back to resolving alphanumeric characters via the keyCode.
                if (event.key && event.key.length === 1) {
                    this._letterKeyStream.next(event.key.toLocaleUpperCase());
                }
                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {
                    this._letterKeyStream.next(String.fromCharCode(keyCode));
                }
                // Note that we return here, in order to avoid preventing
                // the default action of non-navigational keys.
                return;
        }
        this._pressedLetters = [];
        event.preventDefault();
    };
    Object.defineProperty(ListKeyManager.prototype, "activeItemIndex", {
        /** Index of the currently active item. */
        get: /**
         * Index of the currently active item.
         * @return {?}
         */
        function () {
            return this._activeItemIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListKeyManager.prototype, "activeItem", {
        /** The active item. */
        get: /**
         * The active item.
         * @return {?}
         */
        function () {
            return this._activeItem;
        },
        enumerable: true,
        configurable: true
    });
    /** Sets the active item to the first enabled item in the list. */
    /**
     * Sets the active item to the first enabled item in the list.
     * @return {?}
     */
    ListKeyManager.prototype.setFirstItemActive = /**
     * Sets the active item to the first enabled item in the list.
     * @return {?}
     */
    function () {
        this._setActiveItemByIndex(0, 1);
    };
    /** Sets the active item to the last enabled item in the list. */
    /**
     * Sets the active item to the last enabled item in the list.
     * @return {?}
     */
    ListKeyManager.prototype.setLastItemActive = /**
     * Sets the active item to the last enabled item in the list.
     * @return {?}
     */
    function () {
        this._setActiveItemByIndex(this._items.length - 1, -1);
    };
    /** Sets the active item to the next enabled item in the list. */
    /**
     * Sets the active item to the next enabled item in the list.
     * @return {?}
     */
    ListKeyManager.prototype.setNextItemActive = /**
     * Sets the active item to the next enabled item in the list.
     * @return {?}
     */
    function () {
        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);
    };
    /** Sets the active item to a previous enabled item in the list. */
    /**
     * Sets the active item to a previous enabled item in the list.
     * @return {?}
     */
    ListKeyManager.prototype.setPreviousItemActive = /**
     * Sets the active item to a previous enabled item in the list.
     * @return {?}
     */
    function () {
        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()
            : this._setActiveItemByDelta(-1);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    ListKeyManager.prototype.updateActiveItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ itemArray = this._getItemsArray();
        var /** @type {?} */ index = typeof item === 'number' ? item : itemArray.indexOf(item);
        this._activeItemIndex = index;
        this._activeItem = itemArray[index];
    };
    /**
     * Allows setting of the activeItemIndex without any other effects.
     * @param index The new activeItemIndex.
     * @deprecated Use `updateActiveItem` instead.
     * @breaking-change 7.0.0
     */
    /**
     * Allows setting of the activeItemIndex without any other effects.
     * @deprecated Use `updateActiveItem` instead.
     * \@breaking-change 7.0.0
     * @param {?} index The new activeItemIndex.
     * @return {?}
     */
    ListKeyManager.prototype.updateActiveItemIndex = /**
     * Allows setting of the activeItemIndex without any other effects.
     * @deprecated Use `updateActiveItem` instead.
     * \@breaking-change 7.0.0
     * @param {?} index The new activeItemIndex.
     * @return {?}
     */
    function (index) {
        this.updateActiveItem(index);
    };
    /**
     * This method sets the active item, given a list of items and the delta between the
     * currently active item and the new active item. It will calculate differently
     * depending on whether wrap mode is turned on.
     * @param {?} delta
     * @return {?}
     */
    ListKeyManager.prototype._setActiveItemByDelta = /**
     * This method sets the active item, given a list of items and the delta between the
     * currently active item and the new active item. It will calculate differently
     * depending on whether wrap mode is turned on.
     * @param {?} delta
     * @return {?}
     */
    function (delta) {
        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);
    };
    /**
     * Sets the active item properly given "wrap" mode. In other words, it will continue to move
     * down the list until it finds an item that is not disabled, and it will wrap if it
     * encounters either end of the list.
     * @param {?} delta
     * @return {?}
     */
    ListKeyManager.prototype._setActiveInWrapMode = /**
     * Sets the active item properly given "wrap" mode. In other words, it will continue to move
     * down the list until it finds an item that is not disabled, and it will wrap if it
     * encounters either end of the list.
     * @param {?} delta
     * @return {?}
     */
    function (delta) {
        var /** @type {?} */ items = this._getItemsArray();
        for (var /** @type {?} */ i = 1; i <= items.length; i++) {
            var /** @type {?} */ index = (this._activeItemIndex + (delta * i) + items.length) % items.length;
            var /** @type {?} */ item = items[index];
            if (!this._skipPredicateFn(item)) {
                this.setActiveItem(index);
                return;
            }
        }
    };
    /**
     * Sets the active item properly given the default mode. In other words, it will
     * continue to move down the list until it finds an item that is not disabled. If
     * it encounters either end of the list, it will stop and not wrap.
     * @param {?} delta
     * @return {?}
     */
    ListKeyManager.prototype._setActiveInDefaultMode = /**
     * Sets the active item properly given the default mode. In other words, it will
     * continue to move down the list until it finds an item that is not disabled. If
     * it encounters either end of the list, it will stop and not wrap.
     * @param {?} delta
     * @return {?}
     */
    function (delta) {
        this._setActiveItemByIndex(this._activeItemIndex + delta, delta);
    };
    /**
     * Sets the active item to the first enabled item starting at the index specified. If the
     * item is disabled, it will move in the fallbackDelta direction until it either
     * finds an enabled item or encounters the end of the list.
     * @param {?} index
     * @param {?} fallbackDelta
     * @return {?}
     */
    ListKeyManager.prototype._setActiveItemByIndex = /**
     * Sets the active item to the first enabled item starting at the index specified. If the
     * item is disabled, it will move in the fallbackDelta direction until it either
     * finds an enabled item or encounters the end of the list.
     * @param {?} index
     * @param {?} fallbackDelta
     * @return {?}
     */
    function (index, fallbackDelta) {
        var /** @type {?} */ items = this._getItemsArray();
        if (!items[index]) {
            return;
        }
        while (this._skipPredicateFn(items[index])) {
            index += fallbackDelta;
            if (!items[index]) {
                return;
            }
        }
        this.setActiveItem(index);
    };
    /**
     * Returns the items as an array.
     * @return {?}
     */
    ListKeyManager.prototype._getItemsArray = /**
     * Returns the items as an array.
     * @return {?}
     */
    function () {
        return this._items instanceof core.QueryList ? this._items.toArray() : this._items;
    };
    return ListKeyManager;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
var  /**
 * @template T
 */
ActiveDescendantKeyManager = /** @class */ (function (_super) {
    __extends(ActiveDescendantKeyManager, _super);
    function ActiveDescendantKeyManager() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    ActiveDescendantKeyManager.prototype.setActiveItem = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (this.activeItem) {
            this.activeItem.setInactiveStyles();
        }
        _super.prototype.setActiveItem.call(this, index);
        if (this.activeItem) {
            this.activeItem.setActiveStyles();
        }
    };
    return ActiveDescendantKeyManager;
}(ListKeyManager));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
var  /**
 * @template T
 */
FocusKeyManager = /** @class */ (function (_super) {
    __extends(FocusKeyManager, _super);
    function FocusKeyManager() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._origin = 'program';
        return _this;
    }
    /**
     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.
     * @param origin Focus origin to be used when focusing items.
     */
    /**
     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.
     * @param {?} origin Focus origin to be used when focusing items.
     * @return {?}
     */
    FocusKeyManager.prototype.setFocusOrigin = /**
     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.
     * @param {?} origin Focus origin to be used when focusing items.
     * @return {?}
     */
    function (origin) {
        this._origin = origin;
        return this;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    FocusKeyManager.prototype.setActiveItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        _super.prototype.setActiveItem.call(this, item);
        if (this.activeItem) {
            this.activeItem.focus(this._origin);
        }
    };
    return FocusKeyManager;
}(ListKeyManager));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Utility for checking the interactivity of an element, such as whether is is focusable or
 * tabbable.
 */
var InteractivityChecker = /** @class */ (function () {
    function InteractivityChecker(_platform) {
        this._platform = _platform;
    }
    /**
     * Gets whether an element is disabled.
     *
     * @param element Element to be checked.
     * @returns Whether the element is disabled.
     */
    /**
     * Gets whether an element is disabled.
     *
     * @param {?} element Element to be checked.
     * @return {?} Whether the element is disabled.
     */
    InteractivityChecker.prototype.isDisabled = /**
     * Gets whether an element is disabled.
     *
     * @param {?} element Element to be checked.
     * @return {?} Whether the element is disabled.
     */
    function (element) {
        // This does not capture some cases, such as a non-form control with a disabled attribute or
        // a form control inside of a disabled form, but should capture the most common cases.
        return element.hasAttribute('disabled');
    };
    /**
     * Gets whether an element is visible for the purposes of interactivity.
     *
     * This will capture states like `display: none` and `visibility: hidden`, but not things like
     * being clipped by an `overflow: hidden` parent or being outside the viewport.
     *
     * @returns Whether the element is visible.
     */
    /**
     * Gets whether an element is visible for the purposes of interactivity.
     *
     * This will capture states like `display: none` and `visibility: hidden`, but not things like
     * being clipped by an `overflow: hidden` parent or being outside the viewport.
     *
     * @param {?} element
     * @return {?} Whether the element is visible.
     */
    InteractivityChecker.prototype.isVisible = /**
     * Gets whether an element is visible for the purposes of interactivity.
     *
     * This will capture states like `display: none` and `visibility: hidden`, but not things like
     * being clipped by an `overflow: hidden` parent or being outside the viewport.
     *
     * @param {?} element
     * @return {?} Whether the element is visible.
     */
    function (element) {
        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';
    };
    /**
     * Gets whether an element can be reached via Tab key.
     * Assumes that the element has already been checked with isFocusable.
     *
     * @param element Element to be checked.
     * @returns Whether the element is tabbable.
     */
    /**
     * Gets whether an element can be reached via Tab key.
     * Assumes that the element has already been checked with isFocusable.
     *
     * @param {?} element Element to be checked.
     * @return {?} Whether the element is tabbable.
     */
    InteractivityChecker.prototype.isTabbable = /**
     * Gets whether an element can be reached via Tab key.
     * Assumes that the element has already been checked with isFocusable.
     *
     * @param {?} element Element to be checked.
     * @return {?} Whether the element is tabbable.
     */
    function (element) {
        // Nothing is tabbable on the the server 
        if (!this._platform.isBrowser) {
            return false;
        }
        var /** @type {?} */ frameElement = getFrameElement(getWindow(element));
        if (frameElement) {
            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();
            // Frame elements inherit their tabindex onto all child elements.
            if (getTabIndexValue(frameElement) === -1) {
                return false;
            }
            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.
            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {
                return false;
            }
            // Webkit and Blink disable tabbing to an element inside of an invisible frame.
            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {
                return false;
            }
        }
        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();
        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);
        if (element.hasAttribute('contenteditable')) {
            return tabIndexValue !== -1;
        }
        if (nodeName === 'iframe') {
            // The frames may be tabbable depending on content, but it's not possibly to reliably
            // investigate the content of the frames.
            return false;
        }
        if (nodeName === 'audio') {
            if (!element.hasAttribute('controls')) {
                // By default an <audio> element without the controls enabled is not tabbable.
                return false;
            }
            else if (this._platform.BLINK) {
                // In Blink <audio controls> elements are always tabbable.
                return true;
            }
        }
        if (nodeName === 'video') {
            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {
                // In Trident a <video> element without the controls enabled is not tabbable.
                return false;
            }
            else if (this._platform.BLINK || this._platform.FIREFOX) {
                // In Chrome and Firefox <video controls> elements are always tabbable.
                return true;
            }
        }
        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {
            // In all Blink and WebKit based browsers <object> elements are never tabbable.
            return false;
        }
        // In iOS the browser only considers some specific elements as tabbable.
        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {
            return false;
        }
        return element.tabIndex >= 0;
    };
    /**
     * Gets whether an element can be focused by the user.
     *
     * @param element Element to be checked.
     * @returns Whether the element is focusable.
     */
    /**
     * Gets whether an element can be focused by the user.
     *
     * @param {?} element Element to be checked.
     * @return {?} Whether the element is focusable.
     */
    InteractivityChecker.prototype.isFocusable = /**
     * Gets whether an element can be focused by the user.
     *
     * @param {?} element Element to be checked.
     * @return {?} Whether the element is focusable.
     */
    function (element) {
        // Perform checks in order of left to most expensive.
        // Again, naive approach that does not capture many edge cases and browser quirks.
        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);
    };
    InteractivityChecker.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    InteractivityChecker.ctorParameters = function () { return [
        { type: Platform, },
    ]; };
    /** @nocollapse */ InteractivityChecker.ngInjectableDef = core.defineInjectable({ factory: function InteractivityChecker_Factory() { return new InteractivityChecker(core.inject(Platform)); }, token: InteractivityChecker, providedIn: "root" });
    return InteractivityChecker;
}());
/**
 * Returns the frame element from a window object. Since browsers like MS Edge throw errors if
 * the frameElement property is being accessed from a different host address, this property
 * should be accessed carefully.
 * @param {?} window
 * @return {?}
 */
function getFrameElement(window) {
    try {
        return /** @type {?} */ (window.frameElement);
    }
    catch (/** @type {?} */ e) {
        return null;
    }
}
/**
 * Checks whether the specified element has any geometry / rectangles.
 * @param {?} element
 * @return {?}
 */
function hasGeometry(element) {
    // Use logic from jQuery to check for an invisible element.
    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12
    return !!(element.offsetWidth || element.offsetHeight ||
        (typeof element.getClientRects === 'function' && element.getClientRects().length));
}
/**
 * Gets whether an element's
 * @param {?} element
 * @return {?}
 */
function isNativeFormElement(element) {
    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();
    return nodeName === 'input' ||
        nodeName === 'select' ||
        nodeName === 'button' ||
        nodeName === 'textarea';
}
/**
 * Gets whether an element is an `<input type="hidden">`.
 * @param {?} element
 * @return {?}
 */
function isHiddenInput(element) {
    return isInputElement(element) && element.type == 'hidden';
}
/**
 * Gets whether an element is an anchor that has an href attribute.
 * @param {?} element
 * @return {?}
 */
function isAnchorWithHref(element) {
    return isAnchorElement(element) && element.hasAttribute('href');
}
/**
 * Gets whether an element is an input element.
 * @param {?} element
 * @return {?}
 */
function isInputElement(element) {
    return element.nodeName.toLowerCase() == 'input';
}
/**
 * Gets whether an element is an anchor element.
 * @param {?} element
 * @return {?}
 */
function isAnchorElement(element) {
    return element.nodeName.toLowerCase() == 'a';
}
/**
 * Gets whether an element has a valid tabindex.
 * @param {?} element
 * @return {?}
 */
function hasValidTabIndex(element) {
    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {
        return false;
    }
    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');
    // IE11 parses tabindex="" as the value "-32768"
    if (tabIndex == '-32768') {
        return false;
    }
    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));
}
/**
 * Returns the parsed tabindex from the element attributes instead of returning the
 * evaluated tabindex from the browsers defaults.
 * @param {?} element
 * @return {?}
 */
function getTabIndexValue(element) {
    if (!hasValidTabIndex(element)) {
        return null;
    }
    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);
    return isNaN(tabIndex) ? -1 : tabIndex;
}
/**
 * Checks whether the specified element is potentially tabbable on iOS
 * @param {?} element
 * @return {?}
 */
function isPotentiallyTabbableIOS(element) {
    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();
    var /** @type {?} */ inputType = nodeName === 'input' && (/** @type {?} */ (element)).type;
    return inputType === 'text'
        || inputType === 'password'
        || nodeName === 'select'
        || nodeName === 'textarea';
}
/**
 * Gets whether an element is potentially focusable without taking current visible/disabled state
 * into account.
 * @param {?} element
 * @return {?}
 */
function isPotentiallyFocusable(element) {
    // Inputs are potentially focusable *unless* they're type="hidden".
    if (isHiddenInput(element)) {
        return false;
    }
    return isNativeFormElement(element) ||
        isAnchorWithHref(element) ||
        element.hasAttribute('contenteditable') ||
        hasValidTabIndex(element);
}
/**
 * Gets the parent window of a DOM node with regards of being inside of an iframe.
 * @param {?} node
 * @return {?}
 */
function getWindow(node) {
    return node.ownerDocument.defaultView || window;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Class that allows for trapping focus within a DOM element.
 *
 * This class currently uses a relatively simple approach to focus trapping.
 * It assumes that the tab order is the same as DOM order, which is not necessarily true.
 * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.
 */
var  /**
 * Class that allows for trapping focus within a DOM element.
 *
 * This class currently uses a relatively simple approach to focus trapping.
 * It assumes that the tab order is the same as DOM order, which is not necessarily true.
 * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.
 */
FocusTrap = /** @class */ (function () {
    function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {
        if (deferAnchors === void 0) { deferAnchors = false; }
        this._element = _element;
        this._checker = _checker;
        this._ngZone = _ngZone;
        this._document = _document;
        this._hasAttached = false;
        this._enabled = true;
        if (!deferAnchors) {
            this.attachAnchors();
        }
    }
    Object.defineProperty(FocusTrap.prototype, "enabled", {
        /** Whether the focus trap is active. */
        get: /**
         * Whether the focus trap is active.
         * @return {?}
         */
        function () { return this._enabled; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._enabled = val;
            if (this._startAnchor && this._endAnchor) {
                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;
            }
        },
        enumerable: true,
        configurable: true
    });
    /** Destroys the focus trap by cleaning up the anchors. */
    /**
     * Destroys the focus trap by cleaning up the anchors.
     * @return {?}
     */
    FocusTrap.prototype.destroy = /**
     * Destroys the focus trap by cleaning up the anchors.
     * @return {?}
     */
    function () {
        if (this._startAnchor && this._startAnchor.parentNode) {
            this._startAnchor.parentNode.removeChild(this._startAnchor);
        }
        if (this._endAnchor && this._endAnchor.parentNode) {
            this._endAnchor.parentNode.removeChild(this._endAnchor);
        }
        this._startAnchor = this._endAnchor = null;
    };
    /**
     * Inserts the anchors into the DOM. This is usually done automatically
     * in the constructor, but can be deferred for cases like directives with `*ngIf`.
     * @returns Whether the focus trap managed to attach successfuly. This may not be the case
     * if the target element isn't currently in the DOM.
     */
    /**
     * Inserts the anchors into the DOM. This is usually done automatically
     * in the constructor, but can be deferred for cases like directives with `*ngIf`.
     * @return {?} Whether the focus trap managed to attach successfuly. This may not be the case
     * if the target element isn't currently in the DOM.
     */
    FocusTrap.prototype.attachAnchors = /**
     * Inserts the anchors into the DOM. This is usually done automatically
     * in the constructor, but can be deferred for cases like directives with `*ngIf`.
     * @return {?} Whether the focus trap managed to attach successfuly. This may not be the case
     * if the target element isn't currently in the DOM.
     */
    function () {
        var _this = this;
        // If we're not on the browser, there can be no focus to trap.
        if (this._hasAttached) {
            return true;
        }
        this._ngZone.runOutsideAngular(function () {
            if (!_this._startAnchor) {
                _this._startAnchor = _this._createAnchor(); /** @type {?} */
                ((_this._startAnchor)).addEventListener('focus', function () { return _this.focusLastTabbableElement(); });
            }
            if (!_this._endAnchor) {
                _this._endAnchor = _this._createAnchor(); /** @type {?} */
                ((_this._endAnchor)).addEventListener('focus', function () { return _this.focusFirstTabbableElement(); });
            }
        });
        if (this._element.parentNode) {
            this._element.parentNode.insertBefore(/** @type {?} */ ((this._startAnchor)), this._element);
            this._element.parentNode.insertBefore(/** @type {?} */ ((this._endAnchor)), this._element.nextSibling);
            this._hasAttached = true;
        }
        return this._hasAttached;
    };
    /**
     * Waits for the zone to stabilize, then either focuses the first element that the
     * user specified, or the first tabbable element.
     * @returns Returns a promise that resolves with a boolean, depending
     * on whether focus was moved successfuly.
     */
    /**
     * Waits for the zone to stabilize, then either focuses the first element that the
     * user specified, or the first tabbable element.
     * @return {?} Returns a promise that resolves with a boolean, depending
     * on whether focus was moved successfuly.
     */
    FocusTrap.prototype.focusInitialElementWhenReady = /**
     * Waits for the zone to stabilize, then either focuses the first element that the
     * user specified, or the first tabbable element.
     * @return {?} Returns a promise that resolves with a boolean, depending
     * on whether focus was moved successfuly.
     */
    function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });
        });
    };
    /**
     * Waits for the zone to stabilize, then focuses
     * the first tabbable element within the focus trap region.
     * @returns Returns a promise that resolves with a boolean, depending
     * on whether focus was moved successfuly.
     */
    /**
     * Waits for the zone to stabilize, then focuses
     * the first tabbable element within the focus trap region.
     * @return {?} Returns a promise that resolves with a boolean, depending
     * on whether focus was moved successfuly.
     */
    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**
     * Waits for the zone to stabilize, then focuses
     * the first tabbable element within the focus trap region.
     * @return {?} Returns a promise that resolves with a boolean, depending
     * on whether focus was moved successfuly.
     */
    function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });
        });
    };
    /**
     * Waits for the zone to stabilize, then focuses
     * the last tabbable element within the focus trap region.
     * @returns Returns a promise that resolves with a boolean, depending
     * on whether focus was moved successfuly.
     */
    /**
     * Waits for the zone to stabilize, then focuses
     * the last tabbable element within the focus trap region.
     * @return {?} Returns a promise that resolves with a boolean, depending
     * on whether focus was moved successfuly.
     */
    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**
     * Waits for the zone to stabilize, then focuses
     * the last tabbable element within the focus trap region.
     * @return {?} Returns a promise that resolves with a boolean, depending
     * on whether focus was moved successfuly.
     */
    function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });
        });
    };
    /**
     * Get the specified boundary element of the trapped region.
     * @param {?} bound The boundary to get (start or end of trapped region).
     * @return {?} The boundary element.
     */
    FocusTrap.prototype._getRegionBoundary = /**
     * Get the specified boundary element of the trapped region.
     * @param {?} bound The boundary to get (start or end of trapped region).
     * @return {?} The boundary element.
     */
    function (bound) {
        // Contains the deprecated version of selector, for temporary backwards comparability.
        var /** @type {?} */ markers = /** @type {?} */ (this._element.querySelectorAll("[cdk-focus-region-" + bound + "], " +
            ("[cdkFocusRegion" + bound + "], ") +
            ("[cdk-focus-" + bound + "]")));
        for (var /** @type {?} */ i = 0; i < markers.length; i++) {
            // @breaking-change 7.0.0
            if (markers[i].hasAttribute("cdk-focus-" + bound)) {
                console.warn("Found use of deprecated attribute 'cdk-focus-" + bound + "', " +
                    ("use 'cdkFocusRegion" + bound + "' instead. The deprecated ") +
                    "attribute will be removed in 7.0.0.", markers[i]);
            }
            else if (markers[i].hasAttribute("cdk-focus-region-" + bound)) {
                console.warn("Found use of deprecated attribute 'cdk-focus-region-" + bound + "', " +
                    ("use 'cdkFocusRegion" + bound + "' instead. The deprecated attribute ") +
                    "will be removed in 7.0.0.", markers[i]);
            }
        }
        if (bound == 'start') {
            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);
        }
        return markers.length ?
            markers[markers.length - 1] : this._getLastTabbableElement(this._element);
    };
    /**
     * Focuses the element that should be focused when the focus trap is initialized.
     * @returns Whether focus was moved successfuly.
     */
    /**
     * Focuses the element that should be focused when the focus trap is initialized.
     * @return {?} Whether focus was moved successfuly.
     */
    FocusTrap.prototype.focusInitialElement = /**
     * Focuses the element that should be focused when the focus trap is initialized.
     * @return {?} Whether focus was moved successfuly.
     */
    function () {
        // Contains the deprecated version of selector, for temporary backwards comparability.
        var /** @type {?} */ redirectToElement = /** @type {?} */ (this._element.querySelector("[cdk-focus-initial], " +
            "[cdkFocusInitial]"));
        if (redirectToElement) {
            // @breaking-change 7.0.0
            if (redirectToElement.hasAttribute("cdk-focus-initial")) {
                console.warn("Found use of deprecated attribute 'cdk-focus-initial', " +
                    "use 'cdkFocusInitial' instead. The deprecated attribute " +
                    "will be removed in 7.0.0", redirectToElement);
            }
            redirectToElement.focus();
            return true;
        }
        return this.focusFirstTabbableElement();
    };
    /**
     * Focuses the first tabbable element within the focus trap region.
     * @returns Whether focus was moved successfuly.
     */
    /**
     * Focuses the first tabbable element within the focus trap region.
     * @return {?} Whether focus was moved successfuly.
     */
    FocusTrap.prototype.focusFirstTabbableElement = /**
     * Focuses the first tabbable element within the focus trap region.
     * @return {?} Whether focus was moved successfuly.
     */
    function () {
        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');
        if (redirectToElement) {
            redirectToElement.focus();
        }
        return !!redirectToElement;
    };
    /**
     * Focuses the last tabbable element within the focus trap region.
     * @returns Whether focus was moved successfuly.
     */
    /**
     * Focuses the last tabbable element within the focus trap region.
     * @return {?} Whether focus was moved successfuly.
     */
    FocusTrap.prototype.focusLastTabbableElement = /**
     * Focuses the last tabbable element within the focus trap region.
     * @return {?} Whether focus was moved successfuly.
     */
    function () {
        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');
        if (redirectToElement) {
            redirectToElement.focus();
        }
        return !!redirectToElement;
    };
    /**
     * Checks whether the focus trap has successfuly been attached.
     */
    /**
     * Checks whether the focus trap has successfuly been attached.
     * @return {?}
     */
    FocusTrap.prototype.hasAttached = /**
     * Checks whether the focus trap has successfuly been attached.
     * @return {?}
     */
    function () {
        return this._hasAttached;
    };
    /**
     * Get the first tabbable element from a DOM subtree (inclusive).
     * @param {?} root
     * @return {?}
     */
    FocusTrap.prototype._getFirstTabbableElement = /**
     * Get the first tabbable element from a DOM subtree (inclusive).
     * @param {?} root
     * @return {?}
     */
    function (root) {
        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
            return root;
        }
        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall
        // back to `childNodes` which includes text nodes, comments etc.
        var /** @type {?} */ children = root.children || root.childNodes;
        for (var /** @type {?} */ i = 0; i < children.length; i++) {
            var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?
                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :
                null;
            if (tabbableChild) {
                return tabbableChild;
            }
        }
        return null;
    };
    /**
     * Get the last tabbable element from a DOM subtree (inclusive).
     * @param {?} root
     * @return {?}
     */
    FocusTrap.prototype._getLastTabbableElement = /**
     * Get the last tabbable element from a DOM subtree (inclusive).
     * @param {?} root
     * @return {?}
     */
    function (root) {
        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
            return root;
        }
        // Iterate in reverse DOM order.
        var /** @type {?} */ children = root.children || root.childNodes;
        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {
            var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?
                this._getLastTabbableElement(/** @type {?} */ (children[i])) :
                null;
            if (tabbableChild) {
                return tabbableChild;
            }
        }
        return null;
    };
    /**
     * Creates an anchor element.
     * @return {?}
     */
    FocusTrap.prototype._createAnchor = /**
     * Creates an anchor element.
     * @return {?}
     */
    function () {
        var /** @type {?} */ anchor = this._document.createElement('div');
        anchor.tabIndex = this._enabled ? 0 : -1;
        anchor.classList.add('cdk-visually-hidden');
        anchor.classList.add('cdk-focus-trap-anchor');
        return anchor;
    };
    /**
     * Executes a function when the zone is stable.
     * @param {?} fn
     * @return {?}
     */
    FocusTrap.prototype._executeOnStable = /**
     * Executes a function when the zone is stable.
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        if (this._ngZone.isStable) {
            fn();
        }
        else {
            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(fn);
        }
    };
    return FocusTrap;
}());
/**
 * Factory that allows easy instantiation of focus traps.
 */
var FocusTrapFactory = /** @class */ (function () {
    function FocusTrapFactory(_checker, _ngZone, _document) {
        this._checker = _checker;
        this._ngZone = _ngZone;
        this._document = _document;
    }
    /**
     * Creates a focus-trapped region around the given element.
     * @param element The element around which focus will be trapped.
     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done
     *     manually by the user.
     * @returns The created focus trap instance.
     */
    /**
     * Creates a focus-trapped region around the given element.
     * @param {?} element The element around which focus will be trapped.
     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done
     *     manually by the user.
     * @return {?} The created focus trap instance.
     */
    FocusTrapFactory.prototype.create = /**
     * Creates a focus-trapped region around the given element.
     * @param {?} element The element around which focus will be trapped.
     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done
     *     manually by the user.
     * @return {?} The created focus trap instance.
     */
    function (element, deferCaptureElements) {
        if (deferCaptureElements === void 0) { deferCaptureElements = false; }
        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);
    };
    FocusTrapFactory.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    FocusTrapFactory.ctorParameters = function () { return [
        { type: InteractivityChecker, },
        { type: core.NgZone, },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
    ]; };
    /** @nocollapse */ FocusTrapFactory.ngInjectableDef = core.defineInjectable({ factory: function FocusTrapFactory_Factory() { return new FocusTrapFactory(core.inject(InteractivityChecker), core.inject(core.NgZone), core.inject(common.DOCUMENT)); }, token: FocusTrapFactory, providedIn: "root" });
    return FocusTrapFactory;
}());
/**
 * Directive for trapping focus within a region.
 */
var CdkTrapFocus = /** @class */ (function () {
    function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {
        this._elementRef = _elementRef;
        this._focusTrapFactory = _focusTrapFactory;
        /**
         * Previously focused element to restore focus to upon destroy when using autoCapture.
         */
        this._previouslyFocusedElement = null;
        this._document = _document;
        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);
    }
    Object.defineProperty(CdkTrapFocus.prototype, "enabled", {
        get: /**
         * Whether the focus trap is active.
         * @return {?}
         */
        function () { return this.focusTrap.enabled; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkTrapFocus.prototype, "autoCapture", {
        get: /**
         * Whether the directive should automatially move focus into the trapped region upon
         * initialization and return focus to the previous activeElement upon destruction.
         * @return {?}
         */
        function () { return this._autoCapture; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._autoCapture = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CdkTrapFocus.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.focusTrap.destroy();
        // If we stored a previously focused element when using autoCapture, return focus to that
        // element now that the trapped region is being destroyed.
        if (this._previouslyFocusedElement) {
            this._previouslyFocusedElement.focus();
            this._previouslyFocusedElement = null;
        }
    };
    /**
     * @return {?}
     */
    CdkTrapFocus.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.focusTrap.attachAnchors();
        if (this.autoCapture) {
            this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);
            this.focusTrap.focusInitialElementWhenReady();
        }
    };
    /**
     * @return {?}
     */
    CdkTrapFocus.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (!this.focusTrap.hasAttached()) {
            this.focusTrap.attachAnchors();
        }
    };
    CdkTrapFocus.decorators = [
        { type: core.Directive, args: [{
                    selector: '[cdkTrapFocus]',
                    exportAs: 'cdkTrapFocus',
                },] },
    ];
    /** @nocollapse */
    CdkTrapFocus.ctorParameters = function () { return [
        { type: core.ElementRef, },
        { type: FocusTrapFactory, },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
    ]; };
    CdkTrapFocus.propDecorators = {
        "enabled": [{ type: core.Input, args: ['cdkTrapFocus',] },],
        "autoCapture": [{ type: core.Input, args: ['cdkTrapFocusAutoCapture',] },],
    };
    return CdkTrapFocus;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// The token for the live announcer element is defined in a separate file from LiveAnnouncer
// as a workaround for https://github.com/angular/angular/issues/22559
var /** @type {?} */ LIVE_ANNOUNCER_ELEMENT_TOKEN = new core.InjectionToken('liveAnnouncerElement', {
    providedIn: 'root',
    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,
});
/**
 * \@docs-private
 * @return {?}
 */
function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {
    return null;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LiveAnnouncer = /** @class */ (function () {
    function LiveAnnouncer(elementToken, _document) {
        // We inject the live element and document as `any` because the constructor signature cannot
        // reference browser globals (HTMLElement, Document) on non-browser environments, since having
        // a class decorator causes TypeScript to preserve the constructor signature types.
        this._document = _document;
        this._liveElement = elementToken || this._createLiveElement();
    }
    /**
     * Announces a message to screenreaders.
     * @param message Message to be announced to the screenreader
     * @param politeness The politeness of the announcer element
     * @returns Promise that will be resolved when the message is added to the DOM.
     */
    /**
     * Announces a message to screenreaders.
     * @param {?} message Message to be announced to the screenreader
     * @param {?=} politeness The politeness of the announcer element
     * @return {?} Promise that will be resolved when the message is added to the DOM.
     */
    LiveAnnouncer.prototype.announce = /**
     * Announces a message to screenreaders.
     * @param {?} message Message to be announced to the screenreader
     * @param {?=} politeness The politeness of the announcer element
     * @return {?} Promise that will be resolved when the message is added to the DOM.
     */
    function (message, politeness) {
        var _this = this;
        if (politeness === void 0) { politeness = 'polite'; }
        this._liveElement.textContent = '';
        // TODO: ensure changing the politeness works on all environments we support.
        this._liveElement.setAttribute('aria-live', politeness);
        // This 100ms timeout is necessary for some browser + screen-reader combinations:
        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.
        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a
        //   second time without clearing and then using a non-zero delay.
        // (using JAWS 17 at time of this writing).
        return new Promise(function (resolve) {
            setTimeout(function () {
                _this._liveElement.textContent = message;
                resolve();
            }, 100);
        });
    };
    /**
     * @return {?}
     */
    LiveAnnouncer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._liveElement && this._liveElement.parentNode) {
            this._liveElement.parentNode.removeChild(this._liveElement);
        }
    };
    /**
     * @return {?}
     */
    LiveAnnouncer.prototype._createLiveElement = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ elementClass = 'cdk-live-announcer-element';
        var /** @type {?} */ previousElements = this._document.getElementsByClassName(elementClass);
        // Remove any old containers. This can happen when coming in from a server-side-rendered page.
        for (var /** @type {?} */ i = 0; i < previousElements.length; i++) {
            /** @type {?} */ ((previousElements[i].parentNode)).removeChild(previousElements[i]);
        }
        var /** @type {?} */ liveEl = this._document.createElement('div');
        liveEl.classList.add(elementClass);
        liveEl.classList.add('cdk-visually-hidden');
        liveEl.setAttribute('aria-atomic', 'true');
        liveEl.setAttribute('aria-live', 'polite');
        this._document.body.appendChild(liveEl);
        return liveEl;
    };
    LiveAnnouncer.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    LiveAnnouncer.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
    ]; };
    /** @nocollapse */ LiveAnnouncer.ngInjectableDef = core.defineInjectable({ factory: function LiveAnnouncer_Factory() { return new LiveAnnouncer(core.inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), core.inject(common.DOCUMENT)); }, token: LiveAnnouncer, providedIn: "root" });
    return LiveAnnouncer;
}());
/**
 * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility
 * with a wider range of browsers and screen readers.
 */
var CdkAriaLive = /** @class */ (function () {
    function CdkAriaLive(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {
        this._elementRef = _elementRef;
        this._liveAnnouncer = _liveAnnouncer;
        this._contentObserver = _contentObserver;
        this._ngZone = _ngZone;
        this._politeness = 'off';
    }
    Object.defineProperty(CdkAriaLive.prototype, "politeness", {
        get: /**
         * The aria-live politeness level to use when announcing messages.
         * @return {?}
         */
        function () { return this._politeness; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            this._politeness = value === 'polite' || value === 'assertive' ? value : 'off';
            if (this._politeness === 'off') {
                if (this._subscription) {
                    this._subscription.unsubscribe();
                    this._subscription = null;
                }
            }
            else if (!this._subscription) {
                this._subscription = this._ngZone.runOutsideAngular(function () {
                    return _this._contentObserver
                        .observe(_this._elementRef)
                        .subscribe(function () {
                        // Note that we use textContent here, rather than innerText, in order to avoid a reflow.
                        var /** @type {?} */ element = _this._elementRef.nativeElement;
                        _this._liveAnnouncer.announce(element.textContent, _this._politeness);
                    });
                });
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CdkAriaLive.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
    };
    CdkAriaLive.decorators = [
        { type: core.Directive, args: [{
                    selector: '[cdkAriaLive]',
                    exportAs: 'cdkAriaLive',
                },] },
    ];
    /** @nocollapse */
    CdkAriaLive.ctorParameters = function () { return [
        { type: core.ElementRef, },
        { type: LiveAnnouncer, },
        { type: ContentObserver, },
        { type: core.NgZone, },
    ]; };
    CdkAriaLive.propDecorators = {
        "politeness": [{ type: core.Input, args: ['cdkAriaLive',] },],
    };
    return CdkAriaLive;
}());
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 * @param {?} parentDispatcher
 * @param {?} liveElement
 * @param {?} _document
 * @return {?}
 */
function LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, _document) {
    return parentDispatcher || new LiveAnnouncer(liveElement, _document);
}
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 */
var /** @type {?} */ LIVE_ANNOUNCER_PROVIDER = {
    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.
    provide: LiveAnnouncer,
    deps: [
        [new core.Optional(), new core.SkipSelf(), LiveAnnouncer],
        [new core.Optional(), new core.Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],
        common.DOCUMENT,
    ],
    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found
// that a value of around 650ms seems appropriate.
var /** @type {?} */ TOUCH_BUFFER_MS = 650;
/**
 * Monitors mouse and keyboard events to determine the cause of focus events.
 */
var FocusMonitor = /** @class */ (function () {
    function FocusMonitor(_ngZone, _platform) {
        this._ngZone = _ngZone;
        this._platform = _platform;
        /**
         * The focus origin that the next focus event is a result of.
         */
        this._origin = null;
        /**
         * Whether the window has just been focused.
         */
        this._windowFocused = false;
        /**
         * Map of elements being monitored to their info.
         */
        this._elementInfo = new Map();
        /**
         * A map of global objects to lists of current listeners.
         */
        this._unregisterGlobalListeners = function () { };
        /**
         * The number of elements currently being monitored.
         */
        this._monitoredElementCount = 0;
    }
    /**
     * Monitors focus on an element and applies appropriate CSS classes.
     * @param element The element to monitor
     * @param checkChildren Whether to count the element as focused when its children are focused.
     * @returns An observable that emits when the focus state of the element changes.
     *     When the element is blurred, null will be emitted.
     */
    /**
     * Monitors focus on an element and applies appropriate CSS classes.
     * @param {?} element The element to monitor
     * @param {?=} checkChildren Whether to count the element as focused when its children are focused.
     * @return {?} An observable that emits when the focus state of the element changes.
     *     When the element is blurred, null will be emitted.
     */
    FocusMonitor.prototype.monitor = /**
     * Monitors focus on an element and applies appropriate CSS classes.
     * @param {?} element The element to monitor
     * @param {?=} checkChildren Whether to count the element as focused when its children are focused.
     * @return {?} An observable that emits when the focus state of the element changes.
     *     When the element is blurred, null will be emitted.
     */
    function (element, checkChildren) {
        var _this = this;
        if (checkChildren === void 0) { checkChildren = false; }
        // Do nothing if we're not on the browser platform.
        if (!this._platform.isBrowser) {
            return of(null);
        }
        // Check if we're already monitoring this element.
        if (this._elementInfo.has(element)) {
            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */
            ((cachedInfo)).checkChildren = checkChildren;
            return /** @type {?} */ ((cachedInfo)).subject.asObservable();
        }
        // Create monitored element info.
        var /** @type {?} */ info = {
            unlisten: function () { },
            checkChildren: checkChildren,
            subject: new Subject()
        };
        this._elementInfo.set(element, info);
        this._incrementMonitoredElementCount();
        // Start listening. We need to listen in capture phase since focus events don't bubble.
        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };
        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };
        this._ngZone.runOutsideAngular(function () {
            element.addEventListener('focus', focusListener, true);
            element.addEventListener('blur', blurListener, true);
        });
        // Create an unlisten function for later.
        info.unlisten = function () {
            element.removeEventListener('focus', focusListener, true);
            element.removeEventListener('blur', blurListener, true);
        };
        return info.subject.asObservable();
    };
    /**
     * Stops monitoring an element and removes all focus classes.
     * @param element The element to stop monitoring.
     */
    /**
     * Stops monitoring an element and removes all focus classes.
     * @param {?} element The element to stop monitoring.
     * @return {?}
     */
    FocusMonitor.prototype.stopMonitoring = /**
     * Stops monitoring an element and removes all focus classes.
     * @param {?} element The element to stop monitoring.
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ elementInfo = this._elementInfo.get(element);
        if (elementInfo) {
            elementInfo.unlisten();
            elementInfo.subject.complete();
            this._setClasses(element);
            this._elementInfo.delete(element);
            this._decrementMonitoredElementCount();
        }
    };
    /**
     * Focuses the element via the specified focus origin.
     * @param element Element to focus.
     * @param origin Focus origin.
     * @param options Options that can be used to configure the focus behavior.
     */
    /**
     * Focuses the element via the specified focus origin.
     * @param {?} element Element to focus.
     * @param {?} origin Focus origin.
     * @param {?=} options Options that can be used to configure the focus behavior.
     * @return {?}
     */
    FocusMonitor.prototype.focusVia = /**
     * Focuses the element via the specified focus origin.
     * @param {?} element Element to focus.
     * @param {?} origin Focus origin.
     * @param {?=} options Options that can be used to configure the focus behavior.
     * @return {?}
     */
    function (element, origin, options) {
        this._setOriginForCurrentEventQueue(origin);
        // `focus` isn't available on the server
        if (typeof element.focus === 'function') {
            // Cast the element to `any`, because the TS typings don't have the `options` parameter yet.
            (/** @type {?} */ (element)).focus(options);
        }
    };
    /**
     * @return {?}
     */
    FocusMonitor.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._elementInfo.forEach(function (_info, element) { return _this.stopMonitoring(element); });
    };
    /**
     * Register necessary event listeners on the document and window.
     * @return {?}
     */
    FocusMonitor.prototype._registerGlobalListeners = /**
     * Register necessary event listeners on the document and window.
     * @return {?}
     */
    function () {
        var _this = this;
        // Do nothing if we're not on the browser platform.
        if (!this._platform.isBrowser) {
            return;
        }
        // On keydown record the origin and clear any touch event that may be in progress.
        var /** @type {?} */ documentKeydownListener = function () {
            _this._lastTouchTarget = null;
            _this._setOriginForCurrentEventQueue('keyboard');
        };
        // On mousedown record the origin only if there is not touch target, since a mousedown can
        // happen as a result of a touch event.
        var /** @type {?} */ documentMousedownListener = function () {
            if (!_this._lastTouchTarget) {
                _this._setOriginForCurrentEventQueue('mouse');
            }
        };
        // When the touchstart event fires the focus event is not yet in the event queue. This means
        // we can't rely on the trick used above (setting timeout of 1ms). Instead we wait 650ms to
        // see if a focus happens.
        var /** @type {?} */ documentTouchstartListener = function (event) {
            if (_this._touchTimeoutId != null) {
                clearTimeout(_this._touchTimeoutId);
            }
            _this._lastTouchTarget = event.target;
            _this._touchTimeoutId = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);
        };
        // Make a note of when the window regains focus, so we can restore the origin info for the
        // focused element.
        var /** @type {?} */ windowFocusListener = function () {
            _this._windowFocused = true;
            _this._windowFocusTimeoutId = setTimeout(function () { return _this._windowFocused = false; });
        };
        // Note: we listen to events in the capture phase so we can detect them even if the user stops
        // propagation.
        this._ngZone.runOutsideAngular(function () {
            document.addEventListener('keydown', documentKeydownListener, true);
            document.addEventListener('mousedown', documentMousedownListener, true);
            document.addEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);
            window.addEventListener('focus', windowFocusListener);
        });
        this._unregisterGlobalListeners = function () {
            document.removeEventListener('keydown', documentKeydownListener, true);
            document.removeEventListener('mousedown', documentMousedownListener, true);
            document.removeEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);
            window.removeEventListener('focus', windowFocusListener);
            // Clear timeouts for all potentially pending timeouts to prevent the leaks.
            clearTimeout(_this._windowFocusTimeoutId);
            clearTimeout(_this._touchTimeoutId);
            clearTimeout(_this._originTimeoutId);
        };
    };
    /**
     * @param {?} element
     * @param {?} className
     * @param {?} shouldSet
     * @return {?}
     */
    FocusMonitor.prototype._toggleClass = /**
     * @param {?} element
     * @param {?} className
     * @param {?} shouldSet
     * @return {?}
     */
    function (element, className, shouldSet) {
        if (shouldSet) {
            element.classList.add(className);
        }
        else {
            element.classList.remove(className);
        }
    };
    /**
     * Sets the focus classes on the element based on the given focus origin.
     * @param {?} element The element to update the classes on.
     * @param {?=} origin The focus origin.
     * @return {?}
     */
    FocusMonitor.prototype._setClasses = /**
     * Sets the focus classes on the element based on the given focus origin.
     * @param {?} element The element to update the classes on.
     * @param {?=} origin The focus origin.
     * @return {?}
     */
    function (element, origin) {
        var /** @type {?} */ elementInfo = this._elementInfo.get(element);
        if (elementInfo) {
            this._toggleClass(element, 'cdk-focused', !!origin);
            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');
            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');
            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');
            this._toggleClass(element, 'cdk-program-focused', origin === 'program');
        }
    };
    /**
     * Sets the origin and schedules an async function to clear it at the end of the event queue.
     * @param {?} origin The origin to set.
     * @return {?}
     */
    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**
     * Sets the origin and schedules an async function to clear it at the end of the event queue.
     * @param {?} origin The origin to set.
     * @return {?}
     */
    function (origin) {
        var _this = this;
        this._ngZone.runOutsideAngular(function () {
            _this._origin = origin;
            // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*
            // tick after the interaction event fired. To ensure the focus origin is always correct,
            // the focus origin will be determined at the beginning of the next tick.
            // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*
            // tick after the interaction event fired. To ensure the focus origin is always correct,
            // the focus origin will be determined at the beginning of the next tick.
            _this._originTimeoutId = setTimeout(function () { return _this._origin = null; }, 1);
        });
    };
    /**
     * Checks whether the given focus event was caused by a touchstart event.
     * @param {?} event The focus event to check.
     * @return {?} Whether the event was caused by a touch.
     */
    FocusMonitor.prototype._wasCausedByTouch = /**
     * Checks whether the given focus event was caused by a touchstart event.
     * @param {?} event The focus event to check.
     * @return {?} Whether the event was caused by a touch.
     */
    function (event) {
        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.
        // Consider the following dom structure:
        //
        // <div #parent tabindex="0" cdkFocusClasses>
        //   <div #child (click)="#parent.focus()"></div>
        // </div>
        //
        // If the user touches the #child element and the #parent is programmatically focused as a
        // result, this code will still consider it to have been caused by the touch event and will
        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a
        // relatively small edge-case that can be worked around by using
        // focusVia(parentEl, 'program') to focus the parent element.
        //
        // If we decide that we absolutely must handle this case correctly, we can do so by listening
        // for the first focus event after the touchstart, and then the first blur event after that
        // focus event. When that blur event fires we know that whatever follows is not a result of the
        // touchstart.
        var /** @type {?} */ focusTarget = event.target;
        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&
            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));
    };
    /**
     * Handles focus events on a registered element.
     * @param {?} event The focus event.
     * @param {?} element The monitored element.
     * @return {?}
     */
    FocusMonitor.prototype._onFocus = /**
     * Handles focus events on a registered element.
     * @param {?} event The focus event.
     * @param {?} element The monitored element.
     * @return {?}
     */
    function (event, element) {
        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent
        // focus event affecting the monitored element. If we want to use the origin of the first event
        // instead we should check for the cdk-focused class here and return if the element already has
        // it. (This only matters for elements that have includesChildren = true).
        // If we are not counting child-element-focus as focused, make sure that the event target is the
        // monitored element itself.
        var /** @type {?} */ elementInfo = this._elementInfo.get(element);
        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {
            return;
        }
        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:
        // 1) The window has just regained focus, in which case we want to restore the focused state of
        //    the element from before the window blurred.
        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.
        // 3) The element was programmatically focused, in which case we should mark the origin as
        //    'program'.
        var /** @type {?} */ origin = this._origin;
        if (!origin) {
            if (this._windowFocused && this._lastFocusOrigin) {
                origin = this._lastFocusOrigin;
            }
            else if (this._wasCausedByTouch(event)) {
                origin = 'touch';
            }
            else {
                origin = 'program';
            }
        }
        this._setClasses(element, origin);
        this._emitOrigin(elementInfo.subject, origin);
        this._lastFocusOrigin = origin;
    };
    /**
     * Handles blur events on a registered element.
     * @param event The blur event.
     * @param element The monitored element.
     */
    /**
     * Handles blur events on a registered element.
     * @param {?} event The blur event.
     * @param {?} element The monitored element.
     * @return {?}
     */
    FocusMonitor.prototype._onBlur = /**
     * Handles blur events on a registered element.
     * @param {?} event The blur event.
     * @param {?} element The monitored element.
     * @return {?}
     */
    function (event, element) {
        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in
        // order to focus another child of the monitored element.
        var /** @type {?} */ elementInfo = this._elementInfo.get(element);
        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&
            element.contains(event.relatedTarget))) {
            return;
        }
        this._setClasses(element);
        this._emitOrigin(elementInfo.subject, null);
    };
    /**
     * @param {?} subject
     * @param {?} origin
     * @return {?}
     */
    FocusMonitor.prototype._emitOrigin = /**
     * @param {?} subject
     * @param {?} origin
     * @return {?}
     */
    function (subject, origin) {
        this._ngZone.run(function () { return subject.next(origin); });
    };
    /**
     * @return {?}
     */
    FocusMonitor.prototype._incrementMonitoredElementCount = /**
     * @return {?}
     */
    function () {
        // Register global listeners when first element is monitored.
        if (++this._monitoredElementCount == 1) {
            this._registerGlobalListeners();
        }
    };
    /**
     * @return {?}
     */
    FocusMonitor.prototype._decrementMonitoredElementCount = /**
     * @return {?}
     */
    function () {
        // Unregister global listeners when last element is unmonitored.
        if (!--this._monitoredElementCount) {
            this._unregisterGlobalListeners();
            this._unregisterGlobalListeners = function () { };
        }
    };
    FocusMonitor.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */
    FocusMonitor.ctorParameters = function () { return [
        { type: core.NgZone, },
        { type: Platform, },
    ]; };
    /** @nocollapse */ FocusMonitor.ngInjectableDef = core.defineInjectable({ factory: function FocusMonitor_Factory() { return new FocusMonitor(core.inject(core.NgZone), core.inject(Platform)); }, token: FocusMonitor, providedIn: "root" });
    return FocusMonitor;
}());
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 * @param {?} parentDispatcher
 * @param {?} ngZone
 * @param {?} platform
 * @return {?}
 */
function FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {
    return parentDispatcher || new FocusMonitor(ngZone, platform);
}
/**
 * \@docs-private \@deprecated \@breaking-change 7.0.0
 */
var /** @type {?} */ FOCUS_MONITOR_PROVIDER = {
    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.
    provide: FocusMonitor,
    deps: [[new core.Optional(), new core.SkipSelf(), FocusMonitor], core.NgZone, Platform],
    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * Screenreaders will often fire fake mousedown events when a focusable element
 * is activated using the keyboard. We can typically distinguish between these faked
 * mousedown events and real mousedown events using the "buttons" property. While
 * real mousedowns will indicate the mouse button that was pressed (e.g. "1" for
 * the left mouse button), faked mousedowns will usually set the property value to 0.
 * @param {?} event
 * @return {?}
 */
function isFakeMousedownFromScreenReader(event) {
    return event.buttons === 0;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Injection token that configures whether the Material sanity checks are enabled.
 */
var /** @type {?} */ MATERIAL_SANITY_CHECKS = new core.InjectionToken('mat-sanity-checks', {
    providedIn: 'root',
    factory: MATERIAL_SANITY_CHECKS_FACTORY,
});
/**
 * \@docs-private
 * @return {?}
 */
function MATERIAL_SANITY_CHECKS_FACTORY() {
    return true;
}
/**
 * Module that captures anything that should be loaded and/or run for *all* Angular Material
 * components. This includes Bidi, etc.
 *
 * This module should be imported to each top-level component module (e.g., MatTabsModule).
 */
var MatCommonModule = /** @class */ (function () {
    function MatCommonModule(_sanityChecksEnabled) {
        this._sanityChecksEnabled = _sanityChecksEnabled;
        /**
         * Whether we've done the global sanity checks (e.g. a theme is loaded, there is a doctype).
         */
        this._hasDoneGlobalChecks = false;
        /**
         * Whether we've already checked for HammerJs availability.
         */
        this._hasCheckedHammer = false;
        /**
         * Reference to the global `document` object.
         */
        this._document = typeof document === 'object' && document ? document : null;
        /**
         * Reference to the global 'window' object.
         */
        this._window = typeof window === 'object' && window ? window : null;
        if (this._areChecksEnabled() && !this._hasDoneGlobalChecks) {
            this._checkDoctypeIsDefined();
            this._checkThemeIsPresent();
            this._hasDoneGlobalChecks = true;
        }
    }
    /**
     * Whether any sanity checks are enabled
     * @return {?}
     */
    MatCommonModule.prototype._areChecksEnabled = /**
     * Whether any sanity checks are enabled
     * @return {?}
     */
    function () {
        return this._sanityChecksEnabled && core.isDevMode() && !this._isTestEnv();
    };
    /**
     * Whether the code is running in tests.
     * @return {?}
     */
    MatCommonModule.prototype._isTestEnv = /**
     * Whether the code is running in tests.
     * @return {?}
     */
    function () {
        return this._window && (this._window['__karma__'] || this._window['jasmine']);
    };
    /**
     * @return {?}
     */
    MatCommonModule.prototype._checkDoctypeIsDefined = /**
     * @return {?}
     */
    function () {
        if (this._document && !this._document.doctype) {
            console.warn('Current document does not have a doctype. This may cause ' +
                'some Angular Material components not to behave as expected.');
        }
    };
    /**
     * @return {?}
     */
    MatCommonModule.prototype._checkThemeIsPresent = /**
     * @return {?}
     */
    function () {
        // We need to assert that the `body` is defined, because these checks run very early
        // and the `body` won't be defined if the consumer put their scripts in the `head`.
        if (this._document && this._document.body && typeof getComputedStyle === 'function') {
            var /** @type {?} */ testElement = this._document.createElement('div');
            testElement.classList.add('mat-theme-loaded-marker');
            this._document.body.appendChild(testElement);
            var /** @type {?} */ computedStyle = getComputedStyle(testElement);
            // In some situations the computed style of the test element can be null. For example in
            // Firefox, the computed style is null if an application is running inside of a hidden iframe.
            // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
            if (computedStyle && computedStyle.display !== 'none') {
                console.warn('Could not find Angular Material core theme. Most Material ' +
                    'components may not work as expected. For more info refer ' +
                    'to the theming guide: https://material.angular.io/guide/theming');
            }
            this._document.body.removeChild(testElement);
        }
    };
    /** Checks whether HammerJS is available. */
    /**
     * Checks whether HammerJS is available.
     * @return {?}
     */
    MatCommonModule.prototype._checkHammerIsAvailable = /**
     * Checks whether HammerJS is available.
     * @return {?}
     */
    function () {
        if (this._hasCheckedHammer || !this._window) {
            return;
        }
        if (this._areChecksEnabled() && !this._window['Hammer']) {
            console.warn('Could not find HammerJS. Certain Angular Material components may not work correctly.');
        }
        this._hasCheckedHammer = true;
    };
    MatCommonModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [BidiModule],
                    exports: [BidiModule],
                },] },
    ];
    /** @nocollapse */
    MatCommonModule.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MATERIAL_SANITY_CHECKS,] },] },
    ]; };
    return MatCommonModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Mixin to augment a directive with a `disabled` property.
 * @template T
 * @param {?} base
 * @return {?}
 */
function mixinDisabled(base) {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            _this._disabled = false;
            return _this;
        }
        Object.defineProperty(class_1.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) { this._disabled = coerceBooleanProperty(value); },
            enumerable: true,
            configurable: true
        });
        return class_1;
    }(base));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Mixin to augment a directive with a `disableRipple` property.
 * @template T
 * @param {?} base
 * @return {?}
 */
function mixinDisableRipple(base) {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            _this._disableRipple = false;
            return _this;
        }
        Object.defineProperty(class_1.prototype, "disableRipple", {
            /** Whether the ripple effect is disabled or not. */
            get: /**
             * Whether the ripple effect is disabled or not.
             * @return {?}
             */
            function () { return this._disableRipple; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) { this._disableRipple = coerceBooleanProperty(value); },
            enumerable: true,
            configurable: true
        });
        return class_1;
    }(base));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * InjectionToken for datepicker that can be used to override default locale code.
 */
var /** @type {?} */ MAT_DATE_LOCALE = new core.InjectionToken('MAT_DATE_LOCALE', {
    providedIn: 'root',
    factory: MAT_DATE_LOCALE_FACTORY,
});
/**
 * \@docs-private
 * @return {?}
 */
function MAT_DATE_LOCALE_FACTORY() {
    return core.inject(core.LOCALE_ID);
}
/**
 * Adapts type `D` to be usable as a date by cdk-based components that work with dates.
 * @abstract
 * @template D
 */
var  /**
 * Adapts type `D` to be usable as a date by cdk-based components that work with dates.
 * @abstract
 * @template D
 */
DateAdapter = /** @class */ (function () {
    function DateAdapter() {
        this._localeChanges = new Subject();
    }
    Object.defineProperty(DateAdapter.prototype, "localeChanges", {
        /** A stream that emits when the locale changes. */
        get: /**
         * A stream that emits when the locale changes.
         * @return {?}
         */
        function () { return this._localeChanges; },
        enumerable: true,
        configurable: true
    });
    /**
     * Attempts to deserialize a value to a valid date object. This is different from parsing in that
     * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601
     * string). The default implementation does not allow any deserialization, it simply checks that
     * the given value is already a valid date object or null. The `<mat-datepicker>` will call this
     * method on all of it's `@Input()` properties that accept dates. It is therefore possible to
     * support passing values from your backend directly to these properties by overriding this method
     * to also deserialize the format used by your backend.
     * @param value The value to be deserialized into a date object.
     * @returns The deserialized date object, either a valid date, null if the value can be
     *     deserialized into a null date (e.g. the empty string), or an invalid date.
     */
    /**
     * Attempts to deserialize a value to a valid date object. This is different from parsing in that
     * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601
     * string). The default implementation does not allow any deserialization, it simply checks that
     * the given value is already a valid date object or null. The `<mat-datepicker>` will call this
     * method on all of it's `\@Input()` properties that accept dates. It is therefore possible to
     * support passing values from your backend directly to these properties by overriding this method
     * to also deserialize the format used by your backend.
     * @param {?} value The value to be deserialized into a date object.
     * @return {?} The deserialized date object, either a valid date, null if the value can be
     *     deserialized into a null date (e.g. the empty string), or an invalid date.
     */
    DateAdapter.prototype.deserialize = /**
     * Attempts to deserialize a value to a valid date object. This is different from parsing in that
     * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601
     * string). The default implementation does not allow any deserialization, it simply checks that
     * the given value is already a valid date object or null. The `<mat-datepicker>` will call this
     * method on all of it's `\@Input()` properties that accept dates. It is therefore possible to
     * support passing values from your backend directly to these properties by overriding this method
     * to also deserialize the format used by your backend.
     * @param {?} value The value to be deserialized into a date object.
     * @return {?} The deserialized date object, either a valid date, null if the value can be
     *     deserialized into a null date (e.g. the empty string), or an invalid date.
     */
    function (value) {
        if (value == null || this.isDateInstance(value) && this.isValid(value)) {
            return value;
        }
        return this.invalid();
    };
    /**
     * Sets the locale used for all dates.
     * @param locale The new locale.
     */
    /**
     * Sets the locale used for all dates.
     * @param {?} locale The new locale.
     * @return {?}
     */
    DateAdapter.prototype.setLocale = /**
     * Sets the locale used for all dates.
     * @param {?} locale The new locale.
     * @return {?}
     */
    function (locale) {
        this.locale = locale;
        this._localeChanges.next();
    };
    /**
     * Compares two dates.
     * @param first The first date to compare.
     * @param second The second date to compare.
     * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,
     *     a number greater than 0 if the first date is later.
     */
    /**
     * Compares two dates.
     * @param {?} first The first date to compare.
     * @param {?} second The second date to compare.
     * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,
     *     a number greater than 0 if the first date is later.
     */
    DateAdapter.prototype.compareDate = /**
     * Compares two dates.
     * @param {?} first The first date to compare.
     * @param {?} second The second date to compare.
     * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,
     *     a number greater than 0 if the first date is later.
     */
    function (first, second) {
        return this.getYear(first) - this.getYear(second) ||
            this.getMonth(first) - this.getMonth(second) ||
            this.getDate(first) - this.getDate(second);
    };
    /**
     * Checks if two dates are equal.
     * @param first The first date to check.
     * @param second The second date to check.
     * @returns Whether the two dates are equal.
     *     Null dates are considered equal to other null dates.
     */
    /**
     * Checks if two dates are equal.
     * @param {?} first The first date to check.
     * @param {?} second The second date to check.
     * @return {?} Whether the two dates are equal.
     *     Null dates are considered equal to other null dates.
     */
    DateAdapter.prototype.sameDate = /**
     * Checks if two dates are equal.
     * @param {?} first The first date to check.
     * @param {?} second The second date to check.
     * @return {?} Whether the two dates are equal.
     *     Null dates are considered equal to other null dates.
     */
    function (first, second) {
        if (first && second) {
            var /** @type {?} */ firstValid = this.isValid(first);
            var /** @type {?} */ secondValid = this.isValid(second);
            if (firstValid && secondValid) {
                return !this.compareDate(first, second);
            }
            return firstValid == secondValid;
        }
        return first == second;
    };
    /**
     * Clamp the given date between min and max dates.
     * @param date The date to clamp.
     * @param min The minimum value to allow. If null or omitted no min is enforced.
     * @param max The maximum value to allow. If null or omitted no max is enforced.
     * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,
     *     otherwise `date`.
     */
    /**
     * Clamp the given date between min and max dates.
     * @param {?} date The date to clamp.
     * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
     * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
     * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
     *     otherwise `date`.
     */
    DateAdapter.prototype.clampDate = /**
     * Clamp the given date between min and max dates.
     * @param {?} date The date to clamp.
     * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
     * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
     * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
     *     otherwise `date`.
     */
    function (date, min, max) {
        if (min && this.compareDate(date, min) < 0) {
            return min;
        }
        if (max && this.compareDate(date, max) > 0) {
            return max;
        }
        return date;
    };
    return DateAdapter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ MAT_DATE_FORMATS = new core.InjectionToken('mat-date-formats');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Whether the browser supports the Intl API.
 */
var /** @type {?} */ SUPPORTS_INTL_API = typeof Intl != 'undefined';
/**
 * The default month names to use if Intl API is not available.
 */
var /** @type {?} */ DEFAULT_MONTH_NAMES = {
    'long': [
        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
        'October', 'November', 'December'
    ],
    'short': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    'narrow': ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D']
};
var 0 = function (i) { return String(i + 1); };
/**
 * The default date names to use if Intl API is not available.
 */
var /** @type {?} */ DEFAULT_DATE_NAMES = range$1(31, 0);
/**
 * The default day of the week names to use if Intl API is not available.
 */
var /** @type {?} */ DEFAULT_DAY_OF_WEEK_NAMES = {
    'long': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    'short': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    'narrow': ['S', 'M', 'T', 'W', 'T', 'F', 'S']
};
/**
 * Matches strings that have the form of a valid RFC 3339 string
 * (https://tools.ietf.org/html/rfc3339). Note that the string may not actually be a valid date
 * because the regex will match strings an with out of bounds month, date, etc.
 */
var /** @type {?} */ ISO_8601_REGEX = /^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|(?:(?:\+|-)\d{2}:\d{2}))?)?$/;
/**
 * Creates an array and fills it with values.
 * @template T
 * @param {?} length
 * @param {?} valueFunction
 * @return {?}
 */
function range$1(length, valueFunction) {
    var /** @type {?} */ valuesArray = Array(length);
    for (var /** @type {?} */ i = 0; i < length; i++) {
        valuesArray[i] = valueFunction(i);
    }
    return valuesArray;
}
/**
 * Adapts the native JS Date for use with cdk-based components that work with dates.
 */
var NativeDateAdapter = /** @class */ (function (_super) {
    __extends(NativeDateAdapter, _super);
    function NativeDateAdapter(matDateLocale, platform) {
        var _this = _super.call(this) || this;
        /**
         * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.
         * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off
         * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`
         * will produce `'8/13/1800'`.
         *
         * TODO(mmalerba): drop this variable. It's not being used in the code right now. We're now
         * getting the string representation of a Date object from it's utc representation. We're keeping
         * it here for sometime, just for precaution, in case we decide to revert some of these changes
         * though.
         */
        _this.useUtcForDisplay = true;
        _super.prototype.setLocale.call(_this, matDateLocale);
        // IE does its own time zone correction, so we disable this on IE.
        // IE does its own time zone correction, so we disable this on IE.
        _this.useUtcForDisplay = !platform.TRIDENT;
        _this._clampDate = platform.TRIDENT || platform.EDGE;
        return _this;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    NativeDateAdapter.prototype.getYear = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return date.getFullYear();
    };
    /**
     * @param {?} date
     * @return {?}
     */
    NativeDateAdapter.prototype.getMonth = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return date.getMonth();
    };
    /**
     * @param {?} date
     * @return {?}
     */
    NativeDateAdapter.prototype.getDate = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return date.getDate();
    };
    /**
     * @param {?} date
     * @return {?}
     */
    NativeDateAdapter.prototype.getDayOfWeek = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return date.getDay();
    };
    /**
     * @param {?} style
     * @return {?}
     */
    NativeDateAdapter.prototype.getMonthNames = /**
     * @param {?} style
     * @return {?}
     */
    function (style) {
        var _this = this;
        if (SUPPORTS_INTL_API) {
            var /** @type {?} */ dtf_1 = new Intl.DateTimeFormat(this.locale, { month: style, timeZone: 'utc' });
            return range$1(12, function (i) {
                return _this._stripDirectionalityCharacters(_this._format(dtf_1, new Date(2017, i, 1)));
            });
        }
        return DEFAULT_MONTH_NAMES[style];
    };
    /**
     * @return {?}
     */
    NativeDateAdapter.prototype.getDateNames = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (SUPPORTS_INTL_API) {
            var /** @type {?} */ dtf_2 = new Intl.DateTimeFormat(this.locale, { day: 'numeric', timeZone: 'utc' });
            return range$1(31, function (i) {
                return _this._stripDirectionalityCharacters(_this._format(dtf_2, new Date(2017, 0, i + 1)));
            });
        }
        return DEFAULT_DATE_NAMES;
    };
    /**
     * @param {?} style
     * @return {?}
     */
    NativeDateAdapter.prototype.getDayOfWeekNames = /**
     * @param {?} style
     * @return {?}
     */
    function (style) {
        var _this = this;
        if (SUPPORTS_INTL_API) {
            var /** @type {?} */ dtf_3 = new Intl.DateTimeFormat(this.locale, { weekday: style, timeZone: 'utc' });
            return range$1(7, function (i) {
                return _this._stripDirectionalityCharacters(_this._format(dtf_3, new Date(2017, 0, i + 1)));
            });
        }
        return DEFAULT_DAY_OF_WEEK_NAMES[style];
    };
    /**
     * @param {?} date
     * @return {?}
     */
    NativeDateAdapter.prototype.getYearName = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (SUPPORTS_INTL_API) {
            var /** @type {?} */ dtf = new Intl.DateTimeFormat(this.locale, { year: 'numeric', timeZone: 'utc' });
            return this._stripDirectionalityCharacters(this._format(dtf, date));
        }
        return String(this.getYear(date));
    };
    /**
     * @return {?}
     */
    NativeDateAdapter.prototype.getFirstDayOfWeek = /**
     * @return {?}
     */
    function () {
        // We can't tell using native JS Date what the first day of the week is, we default to Sunday.
        return 0;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    NativeDateAdapter.prototype.getNumDaysInMonth = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));
    };
    /**
     * @param {?} date
     * @return {?}
     */
    NativeDateAdapter.prototype.clone = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return this.createDate(this.getYear(date), this.getMonth(date), this.getDate(date));
    };
    /**
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    NativeDateAdapter.prototype.createDate = /**
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    function (year, month, date) {
        // Check for invalid month and date (except upper bound on date which we have to check after
        // creating the Date).
        if (month < 0 || month > 11) {
            throw Error("Invalid month index \"" + month + "\". Month index has to be between 0 and 11.");
        }
        if (date < 1) {
            throw Error("Invalid date \"" + date + "\". Date has to be greater than 0.");
        }
        var /** @type {?} */ result = this._createDateWithOverflow(year, month, date);
        // Check that the date wasn't above the upper bound for the month, causing the month to overflow
        if (result.getMonth() != month) {
            throw Error("Invalid date \"" + date + "\" for month with index \"" + month + "\".");
        }
        return result;
    };
    /**
     * @return {?}
     */
    NativeDateAdapter.prototype.today = /**
     * @return {?}
     */
    function () {
        return new Date();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    NativeDateAdapter.prototype.parse = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // We have no way using the native JS Date to set the parse format or locale, so we ignore these
        // parameters.
        if (typeof value == 'number') {
            return new Date(value);
        }
        return value ? new Date(Date.parse(value)) : null;
    };
    /**
     * @param {?} date
     * @param {?} displayFormat
     * @return {?}
     */
    NativeDateAdapter.prototype.format = /**
     * @param {?} date
     * @param {?} displayFormat
     * @return {?}
     */
    function (date, displayFormat) {
        if (!this.isValid(date)) {
            throw Error('NativeDateAdapter: Cannot format invalid date.');
        }
        if (SUPPORTS_INTL_API) {
            // On IE and Edge the i18n API will throw a hard error that can crash the entire app
            // if we attempt to format a date whose year is less than 1 or greater than 9999.
            if (this._clampDate && (date.getFullYear() < 1 || date.getFullYear() > 9999)) {
                date = this.clone(date);
                date.setFullYear(Math.max(1, Math.min(9999, date.getFullYear())));
            }
            displayFormat = __assign({}, displayFormat, { timeZone: 'utc' });
            var /** @type {?} */ dtf = new Intl.DateTimeFormat(this.locale, displayFormat);
            return this._stripDirectionalityCharacters(this._format(dtf, date));
        }
        return this._stripDirectionalityCharacters(date.toDateString());
    };
    /**
     * @param {?} date
     * @param {?} years
     * @return {?}
     */
    NativeDateAdapter.prototype.addCalendarYears = /**
     * @param {?} date
     * @param {?} years
     * @return {?}
     */
    function (date, years) {
        return this.addCalendarMonths(date, years * 12);
    };
    /**
     * @param {?} date
     * @param {?} months
     * @return {?}
     */
    NativeDateAdapter.prototype.addCalendarMonths = /**
     * @param {?} date
     * @param {?} months
     * @return {?}
     */
    function (date, months) {
        var /** @type {?} */ newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date));
        // It's possible to wind up in the wrong month if the original month has more days than the new
        // month. In this case we want to go to the last day of the desired month.
        // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't
        // guarantee this.
        if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {
            newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);
        }
        return newDate;
    };
    /**
     * @param {?} date
     * @param {?} days
     * @return {?}
     */
    NativeDateAdapter.prototype.addCalendarDays = /**
     * @param {?} date
     * @param {?} days
     * @return {?}
     */
    function (date, days) {
        return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);
    };
    /**
     * @param {?} date
     * @return {?}
     */
    NativeDateAdapter.prototype.toIso8601 = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return [
            date.getUTCFullYear(),
            this._2digit(date.getUTCMonth() + 1),
            this._2digit(date.getUTCDate())
        ].join('-');
    };
    /**
     * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings
     * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an
     * invalid date for all other values.
     */
    /**
     * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings
     * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an
     * invalid date for all other values.
     * @param {?} value
     * @return {?}
     */
    NativeDateAdapter.prototype.deserialize = /**
     * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings
     * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an
     * invalid date for all other values.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (typeof value === 'string') {
            if (!value) {
                return null;
            }
            // The `Date` constructor accepts formats other than ISO 8601, so we need to make sure the
            // string is the right format first.
            if (ISO_8601_REGEX.test(value)) {
                var /** @type {?} */ date = new Date(value);
                if (this.isValid(date)) {
                    return date;
                }
            }
        }
        return _super.prototype.deserialize.call(this, value);
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    NativeDateAdapter.prototype.isDateInstance = /**
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
        return obj instanceof Date;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    NativeDateAdapter.prototype.isValid = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return !isNaN(date.getTime());
    };
    /**
     * @return {?}
     */
    NativeDateAdapter.prototype.invalid = /**
     * @return {?}
     */
    function () {
        return new Date(NaN);
    };
    /**
     * Creates a date but allows the month and date to overflow.
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    NativeDateAdapter.prototype._createDateWithOverflow = /**
     * Creates a date but allows the month and date to overflow.
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    function (year, month, date) {
        var /** @type {?} */ result = new Date(year, month, date);
        // We need to correct for the fact that JS native Date treats years in range [0, 99] as
        // abbreviations for 19xx.
        if (year >= 0 && year < 100) {
            result.setFullYear(this.getYear(result) - 1900);
        }
        return result;
    };
    /**
     * Pads a number to make it two digits.
     * @param {?} n The number to pad.
     * @return {?} The padded number.
     */
    NativeDateAdapter.prototype._2digit = /**
     * Pads a number to make it two digits.
     * @param {?} n The number to pad.
     * @return {?} The padded number.
     */
    function (n) {
        return ('00' + n).slice(-2);
    };
    /**
     * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
     * other browsers do not. We remove them to make output consistent and because they interfere with
     * date parsing.
     * @param {?} str The string to strip direction characters from.
     * @return {?} The stripped string.
     */
    NativeDateAdapter.prototype._stripDirectionalityCharacters = /**
     * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
     * other browsers do not. We remove them to make output consistent and because they interfere with
     * date parsing.
     * @param {?} str The string to strip direction characters from.
     * @return {?} The stripped string.
     */
    function (str) {
        return str.replace(/[\u200e\u200f]/g, '');
    };
    /**
     * When converting Date object to string, javascript built-in functions may return wrong
     * results because it applies its internal DST rules. The DST rules around the world change
     * very frequently, and the current valid rule is not always valid in previous years though.
     * We work around this problem building a new Date object which has its internal UTC
     * representation with the local date and time.
     * @param {?} dtf Intl.DateTimeFormat object, containg the desired string format. It must have
     *    timeZone set to 'utc' to work fine.
     * @param {?} date Date from which we want to get the string representation according to dtf
     * @return {?} A Date object with its UTC representation based on the passed in date info
     */
    NativeDateAdapter.prototype._format = /**
     * When converting Date object to string, javascript built-in functions may return wrong
     * results because it applies its internal DST rules. The DST rules around the world change
     * very frequently, and the current valid rule is not always valid in previous years though.
     * We work around this problem building a new Date object which has its internal UTC
     * representation with the local date and time.
     * @param {?} dtf Intl.DateTimeFormat object, containg the desired string format. It must have
     *    timeZone set to 'utc' to work fine.
     * @param {?} date Date from which we want to get the string representation according to dtf
     * @return {?} A Date object with its UTC representation based on the passed in date info
     */
    function (dtf, date) {
        var /** @type {?} */ d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
        return dtf.format(d);
    };
    NativeDateAdapter.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    NativeDateAdapter.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_DATE_LOCALE,] },] },
        { type: Platform, },
    ]; };
    return NativeDateAdapter;
}(DateAdapter));
/**
 * Provider that defines how form controls behave with regards to displaying error messages.
 */
var ErrorStateMatcher = /** @class */ (function () {
    function ErrorStateMatcher() {
    }
    /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    ErrorStateMatcher.prototype.isErrorState = /**
     * @param {?} control
     * @param {?} form
     * @return {?}
     */
    function (control, form) {
        return !!(control && control.invalid && (control.touched || (form && form.submitted)));
    };
    ErrorStateMatcher.decorators = [
        { type: core.Injectable, args: [{ providedIn: 'root' },] },
    ];
    /** @nocollapse */ ErrorStateMatcher.ngInjectableDef = core.defineInjectable({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: "root" });
    return ErrorStateMatcher;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Injection token that can be used to provide options to the Hammerjs instance.
 * More info at http://hammerjs.github.io/api/.
 */
var /** @type {?} */ MAT_HAMMER_OPTIONS = new core.InjectionToken('MAT_HAMMER_OPTIONS');
var /** @type {?} */ ANGULAR_MATERIAL_SUPPORTED_HAMMER_GESTURES = [
    'longpress',
    'slide',
    'slidestart',
    'slideend',
    'slideright',
    'slideleft'
];
var 0$2 = function () { }, 1 = function () { };
/**
 * Fake HammerInstance that is used when a Hammer instance is requested when HammerJS has not
 * been loaded on the page.
 */
var /** @type {?} */ noopHammerInstance = {
    on: 0$2,
    off: 1,
};
/**
 * Adjusts configuration of our gesture library, Hammer.
 */
var GestureConfig = /** @class */ (function (_super) {
    __extends(GestureConfig, _super);
    function GestureConfig(_hammerOptions, commonModule) {
        var _this = _super.call(this) || this;
        _this._hammerOptions = _hammerOptions;
        /**
         * List of new event names to add to the gesture support list
         */
        _this.events = ANGULAR_MATERIAL_SUPPORTED_HAMMER_GESTURES;
        if (commonModule) {
            commonModule._checkHammerIsAvailable();
        }
        return _this;
    }
    /**
     * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
     *
     * Our gesture names come from the Material Design gestures spec:
     * https://material.io/design/#gestures-touch-mechanics
     *
     * More information on default recognizers can be found in Hammer docs:
     * http://hammerjs.github.io/recognizer-pan/
     * http://hammerjs.github.io/recognizer-press/
     *
     * @param element Element to which to assign the new HammerJS gestures.
     * @returns Newly-created HammerJS instance.
     */
    /**
     * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
     *
     * Our gesture names come from the Material Design gestures spec:
     * https://material.io/design/#gestures-touch-mechanics
     *
     * More information on default recognizers can be found in Hammer docs:
     * http://hammerjs.github.io/recognizer-pan/
     * http://hammerjs.github.io/recognizer-press/
     *
     * @param {?} element Element to which to assign the new HammerJS gestures.
     * @return {?} Newly-created HammerJS instance.
     */
    GestureConfig.prototype.buildHammer = /**
     * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
     *
     * Our gesture names come from the Material Design gestures spec:
     * https://material.io/design/#gestures-touch-mechanics
     *
     * More information on default recognizers can be found in Hammer docs:
     * http://hammerjs.github.io/recognizer-pan/
     * http://hammerjs.github.io/recognizer-press/
     *
     * @param {?} element Element to which to assign the new HammerJS gestures.
     * @return {?} Newly-created HammerJS instance.
     */
    function (element) {
        var /** @type {?} */ hammer = typeof window !== 'undefined' ? (/** @type {?} */ (window)).Hammer : null;
        if (!hammer) {
            // If HammerJS is not loaded here, return the noop HammerInstance. This is necessary to
            // ensure that omitting HammerJS completely will not cause any errors while *also* supporting
            // the lazy-loading of HammerJS via the HAMMER_LOADER token introduced in Angular 6.1.
            // Because we can't depend on HAMMER_LOADER's existance until 7.0, we have to always set
            // `this.events` to the set we support, instead of conditionally setting it to `[]` if
            // `HAMMER_LOADER` is present (and then throwing an Error here if `window.Hammer` is
            // undefined).
            // @breaking-change 7.0.0
            return noopHammerInstance;
        }
        var /** @type {?} */ mc = new hammer(element, this._hammerOptions || undefined);
        // Default Hammer Recognizers.
        var /** @type {?} */ pan = new hammer.Pan();
        var /** @type {?} */ swipe = new hammer.Swipe();
        var /** @type {?} */ press = new hammer.Press();
        // Notice that a HammerJS recognizer can only depend on one other recognizer once.
        // Otherwise the previous `recognizeWith` will be dropped.
        // TODO: Confirm threshold numbers with Material Design UX Team
        var /** @type {?} */ slide = this._createRecognizer(pan, { event: 'slide', threshold: 0 }, swipe);
        var /** @type {?} */ longpress = this._createRecognizer(press, { event: 'longpress', time: 500 });
        // Overwrite the default `pan` event to use the swipe event.
        pan.recognizeWith(swipe);
        // Add customized gestures to Hammer manager
        mc.add([swipe, press, pan, slide, longpress]);
        return /** @type {?} */ (mc);
    };
    /**
     * Creates a new recognizer, without affecting the default recognizers of HammerJS
     * @param {?} base
     * @param {?} options
     * @param {...?} inheritances
     * @return {?}
     */
    GestureConfig.prototype._createRecognizer = /**
     * Creates a new recognizer, without affecting the default recognizers of HammerJS
     * @param {?} base
     * @param {?} options
     * @param {...?} inheritances
     * @return {?}
     */
    function (base, options) {
        var inheritances = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            inheritances[_i - 2] = arguments[_i];
        }
        var /** @type {?} */ recognizer = new (/** @type {?} */ (base.constructor))(options);
        inheritances.push(base);
        inheritances.forEach(function (item) { return recognizer.recognizeWith(item); });
        return recognizer;
    };
    GestureConfig.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    GestureConfig.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_HAMMER_OPTIONS,] },] },
        { type: MatCommonModule, decorators: [{ type: core.Optional },] },
    ]; };
    return GestureConfig;
}(platformBrowser.HammerGestureConfig));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/** @enum {number} */
var RippleState = {
    FADING_IN: 0,
    VISIBLE: 1,
    FADING_OUT: 2,
    HIDDEN: 3,
};
RippleState[RippleState.FADING_IN] = "FADING_IN";
RippleState[RippleState.VISIBLE] = "VISIBLE";
RippleState[RippleState.FADING_OUT] = "FADING_OUT";
RippleState[RippleState.HIDDEN] = "HIDDEN";
/**
 * Reference to a previously launched ripple element.
 */
var  /**
 * Reference to a previously launched ripple element.
 */
RippleRef = /** @class */ (function () {
    function RippleRef(_renderer, element, config$$1) {
        this._renderer = _renderer;
        this.element = element;
        this.config = config$$1;
        /**
         * Current state of the ripple reference.
         */
        this.state = RippleState.HIDDEN;
    }
    /** Fades out the ripple element. */
    /**
     * Fades out the ripple element.
     * @return {?}
     */
    RippleRef.prototype.fadeOut = /**
     * Fades out the ripple element.
     * @return {?}
     */
    function () {
        this._renderer.fadeOutRipple(this);
    };
    return RippleRef;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Default ripple animation configuration for ripples without an explicit
 * animation config specified.
 */
var /** @type {?} */ defaultRippleAnimationConfig = {
    enterDuration: 450,
    exitDuration: 400
};
/**
 * Timeout for ignoring mouse events. Mouse events will be temporary ignored after touch
 * events to avoid synthetic mouse events.
 */
var /** @type {?} */ ignoreMouseEventsTimeout = 800;
/**
 * Helper service that performs DOM manipulations. Not intended to be used outside this module.
 * The constructor takes a reference to the ripple directive's host element and a map of DOM
 * event handlers to be installed on the element that triggers ripple animations.
 * This will eventually become a custom renderer once Angular support exists.
 * \@docs-private
 */
var  /**
 * Helper service that performs DOM manipulations. Not intended to be used outside this module.
 * The constructor takes a reference to the ripple directive's host element and a map of DOM
 * event handlers to be installed on the element that triggers ripple animations.
 * This will eventually become a custom renderer once Angular support exists.
 * \@docs-private
 */
RippleRenderer = /** @class */ (function () {
    function RippleRenderer(_target, _ngZone, elementRef, platform) {
        var _this = this;
        this._target = _target;
        this._ngZone = _ngZone;
        /**
         * Whether the pointer is currently down or not.
         */
        this._isPointerDown = false;
        /**
         * Events to be registered on the trigger element.
         */
        this._triggerEvents = new Map();
        /**
         * Set of currently active ripple references.
         */
        this._activeRipples = new Set();
        /**
         * Options that apply to all the event listeners that are bound by the renderer.
         */
        this._eventOptions = supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true })) : false;
        /**
         * Function being called whenever the trigger is being pressed using mouse.
         */
        this.onMousedown = function (event) {
            // Screen readers will fire fake mouse events for space/enter. Skip launching a
            // ripple in this case for consistency with the non-screen-reader experience.
            var /** @type {?} */ isFakeMousedown = isFakeMousedownFromScreenReader(event);
            var /** @type {?} */ isSyntheticEvent = _this._lastTouchStartEvent &&
                Date.now() < _this._lastTouchStartEvent + ignoreMouseEventsTimeout;
            if (!_this._target.rippleDisabled && !isFakeMousedown && !isSyntheticEvent) {
                _this._isPointerDown = true;
                _this.fadeInRipple(event.clientX, event.clientY, _this._target.rippleConfig);
            }
        };
        /**
         * Function being called whenever the trigger is being pressed using touch.
         */
        this.onTouchStart = function (event) {
            if (!_this._target.rippleDisabled) {
                // Some browsers fire mouse events after a `touchstart` event. Those synthetic mouse
                // events will launch a second ripple if we don't ignore mouse events for a specific
                // time after a touchstart event.
                // Some browsers fire mouse events after a `touchstart` event. Those synthetic mouse
                // events will launch a second ripple if we don't ignore mouse events for a specific
                // time after a touchstart event.
                _this._lastTouchStartEvent = Date.now();
                _this._isPointerDown = true;
                _this.fadeInRipple(event.touches[0].clientX, event.touches[0].clientY, _this._target.rippleConfig);
            }
        };
        /**
         * Function being called whenever the trigger is being released.
         */
        this.onPointerUp = function () {
            if (!_this._isPointerDown) {
                return;
            }
            _this._isPointerDown = false;
            // Fade-out all ripples that are visible and not persistent.
            // Fade-out all ripples that are visible and not persistent.
            _this._activeRipples.forEach(function (ripple) {
                // By default, only ripples that are completely visible will fade out on pointer release.
                // If the `terminateOnPointerUp` option is set, ripples that still fade in will also fade out.
                var /** @type {?} */ isVisible = ripple.state === RippleState.VISIBLE ||
                    ripple.config.terminateOnPointerUp && ripple.state === RippleState.FADING_IN;
                if (!ripple.config.persistent && isVisible) {
                    ripple.fadeOut();
                }
            });
        };
        // Only do anything if we're on the browser.
        if (platform.isBrowser) {
            this._containerElement = elementRef.nativeElement;
            // Specify events which need to be registered on the trigger.
            this._triggerEvents.set('mousedown', this.onMousedown);
            this._triggerEvents.set('mouseup', this.onPointerUp);
            this._triggerEvents.set('mouseleave', this.onPointerUp);
            this._triggerEvents.set('touchstart', this.onTouchStart);
            this._triggerEvents.set('touchend', this.onPointerUp);
        }
    }
    /**
     * Fades in a ripple at the given coordinates.
     * @param x Coordinate within the element, along the X axis at which to start the ripple.
     * @param y Coordinate within the element, along the Y axis at which to start the ripple.
     * @param config Extra ripple options.
     */
    /**
     * Fades in a ripple at the given coordinates.
     * @param {?} x Coordinate within the element, along the X axis at which to start the ripple.
     * @param {?} y Coordinate within the element, along the Y axis at which to start the ripple.
     * @param {?=} config Extra ripple options.
     * @return {?}
     */
    RippleRenderer.prototype.fadeInRipple = /**
     * Fades in a ripple at the given coordinates.
     * @param {?} x Coordinate within the element, along the X axis at which to start the ripple.
     * @param {?} y Coordinate within the element, along the Y axis at which to start the ripple.
     * @param {?=} config Extra ripple options.
     * @return {?}
     */
    function (x, y, config$$1) {
        var _this = this;
        if (config$$1 === void 0) { config$$1 = {}; }
        var /** @type {?} */ containerRect = this._containerRect =
            this._containerRect || this._containerElement.getBoundingClientRect();
        var /** @type {?} */ animationConfig = __assign({}, defaultRippleAnimationConfig, config$$1.animation);
        if (config$$1.centered) {
            x = containerRect.left + containerRect.width / 2;
            y = containerRect.top + containerRect.height / 2;
        }
        var /** @type {?} */ radius = config$$1.radius || distanceToFurthestCorner(x, y, containerRect);
        var /** @type {?} */ offsetX = x - containerRect.left;
        var /** @type {?} */ offsetY = y - containerRect.top;
        var /** @type {?} */ duration = animationConfig.enterDuration / (config$$1.speedFactor || 1);
        var /** @type {?} */ ripple = document.createElement('div');
        ripple.classList.add('mat-ripple-element');
        ripple.style.left = offsetX - radius + "px";
        ripple.style.top = offsetY - radius + "px";
        ripple.style.height = radius * 2 + "px";
        ripple.style.width = radius * 2 + "px";
        // If the color is not set, the default CSS color will be used.
        ripple.style.backgroundColor = config$$1.color || null;
        ripple.style.transitionDuration = duration + "ms";
        this._containerElement.appendChild(ripple);
        // By default the browser does not recalculate the styles of dynamically created
        // ripple elements. This is critical because then the `scale` would not animate properly.
        enforceStyleRecalculation(ripple);
        ripple.style.transform = 'scale(1)';
        // Exposed reference to the ripple that will be returned.
        var /** @type {?} */ rippleRef = new RippleRef(this, ripple, config$$1);
        rippleRef.state = RippleState.FADING_IN;
        // Add the ripple reference to the list of all active ripples.
        this._activeRipples.add(rippleRef);
        if (!config$$1.persistent) {
            this._mostRecentTransientRipple = rippleRef;
        }
        // Wait for the ripple element to be completely faded in.
        // Once it's faded in, the ripple can be hidden immediately if the mouse is released.
        this.runTimeoutOutsideZone(function () {
            var /** @type {?} */ isMostRecentTransientRipple = rippleRef === _this._mostRecentTransientRipple;
            rippleRef.state = RippleState.VISIBLE;
            // When the timer runs out while the user has kept their pointer down, we want to
            // keep only the persistent ripples and the latest transient ripple. We do this,
            // because we don't want stacked transient ripples to appear after their enter
            // animation has finished.
            if (!config$$1.persistent && (!isMostRecentTransientRipple || !_this._isPointerDown)) {
                rippleRef.fadeOut();
            }
        }, duration);
        return rippleRef;
    };
    /** Fades out a ripple reference. */
    /**
     * Fades out a ripple reference.
     * @param {?} rippleRef
     * @return {?}
     */
    RippleRenderer.prototype.fadeOutRipple = /**
     * Fades out a ripple reference.
     * @param {?} rippleRef
     * @return {?}
     */
    function (rippleRef) {
        var /** @type {?} */ wasActive = this._activeRipples.delete(rippleRef);
        if (rippleRef === this._mostRecentTransientRipple) {
            this._mostRecentTransientRipple = null;
        }
        // Clear out the cached bounding rect if we have no more ripples.
        if (!this._activeRipples.size) {
            this._containerRect = null;
        }
        // For ripples that are not active anymore, don't re-un the fade-out animation.
        if (!wasActive) {
            return;
        }
        var /** @type {?} */ rippleEl = rippleRef.element;
        var /** @type {?} */ animationConfig = __assign({}, defaultRippleAnimationConfig, rippleRef.config.animation);
        rippleEl.style.transitionDuration = animationConfig.exitDuration + "ms";
        rippleEl.style.opacity = '0';
        rippleRef.state = RippleState.FADING_OUT;
        // Once the ripple faded out, the ripple can be safely removed from the DOM.
        this.runTimeoutOutsideZone(function () {
            rippleRef.state = RippleState.HIDDEN; /** @type {?} */
            ((rippleEl.parentNode)).removeChild(rippleEl);
        }, animationConfig.exitDuration);
    };
    /** Fades out all currently active ripples. */
    /**
     * Fades out all currently active ripples.
     * @return {?}
     */
    RippleRenderer.prototype.fadeOutAll = /**
     * Fades out all currently active ripples.
     * @return {?}
     */
    function () {
        this._activeRipples.forEach(function (ripple) { return ripple.fadeOut(); });
    };
    /** Sets up the trigger event listeners */
    /**
     * Sets up the trigger event listeners
     * @param {?} element
     * @return {?}
     */
    RippleRenderer.prototype.setupTriggerEvents = /**
     * Sets up the trigger event listeners
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var _this = this;
        if (!element || element === this._triggerElement) {
            return;
        }
        // Remove all previously registered event listeners from the trigger element.
        this._removeTriggerEvents();
        this._ngZone.runOutsideAngular(function () {
            _this._triggerEvents.forEach(function (fn, type) {
                return element.addEventListener(type, fn, _this._eventOptions);
            });
        });
        this._triggerElement = element;
    };
    /**
     * Runs a timeout outside of the Angular zone to avoid triggering the change detection.
     * @param {?} fn
     * @param {?=} delay
     * @return {?}
     */
    RippleRenderer.prototype.runTimeoutOutsideZone = /**
     * Runs a timeout outside of the Angular zone to avoid triggering the change detection.
     * @param {?} fn
     * @param {?=} delay
     * @return {?}
     */
    function (fn, delay) {
        if (delay === void 0) { delay = 0; }
        this._ngZone.runOutsideAngular(function () { return setTimeout(fn, delay); });
    };
    /** Removes previously registered event listeners from the trigger element. */
    /**
     * Removes previously registered event listeners from the trigger element.
     * @return {?}
     */
    RippleRenderer.prototype._removeTriggerEvents = /**
     * Removes previously registered event listeners from the trigger element.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._triggerElement) {
            this._triggerEvents.forEach(function (fn, type) {
                /** @type {?} */ ((_this._triggerElement)).removeEventListener(type, fn, _this._eventOptions);
            });
        }
    };
    return RippleRenderer;
}());
/**
 * Enforces a style recalculation of a DOM element by computing its styles.
 * @param {?} element
 * @return {?}
 */
function enforceStyleRecalculation(element) {
    // Enforce a style recalculation by calling `getComputedStyle` and accessing any property.
    // Calling `getPropertyValue` is important to let optimizers know that this is not a noop.
    // See: https://gist.github.com/paulirish/5d52fb081b3570c81e3a
    window.getComputedStyle(element).getPropertyValue('opacity');
}
/**
 * Returns the distance from the point (x, y) to the furthest corner of a rectangle.
 * @param {?} x
 * @param {?} y
 * @param {?} rect
 * @return {?}
 */
function distanceToFurthestCorner(x, y, rect) {
    var /** @type {?} */ distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));
    var /** @type {?} */ distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));
    return Math.sqrt(distX * distX + distY * distY);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Injection token that can be used to specify the global ripple options.
 */
var /** @type {?} */ MAT_RIPPLE_GLOBAL_OPTIONS = new core.InjectionToken('mat-ripple-global-options');
var MatRipple = /** @class */ (function () {
    function MatRipple(_elementRef, ngZone, platform, globalOptions, animationMode) {
        this._elementRef = _elementRef;
        /**
         * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius
         * will be the distance from the center of the ripple to the furthest corner of the host element's
         * bounding rectangle.
         */
        this.radius = 0;
        /**
         * If set, the normal duration of ripple animations is divided by this value. For example,
         * setting it to 0.5 will cause the animations to take twice as long.
         * A changed speedFactor will not modify the fade-out duration of the ripples.
         * @deprecated Use the [matRippleAnimation] binding instead.
         * \@breaking-change 7.0.0
         */
        this.speedFactor = 1;
        this._disabled = false;
        /**
         * Whether ripple directive is initialized and the input bindings are set.
         */
        this._isInitialized = false;
        this._globalOptions = globalOptions || {};
        this._rippleRenderer = new RippleRenderer(this, ngZone, _elementRef, platform);
        if (animationMode === 'NoopAnimations') {
            this._globalOptions.animation = { enterDuration: 0, exitDuration: 0 };
        }
    }
    Object.defineProperty(MatRipple.prototype, "disabled", {
        get: /**
         * Whether click events will not trigger the ripple. Ripples can be still launched manually
         * by using the `launch()` method.
         * @return {?}
         */
        function () { return this._disabled; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = value;
            this._setupTriggerEventsIfEnabled();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatRipple.prototype, "trigger", {
        get: /**
         * The element that triggers the ripple when click events are received.
         * Defaults to the directive's host element.
         * @return {?}
         */
        function () { return this._trigger || this._elementRef.nativeElement; },
        set: /**
         * @param {?} trigger
         * @return {?}
         */
        function (trigger) {
            this._trigger = trigger;
            this._setupTriggerEventsIfEnabled();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MatRipple.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._isInitialized = true;
        this._setupTriggerEventsIfEnabled();
    };
    /**
     * @return {?}
     */
    MatRipple.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._rippleRenderer._removeTriggerEvents();
    };
    /** Fades out all currently showing ripple elements. */
    /**
     * Fades out all currently showing ripple elements.
     * @return {?}
     */
    MatRipple.prototype.fadeOutAll = /**
     * Fades out all currently showing ripple elements.
     * @return {?}
     */
    function () {
        this._rippleRenderer.fadeOutAll();
    };
    Object.defineProperty(MatRipple.prototype, "rippleConfig", {
        /** Ripple configuration from the directive's input values. */
        get: /**
         * Ripple configuration from the directive's input values.
         * @return {?}
         */
        function () {
            return {
                centered: this.centered,
                radius: this.radius,
                color: this.color,
                animation: __assign({}, this._globalOptions.animation, this.animation),
                terminateOnPointerUp: this._globalOptions.terminateOnPointerUp,
                speedFactor: this.speedFactor * (this._globalOptions.baseSpeedFactor || 1),
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatRipple.prototype, "rippleDisabled", {
        /** Whether ripples on pointer-down are disabled or not. */
        get: /**
         * Whether ripples on pointer-down are disabled or not.
         * @return {?}
         */
        function () {
            return this.disabled || !!this._globalOptions.disabled;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets up the the trigger event listeners if ripples are enabled.
     * @return {?}
     */
    MatRipple.prototype._setupTriggerEventsIfEnabled = /**
     * Sets up the the trigger event listeners if ripples are enabled.
     * @return {?}
     */
    function () {
        if (!this.disabled && this._isInitialized) {
            this._rippleRenderer.setupTriggerEvents(this.trigger);
        }
    };
    /** Launches a manual ripple at the specified coordinated or just by the ripple config. */
    /**
     * Launches a manual ripple at the specified coordinated or just by the ripple config.
     * @param {?} configOrX
     * @param {?=} y
     * @param {?=} config
     * @return {?}
     */
    MatRipple.prototype.launch = /**
     * Launches a manual ripple at the specified coordinated or just by the ripple config.
     * @param {?} configOrX
     * @param {?=} y
     * @param {?=} config
     * @return {?}
     */
    function (configOrX, y, config$$1) {
        if (y === void 0) { y = 0; }
        if (typeof configOrX === 'number') {
            return this._rippleRenderer.fadeInRipple(configOrX, y, __assign({}, this.rippleConfig, config$$1));
        }
        else {
            return this._rippleRenderer.fadeInRipple(0, 0, __assign({}, this.rippleConfig, configOrX));
        }
    };
    MatRipple.decorators = [
        { type: core.Directive, args: [{
                    selector: '[mat-ripple], [matRipple]',
                    exportAs: 'matRipple',
                    host: {
                        'class': 'mat-ripple',
                        '[class.mat-ripple-unbounded]': 'unbounded'
                    }
                },] },
    ];
    /** @nocollapse */
    MatRipple.ctorParameters = function () { return [
        { type: core.ElementRef, },
        { type: core.NgZone, },
        { type: Platform, },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_RIPPLE_GLOBAL_OPTIONS,] },] },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] },] },
    ]; };
    MatRipple.propDecorators = {
        "color": [{ type: core.Input, args: ['matRippleColor',] },],
        "unbounded": [{ type: core.Input, args: ['matRippleUnbounded',] },],
        "centered": [{ type: core.Input, args: ['matRippleCentered',] },],
        "radius": [{ type: core.Input, args: ['matRippleRadius',] },],
        "speedFactor": [{ type: core.Input, args: ['matRippleSpeedFactor',] },],
        "animation": [{ type: core.Input, args: ['matRippleAnimation',] },],
        "disabled": [{ type: core.Input, args: ['matRippleDisabled',] },],
        "trigger": [{ type: core.Input, args: ['matRippleTrigger',] },],
    };
    return MatRipple;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Component that shows a simplified checkbox without including any kind of "real" checkbox.
 * Meant to be used when the checkbox is purely decorative and a large number of them will be
 * included, such as for the options in a multi-select. Uses no SVGs or complex animations.
 * Note that theming is meant to be handled by the parent element, e.g.
 * `mat-primary .mat-pseudo-checkbox`.
 *
 * Note that this component will be completely invisible to screen-reader users. This is *not*
 * interchangeable with `<mat-checkbox>` and should *not* be used if the user would directly
 * interact with the checkbox. The pseudo-checkbox should only be used as an implementation detail
 * of more complex components that appropriately handle selected / checked state.
 * \@docs-private
 */
var MatPseudoCheckbox = /** @class */ (function () {
    function MatPseudoCheckbox(_animationMode) {
        this._animationMode = _animationMode;
        /**
         * Display state of the checkbox.
         */
        this.state = 'unchecked';
        /**
         * Whether the checkbox is disabled.
         */
        this.disabled = false;
    }
    MatPseudoCheckbox.decorators = [
        { type: core.Component, args: [{encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    selector: 'mat-pseudo-checkbox',
                    styles: [".mat-pseudo-checkbox{width:20px;height:20px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0,0,.2,.1),background-color 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:'';border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:transparent}._mat-animation-noopable.mat-pseudo-checkbox{transition:none;animation:none}._mat-animation-noopable.mat-pseudo-checkbox::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:7px;left:0;width:16px;opacity:1}.mat-pseudo-checkbox-checked::after{top:3px;left:1px;width:12px;height:5px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1}"],
                    template: '',
                    host: {
                        'class': 'mat-pseudo-checkbox',
                        '[class.mat-pseudo-checkbox-indeterminate]': 'state === "indeterminate"',
                        '[class.mat-pseudo-checkbox-checked]': 'state === "checked"',
                        '[class.mat-pseudo-checkbox-disabled]': 'disabled',
                        '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                    },
                },] },
    ];
    /** @nocollapse */
    MatPseudoCheckbox.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] },] },
    ]; };
    MatPseudoCheckbox.propDecorators = {
        "state": [{ type: core.Input },],
        "disabled": [{ type: core.Input },],
    };
    return MatPseudoCheckbox;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@docs-private
 */
var  /**
 * \@docs-private
 */
MatOptgroupBase = /** @class */ (function () {
    function MatOptgroupBase() {
    }
    return MatOptgroupBase;
}());
var /** @type {?} */ _MatOptgroupMixinBase = mixinDisabled(MatOptgroupBase);
// Counter for unique group ids.
var /** @type {?} */ _uniqueOptgroupIdCounter = 0;
/**
 * Component that is used to group instances of `mat-option`.
 */
var MatOptgroup = /** @class */ (function (_super) {
    __extends(MatOptgroup, _super);
    function MatOptgroup() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Unique id for the underlying label.
         */
        _this._labelId = "mat-optgroup-label-" + _uniqueOptgroupIdCounter++;
        return _this;
    }
    MatOptgroup.decorators = [
        { type: core.Component, args: [{selector: 'mat-optgroup',
                    exportAs: 'matOptgroup',
                    template: "<label class=\"mat-optgroup-label\" [id]=\"_labelId\">{{ label }}</label><ng-content select=\"mat-option, ng-container\"></ng-content>",
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: ['disabled'],
                    styles: [".mat-optgroup-label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup-label[disabled]{cursor:default}[dir=rtl] .mat-optgroup-label{text-align:right}.mat-optgroup-label .mat-icon{margin-right:16px;vertical-align:middle}.mat-optgroup-label .mat-icon svg{vertical-align:top}[dir=rtl] .mat-optgroup-label .mat-icon{margin-left:16px;margin-right:0}"],
                    host: {
                        'class': 'mat-optgroup',
                        'role': 'group',
                        '[class.mat-optgroup-disabled]': 'disabled',
                        '[attr.aria-disabled]': 'disabled.toString()',
                        '[attr.aria-labelledby]': '_labelId',
                    }
                },] },
    ];
    /** @nocollapse */
    MatOptgroup.propDecorators = {
        "label": [{ type: core.Input },],
    };
    return MatOptgroup;
}(_MatOptgroupMixinBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Option IDs need to be unique across components, so this counter exists outside of
 * the component definition.
 */
var /** @type {?} */ _uniqueIdCounter = 0;
/**
 * Event object emitted by MatOption when selected or deselected.
 */
var  /**
 * Event object emitted by MatOption when selected or deselected.
 */
MatOptionSelectionChange = /** @class */ (function () {
    function MatOptionSelectionChange(source, isUserInput) {
        if (isUserInput === void 0) { isUserInput = false; }
        this.source = source;
        this.isUserInput = isUserInput;
    }
    return MatOptionSelectionChange;
}());
/**
 * Injection token used to provide the parent component to options.
 */
var /** @type {?} */ MAT_OPTION_PARENT_COMPONENT = new core.InjectionToken('MAT_OPTION_PARENT_COMPONENT');
/**
 * Single option inside of a `<mat-select>` element.
 */
var MatOption = /** @class */ (function () {
    function MatOption(_element, _changeDetectorRef, _parent, group) {
        this._element = _element;
        this._changeDetectorRef = _changeDetectorRef;
        this._parent = _parent;
        this.group = group;
        this._selected = false;
        this._active = false;
        this._disabled = false;
        this._mostRecentViewValue = '';
        /**
         * The unique ID of the option.
         */
        this.id = "mat-option-" + _uniqueIdCounter++;
        /**
         * Event emitted when the option is selected or deselected.
         */
        this.onSelectionChange = new core.EventEmitter();
        /**
         * Emits when the state of the option changes and any parents have to be notified.
         */
        this._stateChanges = new Subject();
    }
    Object.defineProperty(MatOption.prototype, "multiple", {
        /** Whether the wrapping component is in multiple selection mode. */
        get: /**
         * Whether the wrapping component is in multiple selection mode.
         * @return {?}
         */
        function () { return this._parent && this._parent.multiple; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatOption.prototype, "selected", {
        /** Whether or not the option is currently selected. */
        get: /**
         * Whether or not the option is currently selected.
         * @return {?}
         */
        function () { return this._selected; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatOption.prototype, "disabled", {
        get: /**
         * Whether the option is disabled.
         * @return {?}
         */
        function () { return (this.group && this.group.disabled) || this._disabled; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._disabled = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatOption.prototype, "disableRipple", {
        /** Whether ripples for the option are disabled. */
        get: /**
         * Whether ripples for the option are disabled.
         * @return {?}
         */
        function () { return this._parent && this._parent.disableRipple; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatOption.prototype, "active", {
        /**
         * Whether or not the option is currently active and ready to be selected.
         * An active option displays styles as if it is focused, but the
         * focus is actually retained somewhere else. This comes in handy
         * for components like autocomplete where focus must remain on the input.
         */
        get: /**
         * Whether or not the option is currently active and ready to be selected.
         * An active option displays styles as if it is focused, but the
         * focus is actually retained somewhere else. This comes in handy
         * for components like autocomplete where focus must remain on the input.
         * @return {?}
         */
        function () {
            return this._active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatOption.prototype, "viewValue", {
        /**
         * The displayed value of the option. It is necessary to show the selected option in the
         * select's trigger.
         */
        get: /**
         * The displayed value of the option. It is necessary to show the selected option in the
         * select's trigger.
         * @return {?}
         */
        function () {
            // TODO(kara): Add input property alternative for node envs.
            return (this._getHostElement().textContent || '').trim();
        },
        enumerable: true,
        configurable: true
    });
    /** Selects the option. */
    /**
     * Selects the option.
     * @return {?}
     */
    MatOption.prototype.select = /**
     * Selects the option.
     * @return {?}
     */
    function () {
        if (!this._selected) {
            this._selected = true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    };
    /** Deselects the option. */
    /**
     * Deselects the option.
     * @return {?}
     */
    MatOption.prototype.deselect = /**
     * Deselects the option.
     * @return {?}
     */
    function () {
        if (this._selected) {
            this._selected = false;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent();
        }
    };
    /** Sets focus onto this option. */
    /**
     * Sets focus onto this option.
     * @return {?}
     */
    MatOption.prototype.focus = /**
     * Sets focus onto this option.
     * @return {?}
     */
    function () {
        var /** @type {?} */ element = this._getHostElement();
        if (typeof element.focus === 'function') {
            element.focus();
        }
    };
    /**
     * This method sets display styles on the option to make it appear
     * active. This is used by the ActiveDescendantKeyManager so key
     * events will display the proper options as active on arrow key events.
     */
    /**
     * This method sets display styles on the option to make it appear
     * active. This is used by the ActiveDescendantKeyManager so key
     * events will display the proper options as active on arrow key events.
     * @return {?}
     */
    MatOption.prototype.setActiveStyles = /**
     * This method sets display styles on the option to make it appear
     * active. This is used by the ActiveDescendantKeyManager so key
     * events will display the proper options as active on arrow key events.
     * @return {?}
     */
    function () {
        if (!this._active) {
            this._active = true;
            this._changeDetectorRef.markForCheck();
        }
    };
    /**
     * This method removes display styles on the option that made it appear
     * active. This is used by the ActiveDescendantKeyManager so key
     * events will display the proper options as active on arrow key events.
     */
    /**
     * This method removes display styles on the option that made it appear
     * active. This is used by the ActiveDescendantKeyManager so key
     * events will display the proper options as active on arrow key events.
     * @return {?}
     */
    MatOption.prototype.setInactiveStyles = /**
     * This method removes display styles on the option that made it appear
     * active. This is used by the ActiveDescendantKeyManager so key
     * events will display the proper options as active on arrow key events.
     * @return {?}
     */
    function () {
        if (this._active) {
            this._active = false;
            this._changeDetectorRef.markForCheck();
        }
    };
    /** Gets the label to be used when determining whether the option should be focused. */
    /**
     * Gets the label to be used when determining whether the option should be focused.
     * @return {?}
     */
    MatOption.prototype.getLabel = /**
     * Gets the label to be used when determining whether the option should be focused.
     * @return {?}
     */
    function () {
        return this.viewValue;
    };
    /** Ensures the option is selected when activated from the keyboard. */
    /**
     * Ensures the option is selected when activated from the keyboard.
     * @param {?} event
     * @return {?}
     */
    MatOption.prototype._handleKeydown = /**
     * Ensures the option is selected when activated from the keyboard.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.keyCode === ENTER || event.keyCode === SPACE) {
            this._selectViaInteraction();
            // Prevent the page from scrolling down and form submits.
            event.preventDefault();
        }
    };
    /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     */
    /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     * @return {?}
     */
    MatOption.prototype._selectViaInteraction = /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     * @return {?}
     */
    function () {
        if (!this.disabled) {
            this._selected = this.multiple ? !this._selected : true;
            this._changeDetectorRef.markForCheck();
            this._emitSelectionChangeEvent(true);
        }
    };
    /** Returns the correct tabindex for the option depending on disabled state. */
    /**
     * Returns the correct tabindex for the option depending on disabled state.
     * @return {?}
     */
    MatOption.prototype._getTabIndex = /**
     * Returns the correct tabindex for the option depending on disabled state.
     * @return {?}
     */
    function () {
        return this.disabled ? '-1' : '0';
    };
    /** Gets the host DOM element. */
    /**
     * Gets the host DOM element.
     * @return {?}
     */
    MatOption.prototype._getHostElement = /**
     * Gets the host DOM element.
     * @return {?}
     */
    function () {
        return this._element.nativeElement;
    };
    /**
     * @return {?}
     */
    MatOption.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        // Since parent components could be using the option's label to display the selected values
        // (e.g. `mat-select`) and they don't have a way of knowing if the option's label has changed
        // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
        // relatively cheap, however we still limit them only to selected options in order to avoid
        // hitting the DOM too often.
        if (this._selected) {
            var /** @type {?} */ viewValue = this.viewValue;
            if (viewValue !== this._mostRecentViewValue) {
                this._mostRecentViewValue = viewValue;
                this._stateChanges.next();
            }
        }
    };
    /**
     * @return {?}
     */
    MatOption.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._stateChanges.complete();
    };
    /**
     * Emits the selection change event.
     * @param {?=} isUserInput
     * @return {?}
     */
    MatOption.prototype._emitSelectionChangeEvent = /**
     * Emits the selection change event.
     * @param {?=} isUserInput
     * @return {?}
     */
    function (isUserInput) {
        if (isUserInput === void 0) { isUserInput = false; }
        this.onSelectionChange.emit(new MatOptionSelectionChange(this, isUserInput));
    };
    MatOption.decorators = [
        { type: core.Component, args: [{selector: 'mat-option',
                    exportAs: 'matOption',
                    host: {
                        'role': 'option',
                        '[attr.tabindex]': '_getTabIndex()',
                        '[class.mat-selected]': 'selected',
                        '[class.mat-option-multiple]': 'multiple',
                        '[class.mat-active]': 'active',
                        '[id]': 'id',
                        '[attr.aria-selected]': 'selected.toString()',
                        '[attr.aria-disabled]': 'disabled.toString()',
                        '[class.mat-option-disabled]': 'disabled',
                        '(click)': '_selectViaInteraction()',
                        '(keydown)': '_handleKeydown($event)',
                        'class': 'mat-option',
                    },
                    styles: [".mat-option{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative;cursor:pointer;outline:0;display:flex;flex-direction:row;max-width:100%;box-sizing:border-box;align-items:center;-webkit-tap-highlight-color:transparent}.mat-option[disabled]{cursor:default}[dir=rtl] .mat-option{text-align:right}.mat-option .mat-icon{margin-right:16px;vertical-align:middle}.mat-option .mat-icon svg{vertical-align:top}[dir=rtl] .mat-option .mat-icon{margin-left:16px;margin-right:0}.mat-option[aria-disabled=true]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:32px}[dir=rtl] .mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:16px;padding-right:32px}@media screen and (-ms-high-contrast:active){.mat-option{margin:0 1px}.mat-option.mat-active{border:solid 1px currentColor;margin:0}}.mat-option-text{display:inline-block;flex-grow:1;overflow:hidden;text-overflow:ellipsis}.mat-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}@media screen and (-ms-high-contrast:active){.mat-option-ripple{opacity:.5}}.mat-option-pseudo-checkbox{margin-right:8px}[dir=rtl] .mat-option-pseudo-checkbox{margin-left:8px;margin-right:0}"],
                    template: "<mat-pseudo-checkbox *ngIf=\"multiple\" class=\"mat-option-pseudo-checkbox\" [state]=\"selected ? 'checked' : ''\" [disabled]=\"disabled\"></mat-pseudo-checkbox><span class=\"mat-option-text\"><ng-content></ng-content></span><div class=\"mat-option-ripple\" mat-ripple [matRippleTrigger]=\"_getHostElement()\" [matRippleDisabled]=\"disabled || disableRipple\"></div>",
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                },] },
    ];
    /** @nocollapse */
    MatOption.ctorParameters = function () { return [
        { type: core.ElementRef, },
        { type: core.ChangeDetectorRef, },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_OPTION_PARENT_COMPONENT,] },] },
        { type: MatOptgroup, decorators: [{ type: core.Optional },] },
    ]; };
    MatOption.propDecorators = {
        "value": [{ type: core.Input },],
        "id": [{ type: core.Input },],
        "disabled": [{ type: core.Input },],
        "onSelectionChange": [{ type: core.Output },],
    };
    return MatOption;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * InjectionToken that can be used to specify the global label options.
 */
var /** @type {?} */ MAT_LABEL_GLOBAL_OPTIONS = new core.InjectionToken('mat-label-global-options');

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Menu content that will be rendered lazily once the menu is opened.
 */
var MatMenuContent = /** @class */ (function () {
    function MatMenuContent(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document) {
        this._template = _template;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._appRef = _appRef;
        this._injector = _injector;
        this._viewContainerRef = _viewContainerRef;
        this._document = _document;
        /**
         * Emits when the menu content has been attached.
         */
        this._attached = new Subject();
    }
    /**
     * Attaches the content with a particular context.
     * @docs-private
     */
    /**
     * Attaches the content with a particular context.
     * \@docs-private
     * @param {?=} context
     * @return {?}
     */
    MatMenuContent.prototype.attach = /**
     * Attaches the content with a particular context.
     * \@docs-private
     * @param {?=} context
     * @return {?}
     */
    function (context) {
        if (context === void 0) { context = {}; }
        if (!this._portal) {
            this._portal = new TemplatePortal(this._template, this._viewContainerRef);
        }
        this.detach();
        if (!this._outlet) {
            this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);
        }
        var /** @type {?} */ element = this._template.elementRef.nativeElement; /** @type {?} */
        ((
        // Because we support opening the same menu from different triggers (which in turn have their
        // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we
        // risk it staying attached to a pane that's no longer in the DOM.
        element.parentNode)).insertBefore(this._outlet.outletElement, element);
        this._portal.attach(this._outlet, context);
        this._attached.next();
    };
    /**
     * Detaches the content.
     * @docs-private
     */
    /**
     * Detaches the content.
     * \@docs-private
     * @return {?}
     */
    MatMenuContent.prototype.detach = /**
     * Detaches the content.
     * \@docs-private
     * @return {?}
     */
    function () {
        if (this._portal.isAttached) {
            this._portal.detach();
        }
    };
    /**
     * @return {?}
     */
    MatMenuContent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._outlet) {
            this._outlet.dispose();
        }
    };
    MatMenuContent.decorators = [
        { type: core.Directive, args: [{
                    selector: 'ng-template[matMenuContent]'
                },] },
    ];
    /** @nocollapse */
    MatMenuContent.ctorParameters = function () { return [
        { type: core.TemplateRef, },
        { type: core.ComponentFactoryResolver, },
        { type: core.ApplicationRef, },
        { type: core.Injector, },
        { type: core.ViewContainerRef, },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
    ]; };
    return MatMenuContent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Animations used by the mat-menu component.
 * Animation duration and timing values are based on:
 * https://material.io/guidelines/components/menus.html#menus-usage
 */
var /** @type {?} */ matMenuAnimations = {
    /**
       * This animation controls the menu panel's entry and exit from the page.
       *
       * When the menu panel is added to the DOM, it scales in and fades in its border.
       *
       * When the menu panel is removed from the DOM, it simply fades out after a brief
       * delay to display the ripple.
       */
    transformMenu: animations$1.trigger('transformMenu', [
        animations$1.state('void', animations$1.style({
            opacity: 0,
            // This starts off from 0.01, instead of 0, because there's an issue in the Angular animations
            // as of 4.2, which causes the animation to be skipped if it starts from 0.
            transform: 'scale(0.01, 0.01)'
        })),
        animations$1.transition('void => enter', animations$1.sequence([
            animations$1.query('.mat-menu-content', animations$1.style({ opacity: 0 })),
            animations$1.animate('100ms linear', animations$1.style({ opacity: 1, transform: 'scale(1, 0.5)' })),
            animations$1.group([
                animations$1.query('.mat-menu-content', animations$1.animate('400ms cubic-bezier(0.55, 0, 0.55, 0.2)', animations$1.style({ opacity: 1 }))),
                animations$1.animate('300ms cubic-bezier(0.25, 0.8, 0.25, 1)', animations$1.style({ transform: 'scale(1, 1)' })),
            ])
        ])),
        animations$1.transition('* => void', animations$1.animate('150ms 50ms linear', animations$1.style({ opacity: 0 })))
    ]),
    /**
       * This animation fades in the background color and content of the menu panel
       * after its containing element is scaled in.
       */
    fadeInItems: animations$1.trigger('fadeInItems', [
        // TODO(crisbeto): this is inside the `transformMenu`
        // now. Remove next time we do breaking changes.
        animations$1.state('showing', animations$1.style({ opacity: 1 })),
        animations$1.transition('void => *', [
            animations$1.style({ opacity: 0 }),
            animations$1.animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')
        ])
    ])
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance
 * \@docs-private
 * @return {?}
 */
function throwMatMenuMissingError() {
    throw Error("matMenuTriggerFor: must pass in an mat-menu instance.\n\n    Example:\n      <mat-menu #menu=\"matMenu\"></mat-menu>\n      <button [matMenuTriggerFor]=\"menu\"></button>");
}
/**
 * Throws an exception for the case when menu's x-position value isn't valid.
 * In other words, it doesn't match 'before' or 'after'.
 * \@docs-private
 * @return {?}
 */
function throwMatMenuInvalidPositionX() {
    throw Error("xPosition value must be either 'before' or after'.\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>");
}
/**
 * Throws an exception for the case when menu's y-position value isn't valid.
 * In other words, it doesn't match 'above' or 'below'.
 * \@docs-private
 * @return {?}
 */
function throwMatMenuInvalidPositionY() {
    throw Error("yPosition value must be either 'above' or below'.\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>");
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Injection token used to provide the parent menu to menu-specific components.
 * \@docs-private
 */
var /** @type {?} */ MAT_MENU_PANEL = new core.InjectionToken('MAT_MENU_PANEL');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@docs-private
 */
var  /**
 * \@docs-private
 */
MatMenuItemBase = /** @class */ (function () {
    function MatMenuItemBase() {
    }
    return MatMenuItemBase;
}());
var /** @type {?} */ _MatMenuItemMixinBase = mixinDisableRipple(mixinDisabled(MatMenuItemBase));
/**
 * This directive is intended to be used inside an mat-menu tag.
 * It exists mostly to set the role attribute.
 */
var MatMenuItem = /** @class */ (function (_super) {
    __extends(MatMenuItem, _super);
    function MatMenuItem(_elementRef, document, _focusMonitor, _parentMenu) {
        var _this = 
        // @breaking-change 7.0.0 make `_focusMonitor` and `document` required params.
        _super.call(this) || this;
        _this._elementRef = _elementRef;
        _this._focusMonitor = _focusMonitor;
        _this._parentMenu = _parentMenu;
        /**
         * Stream that emits when the menu item is hovered.
         */
        _this._hovered = new Subject();
        /**
         * Whether the menu item is highlighted.
         */
        _this._highlighted = false;
        /**
         * Whether the menu item acts as a trigger for a sub-menu.
         */
        _this._triggersSubmenu = false;
        if (_focusMonitor) {
            // Start monitoring the element so it gets the appropriate focused classes. We want
            // to show the focus style for menu items only when the focus was not caused by a
            // mouse or touch interaction.
            _focusMonitor.monitor(_this._getHostElement(), false);
        }
        if (_parentMenu && _parentMenu.addItem) {
            _parentMenu.addItem(_this);
        }
        _this._document = document;
        return _this;
    }
    /** Focuses the menu item. */
    /**
     * Focuses the menu item.
     * @param {?=} origin
     * @return {?}
     */
    MatMenuItem.prototype.focus = /**
     * Focuses the menu item.
     * @param {?=} origin
     * @return {?}
     */
    function (origin) {
        if (origin === void 0) { origin = 'program'; }
        if (this._focusMonitor) {
            this._focusMonitor.focusVia(this._getHostElement(), origin);
        }
        else {
            this._getHostElement().focus();
        }
    };
    /**
     * @return {?}
     */
    MatMenuItem.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._focusMonitor) {
            this._focusMonitor.stopMonitoring(this._getHostElement());
        }
        if (this._parentMenu && this._parentMenu.removeItem) {
            this._parentMenu.removeItem(this);
        }
        this._hovered.complete();
    };
    /** Used to set the `tabindex`. */
    /**
     * Used to set the `tabindex`.
     * @return {?}
     */
    MatMenuItem.prototype._getTabIndex = /**
     * Used to set the `tabindex`.
     * @return {?}
     */
    function () {
        return this.disabled ? '-1' : '0';
    };
    /** Returns the host DOM element. */
    /**
     * Returns the host DOM element.
     * @return {?}
     */
    MatMenuItem.prototype._getHostElement = /**
     * Returns the host DOM element.
     * @return {?}
     */
    function () {
        return this._elementRef.nativeElement;
    };
    /** Prevents the default element actions if it is disabled. */
    /**
     * Prevents the default element actions if it is disabled.
     * @param {?} event
     * @return {?}
     */
    MatMenuItem.prototype._checkDisabled = /**
     * Prevents the default element actions if it is disabled.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.disabled) {
            event.preventDefault();
            event.stopPropagation();
        }
    };
    /** Emits to the hover stream. */
    /**
     * Emits to the hover stream.
     * @return {?}
     */
    MatMenuItem.prototype._handleMouseEnter = /**
     * Emits to the hover stream.
     * @return {?}
     */
    function () {
        this._hovered.next(this);
    };
    /** Gets the label to be used when determining whether the option should be focused. */
    /**
     * Gets the label to be used when determining whether the option should be focused.
     * @return {?}
     */
    MatMenuItem.prototype.getLabel = /**
     * Gets the label to be used when determining whether the option should be focused.
     * @return {?}
     */
    function () {
        var /** @type {?} */ element = this._elementRef.nativeElement;
        var /** @type {?} */ textNodeType = this._document ? this._document.TEXT_NODE : 3;
        var /** @type {?} */ output = '';
        if (element.childNodes) {
            var /** @type {?} */ length_1 = element.childNodes.length;
            // Go through all the top-level text nodes and extract their text.
            // We skip anything that's not a text node to prevent the text from
            // being thrown off by something like an icon.
            for (var /** @type {?} */ i = 0; i < length_1; i++) {
                if (element.childNodes[i].nodeType === textNodeType) {
                    output += element.childNodes[i].textContent;
                }
            }
        }
        return output.trim();
    };
    MatMenuItem.decorators = [
        { type: core.Component, args: [{selector: '[mat-menu-item]',
                    exportAs: 'matMenuItem',
                    inputs: ['disabled', 'disableRipple'],
                    host: {
                        'role': 'menuitem',
                        'class': 'mat-menu-item',
                        '[class.mat-menu-item-highlighted]': '_highlighted',
                        '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',
                        '[attr.tabindex]': '_getTabIndex()',
                        '[attr.aria-disabled]': 'disabled.toString()',
                        '[attr.disabled]': 'disabled || null',
                        '(click)': '_checkDisabled($event)',
                        '(mouseenter)': '_handleMouseEnter()',
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    encapsulation: core.ViewEncapsulation.None,
                    template: "<ng-content></ng-content><div class=\"mat-menu-ripple\" matRipple [matRippleDisabled]=\"disableRipple || disabled\" [matRippleTrigger]=\"_getHostElement()\"></div>",
                },] },
    ];
    /** @nocollapse */
    MatMenuItem.ctorParameters = function () { return [
        { type: core.ElementRef, },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
        { type: FocusMonitor, },
        { type: undefined, decorators: [{ type: core.Inject, args: [MAT_MENU_PANEL,] }, { type: core.Optional },] },
    ]; };
    return MatMenuItem;
}(_MatMenuItemMixinBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Injection token to be used to override the default options for `mat-menu`.
 */
var /** @type {?} */ MAT_MENU_DEFAULT_OPTIONS = new core.InjectionToken('mat-menu-default-options', {
    providedIn: 'root',
    factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY
});
/**
 * \@docs-private
 * @return {?}
 */
function MAT_MENU_DEFAULT_OPTIONS_FACTORY() {
    return {
        overlapTrigger: true,
        xPosition: 'after',
        yPosition: 'below',
        backdropClass: 'cdk-overlay-transparent-backdrop',
    };
}
/**
 * Start elevation for the menu panel.
 * \@docs-private
 */
var /** @type {?} */ MAT_MENU_BASE_ELEVATION = 2;
var MatMenu = /** @class */ (function () {
    function MatMenu(_elementRef, _ngZone, _defaultOptions) {
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this._defaultOptions = _defaultOptions;
        this._xPosition = this._defaultOptions.xPosition;
        this._yPosition = this._defaultOptions.yPosition;
        /**
         * Menu items inside the current menu.
         */
        this._items = [];
        /**
         * Emits whenever the amount of menu items changes.
         */
        this._itemChanges = new Subject();
        /**
         * Subscription to tab events on the menu panel
         */
        this._tabSubscription = Subscription.EMPTY;
        /**
         * Config object to be passed into the menu's ngClass
         */
        this._classList = {};
        /**
         * Current state of the panel animation.
         */
        this._panelAnimationState = 'void';
        /**
         * Emits whenever an animation on the menu completes.
         */
        this._animationDone = new Subject();
        /**
         * Class to be added to the backdrop element.
         */
        this.backdropClass = this._defaultOptions.backdropClass;
        this._overlapTrigger = this._defaultOptions.overlapTrigger;
        this._hasBackdrop = this._defaultOptions.hasBackdrop;
        /**
         * Event emitted when the menu is closed.
         */
        this.closed = new core.EventEmitter();
        /**
         * Event emitted when the menu is closed.
         * @deprecated Switch to `closed` instead
         * \@breaking-change 7.0.0
         */
        this.close = this.closed;
    }
    Object.defineProperty(MatMenu.prototype, "xPosition", {
        get: /**
         * Position of the menu in the X axis.
         * @return {?}
         */
        function () { return this._xPosition; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== 'before' && value !== 'after') {
                throwMatMenuInvalidPositionX();
            }
            this._xPosition = value;
            this.setPositionClasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatMenu.prototype, "yPosition", {
        get: /**
         * Position of the menu in the Y axis.
         * @return {?}
         */
        function () { return this._yPosition; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== 'above' && value !== 'below') {
                throwMatMenuInvalidPositionY();
            }
            this._yPosition = value;
            this.setPositionClasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatMenu.prototype, "overlapTrigger", {
        get: /**
         * Whether the menu should overlap its trigger.
         * @return {?}
         */
        function () { return this._overlapTrigger; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._overlapTrigger = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatMenu.prototype, "hasBackdrop", {
        get: /**
         * Whether the menu has a backdrop.
         * @return {?}
         */
        function () { return this._hasBackdrop; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._hasBackdrop = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatMenu.prototype, "panelClass", {
        set: /**
         * This method takes classes set on the host mat-menu element and applies them on the
         * menu template that displays in the overlay container.  Otherwise, it's difficult
         * to style the containing menu from outside the component.
         * @param {?} classes list of class names
         * @return {?}
         */
        function (classes) {
            if (classes && classes.length) {
                this._classList = classes.split(' ').reduce(function (obj, className) {
                    obj[className] = true;
                    return obj;
                }, {});
                this._elementRef.nativeElement.className = '';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatMenu.prototype, "classList", {
        get: /**
         * This method takes classes set on the host mat-menu element and applies them on the
         * menu template that displays in the overlay container.  Otherwise, it's difficult
         * to style the containing menu from outside the component.
         * @deprecated Use `panelClass` instead.
         * \@breaking-change 7.0.0
         * @return {?}
         */
        function () { return this.panelClass; },
        set: /**
         * @param {?} classes
         * @return {?}
         */
        function (classes) { this.panelClass = classes; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MatMenu.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.setPositionClasses();
    };
    /**
     * @return {?}
     */
    MatMenu.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._keyManager = new FocusKeyManager(this._items).withWrap().withTypeAhead();
        this._tabSubscription = this._keyManager.tabOut.subscribe(function () { return _this.closed.emit('tab'); });
    };
    /**
     * @return {?}
     */
    MatMenu.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._tabSubscription.unsubscribe();
        this.closed.complete();
    };
    /** Stream that emits whenever the hovered menu item changes. */
    /**
     * Stream that emits whenever the hovered menu item changes.
     * @return {?}
     */
    MatMenu.prototype._hovered = /**
     * Stream that emits whenever the hovered menu item changes.
     * @return {?}
     */
    function () {
        return this._itemChanges.pipe(startWith(this._items), switchMap(function (items) { return merge.apply(void 0, items.map(function (item) { return item._hovered; })); }));
    };
    /** Handle a keyboard event from the menu, delegating to the appropriate action. */
    /**
     * Handle a keyboard event from the menu, delegating to the appropriate action.
     * @param {?} event
     * @return {?}
     */
    MatMenu.prototype._handleKeydown = /**
     * Handle a keyboard event from the menu, delegating to the appropriate action.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ keyCode = event.keyCode;
        switch (keyCode) {
            case ESCAPE:
                this.closed.emit('keydown');
                event.stopPropagation();
                break;
            case LEFT_ARROW:
                if (this.parentMenu && this.direction === 'ltr') {
                    this.closed.emit('keydown');
                }
                break;
            case RIGHT_ARROW:
                if (this.parentMenu && this.direction === 'rtl') {
                    this.closed.emit('keydown');
                }
                break;
            default:
                if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {
                    this._keyManager.setFocusOrigin('keyboard');
                }
                this._keyManager.onKeydown(event);
        }
    };
    /**
     * Focus the first item in the menu.
     * @param origin Action from which the focus originated. Used to set the correct styling.
     */
    /**
     * Focus the first item in the menu.
     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.
     * @return {?}
     */
    MatMenu.prototype.focusFirstItem = /**
     * Focus the first item in the menu.
     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.
     * @return {?}
     */
    function (origin) {
        var _this = this;
        if (origin === void 0) { origin = 'program'; }
        // When the content is rendered lazily, it takes a bit before the items are inside the DOM.
        if (this.lazyContent) {
            this._ngZone.onStable.asObservable()
                .pipe(take(1))
                .subscribe(function () { return _this._keyManager.setFocusOrigin(origin).setFirstItemActive(); });
        }
        else {
            this._keyManager.setFocusOrigin(origin).setFirstItemActive();
        }
    };
    /**
     * Resets the active item in the menu. This is used when the menu is opened, allowing
     * the user to start from the first option when pressing the down arrow.
     */
    /**
     * Resets the active item in the menu. This is used when the menu is opened, allowing
     * the user to start from the first option when pressing the down arrow.
     * @return {?}
     */
    MatMenu.prototype.resetActiveItem = /**
     * Resets the active item in the menu. This is used when the menu is opened, allowing
     * the user to start from the first option when pressing the down arrow.
     * @return {?}
     */
    function () {
        this._keyManager.setActiveItem(-1);
    };
    /**
     * Sets the menu panel elevation.
     * @param depth Number of parent menus that come before the menu.
     */
    /**
     * Sets the menu panel elevation.
     * @param {?} depth Number of parent menus that come before the menu.
     * @return {?}
     */
    MatMenu.prototype.setElevation = /**
     * Sets the menu panel elevation.
     * @param {?} depth Number of parent menus that come before the menu.
     * @return {?}
     */
    function (depth) {
        // The elevation starts at the base and increases by one for each level.
        var /** @type {?} */ newElevation = "mat-elevation-z" + (MAT_MENU_BASE_ELEVATION + depth);
        var /** @type {?} */ customElevation = Object.keys(this._classList).find(function (c) { return c.startsWith('mat-elevation-z'); });
        if (!customElevation || customElevation === this._previousElevation) {
            if (this._previousElevation) {
                this._classList[this._previousElevation] = false;
            }
            this._classList[newElevation] = true;
            this._previousElevation = newElevation;
        }
    };
    /**
     * Registers a menu item with the menu.
     * @docs-private
     */
    /**
     * Registers a menu item with the menu.
     * \@docs-private
     * @param {?} item
     * @return {?}
     */
    MatMenu.prototype.addItem = /**
     * Registers a menu item with the menu.
     * \@docs-private
     * @param {?} item
     * @return {?}
     */
    function (item) {
        // We register the items through this method, rather than picking them up through
        // `ContentChildren`, because we need the items to be picked up by their closest
        // `mat-menu` ancestor. If we used `@ContentChildren(MatMenuItem, {descendants: true})`,
        // all descendant items will bleed into the top-level menu in the case where the consumer
        // has `mat-menu` instances nested inside each other.
        if (this._items.indexOf(item) === -1) {
            this._items.push(item);
            this._itemChanges.next(this._items);
        }
    };
    /**
     * Removes an item from the menu.
     * @docs-private
     */
    /**
     * Removes an item from the menu.
     * \@docs-private
     * @param {?} item
     * @return {?}
     */
    MatMenu.prototype.removeItem = /**
     * Removes an item from the menu.
     * \@docs-private
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ index = this._items.indexOf(item);
        if (this._items.indexOf(item) > -1) {
            this._items.splice(index, 1);
            this._itemChanges.next(this._items);
        }
    };
    /**
     * Adds classes to the menu panel based on its position. Can be used by
     * consumers to add specific styling based on the position.
     * @param posX Position of the menu along the x axis.
     * @param posY Position of the menu along the y axis.
     * @docs-private
     */
    /**
     * Adds classes to the menu panel based on its position. Can be used by
     * consumers to add specific styling based on the position.
     * \@docs-private
     * @param {?=} posX Position of the menu along the x axis.
     * @param {?=} posY Position of the menu along the y axis.
     * @return {?}
     */
    MatMenu.prototype.setPositionClasses = /**
     * Adds classes to the menu panel based on its position. Can be used by
     * consumers to add specific styling based on the position.
     * \@docs-private
     * @param {?=} posX Position of the menu along the x axis.
     * @param {?=} posY Position of the menu along the y axis.
     * @return {?}
     */
    function (posX, posY) {
        if (posX === void 0) { posX = this.xPosition; }
        if (posY === void 0) { posY = this.yPosition; }
        var /** @type {?} */ classes = this._classList;
        classes['mat-menu-before'] = posX === 'before';
        classes['mat-menu-after'] = posX === 'after';
        classes['mat-menu-above'] = posY === 'above';
        classes['mat-menu-below'] = posY === 'below';
    };
    /** Starts the enter animation. */
    /**
     * Starts the enter animation.
     * @return {?}
     */
    MatMenu.prototype._startAnimation = /**
     * Starts the enter animation.
     * @return {?}
     */
    function () {
        // @breaking-change 7.0.0 Combine with _resetAnimation.
        this._panelAnimationState = 'enter';
    };
    /** Resets the panel animation to its initial state. */
    /**
     * Resets the panel animation to its initial state.
     * @return {?}
     */
    MatMenu.prototype._resetAnimation = /**
     * Resets the panel animation to its initial state.
     * @return {?}
     */
    function () {
        // @breaking-change 7.0.0 Combine with _startAnimation.
        this._panelAnimationState = 'void';
    };
    /** Callback that is invoked when the panel animation completes. */
    /**
     * Callback that is invoked when the panel animation completes.
     * @param {?} event
     * @return {?}
     */
    MatMenu.prototype._onAnimationDone = /**
     * Callback that is invoked when the panel animation completes.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._animationDone.next(event);
        this._isAnimating = false;
        // Scroll the content element to the top once the animation is done. This is necessary, because
        // we move focus to the first item while it's still being animated, which can throw the browser
        // off when it determines the scroll position. Alternatively we can move focus when the
        // animation is done, however moving focus asynchronously will interrupt screen readers
        // which are in the process of reading out the menu already. We take the `element` from
        // the `event` since we can't use a `ViewChild` to access the pane.
        if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {
            event.element.scrollTop = 0;
        }
    };
    MatMenu.decorators = [
        { type: core.Component, args: [{selector: 'mat-menu',
                    template: "<ng-template><div class=\"mat-menu-panel\" [ngClass]=\"_classList\" (keydown)=\"_handleKeydown($event)\" (click)=\"closed.emit('click')\" [@transformMenu]=\"_panelAnimationState\" (@transformMenu.start)=\"_isAnimating = true\" (@transformMenu.done)=\"_onAnimationDone($event)\" tabindex=\"-1\" role=\"menu\"><div class=\"mat-menu-content\"><ng-content></ng-content></div></div></ng-template>",
                    styles: [".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:2px;outline:0}.mat-menu-panel:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}@media screen and (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}.mat-menu-panel.ng-animating .mat-menu-item-submenu-trigger{pointer-events:none}button.mat-menu-item{width:100%}.mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}"],
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    encapsulation: core.ViewEncapsulation.None,
                    exportAs: 'matMenu',
                    animations: [
                        matMenuAnimations.transformMenu,
                        matMenuAnimations.fadeInItems
                    ],
                    providers: [
                        { provide: MAT_MENU_PANEL, useExisting: MatMenu }
                    ]
                },] },
    ];
    /** @nocollapse */
    MatMenu.ctorParameters = function () { return [
        { type: core.ElementRef, },
        { type: core.NgZone, },
        { type: undefined, decorators: [{ type: core.Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] },] },
    ]; };
    MatMenu.propDecorators = {
        "backdropClass": [{ type: core.Input },],
        "xPosition": [{ type: core.Input },],
        "yPosition": [{ type: core.Input },],
        "templateRef": [{ type: core.ViewChild, args: [core.TemplateRef,] },],
        "items": [{ type: core.ContentChildren, args: [MatMenuItem,] },],
        "lazyContent": [{ type: core.ContentChild, args: [MatMenuContent,] },],
        "overlapTrigger": [{ type: core.Input },],
        "hasBackdrop": [{ type: core.Input },],
        "panelClass": [{ type: core.Input, args: ['class',] },],
        "classList": [{ type: core.Input },],
        "closed": [{ type: core.Output },],
        "close": [{ type: core.Output },],
    };
    return MatMenu;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Injection token that determines the scroll handling while the menu is open.
 */
var /** @type {?} */ MAT_MENU_SCROLL_STRATEGY = new core.InjectionToken('mat-menu-scroll-strategy');
/**
 * Default top padding of the menu panel.
 */
var /** @type {?} */ MENU_PANEL_TOP_PADDING = 8;
/**
 * This directive is intended to be used in conjunction with an mat-menu tag.  It is
 * responsible for toggling the display of the provided menu instance.
 */
var MatMenuTrigger = /** @class */ (function () {
    function MatMenuTrigger(_overlay, _element, _viewContainerRef, _scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {
        this._overlay = _overlay;
        this._element = _element;
        this._viewContainerRef = _viewContainerRef;
        this._scrollStrategy = _scrollStrategy;
        this._parentMenu = _parentMenu;
        this._menuItemInstance = _menuItemInstance;
        this._dir = _dir;
        this._focusMonitor = _focusMonitor;
        this._overlayRef = null;
        this._menuOpen = false;
        this._closeSubscription = Subscription.EMPTY;
        this._hoverSubscription = Subscription.EMPTY;
        this._openedByMouse = false;
        /**
         * Event emitted when the associated menu is opened.
         */
        this.menuOpened = new core.EventEmitter();
        /**
         * Event emitted when the associated menu is opened.
         * @deprecated Switch to `menuOpened` instead
         * \@breaking-change 7.0.0
         */
        this.onMenuOpen = this.menuOpened;
        /**
         * Event emitted when the associated menu is closed.
         */
        this.menuClosed = new core.EventEmitter();
        /**
         * Event emitted when the associated menu is closed.
         * @deprecated Switch to `menuClosed` instead
         * \@breaking-change 7.0.0
         */
        this.onMenuClose = this.menuClosed;
        if (_menuItemInstance) {
            _menuItemInstance._triggersSubmenu = this.triggersSubmenu();
        }
    }
    Object.defineProperty(MatMenuTrigger.prototype, "_deprecatedMatMenuTriggerFor", {
        get: /**
         * @deprecated
         * \@breaking-change 7.0.0
         * @return {?}
         */
        function () {
            return this.menu;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this.menu = v;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MatMenuTrigger.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._checkMenu();
        this.menu.close.subscribe(function (reason) {
            _this._destroyMenu();
            // If a click closed the menu, we should close the entire chain of nested menus.
            if ((reason === 'click' || reason === 'tab') && _this._parentMenu) {
                _this._parentMenu.closed.emit(reason);
            }
        });
        this._handleHover();
    };
    /**
     * @return {?}
     */
    MatMenuTrigger.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
        this._cleanUpSubscriptions();
    };
    Object.defineProperty(MatMenuTrigger.prototype, "menuOpen", {
        /** Whether the menu is open. */
        get: /**
         * Whether the menu is open.
         * @return {?}
         */
        function () {
            return this._menuOpen;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatMenuTrigger.prototype, "dir", {
        /** The text direction of the containing app. */
        get: /**
         * The text direction of the containing app.
         * @return {?}
         */
        function () {
            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    /** Whether the menu triggers a sub-menu or a top-level one. */
    /**
     * Whether the menu triggers a sub-menu or a top-level one.
     * @return {?}
     */
    MatMenuTrigger.prototype.triggersSubmenu = /**
     * Whether the menu triggers a sub-menu or a top-level one.
     * @return {?}
     */
    function () {
        return !!(this._menuItemInstance && this._parentMenu);
    };
    /** Toggles the menu between the open and closed states. */
    /**
     * Toggles the menu between the open and closed states.
     * @return {?}
     */
    MatMenuTrigger.prototype.toggleMenu = /**
     * Toggles the menu between the open and closed states.
     * @return {?}
     */
    function () {
        return this._menuOpen ? this.closeMenu() : this.openMenu();
    };
    /** Opens the menu. */
    /**
     * Opens the menu.
     * @return {?}
     */
    MatMenuTrigger.prototype.openMenu = /**
     * Opens the menu.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._menuOpen) {
            return;
        }
        this._checkMenu();
        var /** @type {?} */ overlayRef = this._createOverlay();
        this._setPosition(/** @type {?} */ (overlayRef.getConfig().positionStrategy));
        overlayRef.attach(this._portal);
        if (this.menu.lazyContent) {
            this.menu.lazyContent.attach(this.menuData);
        }
        this._closeSubscription = this._menuClosingActions().subscribe(function () { return _this.closeMenu(); });
        this._initMenu();
        if (this.menu instanceof MatMenu) {
            this.menu._startAnimation();
        }
    };
    /** Closes the menu. */
    /**
     * Closes the menu.
     * @return {?}
     */
    MatMenuTrigger.prototype.closeMenu = /**
     * Closes the menu.
     * @return {?}
     */
    function () {
        this.menu.close.emit();
    };
    /**
     * Focuses the menu trigger.
     * @param origin Source of the menu trigger's focus.
     */
    /**
     * Focuses the menu trigger.
     * @param {?=} origin Source of the menu trigger's focus.
     * @return {?}
     */
    MatMenuTrigger.prototype.focus = /**
     * Focuses the menu trigger.
     * @param {?=} origin Source of the menu trigger's focus.
     * @return {?}
     */
    function (origin) {
        if (origin === void 0) { origin = 'program'; }
        if (this._focusMonitor) {
            this._focusMonitor.focusVia(this._element.nativeElement, origin);
        }
        else {
            this._element.nativeElement.focus();
        }
    };
    /**
     * Closes the menu and does the necessary cleanup.
     * @return {?}
     */
    MatMenuTrigger.prototype._destroyMenu = /**
     * Closes the menu and does the necessary cleanup.
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._overlayRef || !this.menuOpen) {
            return;
        }
        var /** @type {?} */ menu = this.menu;
        this._closeSubscription.unsubscribe();
        this._overlayRef.detach();
        if (menu instanceof MatMenu) {
            menu._resetAnimation();
            if (menu.lazyContent) {
                // Wait for the exit animation to finish before detaching the content.
                menu._animationDone
                    .pipe(filter(function (event) { return event.toState === 'void'; }), take(1), 
                // Interrupt if the content got re-attached.
                takeUntil(menu.lazyContent._attached))
                    .subscribe(function () { return ((menu.lazyContent)).detach(); }, undefined, function () {
                    // No matter whether the content got re-attached, reset the menu.
                    // No matter whether the content got re-attached, reset the menu.
                    _this._resetMenu();
                });
            }
            else {
                this._resetMenu();
            }
        }
        else {
            this._resetMenu();
            if (menu.lazyContent) {
                menu.lazyContent.detach();
            }
        }
    };
    /**
     * This method sets the menu state to open and focuses the first item if
     * the menu was opened via the keyboard.
     * @return {?}
     */
    MatMenuTrigger.prototype._initMenu = /**
     * This method sets the menu state to open and focuses the first item if
     * the menu was opened via the keyboard.
     * @return {?}
     */
    function () {
        this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;
        this.menu.direction = this.dir;
        this._setMenuElevation();
        this._setIsMenuOpen(true);
        this.menu.focusFirstItem(this._openedByMouse ? 'mouse' : 'program');
    };
    /**
     * Updates the menu elevation based on the amount of parent menus that it has.
     * @return {?}
     */
    MatMenuTrigger.prototype._setMenuElevation = /**
     * Updates the menu elevation based on the amount of parent menus that it has.
     * @return {?}
     */
    function () {
        if (this.menu.setElevation) {
            var /** @type {?} */ depth = 0;
            var /** @type {?} */ parentMenu = this.menu.parentMenu;
            while (parentMenu) {
                depth++;
                parentMenu = parentMenu.parentMenu;
            }
            this.menu.setElevation(depth);
        }
    };
    /**
     * This method resets the menu when it's closed, most importantly restoring
     * focus to the menu trigger if the menu was opened via the keyboard.
     * @return {?}
     */
    MatMenuTrigger.prototype._resetMenu = /**
     * This method resets the menu when it's closed, most importantly restoring
     * focus to the menu trigger if the menu was opened via the keyboard.
     * @return {?}
     */
    function () {
        this._setIsMenuOpen(false);
        // We should reset focus if the user is navigating using a keyboard or
        // if we have a top-level trigger which might cause focus to be lost
        // when clicking on the backdrop.
        if (!this._openedByMouse) {
            // Note that the focus style will show up both for `program` and
            // `keyboard` so we don't have to specify which one it is.
            this.focus();
        }
        else if (!this.triggersSubmenu()) {
            this.focus('mouse');
        }
        this._openedByMouse = false;
    };
    /**
     * @param {?} isOpen
     * @return {?}
     */
    MatMenuTrigger.prototype._setIsMenuOpen = /**
     * @param {?} isOpen
     * @return {?}
     */
    function (isOpen) {
        this._menuOpen = isOpen;
        this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();
        if (this.triggersSubmenu()) {
            this._menuItemInstance._highlighted = isOpen;
        }
    };
    /**
     * This method checks that a valid instance of MatMenu has been passed into
     * matMenuTriggerFor. If not, an exception is thrown.
     * @return {?}
     */
    MatMenuTrigger.prototype._checkMenu = /**
     * This method checks that a valid instance of MatMenu has been passed into
     * matMenuTriggerFor. If not, an exception is thrown.
     * @return {?}
     */
    function () {
        if (!this.menu) {
            throwMatMenuMissingError();
        }
    };
    /**
     * This method creates the overlay from the provided menu's template and saves its
     * OverlayRef so that it can be attached to the DOM when openMenu is called.
     * @return {?}
     */
    MatMenuTrigger.prototype._createOverlay = /**
     * This method creates the overlay from the provided menu's template and saves its
     * OverlayRef so that it can be attached to the DOM when openMenu is called.
     * @return {?}
     */
    function () {
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);
            var /** @type {?} */ config$$1 = this._getOverlayConfig();
            this._subscribeToPositions(/** @type {?} */ (config$$1.positionStrategy));
            this._overlayRef = this._overlay.create(config$$1);
        }
        return this._overlayRef;
    };
    /**
     * This method builds the configuration object needed to create the overlay, the OverlayState.
     * @return {?} OverlayConfig
     */
    MatMenuTrigger.prototype._getOverlayConfig = /**
     * This method builds the configuration object needed to create the overlay, the OverlayState.
     * @return {?} OverlayConfig
     */
    function () {
        return new OverlayConfig({
            positionStrategy: this._overlay.position()
                .flexibleConnectedTo(this._element)
                .withTransformOriginOn('.mat-menu-panel'),
            hasBackdrop: this.menu.hasBackdrop == null ? !this.triggersSubmenu() : this.menu.hasBackdrop,
            backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._scrollStrategy(),
            direction: this._dir
        });
    };
    /**
     * Listens to changes in the position of the overlay and sets the correct classes
     * on the menu based on the new position. This ensures the animation origin is always
     * correct, even if a fallback position is used for the overlay.
     * @param {?} position
     * @return {?}
     */
    MatMenuTrigger.prototype._subscribeToPositions = /**
     * Listens to changes in the position of the overlay and sets the correct classes
     * on the menu based on the new position. This ensures the animation origin is always
     * correct, even if a fallback position is used for the overlay.
     * @param {?} position
     * @return {?}
     */
    function (position) {
        var _this = this;
        if (this.menu.setPositionClasses) {
            position.positionChanges.subscribe(function (change) {
                var /** @type {?} */ posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';
                var /** @type {?} */ posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above'; /** @type {?} */
                ((_this.menu.setPositionClasses))(posX, posY);
            });
        }
    };
    /**
     * Sets the appropriate positions on a position strategy
     * so the overlay connects with the trigger correctly.
     * @param {?} positionStrategy Strategy whose position to update.
     * @return {?}
     */
    MatMenuTrigger.prototype._setPosition = /**
     * Sets the appropriate positions on a position strategy
     * so the overlay connects with the trigger correctly.
     * @param {?} positionStrategy Strategy whose position to update.
     * @return {?}
     */
    function (positionStrategy) {
        var _a = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'], originX = _a[0], originFallbackX = _a[1];
        var _b = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], overlayY = _b[0], overlayFallbackY = _b[1];
        var _c = [overlayY, overlayFallbackY], originY = _c[0], originFallbackY = _c[1];
        var _d = [originX, originFallbackX], overlayX = _d[0], overlayFallbackX = _d[1];
        var /** @type {?} */ offsetY = 0;
        if (this.triggersSubmenu()) {
            // When the menu is a sub-menu, it should always align itself
            // to the edges of the trigger, instead of overlapping it.
            overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';
            originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';
            offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;
        }
        else if (!this.menu.overlapTrigger) {
            originY = overlayY === 'top' ? 'bottom' : 'top';
            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';
        }
        positionStrategy.withPositions([
            { originX: originX, originY: originY, overlayX: overlayX, overlayY: overlayY, offsetY: offsetY },
            { originX: originFallbackX, originY: originY, overlayX: overlayFallbackX, overlayY: overlayY, offsetY: offsetY },
            {
                originX: originX,
                originY: originFallbackY,
                overlayX: overlayX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            },
            {
                originX: originFallbackX,
                originY: originFallbackY,
                overlayX: overlayFallbackX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            }
        ]);
    };
    /**
     * Cleans up the active subscriptions.
     * @return {?}
     */
    MatMenuTrigger.prototype._cleanUpSubscriptions = /**
     * Cleans up the active subscriptions.
     * @return {?}
     */
    function () {
        this._closeSubscription.unsubscribe();
        this._hoverSubscription.unsubscribe();
    };
    /**
     * Returns a stream that emits whenever an action that should close the menu occurs.
     * @return {?}
     */
    MatMenuTrigger.prototype._menuClosingActions = /**
     * Returns a stream that emits whenever an action that should close the menu occurs.
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ backdrop = /** @type {?} */ ((this._overlayRef)).backdropClick();
        var /** @type {?} */ detachments = /** @type {?} */ ((this._overlayRef)).detachments();
        var /** @type {?} */ parentClose = this._parentMenu ? this._parentMenu.closed : of();
        var /** @type {?} */ hover = this._parentMenu ? this._parentMenu._hovered().pipe(filter(function (active) { return active !== _this._menuItemInstance; }), filter(function () { return _this._menuOpen; })) : of();
        return merge(backdrop, parentClose, hover, detachments);
    };
    /** Handles mouse presses on the trigger. */
    /**
     * Handles mouse presses on the trigger.
     * @param {?} event
     * @return {?}
     */
    MatMenuTrigger.prototype._handleMousedown = /**
     * Handles mouse presses on the trigger.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!isFakeMousedownFromScreenReader(event)) {
            this._openedByMouse = true;
            // Since clicking on the trigger won't close the menu if it opens a sub-menu,
            // we should prevent focus from moving onto it via click to avoid the
            // highlight from lingering on the menu item.
            if (this.triggersSubmenu()) {
                event.preventDefault();
            }
        }
    };
    /** Handles key presses on the trigger. */
    /**
     * Handles key presses on the trigger.
     * @param {?} event
     * @return {?}
     */
    MatMenuTrigger.prototype._handleKeydown = /**
     * Handles key presses on the trigger.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ keyCode = event.keyCode;
        if (this.triggersSubmenu() && ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||
            (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {
            this.openMenu();
        }
    };
    /** Handles click events on the trigger. */
    /**
     * Handles click events on the trigger.
     * @param {?} event
     * @return {?}
     */
    MatMenuTrigger.prototype._handleClick = /**
     * Handles click events on the trigger.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.triggersSubmenu()) {
            // Stop event propagation to avoid closing the parent menu.
            event.stopPropagation();
            this.openMenu();
        }
        else {
            this.toggleMenu();
        }
    };
    /**
     * Handles the cases where the user hovers over the trigger.
     * @return {?}
     */
    MatMenuTrigger.prototype._handleHover = /**
     * Handles the cases where the user hovers over the trigger.
     * @return {?}
     */
    function () {
        var _this = this;
        // Subscribe to changes in the hovered item in order to toggle the panel.
        if (!this.triggersSubmenu()) {
            return;
        }
        this._hoverSubscription = this._parentMenu._hovered()
            .pipe(filter(function (active) { return active === _this._menuItemInstance && !active.disabled; }), delay(0, asap))
            .subscribe(function () {
            _this._openedByMouse = true;
            // If the same menu is used between multiple triggers, it might still be animating
            // while the new trigger tries to re-open it. Wait for the animation to finish
            // before doing so. Also interrupt if the user moves to another item.
            if (_this.menu instanceof MatMenu && _this.menu._isAnimating) {
                _this.menu._animationDone
                    .pipe(take(1), takeUntil(_this._parentMenu._hovered()))
                    .subscribe(function () { return _this.openMenu(); });
            }
            else {
                _this.openMenu();
            }
        });
    };
    MatMenuTrigger.decorators = [
        { type: core.Directive, args: [{
                    selector: "[mat-menu-trigger-for], [matMenuTriggerFor]",
                    host: {
                        'aria-haspopup': 'true',
                        '[attr.aria-expanded]': 'menuOpen || null',
                        '(mousedown)': '_handleMousedown($event)',
                        '(keydown)': '_handleKeydown($event)',
                        '(click)': '_handleClick($event)',
                    },
                    exportAs: 'matMenuTrigger'
                },] },
    ];
    /** @nocollapse */
    MatMenuTrigger.ctorParameters = function () { return [
        { type: Overlay, },
        { type: core.ElementRef, },
        { type: core.ViewContainerRef, },
        { type: undefined, decorators: [{ type: core.Inject, args: [MAT_MENU_SCROLL_STRATEGY,] },] },
        { type: MatMenu, decorators: [{ type: core.Optional },] },
        { type: MatMenuItem, decorators: [{ type: core.Optional }, { type: core.Self },] },
        { type: Directionality, decorators: [{ type: core.Optional },] },
        { type: FocusMonitor, },
    ]; };
    MatMenuTrigger.propDecorators = {
        "_deprecatedMatMenuTriggerFor": [{ type: core.Input, args: ['mat-menu-trigger-for',] },],
        "menu": [{ type: core.Input, args: ['matMenuTriggerFor',] },],
        "menuData": [{ type: core.Input, args: ['matMenuTriggerData',] },],
        "menuOpened": [{ type: core.Output },],
        "onMenuOpen": [{ type: core.Output },],
        "menuClosed": [{ type: core.Output },],
        "onMenuClose": [{ type: core.Output },],
    };
    return MatMenuTrigger;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// Copyright (C) 2016-2018 Sergey Akopkokhyants
// This project is licensed under the terms of the MIT license.
// https://github.com/akserg/ng2-dnd
/**
 * Check and return true if an object is type of string
 * @param {?} obj
 * @return {?}
 */
function isString(obj) {
    return typeof obj === "string";
}
/**
 * Check and return true if an object not undefined or null
 * @param {?} obj
 * @return {?}
 */
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
/**
 * Check and return true if an object is type of Function
 * @param {?} obj
 * @return {?}
 */
function isFunction$1(obj) {
    return typeof obj === "function";
}
/**
 * Create Image element with specified url string
 * @param {?} src
 * @return {?}
 */
function createImage(src) {
    /** @type {?} */
    var img = new HTMLImageElement();
    img.src = src;
    return img;
}
/**
 * Call the function
 * @param {?} fun
 * @return {?}
 */
function callFun(fun) {
    return fun();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DataTransferEffect = /** @class */ (function () {
    function DataTransferEffect(name) {
        this.name = name;
    }
    DataTransferEffect.COPY = new DataTransferEffect('copy');
    DataTransferEffect.LINK = new DataTransferEffect('link');
    DataTransferEffect.MOVE = new DataTransferEffect('move');
    DataTransferEffect.NONE = new DataTransferEffect('none');
    return DataTransferEffect;
}());
var DragDropConfig = /** @class */ (function () {
    function DragDropConfig() {
        this.onDragStartClass = "dnd-drag-start";
        this.onDragEnterClass = "dnd-drag-enter";
        this.onDragOverClass = "dnd-drag-over";
        this.onSortableDragClass = "dnd-sortable-drag";
        this.dragEffect = DataTransferEffect.MOVE;
        this.dropEffect = DataTransferEffect.MOVE;
        this.dragCursor = "move";
        this.defaultCursor = "pointer";
    }
    return DragDropConfig;
}());
/**
 * @return {?}
 */
function dragDropServiceFactory() {
    return new DragDropService();
}
var DragDropService = /** @class */ (function () {
    function DragDropService() {
        this.allowedDropZones = [];
    }
    DragDropService.decorators = [
        { type: core.Injectable }
    ];
    return DragDropService;
}());
/**
 * @param {?} config
 * @return {?}
 */
function dragDropSortableServiceFactory(config) {
    return new DragDropSortableService(config);
}
var DragDropSortableService = /** @class */ (function () {
    function DragDropSortableService(_config) {
        this._config = _config;
    }
    Object.defineProperty(DragDropSortableService.prototype, "elem", {
        get: /**
         * @return {?}
         */
        function () {
            return this._elem;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} elem
     * @return {?}
     */
    DragDropSortableService.prototype.markSortable = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        if (isPresent(this._elem)) {
            this._elem.classList.remove(this._config.onSortableDragClass);
        }
        if (isPresent(elem)) {
            this._elem = elem;
            this._elem.classList.add(this._config.onSortableDragClass);
        }
    };
    DragDropSortableService.decorators = [
        { type: core.Injectable }
    ];
    /** @nocollapse */
    DragDropSortableService.ctorParameters = function () { return [
        { type: DragDropConfig }
    ]; };
    return DragDropSortableService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var AbstractComponent = /** @class */ (function () {
    function AbstractComponent(elemRef, _dragDropService, _config, _cdr) {
        var _this = this;
        this._dragDropService = _dragDropService;
        this._config = _config;
        this._cdr = _cdr;
        /**
         * Whether the object is draggable. Default is true.
         */
        this._dragEnabled = false;
        /**
         * Allows drop on this element
         */
        this.dropEnabled = false;
        this.dropZones = [];
        this.cloneItem = false;
        // Assign default cursor unless overridden
        this._defaultCursor = _config.defaultCursor;
        this._elem = elemRef.nativeElement;
        this._elem.style.cursor = this._defaultCursor; // set default cursor on our element
        //
        // DROP events
        //
        this._elem.ondragenter = function (event) {
            _this._onDragEnter(event);
        };
        this._elem.ondragover = function (event) {
            _this._onDragOver(event);
            //
            if (event.dataTransfer != null) {
                event.dataTransfer.dropEffect = _this._config.dropEffect.name;
            }
            return false;
        };
        this._elem.ondragleave = function (event) {
            _this._onDragLeave(event);
        };
        this._elem.ondrop = function (event) {
            _this._onDrop(event);
        };
        //
        // Drag events
        //
        this._elem.onmousedown = function (event) {
            _this._target = event.target;
        };
        this._elem.ondragstart = function (event) {
            if (_this._dragHandle) {
                if (!_this._dragHandle.contains(/** @type {?} */ (_this._target))) {
                    event.preventDefault();
                    return;
                }
            }
            _this._onDragStart(event);
            //
            if (event.dataTransfer != null) {
                event.dataTransfer.setData('text', '');
                // Change drag effect
                event.dataTransfer.effectAllowed = _this.effectAllowed || _this._config.dragEffect.name;
                // Change drag image
                if (isPresent(_this.dragImage)) {
                    if (isString(_this.dragImage)) {
                        (/** @type {?} */ (event.dataTransfer)).setDragImage(createImage(/** @type {?} */ (_this.dragImage)));
                    }
                    else if (isFunction$1(_this.dragImage)) {
                        (/** @type {?} */ (event.dataTransfer)).setDragImage(callFun(/** @type {?} */ (_this.dragImage)));
                    }
                    else {
                        /** @type {?} */
                        var img = /** @type {?} */ (_this.dragImage);
                        (/** @type {?} */ (event.dataTransfer)).setDragImage(img.imageElement, img.x_offset, img.y_offset);
                    }
                }
                else if (isPresent(_this._config.dragImage)) {
                    /** @type {?} */
                    var dragImage = _this._config.dragImage;
                    (/** @type {?} */ (event.dataTransfer)).setDragImage(dragImage.imageElement, dragImage.x_offset, dragImage.y_offset);
                }
                else if (_this.cloneItem) {
                    _this._dragHelper = /** @type {?} */ (_this._elem.cloneNode(true));
                    _this._dragHelper.classList.add('dnd-drag-item');
                    _this._dragHelper.style.position = "absolute";
                    _this._dragHelper.style.top = "0px";
                    _this._dragHelper.style.left = "-1000px";
                    _this._elem.parentElement.appendChild(_this._dragHelper);
                    (/** @type {?} */ (event.dataTransfer)).setDragImage(_this._dragHelper, event.offsetX, event.offsetY);
                }
                /** @type {?} */
                var cursorelem = (_this._dragHandle) ? _this._dragHandle : _this._elem;
                if (_this._dragEnabled) {
                    cursorelem.style.cursor = _this.effectCursor ? _this.effectCursor : _this._config.dragCursor;
                }
                else {
                    cursorelem.style.cursor = _this._defaultCursor;
                }
            }
        };
        this._elem.ondragend = function (event) {
            if (_this._elem.parentElement && _this._dragHelper) {
                _this._elem.parentElement.removeChild(_this._dragHelper);
            }
            // console.log('ondragend', event.target);
            // console.log('ondragend', event.target);
            _this._onDragEnd(event);
            /** @type {?} */
            var cursorelem = (_this._dragHandle) ? _this._dragHandle : _this._elem;
            cursorelem.style.cursor = _this._defaultCursor;
        };
    }
    Object.defineProperty(AbstractComponent.prototype, "dragEnabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dragEnabled;
        },
        set: /**
         * @param {?} enabled
         * @return {?}
         */
        function (enabled) {
            this._dragEnabled = !!enabled;
            this._elem.draggable = this._dragEnabled;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} elem
     * @return {?}
     */
    AbstractComponent.prototype.setDragHandle = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        this._dragHandle = elem;
    };
    /******* Change detection ******/
    /**
     * **** Change detection *****
     * @return {?}
     */
    AbstractComponent.prototype.detectChanges = /**
     * **** Change detection *****
     * @return {?}
     */
    function () {
        var _this = this;
        // Programmatically run change detection to fix issue in Safari
        setTimeout(function () {
            if (_this._cdr && !(/** @type {?} */ (_this._cdr)).destroyed) {
                _this._cdr.detectChanges();
            }
        }, 250);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._onDragEnter = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // console.log('ondragenter._isDropAllowed', this._isDropAllowed);
        if (this._isDropAllowed(event)) {
            // event.preventDefault();
            this._onDragEnterCallback(event);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._onDragOver = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // // console.log('ondragover._isDropAllowed', this._isDropAllowed);
        if (this._isDropAllowed(event)) {
            // The element is over the same source element - do nothing
            if (event.preventDefault) {
                // Necessary. Allows us to drop.
                event.preventDefault();
            }
            this._onDragOverCallback(event);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._onDragLeave = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // console.log('ondragleave._isDropAllowed', this._isDropAllowed);
        if (this._isDropAllowed(event)) {
            // event.preventDefault();
            this._onDragLeaveCallback(event);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._onDrop = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // console.log('ondrop._isDropAllowed', this._isDropAllowed);
        if (this._isDropAllowed(event)) {
            // Necessary. Allows us to drop.
            this._preventAndStop(event);
            this._onDropCallback(event);
            this.detectChanges();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._isDropAllowed = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if ((this._dragDropService.isDragged || (event.dataTransfer && event.dataTransfer.files)) && this.dropEnabled) {
            // First, if `allowDrop` is set, call it to determine whether the
            // dragged element can be dropped here.
            if (this.allowDrop) {
                return this.allowDrop(this._dragDropService.dragData);
            }
            // Otherwise, use dropZones if they are set.
            if (this.dropZones.length === 0 && this._dragDropService.allowedDropZones.length === 0) {
                return true;
            }
            for (var i = 0; i < this._dragDropService.allowedDropZones.length; i++) {
                /** @type {?} */
                var dragZone = this._dragDropService.allowedDropZones[i];
                if (this.dropZones.indexOf(dragZone) !== -1) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._preventAndStop = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.preventDefault) {
            event.preventDefault();
        }
        if (event.stopPropagation) {
            event.stopPropagation();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._onDragStart = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        //console.log('ondragstart.dragEnabled', this._dragEnabled);
        if (this._dragEnabled) {
            this._dragDropService.allowedDropZones = this.dropZones;
            // console.log('ondragstart.allowedDropZones', this._dragDropService.allowedDropZones);
            this._onDragStartCallback(event);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._onDragEnd = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._dragDropService.allowedDropZones = [];
        // console.log('ondragend.allowedDropZones', this._dragDropService.allowedDropZones);
        this._onDragEndCallback(event);
    };
    //**** Drop Callbacks ****//
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._onDragEnterCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) { };
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._onDragOverCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) { };
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._onDragLeaveCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) { };
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._onDropCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) { };
    //**** Drag Callbacks ****//
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._onDragStartCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) { };
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractComponent.prototype._onDragEndCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) { };
    AbstractComponent.decorators = [
        { type: core.Injectable }
    ];
    /** @nocollapse */
    AbstractComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: DragDropService },
        { type: DragDropConfig },
        { type: core.ChangeDetectorRef }
    ]; };
    return AbstractComponent;
}());
var AbstractHandleComponent = /** @class */ (function () {
    function AbstractHandleComponent(elemRef, _dragDropService, _config, _Component, _cdr) {
        this._dragDropService = _dragDropService;
        this._config = _config;
        this._Component = _Component;
        this._cdr = _cdr;
        this._elem = elemRef.nativeElement;
        this._Component.setDragHandle(this._elem);
    }
    return AbstractHandleComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DraggableComponent = /** @class */ (function (_super) {
    __extends(DraggableComponent, _super);
    function DraggableComponent(elemRef, dragDropService, config, cdr) {
        var _this = _super.call(this, elemRef, dragDropService, config, cdr) || this;
        /**
         * Callback function called when the drag actions happened.
         */
        _this.onDragStart = new core.EventEmitter();
        _this.onDragEnd = new core.EventEmitter();
        /**
         * Callback function called when the drag action ends with a valid drop action.
         * It is activated after the on-drop-success callback
         */
        _this.onDragSuccessCallback = new core.EventEmitter();
        _this._defaultCursor = _this._elem.style.cursor;
        _this.dragEnabled = true;
        return _this;
    }
    Object.defineProperty(DraggableComponent.prototype, "draggable", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.dragEnabled = !!value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DraggableComponent.prototype, "dropzones", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.dropZones = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DraggableComponent.prototype, "effectallowed", {
        /**
         * Drag allowed effect
         */
        set: /**
         * Drag allowed effect
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.effectAllowed = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DraggableComponent.prototype, "effectcursor", {
        /**
         * Drag effect cursor
         */
        set: /**
         * Drag effect cursor
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.effectCursor = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    DraggableComponent.prototype._onDragStartCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._dragDropService.isDragged = true;
        this._dragDropService.dragData = this.dragData;
        this._dragDropService.onDragSuccessCallback = this.onDragSuccessCallback;
        this._elem.classList.add(this._config.onDragStartClass);
        //
        this.onDragStart.emit({ dragData: this.dragData, mouseEvent: event });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DraggableComponent.prototype._onDragEndCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._dragDropService.isDragged = false;
        this._dragDropService.dragData = null;
        this._dragDropService.onDragSuccessCallback = null;
        this._elem.classList.remove(this._config.onDragStartClass);
        //
        this.onDragEnd.emit({ dragData: this.dragData, mouseEvent: event });
    };
    DraggableComponent.decorators = [
        { type: core.Directive, args: [{ selector: '[dnd-draggable]' },] }
    ];
    /** @nocollapse */
    DraggableComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: DragDropService },
        { type: DragDropConfig },
        { type: core.ChangeDetectorRef }
    ]; };
    DraggableComponent.propDecorators = {
        draggable: [{ type: core.Input, args: ["dragEnabled",] }],
        onDragStart: [{ type: core.Output }],
        onDragEnd: [{ type: core.Output }],
        dragData: [{ type: core.Input }],
        onDragSuccessCallback: [{ type: core.Output, args: ["onDragSuccess",] }],
        dropzones: [{ type: core.Input, args: ["dropZones",] }],
        effectallowed: [{ type: core.Input, args: ["effectAllowed",] }],
        effectcursor: [{ type: core.Input, args: ["effectCursor",] }],
        dragImage: [{ type: core.Input }],
        cloneItem: [{ type: core.Input }]
    };
    return DraggableComponent;
}(AbstractComponent));
var DraggableHandleComponent = /** @class */ (function (_super) {
    __extends(DraggableHandleComponent, _super);
    function DraggableHandleComponent(elemRef, dragDropService, config, _Component, cdr) {
        return _super.call(this, elemRef, dragDropService, config, _Component, cdr) || this;
    }
    DraggableHandleComponent.decorators = [
        { type: core.Directive, args: [{ selector: '[dnd-draggable-handle]' },] }
    ];
    /** @nocollapse */
    DraggableHandleComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: DragDropService },
        { type: DragDropConfig },
        { type: DraggableComponent },
        { type: core.ChangeDetectorRef }
    ]; };
    return DraggableHandleComponent;
}(AbstractHandleComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DroppableComponent = /** @class */ (function (_super) {
    __extends(DroppableComponent, _super);
    function DroppableComponent(elemRef, dragDropService, config, cdr) {
        var _this = _super.call(this, elemRef, dragDropService, config, cdr) || this;
        /**
         * Callback function called when the drop action completes correctly.
         * It is activated before the on-drag-success callback.
         */
        _this.onDropSuccess = new core.EventEmitter();
        _this.onDragEnter = new core.EventEmitter();
        _this.onDragOver = new core.EventEmitter();
        _this.onDragLeave = new core.EventEmitter();
        _this.dropEnabled = true;
        return _this;
    }
    Object.defineProperty(DroppableComponent.prototype, "droppable", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.dropEnabled = !!value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DroppableComponent.prototype, "allowdrop", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.allowDrop = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DroppableComponent.prototype, "dropzones", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.dropZones = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DroppableComponent.prototype, "effectallowed", {
        /**
         * Drag allowed effect
         */
        set: /**
         * Drag allowed effect
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.effectAllowed = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DroppableComponent.prototype, "effectcursor", {
        /**
         * Drag effect cursor
         */
        set: /**
         * Drag effect cursor
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.effectCursor = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    DroppableComponent.prototype._onDragEnterCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._dragDropService.isDragged) {
            this._elem.classList.add(this._config.onDragEnterClass);
            this.onDragEnter.emit({ dragData: this._dragDropService.dragData, mouseEvent: event });
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DroppableComponent.prototype._onDragOverCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._dragDropService.isDragged) {
            this._elem.classList.add(this._config.onDragOverClass);
            this.onDragOver.emit({ dragData: this._dragDropService.dragData, mouseEvent: event });
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DroppableComponent.prototype._onDragLeaveCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._dragDropService.isDragged) {
            this._elem.classList.remove(this._config.onDragOverClass);
            this._elem.classList.remove(this._config.onDragEnterClass);
            this.onDragLeave.emit({ dragData: this._dragDropService.dragData, mouseEvent: event });
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DroppableComponent.prototype._onDropCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var dataTransfer = (/** @type {?} */ (event)).dataTransfer;
        if (this._dragDropService.isDragged || (dataTransfer && dataTransfer.files)) {
            this.onDropSuccess.emit({ dragData: this._dragDropService.dragData, mouseEvent: event });
            if (this._dragDropService.onDragSuccessCallback) {
                this._dragDropService.onDragSuccessCallback.emit({ dragData: this._dragDropService.dragData, mouseEvent: event });
            }
            this._elem.classList.remove(this._config.onDragOverClass);
            this._elem.classList.remove(this._config.onDragEnterClass);
        }
    };
    DroppableComponent.decorators = [
        { type: core.Directive, args: [{ selector: '[dnd-droppable]' },] }
    ];
    /** @nocollapse */
    DroppableComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: DragDropService },
        { type: DragDropConfig },
        { type: core.ChangeDetectorRef }
    ]; };
    DroppableComponent.propDecorators = {
        droppable: [{ type: core.Input, args: ["dropEnabled",] }],
        onDropSuccess: [{ type: core.Output }],
        onDragEnter: [{ type: core.Output }],
        onDragOver: [{ type: core.Output }],
        onDragLeave: [{ type: core.Output }],
        allowdrop: [{ type: core.Input, args: ["allowDrop",] }],
        dropzones: [{ type: core.Input, args: ["dropZones",] }],
        effectallowed: [{ type: core.Input, args: ["effectAllowed",] }],
        effectcursor: [{ type: core.Input, args: ["effectCursor",] }]
    };
    return DroppableComponent;
}(AbstractComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var SortableContainer = /** @class */ (function (_super) {
    __extends(SortableContainer, _super);
    function SortableContainer(elemRef, dragDropService, config, cdr, _sortableDataService) {
        var _this = _super.call(this, elemRef, dragDropService, config, cdr) || this;
        _this._sortableDataService = _sortableDataService;
        _this._sortableData = [];
        _this.dragEnabled = false;
        return _this;
    }
    Object.defineProperty(SortableContainer.prototype, "draggable", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.dragEnabled = !!value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SortableContainer.prototype, "sortableData", {
        get: /**
         * @return {?}
         */
        function () {
            return this._sortableData;
        },
        set: /**
         * @param {?} sortableData
         * @return {?}
         */
        function (sortableData) {
            this._sortableData = sortableData;
            if (sortableData instanceof forms.FormArray) {
                this.sortableHandler = new SortableFormArrayHandler();
            }
            else {
                this.sortableHandler = new SortableArrayHandler();
            }
            //
            this.dropEnabled = !!this._sortableData;
            // console.log("collection is changed, drop enabled: " + this.dropEnabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SortableContainer.prototype, "dropzones", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.dropZones = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    SortableContainer.prototype._onDragEnterCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._sortableDataService.isDragged) {
            /** @type {?} */
            var item = this._sortableDataService.sortableContainer.getItemAt(this._sortableDataService.index);
            // Check does element exist in sortableData of this Container
            if (this.indexOf(item) === -1) {
                // Let's add it
                // console.log('Container._onDragEnterCallback. drag node [' + this._sortableDataService.index.toString() + '] over parent node');
                // Remove item from previouse list
                this._sortableDataService.sortableContainer.removeItemAt(this._sortableDataService.index);
                if (this._sortableDataService.sortableContainer._sortableData.length === 0) {
                    this._sortableDataService.sortableContainer.dropEnabled = true;
                }
                // Add item to new list
                this.insertItemAt(item, 0);
                this._sortableDataService.sortableContainer = this;
                this._sortableDataService.index = 0;
            }
            // Refresh changes in properties of container component
            this.detectChanges();
        }
    };
    /**
     * @param {?} index
     * @return {?}
     */
    SortableContainer.prototype.getItemAt = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return this.sortableHandler.getItemAt(this._sortableData, index);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    SortableContainer.prototype.indexOf = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.sortableHandler.indexOf(this._sortableData, item);
    };
    /**
     * @param {?} index
     * @return {?}
     */
    SortableContainer.prototype.removeItemAt = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        this.sortableHandler.removeItemAt(this._sortableData, index);
    };
    /**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    SortableContainer.prototype.insertItemAt = /**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    function (item, index) {
        this.sortableHandler.insertItemAt(this._sortableData, item, index);
    };
    SortableContainer.decorators = [
        { type: core.Directive, args: [{ selector: '[dnd-sortable-container]' },] }
    ];
    /** @nocollapse */
    SortableContainer.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: DragDropService },
        { type: DragDropConfig },
        { type: core.ChangeDetectorRef },
        { type: DragDropSortableService }
    ]; };
    SortableContainer.propDecorators = {
        draggable: [{ type: core.Input, args: ["dragEnabled",] }],
        sortableData: [{ type: core.Input }],
        dropzones: [{ type: core.Input, args: ["dropZones",] }]
    };
    return SortableContainer;
}(AbstractComponent));
var SortableArrayHandler = /** @class */ (function () {
    function SortableArrayHandler() {
    }
    /**
     * @param {?} sortableData
     * @param {?} index
     * @return {?}
     */
    SortableArrayHandler.prototype.getItemAt = /**
     * @param {?} sortableData
     * @param {?} index
     * @return {?}
     */
    function (sortableData, index) {
        return sortableData[index];
    };
    /**
     * @param {?} sortableData
     * @param {?} item
     * @return {?}
     */
    SortableArrayHandler.prototype.indexOf = /**
     * @param {?} sortableData
     * @param {?} item
     * @return {?}
     */
    function (sortableData, item) {
        return sortableData.indexOf(item);
    };
    /**
     * @param {?} sortableData
     * @param {?} index
     * @return {?}
     */
    SortableArrayHandler.prototype.removeItemAt = /**
     * @param {?} sortableData
     * @param {?} index
     * @return {?}
     */
    function (sortableData, index) {
        sortableData.splice(index, 1);
    };
    /**
     * @param {?} sortableData
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    SortableArrayHandler.prototype.insertItemAt = /**
     * @param {?} sortableData
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    function (sortableData, item, index) {
        sortableData.splice(index, 0, item);
    };
    return SortableArrayHandler;
}());
var SortableFormArrayHandler = /** @class */ (function () {
    function SortableFormArrayHandler() {
    }
    /**
     * @param {?} sortableData
     * @param {?} index
     * @return {?}
     */
    SortableFormArrayHandler.prototype.getItemAt = /**
     * @param {?} sortableData
     * @param {?} index
     * @return {?}
     */
    function (sortableData, index) {
        return sortableData.at(index);
    };
    /**
     * @param {?} sortableData
     * @param {?} item
     * @return {?}
     */
    SortableFormArrayHandler.prototype.indexOf = /**
     * @param {?} sortableData
     * @param {?} item
     * @return {?}
     */
    function (sortableData, item) {
        return sortableData.controls.indexOf(item);
    };
    /**
     * @param {?} sortableData
     * @param {?} index
     * @return {?}
     */
    SortableFormArrayHandler.prototype.removeItemAt = /**
     * @param {?} sortableData
     * @param {?} index
     * @return {?}
     */
    function (sortableData, index) {
        sortableData.removeAt(index);
    };
    /**
     * @param {?} sortableData
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    SortableFormArrayHandler.prototype.insertItemAt = /**
     * @param {?} sortableData
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    function (sortableData, item, index) {
        sortableData.insert(index, item);
    };
    return SortableFormArrayHandler;
}());
var SortableComponent = /** @class */ (function (_super) {
    __extends(SortableComponent, _super);
    function SortableComponent(elemRef, dragDropService, config, _sortableContainer, _sortableDataService, cdr) {
        var _this = _super.call(this, elemRef, dragDropService, config, cdr) || this;
        _this._sortableContainer = _sortableContainer;
        _this._sortableDataService = _sortableDataService;
        /**
         * Callback function called when the drag action ends with a valid drop action.
         * It is activated after the on-drop-success callback
         */
        _this.onDragSuccessCallback = new core.EventEmitter();
        _this.onDragStartCallback = new core.EventEmitter();
        _this.onDragOverCallback = new core.EventEmitter();
        _this.onDragEndCallback = new core.EventEmitter();
        _this.onDropSuccessCallback = new core.EventEmitter();
        _this.dropZones = _this._sortableContainer.dropZones;
        _this.dragEnabled = true;
        _this.dropEnabled = true;
        return _this;
    }
    Object.defineProperty(SortableComponent.prototype, "draggable", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.dragEnabled = !!value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SortableComponent.prototype, "droppable", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.dropEnabled = !!value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SortableComponent.prototype, "effectallowed", {
        /**
         * Drag allowed effect
         */
        set: /**
         * Drag allowed effect
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.effectAllowed = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SortableComponent.prototype, "effectcursor", {
        /**
         * Drag effect cursor
         */
        set: /**
         * Drag effect cursor
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.effectCursor = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    SortableComponent.prototype._onDragStartCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // console.log('_onDragStartCallback. dragging elem with index ' + this.index);
        this._sortableDataService.isDragged = true;
        this._sortableDataService.sortableContainer = this._sortableContainer;
        this._sortableDataService.index = this.index;
        this._sortableDataService.markSortable(this._elem);
        // Add dragData
        this._dragDropService.isDragged = true;
        this._dragDropService.dragData = this.dragData;
        this._dragDropService.onDragSuccessCallback = this.onDragSuccessCallback;
        //
        this.onDragStartCallback.emit(this._dragDropService.dragData);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SortableComponent.prototype._onDragOverCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._sortableDataService.isDragged && this._elem !== this._sortableDataService.elem) {
            // console.log('_onDragOverCallback. dragging elem with index ' + this.index);
            this._sortableDataService.sortableContainer = this._sortableContainer;
            this._sortableDataService.index = this.index;
            this._sortableDataService.markSortable(this._elem);
            this.onDragOverCallback.emit(this._dragDropService.dragData);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SortableComponent.prototype._onDragEndCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // console.log('_onDragEndCallback. end dragging elem with index ' + this.index);
        this._sortableDataService.isDragged = false;
        this._sortableDataService.sortableContainer = null;
        this._sortableDataService.index = null;
        this._sortableDataService.markSortable(null);
        // Add dragGata
        this._dragDropService.isDragged = false;
        this._dragDropService.dragData = null;
        this._dragDropService.onDragSuccessCallback = null;
        //
        this.onDragEndCallback.emit(this._dragDropService.dragData);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SortableComponent.prototype._onDragEnterCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._sortableDataService.isDragged) {
            this._sortableDataService.markSortable(this._elem);
            if ((this.index !== this._sortableDataService.index) ||
                (this._sortableDataService.sortableContainer.sortableData !== this._sortableContainer.sortableData)) {
                /** @type {?} */
                var item = this._sortableDataService.sortableContainer.getItemAt(this._sortableDataService.index);
                // Remove item from previouse list
                this._sortableDataService.sortableContainer.removeItemAt(this._sortableDataService.index);
                if (this._sortableDataService.sortableContainer.sortableData.length === 0) {
                    this._sortableDataService.sortableContainer.dropEnabled = true;
                }
                // Add item to new list
                this._sortableContainer.insertItemAt(item, this.index);
                if (this._sortableContainer.dropEnabled) {
                    this._sortableContainer.dropEnabled = false;
                }
                this._sortableDataService.sortableContainer = this._sortableContainer;
                this._sortableDataService.index = this.index;
                this.detectChanges();
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SortableComponent.prototype._onDropCallback = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._sortableDataService.isDragged) {
            // console.log('onDropCallback.onDropSuccessCallback.dragData', this._dragDropService.dragData);
            this.onDropSuccessCallback.emit(this._dragDropService.dragData);
            if (this._dragDropService.onDragSuccessCallback) {
                // console.log('onDropCallback.onDragSuccessCallback.dragData', this._dragDropService.dragData);
                this._dragDropService.onDragSuccessCallback.emit(this._dragDropService.dragData);
            }
            // Refresh changes in properties of container component
            this._sortableContainer.detectChanges();
        }
    };
    SortableComponent.decorators = [
        { type: core.Directive, args: [{ selector: '[dnd-sortable]' },] }
    ];
    /** @nocollapse */
    SortableComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: DragDropService },
        { type: DragDropConfig },
        { type: SortableContainer },
        { type: DragDropSortableService },
        { type: core.ChangeDetectorRef }
    ]; };
    SortableComponent.propDecorators = {
        index: [{ type: core.Input, args: ['sortableIndex',] }],
        draggable: [{ type: core.Input, args: ["dragEnabled",] }],
        droppable: [{ type: core.Input, args: ["dropEnabled",] }],
        dragData: [{ type: core.Input }],
        effectallowed: [{ type: core.Input, args: ["effectAllowed",] }],
        effectcursor: [{ type: core.Input, args: ["effectCursor",] }],
        onDragSuccessCallback: [{ type: core.Output, args: ["onDragSuccess",] }],
        onDragStartCallback: [{ type: core.Output, args: ["onDragStart",] }],
        onDragOverCallback: [{ type: core.Output, args: ["onDragOver",] }],
        onDragEndCallback: [{ type: core.Output, args: ["onDragEnd",] }],
        onDropSuccessCallback: [{ type: core.Output, args: ["onDropSuccess",] }]
    };
    return SortableComponent;
}(AbstractComponent));
var SortableHandleComponent = /** @class */ (function (_super) {
    __extends(SortableHandleComponent, _super);
    function SortableHandleComponent(elemRef, dragDropService, config, _Component, cdr) {
        return _super.call(this, elemRef, dragDropService, config, _Component, cdr) || this;
    }
    SortableHandleComponent.decorators = [
        { type: core.Directive, args: [{ selector: '[dnd-sortable-handle]' },] }
    ];
    /** @nocollapse */
    SortableHandleComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: DragDropService },
        { type: DragDropConfig },
        { type: SortableComponent },
        { type: core.ChangeDetectorRef }
    ]; };
    return SortableHandleComponent;
}(AbstractHandleComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var providers = [
    DragDropConfig,
    { provide: DragDropService, useFactory: dragDropServiceFactory },
    { provide: DragDropSortableService, useFactory: dragDropSortableServiceFactory, deps: [DragDropConfig] }
];
var DndModule = /** @class */ (function () {
    function DndModule() {
    }
    /**
     * @return {?}
     */
    DndModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: DndModule,
            providers: providers
        };
    };
    DndModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [DraggableComponent, DraggableHandleComponent, DroppableComponent, SortableContainer, SortableComponent, SortableHandleComponent],
                    exports: [DraggableComponent, DraggableHandleComponent, DroppableComponent, SortableContainer, SortableComponent, SortableHandleComponent],
                },] }
    ];
    return DndModule;
}());

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Mixin to provide a directive with a function that checks if the sticky input has been
 * changed since the last time the function was called. Essentially adds a dirty-check to the
 * sticky value.
 * @template T
 * @param {?} base
 * @return {?}
 */
function mixinHasStickyInput(base) {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            _this._sticky = false;
            /**
             * Whether the sticky input has changed since it was last checked.
             */
            _this._hasStickyChanged = false;
            return _this;
        }
        Object.defineProperty(class_1.prototype, "sticky", {
            /** Whether sticky positioning should be applied. */
            get: /**
             * Whether sticky positioning should be applied.
             * @return {?}
             */
            function () { return this._sticky; },
            set: /**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                var /** @type {?} */ prevValue = this._sticky;
                this._sticky = coerceBooleanProperty(v);
                this._hasStickyChanged = prevValue !== this._sticky;
            },
            enumerable: true,
            configurable: true
        });
        /** Whether the sticky value has changed since this was last called. */
        /**
         * Whether the sticky value has changed since this was last called.
         * @return {?}
         */
        class_1.prototype.hasStickyChanged = /**
         * Whether the sticky value has changed since this was last called.
         * @return {?}
         */
        function () {
            var /** @type {?} */ hasStickyChanged = this._hasStickyChanged;
            this._hasStickyChanged = false;
            return hasStickyChanged;
        };
        /** Resets the dirty check for cases where the sticky state has been used without checking. */
        /**
         * Resets the dirty check for cases where the sticky state has been used without checking.
         * @return {?}
         */
        class_1.prototype.resetStickyChanged = /**
         * Resets the dirty check for cases where the sticky state has been used without checking.
         * @return {?}
         */
        function () {
            this._hasStickyChanged = false;
        };
        return class_1;
    }(base));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Cell definition for a CDK table.
 * Captures the template of a column's data row cell as well as cell-specific properties.
 */
var CdkCellDef = /** @class */ (function () {
    function CdkCellDef(template) {
        this.template = template;
    }
    CdkCellDef.decorators = [
        { type: core.Directive, args: [{ selector: '[cdkCellDef]' },] },
    ];
    /** @nocollapse */
    CdkCellDef.ctorParameters = function () { return [
        { type: core.TemplateRef, },
    ]; };
    return CdkCellDef;
}());
/**
 * Header cell definition for a CDK table.
 * Captures the template of a column's header cell and as well as cell-specific properties.
 */
var CdkHeaderCellDef = /** @class */ (function () {
    function CdkHeaderCellDef(template) {
        this.template = template;
    }
    CdkHeaderCellDef.decorators = [
        { type: core.Directive, args: [{ selector: '[cdkHeaderCellDef]' },] },
    ];
    /** @nocollapse */
    CdkHeaderCellDef.ctorParameters = function () { return [
        { type: core.TemplateRef, },
    ]; };
    return CdkHeaderCellDef;
}());
/**
 * Footer cell definition for a CDK table.
 * Captures the template of a column's footer cell and as well as cell-specific properties.
 */
var CdkFooterCellDef = /** @class */ (function () {
    function CdkFooterCellDef(template) {
        this.template = template;
    }
    CdkFooterCellDef.decorators = [
        { type: core.Directive, args: [{ selector: '[cdkFooterCellDef]' },] },
    ];
    /** @nocollapse */
    CdkFooterCellDef.ctorParameters = function () { return [
        { type: core.TemplateRef, },
    ]; };
    return CdkFooterCellDef;
}());
/**
 * \@docs-private
 */
var  /**
 * \@docs-private
 */
CdkColumnDefBase = /** @class */ (function () {
    function CdkColumnDefBase() {
    }
    return CdkColumnDefBase;
}());
var /** @type {?} */ _CdkColumnDefBase = mixinHasStickyInput(CdkColumnDefBase);
/**
 * Column definition for the CDK table.
 * Defines a set of cells available for a table column.
 */
var CdkColumnDef = /** @class */ (function (_super) {
    __extends(CdkColumnDef, _super);
    function CdkColumnDef() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._stickyEnd = false;
        return _this;
    }
    Object.defineProperty(CdkColumnDef.prototype, "name", {
        get: /**
         * Unique name for this column.
         * @return {?}
         */
        function () { return this._name; },
        set: /**
         * @param {?} name
         * @return {?}
         */
        function (name) {
            // If the directive is set without a name (updated programatically), then this setter will
            // trigger with an empty string and should not overwrite the programatically set value.
            if (!name) {
                return;
            }
            this._name = name;
            this.cssClassFriendlyName = name.replace(/[^a-z0-9_-]/ig, '-');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkColumnDef.prototype, "stickyEnd", {
        get: /**
         * Whether this column should be sticky positioned on the end of the row. Should make sure
         * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value
         * has been changed.
         * @return {?}
         */
        function () { return this._stickyEnd; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            var /** @type {?} */ prevValue = this._stickyEnd;
            this._stickyEnd = coerceBooleanProperty(v);
            this._hasStickyChanged = prevValue !== this._stickyEnd;
        },
        enumerable: true,
        configurable: true
    });
    CdkColumnDef.decorators = [
        { type: core.Directive, args: [{
                    selector: '[cdkColumnDef]',
                    inputs: ['sticky']
                },] },
    ];
    /** @nocollapse */
    CdkColumnDef.propDecorators = {
        "name": [{ type: core.Input, args: ['cdkColumnDef',] },],
        "stickyEnd": [{ type: core.Input, args: ['stickyEnd',] },],
        "cell": [{ type: core.ContentChild, args: [CdkCellDef,] },],
        "headerCell": [{ type: core.ContentChild, args: [CdkHeaderCellDef,] },],
        "footerCell": [{ type: core.ContentChild, args: [CdkFooterCellDef,] },],
    };
    return CdkColumnDef;
}(_CdkColumnDefBase));
/**
 * Base class for the cells. Adds a CSS classname that identifies the column it renders in.
 */
var  /**
 * Base class for the cells. Adds a CSS classname that identifies the column it renders in.
 */
BaseCdkCell = /** @class */ (function () {
    function BaseCdkCell(columnDef, elementRef) {
        var /** @type {?} */ columnClassName = "cdk-column-" + columnDef.cssClassFriendlyName;
        elementRef.nativeElement.classList.add(columnClassName);
    }
    return BaseCdkCell;
}());
/**
 * Header cell template container that adds the right classes and role.
 */
var CdkHeaderCell = /** @class */ (function (_super) {
    __extends(CdkHeaderCell, _super);
    function CdkHeaderCell(columnDef, elementRef) {
        return _super.call(this, columnDef, elementRef) || this;
    }
    CdkHeaderCell.decorators = [
        { type: core.Directive, args: [{
                    selector: 'cdk-header-cell, th[cdk-header-cell]',
                    host: {
                        'class': 'cdk-header-cell',
                        'role': 'columnheader',
                    },
                },] },
    ];
    /** @nocollapse */
    CdkHeaderCell.ctorParameters = function () { return [
        { type: CdkColumnDef, },
        { type: core.ElementRef, },
    ]; };
    return CdkHeaderCell;
}(BaseCdkCell));
/**
 * Footer cell template container that adds the right classes and role.
 */
var CdkFooterCell = /** @class */ (function (_super) {
    __extends(CdkFooterCell, _super);
    function CdkFooterCell(columnDef, elementRef) {
        return _super.call(this, columnDef, elementRef) || this;
    }
    CdkFooterCell.decorators = [
        { type: core.Directive, args: [{
                    selector: 'cdk-footer-cell, td[cdk-footer-cell]',
                    host: {
                        'class': 'cdk-footer-cell',
                        'role': 'gridcell',
                    },
                },] },
    ];
    /** @nocollapse */
    CdkFooterCell.ctorParameters = function () { return [
        { type: CdkColumnDef, },
        { type: core.ElementRef, },
    ]; };
    return CdkFooterCell;
}(BaseCdkCell));
/**
 * Cell template container that adds the right classes and role.
 */
var CdkCell = /** @class */ (function (_super) {
    __extends(CdkCell, _super);
    function CdkCell(columnDef, elementRef) {
        return _super.call(this, columnDef, elementRef) || this;
    }
    CdkCell.decorators = [
        { type: core.Directive, args: [{
                    selector: 'cdk-cell, td[cdk-cell]',
                    host: {
                        'class': 'cdk-cell',
                        'role': 'gridcell',
                    },
                },] },
    ];
    /** @nocollapse */
    CdkCell.ctorParameters = function () { return [
        { type: CdkColumnDef, },
        { type: core.ElementRef, },
    ]; };
    return CdkCell;
}(BaseCdkCell));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * The row template that can be used by the mat-table. Should not be used outside of the
 * material library.
 */
var /** @type {?} */ CDK_ROW_TEMPLATE = "<ng-container cdkCellOutlet></ng-container>";
/**
 * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs
 * for changes and notifying the table.
 * @abstract
 */
var  /**
 * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs
 * for changes and notifying the table.
 * @abstract
 */
BaseRowDef = /** @class */ (function () {
    function BaseRowDef(template, _differs) {
        this.template = template;
        this._differs = _differs;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    BaseRowDef.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // Create a new columns differ if one does not yet exist. Initialize it based on initial value
        // of the columns property or an empty array if none is provided.
        if (!this._columnsDiffer) {
            var /** @type {?} */ columns = (changes['columns'] && changes['columns'].currentValue) || [];
            this._columnsDiffer = this._differs.find(columns).create();
            this._columnsDiffer.diff(columns);
        }
    };
    /**
     * Returns the difference between the current columns and the columns from the last diff, or null
     * if there is no difference.
     */
    /**
     * Returns the difference between the current columns and the columns from the last diff, or null
     * if there is no difference.
     * @return {?}
     */
    BaseRowDef.prototype.getColumnsDiff = /**
     * Returns the difference between the current columns and the columns from the last diff, or null
     * if there is no difference.
     * @return {?}
     */
    function () {
        return this._columnsDiffer.diff(this.columns);
    };
    /** Gets this row def's relevant cell template from the provided column def. */
    /**
     * Gets this row def's relevant cell template from the provided column def.
     * @param {?} column
     * @return {?}
     */
    BaseRowDef.prototype.extractCellTemplate = /**
     * Gets this row def's relevant cell template from the provided column def.
     * @param {?} column
     * @return {?}
     */
    function (column) {
        if (this instanceof CdkHeaderRowDef) {
            return column.headerCell.template;
        }
        if (this instanceof CdkFooterRowDef) {
            return column.footerCell.template;
        }
        else {
            return column.cell.template;
        }
    };
    return BaseRowDef;
}());
/**
 * \@docs-private
 */
var  /**
 * \@docs-private
 */
CdkHeaderRowDefBase = /** @class */ (function (_super) {
    __extends(CdkHeaderRowDefBase, _super);
    function CdkHeaderRowDefBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CdkHeaderRowDefBase;
}(BaseRowDef));
var /** @type {?} */ _CdkHeaderRowDefBase = mixinHasStickyInput(CdkHeaderRowDefBase);
/**
 * Header row definition for the CDK table.
 * Captures the header row's template and other header properties such as the columns to display.
 */
var CdkHeaderRowDef = /** @class */ (function (_super) {
    __extends(CdkHeaderRowDef, _super);
    function CdkHeaderRowDef(template, _differs) {
        return _super.call(this, template, _differs) || this;
    }
    // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
    // Explicitly define it so that the method is called as part of the Angular lifecycle.
    /**
     * @param {?} changes
     * @return {?}
     */
    CdkHeaderRowDef.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
    };
    CdkHeaderRowDef.decorators = [
        { type: core.Directive, args: [{
                    selector: '[cdkHeaderRowDef]',
                    inputs: ['columns: cdkHeaderRowDef', 'sticky: cdkHeaderRowDefSticky'],
                },] },
    ];
    /** @nocollapse */
    CdkHeaderRowDef.ctorParameters = function () { return [
        { type: core.TemplateRef, },
        { type: core.IterableDiffers, },
    ]; };
    return CdkHeaderRowDef;
}(_CdkHeaderRowDefBase));
/**
 * \@docs-private
 */
var  /**
 * \@docs-private
 */
CdkFooterRowDefBase = /** @class */ (function (_super) {
    __extends(CdkFooterRowDefBase, _super);
    function CdkFooterRowDefBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CdkFooterRowDefBase;
}(BaseRowDef));
var /** @type {?} */ _CdkFooterRowDefBase = mixinHasStickyInput(CdkFooterRowDefBase);
/**
 * Footer row definition for the CDK table.
 * Captures the footer row's template and other footer properties such as the columns to display.
 */
var CdkFooterRowDef = /** @class */ (function (_super) {
    __extends(CdkFooterRowDef, _super);
    function CdkFooterRowDef(template, _differs) {
        return _super.call(this, template, _differs) || this;
    }
    // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
    // Explicitly define it so that the method is called as part of the Angular lifecycle.
    /**
     * @param {?} changes
     * @return {?}
     */
    CdkFooterRowDef.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
    };
    CdkFooterRowDef.decorators = [
        { type: core.Directive, args: [{
                    selector: '[cdkFooterRowDef]',
                    inputs: ['columns: cdkFooterRowDef', 'sticky: cdkFooterRowDefSticky'],
                },] },
    ];
    /** @nocollapse */
    CdkFooterRowDef.ctorParameters = function () { return [
        { type: core.TemplateRef, },
        { type: core.IterableDiffers, },
    ]; };
    return CdkFooterRowDef;
}(_CdkFooterRowDefBase));
/**
 * Data row definition for the CDK table.
 * Captures the header row's template and other row properties such as the columns to display and
 * a when predicate that describes when this row should be used.
 * @template T
 */
var CdkRowDef = /** @class */ (function (_super) {
    __extends(CdkRowDef, _super);
    // TODO(andrewseguin): Add an input for providing a switch function to determine
    //   if this template should be used.
    function CdkRowDef(template, _differs) {
        return _super.call(this, template, _differs) || this;
    }
    CdkRowDef.decorators = [
        { type: core.Directive, args: [{
                    selector: '[cdkRowDef]',
                    inputs: ['columns: cdkRowDefColumns', 'when: cdkRowDefWhen'],
                },] },
    ];
    /** @nocollapse */
    CdkRowDef.ctorParameters = function () { return [
        { type: core.TemplateRef, },
        { type: core.IterableDiffers, },
    ]; };
    return CdkRowDef;
}(BaseRowDef));
/**
 * Outlet for rendering cells inside of a row or header row.
 * \@docs-private
 */
var CdkCellOutlet = /** @class */ (function () {
    function CdkCellOutlet(_viewContainer) {
        this._viewContainer = _viewContainer;
        CdkCellOutlet.mostRecentCellOutlet = this;
    }
    /**
     * @return {?}
     */
    CdkCellOutlet.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // If this was the last outlet being rendered in the view, remove the reference
        // from the static property after it has been destroyed to avoid leaking memory.
        if (CdkCellOutlet.mostRecentCellOutlet === this) {
            CdkCellOutlet.mostRecentCellOutlet = null;
        }
    };
    /**
     * Static property containing the latest constructed instance of this class.
     * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using
     * createEmbeddedView. After one of these components are created, this property will provide
     * a handle to provide that component's cells and context. After init, the CdkCellOutlet will
     * construct the cells with the provided context.
     */
    CdkCellOutlet.mostRecentCellOutlet = null;
    CdkCellOutlet.decorators = [
        { type: core.Directive, args: [{ selector: '[cdkCellOutlet]' },] },
    ];
    /** @nocollapse */
    CdkCellOutlet.ctorParameters = function () { return [
        { type: core.ViewContainerRef, },
    ]; };
    return CdkCellOutlet;
}());
/**
 * Header template container that contains the cell outlet. Adds the right class and role.
 */
var CdkHeaderRow = /** @class */ (function () {
    function CdkHeaderRow() {
    }
    CdkHeaderRow.decorators = [
        { type: core.Component, args: [{selector: 'cdk-header-row, tr[cdk-header-row]',
                    template: CDK_ROW_TEMPLATE,
                    host: {
                        'class': 'cdk-header-row',
                        'role': 'row',
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    encapsulation: core.ViewEncapsulation.None,
                },] },
    ];
    return CdkHeaderRow;
}());
/**
 * Footer template container that contains the cell outlet. Adds the right class and role.
 */
var CdkFooterRow = /** @class */ (function () {
    function CdkFooterRow() {
    }
    CdkFooterRow.decorators = [
        { type: core.Component, args: [{selector: 'cdk-footer-row, tr[cdk-footer-row]',
                    template: CDK_ROW_TEMPLATE,
                    host: {
                        'class': 'cdk-footer-row',
                        'role': 'row',
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    encapsulation: core.ViewEncapsulation.None,
                },] },
    ];
    return CdkFooterRow;
}());
/**
 * Data row template container that contains the cell outlet. Adds the right class and role.
 */
var CdkRow = /** @class */ (function () {
    function CdkRow() {
    }
    CdkRow.decorators = [
        { type: core.Component, args: [{selector: 'cdk-row, tr[cdk-row]',
                    template: CDK_ROW_TEMPLATE,
                    host: {
                        'class': 'cdk-row',
                        'role': 'row',
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    encapsulation: core.ViewEncapsulation.None,
                },] },
    ];
    return CdkRow;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * Returns an error to be thrown when attempting to find an unexisting column.
 * \@docs-private
 * @param {?} id Id whose lookup failed.
 * @return {?}
 */
function getTableUnknownColumnError(id) {
    return Error("Could not find column with id \"" + id + "\".");
}
/**
 * Returns an error to be thrown when two column definitions have the same name.
 * \@docs-private
 * @param {?} name
 * @return {?}
 */
function getTableDuplicateColumnNameError(name) {
    return Error("Duplicate column definition name provided: \"" + name + "\".");
}
/**
 * Returns an error to be thrown when there are multiple rows that are missing a when function.
 * \@docs-private
 * @return {?}
 */
function getTableMultipleDefaultRowDefsError() {
    return Error("There can only be one default row without a when predicate function.");
}
/**
 * Returns an error to be thrown when there are no matching row defs for a particular set of data.
 * \@docs-private
 * @param {?} data
 * @return {?}
 */
function getTableMissingMatchingRowDefError(data) {
    return Error("Could not find a matching row definition for the" +
        ("provided row data: " + JSON.stringify(data)));
}
/**
 * Returns an error to be thrown when there is no row definitions present in the content.
 * \@docs-private
 * @return {?}
 */
function getTableMissingRowDefsError() {
    return Error('Missing definitions for header, footer, and row; ' +
        'cannot determine which columns should be rendered.');
}
/**
 * Returns an error to be thrown when the data source does not match the compatible types.
 * \@docs-private
 * @return {?}
 */
function getTableUnknownDataSourceError() {
    return Error("Provided data source did not match an array, Observable, or DataSource");
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * List of all possible directions that can be used for sticky positioning.
 * \@docs-private
 */
var /** @type {?} */ STICKY_DIRECTIONS = ['top', 'bottom', 'left', 'right'];
/**
 * Applies and removes sticky positioning styles to the `CdkTable` rows and columns cells.
 * \@docs-private
 */
var  /**
 * Applies and removes sticky positioning styles to the `CdkTable` rows and columns cells.
 * \@docs-private
 */
StickyStyler = /** @class */ (function () {
    /**
     * @param isNativeHtmlTable Whether the sticky logic should be based on a table
     *     that uses the native `<table>` element.
     * @param stickCellCss The CSS class that will be applied to every row/cell that has
     *     sticky positioning applied.
     * @param direction The directionality context of the table (ltr/rtl); affects column positioning
     *     by reversing left/right positions.
     * @param _isBrowser Whether the table is currently being rendered on the server or the client.
     */
    function StickyStyler(isNativeHtmlTable, stickCellCss, direction, _isBrowser) {
        if (_isBrowser === void 0) { _isBrowser = true; }
        this.isNativeHtmlTable = isNativeHtmlTable;
        this.stickCellCss = stickCellCss;
        this.direction = direction;
        this._isBrowser = _isBrowser;
    }
    /**
     * Clears the sticky positioning styles from the row and its cells by resetting the `position`
     * style, setting the zIndex to 0, and unsetting each provided sticky direction.
     * @param rows The list of rows that should be cleared from sticking in the provided directions
     * @param stickyDirections The directions that should no longer be set as sticky on the rows.
     */
    /**
     * Clears the sticky positioning styles from the row and its cells by resetting the `position`
     * style, setting the zIndex to 0, and unsetting each provided sticky direction.
     * @param {?} rows The list of rows that should be cleared from sticking in the provided directions
     * @param {?} stickyDirections The directions that should no longer be set as sticky on the rows.
     * @return {?}
     */
    StickyStyler.prototype.clearStickyPositioning = /**
     * Clears the sticky positioning styles from the row and its cells by resetting the `position`
     * style, setting the zIndex to 0, and unsetting each provided sticky direction.
     * @param {?} rows The list of rows that should be cleared from sticking in the provided directions
     * @param {?} stickyDirections The directions that should no longer be set as sticky on the rows.
     * @return {?}
     */
    function (rows, stickyDirections) {
        for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {
            var row = rows_1[_i];
            // If the row isn't an element (e.g. if it's an `ng-container`),
            // it won't have inline styles or `children` so we skip it.
            if (row.nodeType !== row.ELEMENT_NODE) {
                continue;
            }
            this._removeStickyStyle(row, stickyDirections);
            for (var /** @type {?} */ i = 0; i < row.children.length; i++) {
                var /** @type {?} */ cell = /** @type {?} */ (row.children[i]);
                this._removeStickyStyle(cell, stickyDirections);
            }
        }
    };
    /**
     * Applies sticky left and right positions to the cells of each row according to the sticky
     * states of the rendered column definitions.
     * @param rows The rows that should have its set of cells stuck according to the sticky states.
     * @param stickyStartStates A list of boolean states where each state represents whether the cell
     *     in this index position should be stuck to the start of the row.
     * @param stickyEndStates A list of boolean states where each state represents whether the cell
     *     in this index position should be stuck to the end of the row.
     */
    /**
     * Applies sticky left and right positions to the cells of each row according to the sticky
     * states of the rendered column definitions.
     * @param {?} rows The rows that should have its set of cells stuck according to the sticky states.
     * @param {?} stickyStartStates A list of boolean states where each state represents whether the cell
     *     in this index position should be stuck to the start of the row.
     * @param {?} stickyEndStates A list of boolean states where each state represents whether the cell
     *     in this index position should be stuck to the end of the row.
     * @return {?}
     */
    StickyStyler.prototype.updateStickyColumns = /**
     * Applies sticky left and right positions to the cells of each row according to the sticky
     * states of the rendered column definitions.
     * @param {?} rows The rows that should have its set of cells stuck according to the sticky states.
     * @param {?} stickyStartStates A list of boolean states where each state represents whether the cell
     *     in this index position should be stuck to the start of the row.
     * @param {?} stickyEndStates A list of boolean states where each state represents whether the cell
     *     in this index position should be stuck to the end of the row.
     * @return {?}
     */
    function (rows, stickyStartStates, stickyEndStates) {
        var /** @type {?} */ hasStickyColumns = stickyStartStates.some(function (state) { return state; }) || stickyEndStates.some(function (state) { return state; });
        if (!rows.length || !hasStickyColumns || !this._isBrowser) {
            return;
        }
        var /** @type {?} */ firstRow = rows[0];
        var /** @type {?} */ numCells = firstRow.children.length;
        var /** @type {?} */ cellWidths = this._getCellWidths(firstRow);
        var /** @type {?} */ startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);
        var /** @type {?} */ endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);
        var /** @type {?} */ isRtl = this.direction === 'rtl';
        for (var _i = 0, rows_2 = rows; _i < rows_2.length; _i++) {
            var row = rows_2[_i];
            for (var /** @type {?} */ i = 0; i < numCells; i++) {
                var /** @type {?} */ cell = /** @type {?} */ (row.children[i]);
                if (stickyStartStates[i]) {
                    this._addStickyStyle(cell, isRtl ? 'right' : 'left', startPositions[i]);
                }
                if (stickyEndStates[i]) {
                    this._addStickyStyle(cell, isRtl ? 'left' : 'right', endPositions[i]);
                }
            }
        }
    };
    /**
     * Applies sticky positioning to the row's cells if using the native table layout, and to the
     * row itself otherwise.
     * @param rowsToStick The list of rows that should be stuck according to their corresponding
     *     sticky state and to the provided top or bottom position.
     * @param stickyStates A list of boolean states where each state represents whether the row
     *     should be stuck in the particular top or bottom position.
     * @param position The position direction in which the row should be stuck if that row should be
     *     sticky.
     *
     */
    /**
     * Applies sticky positioning to the row's cells if using the native table layout, and to the
     * row itself otherwise.
     * @param {?} rowsToStick The list of rows that should be stuck according to their corresponding
     *     sticky state and to the provided top or bottom position.
     * @param {?} stickyStates A list of boolean states where each state represents whether the row
     *     should be stuck in the particular top or bottom position.
     * @param {?} position The position direction in which the row should be stuck if that row should be
     *     sticky.
     *
     * @return {?}
     */
    StickyStyler.prototype.stickRows = /**
     * Applies sticky positioning to the row's cells if using the native table layout, and to the
     * row itself otherwise.
     * @param {?} rowsToStick The list of rows that should be stuck according to their corresponding
     *     sticky state and to the provided top or bottom position.
     * @param {?} stickyStates A list of boolean states where each state represents whether the row
     *     should be stuck in the particular top or bottom position.
     * @param {?} position The position direction in which the row should be stuck if that row should be
     *     sticky.
     *
     * @return {?}
     */
    function (rowsToStick, stickyStates, position) {
        // Since we can't measure the rows on the server, we can't stick the rows properly.
        if (!this._isBrowser) {
            return;
        }
        // If positioning the rows to the bottom, reverse their order when evaluating the sticky
        // position such that the last row stuck will be "bottom: 0px" and so on.
        var /** @type {?} */ rows = position === 'bottom' ? rowsToStick.reverse() : rowsToStick;
        var /** @type {?} */ stickyHeight = 0;
        for (var /** @type {?} */ rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            if (!stickyStates[rowIndex]) {
                continue;
            }
            var /** @type {?} */ row = rows[rowIndex];
            if (this.isNativeHtmlTable) {
                for (var /** @type {?} */ j = 0; j < row.children.length; j++) {
                    var /** @type {?} */ cell = /** @type {?} */ (row.children[j]);
                    this._addStickyStyle(cell, position, stickyHeight);
                }
            }
            else {
                // Flex does not respect the stick positioning on the cells, needs to be applied to the row.
                // If this is applied on a native table, Safari causes the header to fly in wrong direction.
                this._addStickyStyle(row, position, stickyHeight);
            }
            stickyHeight += row.getBoundingClientRect().height;
        }
    };
    /**
     * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
     * footer rows is to apply sticky styling to the tfoot container. This should only be done if
     * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
     * the tfoot element.
     */
    /**
     * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
     * footer rows is to apply sticky styling to the tfoot container. This should only be done if
     * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
     * the tfoot element.
     * @param {?} tableElement
     * @param {?} stickyStates
     * @return {?}
     */
    StickyStyler.prototype.updateStickyFooterContainer = /**
     * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
     * footer rows is to apply sticky styling to the tfoot container. This should only be done if
     * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
     * the tfoot element.
     * @param {?} tableElement
     * @param {?} stickyStates
     * @return {?}
     */
    function (tableElement, stickyStates) {
        if (!this.isNativeHtmlTable) {
            return;
        }
        var /** @type {?} */ tfoot = /** @type {?} */ ((tableElement.querySelector('tfoot')));
        if (stickyStates.some(function (state) { return !state; })) {
            this._removeStickyStyle(tfoot, ['bottom']);
        }
        else {
            this._addStickyStyle(tfoot, 'bottom', 0);
        }
    };
    /**
     * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
     * the zIndex, removing each of the provided sticky directions, and removing the
     * sticky position if there are no more directions.
     */
    /**
     * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
     * the zIndex, removing each of the provided sticky directions, and removing the
     * sticky position if there are no more directions.
     * @param {?} element
     * @param {?} stickyDirections
     * @return {?}
     */
    StickyStyler.prototype._removeStickyStyle = /**
     * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
     * the zIndex, removing each of the provided sticky directions, and removing the
     * sticky position if there are no more directions.
     * @param {?} element
     * @param {?} stickyDirections
     * @return {?}
     */
    function (element, stickyDirections) {
        for (var _i = 0, stickyDirections_1 = stickyDirections; _i < stickyDirections_1.length; _i++) {
            var dir = stickyDirections_1[_i];
            element.style[dir] = '';
        }
        element.style.zIndex = this._getCalculatedZIndex(element);
        // If the element no longer has any more sticky directions, remove sticky positioning and
        // the sticky CSS class.
        var /** @type {?} */ hasDirection = STICKY_DIRECTIONS.some(function (dir) { return !!element.style[dir]; });
        if (!hasDirection) {
            element.style.position = '';
            element.classList.remove(this.stickCellCss);
        }
    };
    /**
     * Adds the sticky styling to the element by adding the sticky style class, changing position
     * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
     * direction and value.
     */
    /**
     * Adds the sticky styling to the element by adding the sticky style class, changing position
     * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
     * direction and value.
     * @param {?} element
     * @param {?} dir
     * @param {?} dirValue
     * @return {?}
     */
    StickyStyler.prototype._addStickyStyle = /**
     * Adds the sticky styling to the element by adding the sticky style class, changing position
     * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
     * direction and value.
     * @param {?} element
     * @param {?} dir
     * @param {?} dirValue
     * @return {?}
     */
    function (element, dir, dirValue) {
        element.classList.add(this.stickCellCss);
        element.style[dir] = dirValue + "px";
        element.style.cssText += 'position: -webkit-sticky; position: sticky; ';
        element.style.zIndex = this._getCalculatedZIndex(element);
    };
    /**
     * Calculate what the z-index should be for the element, depending on what directions (top,
     * bottom, left, right) have been set. It should be true that elements with a top direction
     * should have the highest index since these are elements like a table header. If any of those
     * elements are also sticky in another direction, then they should appear above other elements
     * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
     * (e.g. footer rows) should then be next in the ordering such that they are below the header
     * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
     * should minimally increment so that they are above non-sticky elements but below top and bottom
     * elements.
     */
    /**
     * Calculate what the z-index should be for the element, depending on what directions (top,
     * bottom, left, right) have been set. It should be true that elements with a top direction
     * should have the highest index since these are elements like a table header. If any of those
     * elements are also sticky in another direction, then they should appear above other elements
     * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
     * (e.g. footer rows) should then be next in the ordering such that they are below the header
     * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
     * should minimally increment so that they are above non-sticky elements but below top and bottom
     * elements.
     * @param {?} element
     * @return {?}
     */
    StickyStyler.prototype._getCalculatedZIndex = /**
     * Calculate what the z-index should be for the element, depending on what directions (top,
     * bottom, left, right) have been set. It should be true that elements with a top direction
     * should have the highest index since these are elements like a table header. If any of those
     * elements are also sticky in another direction, then they should appear above other elements
     * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
     * (e.g. footer rows) should then be next in the ordering such that they are below the header
     * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
     * should minimally increment so that they are above non-sticky elements but below top and bottom
     * elements.
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ zIndexIncrements = {
            top: 100,
            bottom: 10,
            left: 1,
            right: 1,
        };
        var /** @type {?} */ zIndex = 0;
        for (var _i = 0, STICKY_DIRECTIONS_1 = STICKY_DIRECTIONS; _i < STICKY_DIRECTIONS_1.length; _i++) {
            var dir = STICKY_DIRECTIONS_1[_i];
            if (element.style[dir]) {
                zIndex += zIndexIncrements[dir];
            }
        }
        return zIndex ? "" + zIndex : '';
    };
    /** Gets the widths for each cell in the provided row. */
    /**
     * Gets the widths for each cell in the provided row.
     * @param {?} row
     * @return {?}
     */
    StickyStyler.prototype._getCellWidths = /**
     * Gets the widths for each cell in the provided row.
     * @param {?} row
     * @return {?}
     */
    function (row) {
        var /** @type {?} */ cellWidths = [];
        var /** @type {?} */ firstRowCells = row.children;
        for (var /** @type {?} */ i = 0; i < firstRowCells.length; i++) {
            var /** @type {?} */ cell = /** @type {?} */ (firstRowCells[i]);
            cellWidths.push(cell.getBoundingClientRect().width);
        }
        return cellWidths;
    };
    /**
     * Determines the left and right positions of each sticky column cell, which will be the
     * accumulation of all sticky column cell widths to the left and right, respectively.
     * Non-sticky cells do not need to have a value set since their positions will not be applied.
     */
    /**
     * Determines the left and right positions of each sticky column cell, which will be the
     * accumulation of all sticky column cell widths to the left and right, respectively.
     * Non-sticky cells do not need to have a value set since their positions will not be applied.
     * @param {?} widths
     * @param {?} stickyStates
     * @return {?}
     */
    StickyStyler.prototype._getStickyStartColumnPositions = /**
     * Determines the left and right positions of each sticky column cell, which will be the
     * accumulation of all sticky column cell widths to the left and right, respectively.
     * Non-sticky cells do not need to have a value set since their positions will not be applied.
     * @param {?} widths
     * @param {?} stickyStates
     * @return {?}
     */
    function (widths, stickyStates) {
        var /** @type {?} */ positions = [];
        var /** @type {?} */ nextPosition = 0;
        for (var /** @type {?} */ i = 0; i < widths.length; i++) {
            if (stickyStates[i]) {
                positions[i] = nextPosition;
                nextPosition += widths[i];
            }
        }
        return positions;
    };
    /**
     * Determines the left and right positions of each sticky column cell, which will be the
     * accumulation of all sticky column cell widths to the left and right, respectively.
     * Non-sticky cells do not need to have a value set since their positions will not be applied.
     */
    /**
     * Determines the left and right positions of each sticky column cell, which will be the
     * accumulation of all sticky column cell widths to the left and right, respectively.
     * Non-sticky cells do not need to have a value set since their positions will not be applied.
     * @param {?} widths
     * @param {?} stickyStates
     * @return {?}
     */
    StickyStyler.prototype._getStickyEndColumnPositions = /**
     * Determines the left and right positions of each sticky column cell, which will be the
     * accumulation of all sticky column cell widths to the left and right, respectively.
     * Non-sticky cells do not need to have a value set since their positions will not be applied.
     * @param {?} widths
     * @param {?} stickyStates
     * @return {?}
     */
    function (widths, stickyStates) {
        var /** @type {?} */ positions = [];
        var /** @type {?} */ nextPosition = 0;
        for (var /** @type {?} */ i = widths.length; i > 0; i--) {
            if (stickyStates[i]) {
                positions[i] = nextPosition;
                nextPosition += widths[i];
            }
        }
        return positions;
    };
    return StickyStyler;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Provides a handle for the table to grab the view container's ng-container to insert data rows.
 * \@docs-private
 */
var DataRowOutlet = /** @class */ (function () {
    function DataRowOutlet(viewContainer, elementRef) {
        this.viewContainer = viewContainer;
        this.elementRef = elementRef;
    }
    DataRowOutlet.decorators = [
        { type: core.Directive, args: [{ selector: '[rowOutlet]' },] },
    ];
    /** @nocollapse */
    DataRowOutlet.ctorParameters = function () { return [
        { type: core.ViewContainerRef, },
        { type: core.ElementRef, },
    ]; };
    return DataRowOutlet;
}());
/**
 * Provides a handle for the table to grab the view container's ng-container to insert the header.
 * \@docs-private
 */
var HeaderRowOutlet = /** @class */ (function () {
    function HeaderRowOutlet(viewContainer, elementRef) {
        this.viewContainer = viewContainer;
        this.elementRef = elementRef;
    }
    HeaderRowOutlet.decorators = [
        { type: core.Directive, args: [{ selector: '[headerRowOutlet]' },] },
    ];
    /** @nocollapse */
    HeaderRowOutlet.ctorParameters = function () { return [
        { type: core.ViewContainerRef, },
        { type: core.ElementRef, },
    ]; };
    return HeaderRowOutlet;
}());
/**
 * Provides a handle for the table to grab the view container's ng-container to insert the footer.
 * \@docs-private
 */
var FooterRowOutlet = /** @class */ (function () {
    function FooterRowOutlet(viewContainer, elementRef) {
        this.viewContainer = viewContainer;
        this.elementRef = elementRef;
    }
    FooterRowOutlet.decorators = [
        { type: core.Directive, args: [{ selector: '[footerRowOutlet]' },] },
    ];
    /** @nocollapse */
    FooterRowOutlet.ctorParameters = function () { return [
        { type: core.ViewContainerRef, },
        { type: core.ElementRef, },
    ]; };
    return FooterRowOutlet;
}());
/**
 * The table template that can be used by the mat-table. Should not be used outside of the
 * material library.
 * \@docs-private
 */
var /** @type {?} */ CDK_TABLE_TEMPLATE = "\n  <ng-container headerRowOutlet></ng-container>\n  <ng-container rowOutlet></ng-container>\n  <ng-container footerRowOutlet></ng-container>";
/**
 * Class used to conveniently type the embedded view ref for rows with a context.
 * \@docs-private
 * @abstract
 * @template T
 */
var /**
 * Class used to conveniently type the embedded view ref for rows with a context.
 * \@docs-private
 * @abstract
 * @template T
 */
RowViewRef = /** @class */ (function (_super) {
    __extends(RowViewRef, _super);
    function RowViewRef() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RowViewRef;
}(core.EmbeddedViewRef));
/**
 * A data table that can render a header row, data rows, and a footer row.
 * Uses the dataSource input to determine the data to be rendered. The data can be provided either
 * as a data array, an Observable stream that emits the data array to render, or a DataSource with a
 * connect function that will return an Observable stream that emits the data array to render.
 * @template T
 */
var CdkTable = /** @class */ (function () {
    function CdkTable(_differs, _changeDetectorRef, _elementRef, role, _dir, /**
                   * @deprecated
                   * @breaking-change 8.0.0 `_document` and `_platform` to
                   *    be made into a required parameters.
                   */
    _document, _platform) {
        this._differs = _differs;
        this._changeDetectorRef = _changeDetectorRef;
        this._elementRef = _elementRef;
        this._dir = _dir;
        this._platform = _platform;
        /**
         * Subject that emits when the component has been destroyed.
         */
        this._onDestroy = new Subject();
        /**
         * Map of all the user's defined columns (header, data, and footer cell template) identified by
         * name. Collection populated by the column definitions gathered by `ContentChildren` as well as
         * any custom column definitions added to `_customColumnDefs`.
         */
        this._columnDefsByName = new Map();
        /**
         * Column definitions that were defined outside of the direct content children of the table.
         * These will be defined when, e.g., creating a wrapper around the cdkTable that has
         * column definitions as *it's* content child.
         */
        this._customColumnDefs = new Set();
        /**
         * Data row definitions that were defined outside of the direct content children of the table.
         * These will be defined when, e.g., creating a wrapper around the cdkTable that has
         * built-in data rows as *it's* content child.
         */
        this._customRowDefs = new Set();
        /**
         * Header row definitions that were defined outside of the direct content children of the table.
         * These will be defined when, e.g., creating a wrapper around the cdkTable that has
         * built-in header rows as *it's* content child.
         */
        this._customHeaderRowDefs = new Set();
        /**
         * Footer row definitions that were defined outside of the direct content children of the table.
         * These will be defined when, e.g., creating a wrapper around the cdkTable that has a
         * built-in footer row as *it's* content child.
         */
        this._customFooterRowDefs = new Set();
        /**
         * Whether the header row definition has been changed. Triggers an update to the header row after
         * content is checked. Initialized as true so that the table renders the initial set of rows.
         */
        this._headerRowDefChanged = true;
        /**
         * Whether the footer row definition has been changed. Triggers an update to the footer row after
         * content is checked. Initialized as true so that the table renders the initial set of rows.
         */
        this._footerRowDefChanged = true;
        /**
         * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing
         * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with
         * the cached `RenderRow` objects when possible, the row identity is preserved when the data
         * and row template matches, which allows the `IterableDiffer` to check rows by reference
         * and understand which rows are added/moved/removed.
         *
         * Implemented as a map of maps where the first key is the `data: T` object and the second is the
         * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that
         * contains an array of created pairs. The array is necessary to handle cases where the data
         * array contains multiple duplicate data objects and each instantiated `RenderRow` must be
         * stored.
         */
        this._cachedRenderRowsMap = new Map();
        /**
         * CSS class added to any row or cell that has sticky positioning applied. May be overriden by
         * table subclasses.
         */
        this.stickyCssClass = 'cdk-table-sticky';
        this._multiTemplateDataRows = false;
        /**
         * Stream containing the latest information on what rows are being displayed on screen.
         * Can be used by the data source to as a heuristic of what data should be provided.
         */
        this.viewChange = new BehaviorSubject({ start: 0, end: Number.MAX_VALUE });
        if (!role) {
            this._elementRef.nativeElement.setAttribute('role', 'grid');
        }
        this._document = _document;
        this._isNativeHtmlTable = this._elementRef.nativeElement.nodeName === 'TABLE';
    }
    Object.defineProperty(CdkTable.prototype, "trackBy", {
        get: /**
         * Tracking function that will be used to check the differences in data changes. Used similarly
         * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data
         * relative to the function to know if a row should be added/removed/moved.
         * Accepts a function that takes two parameters, `index` and `item`.
         * @return {?}
         */
        function () { return this._trackByFn; },
        set: /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            if (core.isDevMode() &&
                fn != null && typeof fn !== 'function' && /** @type {?} */ (console) && /** @type {?} */ (console.warn)) {
                console.warn("trackBy must be a function, but received " + JSON.stringify(fn) + ".");
            }
            this._trackByFn = fn;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkTable.prototype, "dataSource", {
        get: /**
         * The table's source of data, which can be provided in three ways (in order of complexity):
         *   - Simple data array (each object represents one table row)
         *   - Stream that emits a data array each time the array changes
         *   - `DataSource` object that implements the connect/disconnect interface.
         *
         * If a data array is provided, the table must be notified when the array's objects are
         * added, removed, or moved. This can be done by calling the `renderRows()` function which will
         * render the diff since the last table render. If the data array reference is changed, the table
         * will automatically trigger an update to the rows.
         *
         * When providing an Observable stream, the table will trigger an update automatically when the
         * stream emits a new array of data.
         *
         * Finally, when providing a `DataSource` object, the table will use the Observable stream
         * provided by the connect function and trigger updates when that stream emits new data array
         * values. During the table's ngOnDestroy or when the data source is removed from the table, the
         * table will call the DataSource's `disconnect` function (may be useful for cleaning up any
         * subscriptions registered during the connect process).
         * @return {?}
         */
        function () { return this._dataSource; },
        set: /**
         * @param {?} dataSource
         * @return {?}
         */
        function (dataSource) {
            if (this._dataSource !== dataSource) {
                this._switchDataSource(dataSource);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CdkTable.prototype, "multiTemplateDataRows", {
        get: /**
         * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'
         * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each
         * dataobject will render the first row that evaluates its when predicate to true, in the order
         * defined in the table, or otherwise the default row which does not have a when predicate.
         * @return {?}
         */
        function () { return this._multiTemplateDataRows; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this._multiTemplateDataRows = coerceBooleanProperty(v);
            if (this._rowOutlet.viewContainer.length) {
                this._forceRenderDataRows();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CdkTable.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._setupStickyStyler();
        if (this._isNativeHtmlTable) {
            this._applyNativeTableSections();
        }
        // Set up the trackBy function so that it uses the `RenderRow` as its identity by default. If
        // the user has provided a custom trackBy, return the result of that function as evaluated
        // with the values of the `RenderRow`'s data and index.
        this._dataDiffer = this._differs.find([]).create(function (_i, dataRow) {
            return _this.trackBy ? _this.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;
        });
    };
    /**
     * @return {?}
     */
    CdkTable.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        // Cache the row and column definitions gathered by ContentChildren and programmatic injection.
        this._cacheRowDefs();
        this._cacheColumnDefs();
        // Make sure that the user has at least added header, footer, or data row def.
        if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length) {
            throw getTableMissingRowDefsError();
        }
        // Render updates if the list of columns have been changed for the header, row, or footer defs.
        this._renderUpdatedColumns();
        // If the header row definition has been changed, trigger a render to the header row.
        if (this._headerRowDefChanged) {
            this._forceRenderHeaderRows();
            this._headerRowDefChanged = false;
        }
        // If the footer row definition has been changed, trigger a render to the footer row.
        if (this._footerRowDefChanged) {
            this._forceRenderFooterRows();
            this._footerRowDefChanged = false;
        }
        // If there is a data source and row definitions, connect to the data source unless a
        // connection has already been made.
        if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {
            this._observeRenderChanges();
        }
        this._checkStickyStates();
    };
    /**
     * @return {?}
     */
    CdkTable.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._rowOutlet.viewContainer.clear();
        this._headerRowOutlet.viewContainer.clear();
        this._footerRowOutlet.viewContainer.clear();
        this._cachedRenderRowsMap.clear();
        this._onDestroy.next();
        this._onDestroy.complete();
        if (this.dataSource instanceof DataSource) {
            this.dataSource.disconnect(this);
        }
    };
    /**
     * Renders rows based on the table's latest set of data, which was either provided directly as an
     * input or retrieved through an Observable stream (directly or from a DataSource).
     * Checks for differences in the data since the last diff to perform only the necessary
     * changes (add/remove/move rows).
     *
     * If the table's data source is a DataSource or Observable, this will be invoked automatically
     * each time the provided Observable stream emits a new data array. Otherwise if your data is
     * an array, this function will need to be called to render any changes.
     */
    /**
     * Renders rows based on the table's latest set of data, which was either provided directly as an
     * input or retrieved through an Observable stream (directly or from a DataSource).
     * Checks for differences in the data since the last diff to perform only the necessary
     * changes (add/remove/move rows).
     *
     * If the table's data source is a DataSource or Observable, this will be invoked automatically
     * each time the provided Observable stream emits a new data array. Otherwise if your data is
     * an array, this function will need to be called to render any changes.
     * @return {?}
     */
    CdkTable.prototype.renderRows = /**
     * Renders rows based on the table's latest set of data, which was either provided directly as an
     * input or retrieved through an Observable stream (directly or from a DataSource).
     * Checks for differences in the data since the last diff to perform only the necessary
     * changes (add/remove/move rows).
     *
     * If the table's data source is a DataSource or Observable, this will be invoked automatically
     * each time the provided Observable stream emits a new data array. Otherwise if your data is
     * an array, this function will need to be called to render any changes.
     * @return {?}
     */
    function () {
        var _this = this;
        this._renderRows = this._getAllRenderRows();
        var /** @type {?} */ changes = this._dataDiffer.diff(this._renderRows);
        if (!changes) {
            return;
        }
        var /** @type {?} */ viewContainer = this._rowOutlet.viewContainer;
        changes.forEachOperation(function (record, prevIndex, currentIndex) {
            if (record.previousIndex == null) {
                _this._insertRow(record.item, currentIndex);
            }
            else if (currentIndex == null) {
                viewContainer.remove(prevIndex);
            }
            else {
                var /** @type {?} */ view = /** @type {?} */ (viewContainer.get(prevIndex));
                viewContainer.move(/** @type {?} */ ((view)), currentIndex);
            }
        });
        // Update the meta context of a row's context data (index, count, first, last, ...)
        this._updateRowIndexContext();
        // Update rows that did not get added/removed/moved but may have had their identity changed,
        // e.g. if trackBy matched data on some property but the actual data reference changed.
        changes.forEachIdentityChange(function (record) {
            var /** @type {?} */ rowView = /** @type {?} */ (viewContainer.get(/** @type {?} */ ((record.currentIndex))));
            rowView.context.$implicit = record.item.data;
        });
        this.updateStickyColumnStyles();
    };
    /**
     * Sets the header row definition to be used. Overrides the header row definition gathered by
     * using `ContentChild`, if one exists. Sets a flag that will re-render the header row after the
     * table's content is checked.
     * @docs-private
     * @deprecated Use `addHeaderRowDef` and `removeHeaderRowDef` instead
     * @breaking-change 8.0.0
     */
    /**
     * Sets the header row definition to be used. Overrides the header row definition gathered by
     * using `ContentChild`, if one exists. Sets a flag that will re-render the header row after the
     * table's content is checked.
     * \@docs-private
     * @deprecated Use `addHeaderRowDef` and `removeHeaderRowDef` instead
     * \@breaking-change 8.0.0
     * @param {?} headerRowDef
     * @return {?}
     */
    CdkTable.prototype.setHeaderRowDef = /**
     * Sets the header row definition to be used. Overrides the header row definition gathered by
     * using `ContentChild`, if one exists. Sets a flag that will re-render the header row after the
     * table's content is checked.
     * \@docs-private
     * @deprecated Use `addHeaderRowDef` and `removeHeaderRowDef` instead
     * \@breaking-change 8.0.0
     * @param {?} headerRowDef
     * @return {?}
     */
    function (headerRowDef) {
        this._customHeaderRowDefs = new Set([headerRowDef]);
        this._headerRowDefChanged = true;
    };
    /**
     * Sets the footer row definition to be used. Overrides the footer row definition gathered by
     * using `ContentChild`, if one exists. Sets a flag that will re-render the footer row after the
     * table's content is checked.
     * @docs-private
     * @deprecated Use `addFooterRowDef` and `removeFooterRowDef` instead
     * @breaking-change 8.0.0
     */
    /**
     * Sets the footer row definition to be used. Overrides the footer row definition gathered by
     * using `ContentChild`, if one exists. Sets a flag that will re-render the footer row after the
     * table's content is checked.
     * \@docs-private
     * @deprecated Use `addFooterRowDef` and `removeFooterRowDef` instead
     * \@breaking-change 8.0.0
     * @param {?} footerRowDef
     * @return {?}
     */
    CdkTable.prototype.setFooterRowDef = /**
     * Sets the footer row definition to be used. Overrides the footer row definition gathered by
     * using `ContentChild`, if one exists. Sets a flag that will re-render the footer row after the
     * table's content is checked.
     * \@docs-private
     * @deprecated Use `addFooterRowDef` and `removeFooterRowDef` instead
     * \@breaking-change 8.0.0
     * @param {?} footerRowDef
     * @return {?}
     */
    function (footerRowDef) {
        this._customFooterRowDefs = new Set([footerRowDef]);
        this._footerRowDefChanged = true;
    };
    /** Adds a column definition that was not included as part of the content children. */
    /**
     * Adds a column definition that was not included as part of the content children.
     * @param {?} columnDef
     * @return {?}
     */
    CdkTable.prototype.addColumnDef = /**
     * Adds a column definition that was not included as part of the content children.
     * @param {?} columnDef
     * @return {?}
     */
    function (columnDef) {
        this._customColumnDefs.add(columnDef);
    };
    /** Removes a column definition that was not included as part of the content children. */
    /**
     * Removes a column definition that was not included as part of the content children.
     * @param {?} columnDef
     * @return {?}
     */
    CdkTable.prototype.removeColumnDef = /**
     * Removes a column definition that was not included as part of the content children.
     * @param {?} columnDef
     * @return {?}
     */
    function (columnDef) {
        this._customColumnDefs.delete(columnDef);
    };
    /** Adds a row definition that was not included as part of the content children. */
    /**
     * Adds a row definition that was not included as part of the content children.
     * @param {?} rowDef
     * @return {?}
     */
    CdkTable.prototype.addRowDef = /**
     * Adds a row definition that was not included as part of the content children.
     * @param {?} rowDef
     * @return {?}
     */
    function (rowDef) {
        this._customRowDefs.add(rowDef);
    };
    /** Removes a row definition that was not included as part of the content children. */
    /**
     * Removes a row definition that was not included as part of the content children.
     * @param {?} rowDef
     * @return {?}
     */
    CdkTable.prototype.removeRowDef = /**
     * Removes a row definition that was not included as part of the content children.
     * @param {?} rowDef
     * @return {?}
     */
    function (rowDef) {
        this._customRowDefs.delete(rowDef);
    };
    /** Adds a header row definition that was not included as part of the content children. */
    /**
     * Adds a header row definition that was not included as part of the content children.
     * @param {?} headerRowDef
     * @return {?}
     */
    CdkTable.prototype.addHeaderRowDef = /**
     * Adds a header row definition that was not included as part of the content children.
     * @param {?} headerRowDef
     * @return {?}
     */
    function (headerRowDef) {
        this._customHeaderRowDefs.add(headerRowDef);
        this._headerRowDefChanged = true;
    };
    /** Removes a header row definition that was not included as part of the content children. */
    /**
     * Removes a header row definition that was not included as part of the content children.
     * @param {?} headerRowDef
     * @return {?}
     */
    CdkTable.prototype.removeHeaderRowDef = /**
     * Removes a header row definition that was not included as part of the content children.
     * @param {?} headerRowDef
     * @return {?}
     */
    function (headerRowDef) {
        this._customHeaderRowDefs.delete(headerRowDef);
        this._headerRowDefChanged = true;
    };
    /** Adds a footer row definition that was not included as part of the content children. */
    /**
     * Adds a footer row definition that was not included as part of the content children.
     * @param {?} footerRowDef
     * @return {?}
     */
    CdkTable.prototype.addFooterRowDef = /**
     * Adds a footer row definition that was not included as part of the content children.
     * @param {?} footerRowDef
     * @return {?}
     */
    function (footerRowDef) {
        this._customFooterRowDefs.add(footerRowDef);
        this._footerRowDefChanged = true;
    };
    /** Removes a footer row definition that was not included as part of the content children. */
    /**
     * Removes a footer row definition that was not included as part of the content children.
     * @param {?} footerRowDef
     * @return {?}
     */
    CdkTable.prototype.removeFooterRowDef = /**
     * Removes a footer row definition that was not included as part of the content children.
     * @param {?} footerRowDef
     * @return {?}
     */
    function (footerRowDef) {
        this._customFooterRowDefs.delete(footerRowDef);
        this._footerRowDefChanged = true;
    };
    /**
     * Updates the header sticky styles. First resets all applied styles with respect to the cells
     * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
     * automatically called when the header row changes its displayed set of columns, or if its
     * sticky input changes. May be called manually for cases where the cell content changes outside
     * of these events.
     */
    /**
     * Updates the header sticky styles. First resets all applied styles with respect to the cells
     * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
     * automatically called when the header row changes its displayed set of columns, or if its
     * sticky input changes. May be called manually for cases where the cell content changes outside
     * of these events.
     * @return {?}
     */
    CdkTable.prototype.updateStickyHeaderRowStyles = /**
     * Updates the header sticky styles. First resets all applied styles with respect to the cells
     * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
     * automatically called when the header row changes its displayed set of columns, or if its
     * sticky input changes. May be called manually for cases where the cell content changes outside
     * of these events.
     * @return {?}
     */
    function () {
        var /** @type {?} */ headerRows = this._getRenderedRows(this._headerRowOutlet);
        this._stickyStyler.clearStickyPositioning(headerRows, ['top']);
        var /** @type {?} */ stickyStates = this._headerRowDefs.map(function (def) { return def.sticky; });
        this._stickyStyler.stickRows(headerRows, stickyStates, 'top');
        // Reset the dirty state of the sticky input change since it has been used.
        this._headerRowDefs.forEach(function (def) { return def.resetStickyChanged(); });
    };
    /**
     * Updates the footer sticky styles. First resets all applied styles with respect to the cells
     * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
     * automatically called when the footer row changes its displayed set of columns, or if its
     * sticky input changes. May be called manually for cases where the cell content changes outside
     * of these events.
     */
    /**
     * Updates the footer sticky styles. First resets all applied styles with respect to the cells
     * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
     * automatically called when the footer row changes its displayed set of columns, or if its
     * sticky input changes. May be called manually for cases where the cell content changes outside
     * of these events.
     * @return {?}
     */
    CdkTable.prototype.updateStickyFooterRowStyles = /**
     * Updates the footer sticky styles. First resets all applied styles with respect to the cells
     * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
     * automatically called when the footer row changes its displayed set of columns, or if its
     * sticky input changes. May be called manually for cases where the cell content changes outside
     * of these events.
     * @return {?}
     */
    function () {
        var /** @type {?} */ footerRows = this._getRenderedRows(this._footerRowOutlet);
        this._stickyStyler.clearStickyPositioning(footerRows, ['bottom']);
        var /** @type {?} */ stickyStates = this._footerRowDefs.map(function (def) { return def.sticky; });
        this._stickyStyler.stickRows(footerRows, stickyStates, 'bottom');
        this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates);
        // Reset the dirty state of the sticky input change since it has been used.
        this._footerRowDefs.forEach(function (def) { return def.resetStickyChanged(); });
    };
    /**
     * Updates the column sticky styles. First resets all applied styles with respect to the cells
     * sticking to the left and right. Then sticky styles are added for the left and right according
     * to the column definitions for each cell in each row. This is automatically called when
     * the data source provides a new set of data or when a column definition changes its sticky
     * input. May be called manually for cases where the cell content changes outside of these events.
     */
    /**
     * Updates the column sticky styles. First resets all applied styles with respect to the cells
     * sticking to the left and right. Then sticky styles are added for the left and right according
     * to the column definitions for each cell in each row. This is automatically called when
     * the data source provides a new set of data or when a column definition changes its sticky
     * input. May be called manually for cases where the cell content changes outside of these events.
     * @return {?}
     */
    CdkTable.prototype.updateStickyColumnStyles = /**
     * Updates the column sticky styles. First resets all applied styles with respect to the cells
     * sticking to the left and right. Then sticky styles are added for the left and right according
     * to the column definitions for each cell in each row. This is automatically called when
     * the data source provides a new set of data or when a column definition changes its sticky
     * input. May be called manually for cases where the cell content changes outside of these events.
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ headerRows = this._getRenderedRows(this._headerRowOutlet);
        var /** @type {?} */ dataRows = this._getRenderedRows(this._rowOutlet);
        var /** @type {?} */ footerRows = this._getRenderedRows(this._footerRowOutlet);
        // Clear the left and right positioning from all columns in the table across all rows since
        // sticky columns span across all table sections (header, data, footer)
        this._stickyStyler.clearStickyPositioning(headerRows.concat(dataRows, footerRows), ['left', 'right']);
        // Update the sticky styles for each header row depending on the def's sticky state
        headerRows.forEach(function (headerRow, i) {
            _this._addStickyColumnStyles([headerRow], _this._headerRowDefs[i]);
        });
        // Update the sticky styles for each data row depending on its def's sticky state
        this._rowDefs.forEach(function (rowDef) {
            // Collect all the rows rendered with this row definition.
            var /** @type {?} */ rows = [];
            for (var /** @type {?} */ i = 0; i < dataRows.length; i++) {
                if (_this._renderRows[i].rowDef === rowDef) {
                    rows.push(dataRows[i]);
                }
            }
            _this._addStickyColumnStyles(rows, rowDef);
        });
        // Update the sticky styles for each footer row depending on the def's sticky state
        footerRows.forEach(function (footerRow, i) {
            _this._addStickyColumnStyles([footerRow], _this._footerRowDefs[i]);
        });
        // Reset the dirty state of the sticky input change since it has been used.
        Array.from(this._columnDefsByName.values()).forEach(function (def) { return def.resetStickyChanged(); });
    };
    /**
     * Get the list of RenderRow objects to render according to the current list of data and defined
     * row definitions. If the previous list already contained a particular pair, it should be reused
     * so that the differ equates their references.
     * @return {?}
     */
    CdkTable.prototype._getAllRenderRows = /**
     * Get the list of RenderRow objects to render according to the current list of data and defined
     * row definitions. If the previous list already contained a particular pair, it should be reused
     * so that the differ equates their references.
     * @return {?}
     */
    function () {
        var /** @type {?} */ renderRows = [];
        // Store the cache and create a new one. Any re-used RenderRow objects will be moved into the
        // new cache while unused ones can be picked up by garbage collection.
        var /** @type {?} */ prevCachedRenderRows = this._cachedRenderRowsMap;
        this._cachedRenderRowsMap = new Map();
        // For each data object, get the list of rows that should be rendered, represented by the
        // respective `RenderRow` object which is the pair of `data` and `CdkRowDef`.
        for (var /** @type {?} */ i = 0; i < this._data.length; i++) {
            var /** @type {?} */ data = this._data[i];
            var /** @type {?} */ renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));
            if (!this._cachedRenderRowsMap.has(data)) {
                this._cachedRenderRowsMap.set(data, new WeakMap());
            }
            for (var /** @type {?} */ j = 0; j < renderRowsForData.length; j++) {
                var /** @type {?} */ renderRow = renderRowsForData[j];
                var /** @type {?} */ cache = /** @type {?} */ ((this._cachedRenderRowsMap.get(renderRow.data)));
                if (cache.has(renderRow.rowDef)) {
                    /** @type {?} */ ((cache.get(renderRow.rowDef))).push(renderRow);
                }
                else {
                    cache.set(renderRow.rowDef, [renderRow]);
                }
                renderRows.push(renderRow);
            }
        }
        return renderRows;
    };
    /**
     * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that
     * should be rendered for this data. Reuses the cached RenderRow objects if they match the same
     * `(T, CdkRowDef)` pair.
     * @param {?} data
     * @param {?} dataIndex
     * @param {?=} cache
     * @return {?}
     */
    CdkTable.prototype._getRenderRowsForData = /**
     * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that
     * should be rendered for this data. Reuses the cached RenderRow objects if they match the same
     * `(T, CdkRowDef)` pair.
     * @param {?} data
     * @param {?} dataIndex
     * @param {?=} cache
     * @return {?}
     */
    function (data, dataIndex, cache) {
        var /** @type {?} */ rowDefs = this._getRowDefs(data, dataIndex);
        return rowDefs.map(function (rowDef) {
            var /** @type {?} */ cachedRenderRows = (cache && cache.has(rowDef)) ? /** @type {?} */ ((cache.get(rowDef))) : [];
            if (cachedRenderRows.length) {
                var /** @type {?} */ dataRow = /** @type {?} */ ((cachedRenderRows.shift()));
                dataRow.dataIndex = dataIndex;
                return dataRow;
            }
            else {
                return { data: data, rowDef: rowDef, dataIndex: dataIndex };
            }
        });
    };
    /**
     * Update the map containing the content's column definitions.
     * @return {?}
     */
    CdkTable.prototype._cacheColumnDefs = /**
     * Update the map containing the content's column definitions.
     * @return {?}
     */
    function () {
        var _this = this;
        this._columnDefsByName.clear();
        var /** @type {?} */ columnDefs = mergeQueryListAndSet(this._contentColumnDefs, this._customColumnDefs);
        columnDefs.forEach(function (columnDef) {
            if (_this._columnDefsByName.has(columnDef.name)) {
                throw getTableDuplicateColumnNameError(columnDef.name);
            }
            _this._columnDefsByName.set(columnDef.name, columnDef);
        });
    };
    /**
     * Update the list of all available row definitions that can be used.
     * @return {?}
     */
    CdkTable.prototype._cacheRowDefs = /**
     * Update the list of all available row definitions that can be used.
     * @return {?}
     */
    function () {
        this._headerRowDefs =
            mergeQueryListAndSet(this._contentHeaderRowDefs, this._customHeaderRowDefs);
        this._footerRowDefs =
            mergeQueryListAndSet(this._contentFooterRowDefs, this._customFooterRowDefs);
        this._rowDefs =
            mergeQueryListAndSet(this._contentRowDefs, this._customRowDefs);
        // After all row definitions are determined, find the row definition to be considered default.
        var /** @type {?} */ defaultRowDefs = this._rowDefs.filter(function (def) { return !def.when; });
        if (!this.multiTemplateDataRows && defaultRowDefs.length > 1) {
            throw getTableMultipleDefaultRowDefsError();
        }
        this._defaultRowDef = defaultRowDefs[0];
    };
    /**
     * Check if the header, data, or footer rows have changed what columns they want to display or
     * whether the sticky states have changed for the header or footer. If there is a diff, then
     * re-render that section.
     * @return {?}
     */
    CdkTable.prototype._renderUpdatedColumns = /**
     * Check if the header, data, or footer rows have changed what columns they want to display or
     * whether the sticky states have changed for the header or footer. If there is a diff, then
     * re-render that section.
     * @return {?}
     */
    function () {
        var /** @type {?} */ columnsDiffReducer = function (acc, def) { return acc || !!def.getColumnsDiff(); };
        // Force re-render data rows if the list of column definitions have changed.
        if (this._rowDefs.reduce(columnsDiffReducer, false)) {
            this._forceRenderDataRows();
        }
        // Force re-render header/footer rows if the list of column definitions have changed..
        if (this._headerRowDefs.reduce(columnsDiffReducer, false)) {
            this._forceRenderHeaderRows();
        }
        if (this._footerRowDefs.reduce(columnsDiffReducer, false)) {
            this._forceRenderFooterRows();
        }
    };
    /**
     * Switch to the provided data source by resetting the data and unsubscribing from the current
     * render change subscription if one exists. If the data source is null, interpret this by
     * clearing the row outlet. Otherwise start listening for new data.
     * @param {?} dataSource
     * @return {?}
     */
    CdkTable.prototype._switchDataSource = /**
     * Switch to the provided data source by resetting the data and unsubscribing from the current
     * render change subscription if one exists. If the data source is null, interpret this by
     * clearing the row outlet. Otherwise start listening for new data.
     * @param {?} dataSource
     * @return {?}
     */
    function (dataSource) {
        this._data = [];
        if (this.dataSource instanceof DataSource) {
            this.dataSource.disconnect(this);
        }
        // Stop listening for data from the previous data source.
        if (this._renderChangeSubscription) {
            this._renderChangeSubscription.unsubscribe();
            this._renderChangeSubscription = null;
        }
        if (!dataSource) {
            if (this._dataDiffer) {
                this._dataDiffer.diff([]);
            }
            this._rowOutlet.viewContainer.clear();
        }
        this._dataSource = dataSource;
    };
    /**
     * Set up a subscription for the data provided by the data source.
     * @return {?}
     */
    CdkTable.prototype._observeRenderChanges = /**
     * Set up a subscription for the data provided by the data source.
     * @return {?}
     */
    function () {
        var _this = this;
        // If no data source has been set, there is nothing to observe for changes.
        if (!this.dataSource) {
            return;
        }
        var /** @type {?} */ dataStream;
        // Check if the datasource is a DataSource object by observing if it has a connect function.
        // Cannot check this.dataSource['connect'] due to potential property renaming, nor can it
        // checked as an instanceof DataSource<T> since the table should allow for data sources
        // that did not explicitly extend DataSource<T>.
        if ((/** @type {?} */ (this.dataSource)).connect instanceof Function) {
            dataStream = (/** @type {?} */ (this.dataSource)).connect(this);
        }
        else if (this.dataSource instanceof Observable) {
            dataStream = this.dataSource;
        }
        else if (Array.isArray(this.dataSource)) {
            dataStream = of(this.dataSource);
        }
        if (dataStream === undefined) {
            throw getTableUnknownDataSourceError();
        }
        this._renderChangeSubscription = dataStream
            .pipe(takeUntil(this._onDestroy))
            .subscribe(function (data) {
            _this._data = data || [];
            _this.renderRows();
        });
    };
    /**
     * Clears any existing content in the header row outlet and creates a new embedded view
     * in the outlet using the header row definition.
     * @return {?}
     */
    CdkTable.prototype._forceRenderHeaderRows = /**
     * Clears any existing content in the header row outlet and creates a new embedded view
     * in the outlet using the header row definition.
     * @return {?}
     */
    function () {
        var _this = this;
        // Clear the header row outlet if any content exists.
        if (this._headerRowOutlet.viewContainer.length > 0) {
            this._headerRowOutlet.viewContainer.clear();
        }
        this._headerRowDefs.forEach(function (def, i) { return _this._renderRow(_this._headerRowOutlet, def, i); });
        this.updateStickyHeaderRowStyles();
        this.updateStickyColumnStyles();
    };
    /**
     * Clears any existing content in the footer row outlet and creates a new embedded view
     * in the outlet using the footer row definition.
     * @return {?}
     */
    CdkTable.prototype._forceRenderFooterRows = /**
     * Clears any existing content in the footer row outlet and creates a new embedded view
     * in the outlet using the footer row definition.
     * @return {?}
     */
    function () {
        var _this = this;
        // Clear the footer row outlet if any content exists.
        if (this._footerRowOutlet.viewContainer.length > 0) {
            this._footerRowOutlet.viewContainer.clear();
        }
        this._footerRowDefs.forEach(function (def, i) { return _this._renderRow(_this._footerRowOutlet, def, i); });
        this.updateStickyFooterRowStyles();
        this.updateStickyColumnStyles();
    };
    /**
     * Adds the sticky column styles for the rows according to the columns' stick states.
     * @param {?} rows
     * @param {?} rowDef
     * @return {?}
     */
    CdkTable.prototype._addStickyColumnStyles = /**
     * Adds the sticky column styles for the rows according to the columns' stick states.
     * @param {?} rows
     * @param {?} rowDef
     * @return {?}
     */
    function (rows, rowDef) {
        var _this = this;
        var /** @type {?} */ columnDefs = Array.from(rowDef.columns || []).map(function (c) { return ((_this._columnDefsByName.get(c))); });
        var /** @type {?} */ stickyStartStates = columnDefs.map(function (columnDef) { return columnDef.sticky; });
        var /** @type {?} */ stickyEndStates = columnDefs.map(function (columnDef) { return columnDef.stickyEnd; });
        this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates);
    };
    /** Gets the list of rows that have been rendered in the row outlet. */
    /**
     * Gets the list of rows that have been rendered in the row outlet.
     * @param {?} rowOutlet
     * @return {?}
     */
    CdkTable.prototype._getRenderedRows = /**
     * Gets the list of rows that have been rendered in the row outlet.
     * @param {?} rowOutlet
     * @return {?}
     */
    function (rowOutlet) {
        var /** @type {?} */ renderedRows = [];
        for (var /** @type {?} */ i = 0; i < rowOutlet.viewContainer.length; i++) {
            var /** @type {?} */ viewRef = (/** @type {?} */ (((rowOutlet.viewContainer.get(i)))));
            renderedRows.push(viewRef.rootNodes[0]);
        }
        return renderedRows;
    };
    /**
     * Get the matching row definitions that should be used for this row data. If there is only
     * one row definition, it is returned. Otherwise, find the row definitions that has a when
     * predicate that returns true with the data. If none return true, return the default row
     * definition.
     */
    /**
     * Get the matching row definitions that should be used for this row data. If there is only
     * one row definition, it is returned. Otherwise, find the row definitions that has a when
     * predicate that returns true with the data. If none return true, return the default row
     * definition.
     * @param {?} data
     * @param {?} dataIndex
     * @return {?}
     */
    CdkTable.prototype._getRowDefs = /**
     * Get the matching row definitions that should be used for this row data. If there is only
     * one row definition, it is returned. Otherwise, find the row definitions that has a when
     * predicate that returns true with the data. If none return true, return the default row
     * definition.
     * @param {?} data
     * @param {?} dataIndex
     * @return {?}
     */
    function (data, dataIndex) {
        if (this._rowDefs.length == 1) {
            return [this._rowDefs[0]];
        }
        var /** @type {?} */ rowDefs = [];
        if (this.multiTemplateDataRows) {
            rowDefs = this._rowDefs.filter(function (def) { return !def.when || def.when(dataIndex, data); });
        }
        else {
            var /** @type {?} */ rowDef = this._rowDefs.find(function (def) { return def.when && def.when(dataIndex, data); }) || this._defaultRowDef;
            if (rowDef) {
                rowDefs.push(rowDef);
            }
        }
        if (!rowDefs.length) {
            throw getTableMissingMatchingRowDefError(data);
        }
        return rowDefs;
    };
    /**
     * Create the embedded view for the data row template and place it in the correct index location
     * within the data row view container.
     * @param {?} renderRow
     * @param {?} renderIndex
     * @return {?}
     */
    CdkTable.prototype._insertRow = /**
     * Create the embedded view for the data row template and place it in the correct index location
     * within the data row view container.
     * @param {?} renderRow
     * @param {?} renderIndex
     * @return {?}
     */
    function (renderRow, renderIndex) {
        var /** @type {?} */ rowDef = renderRow.rowDef;
        var /** @type {?} */ context = { $implicit: renderRow.data };
        this._renderRow(this._rowOutlet, rowDef, renderIndex, context);
    };
    /**
     * Creates a new row template in the outlet and fills it with the set of cell templates.
     * Optionally takes a context to provide to the row and cells, as well as an optional index
     * of where to place the new row template in the outlet.
     * @param {?} outlet
     * @param {?} rowDef
     * @param {?} index
     * @param {?=} context
     * @return {?}
     */
    CdkTable.prototype._renderRow = /**
     * Creates a new row template in the outlet and fills it with the set of cell templates.
     * Optionally takes a context to provide to the row and cells, as well as an optional index
     * of where to place the new row template in the outlet.
     * @param {?} outlet
     * @param {?} rowDef
     * @param {?} index
     * @param {?=} context
     * @return {?}
     */
    function (outlet, rowDef, index, context) {
        if (context === void 0) { context = {}; }
        // TODO(andrewseguin): enforce that one outlet was instantiated from createEmbeddedView
        outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);
        for (var _a = 0, _b = this._getCellTemplates(rowDef); _a < _b.length; _a++) {
            var cellTemplate = _b[_a];
            if (CdkCellOutlet.mostRecentCellOutlet) {
                CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);
            }
        }
        this._changeDetectorRef.markForCheck();
    };
    /**
     * Updates the index-related context for each row to reflect any changes in the index of the rows,
     * e.g. first/last/even/odd.
     * @return {?}
     */
    CdkTable.prototype._updateRowIndexContext = /**
     * Updates the index-related context for each row to reflect any changes in the index of the rows,
     * e.g. first/last/even/odd.
     * @return {?}
     */
    function () {
        var /** @type {?} */ viewContainer = this._rowOutlet.viewContainer;
        for (var /** @type {?} */ renderIndex = 0, /** @type {?} */ count$$1 = viewContainer.length; renderIndex < count$$1; renderIndex++) {
            var /** @type {?} */ viewRef = /** @type {?} */ (viewContainer.get(renderIndex));
            var /** @type {?} */ context = /** @type {?} */ (viewRef.context);
            context.count = count$$1;
            context.first = renderIndex === 0;
            context.last = renderIndex === count$$1 - 1;
            context.even = renderIndex % 2 === 0;
            context.odd = !context.even;
            if (this.multiTemplateDataRows) {
                context.dataIndex = this._renderRows[renderIndex].dataIndex;
                context.renderIndex = renderIndex;
            }
            else {
                context.index = this._renderRows[renderIndex].dataIndex;
            }
        }
    };
    /**
     * Gets the column definitions for the provided row def.
     * @param {?} rowDef
     * @return {?}
     */
    CdkTable.prototype._getCellTemplates = /**
     * Gets the column definitions for the provided row def.
     * @param {?} rowDef
     * @return {?}
     */
    function (rowDef) {
        var _this = this;
        if (!rowDef || !rowDef.columns) {
            return [];
        }
        return Array.from(rowDef.columns, function (columnId) {
            var /** @type {?} */ column = _this._columnDefsByName.get(columnId);
            if (!column) {
                throw getTableUnknownColumnError(columnId);
            }
            return rowDef.extractCellTemplate(column);
        });
    };
    /**
     * Adds native table sections (e.g. tbody) and moves the row outlets into them.
     * @return {?}
     */
    CdkTable.prototype._applyNativeTableSections = /**
     * Adds native table sections (e.g. tbody) and moves the row outlets into them.
     * @return {?}
     */
    function () {
        var /** @type {?} */ sections = [
            { tag: 'thead', outlet: this._headerRowOutlet },
            { tag: 'tbody', outlet: this._rowOutlet },
            { tag: 'tfoot', outlet: this._footerRowOutlet },
        ];
        for (var _a = 0, sections_1 = sections; _a < sections_1.length; _a++) {
            var section = sections_1[_a];
            // @breaking-change 8.0.0 remove the `|| document` once the `_document` is a required param.
            var /** @type {?} */ documentRef = this._document || document;
            var /** @type {?} */ element = documentRef.createElement(section.tag);
            element.appendChild(section.outlet.elementRef.nativeElement);
            this._elementRef.nativeElement.appendChild(element);
        }
    };
    /**
     * Forces a re-render of the data rows. Should be called in cases where there has been an input
     * change that affects the evaluation of which rows should be rendered, e.g. toggling
     * `multiTemplateDataRows` or adding/removing row definitions.
     * @return {?}
     */
    CdkTable.prototype._forceRenderDataRows = /**
     * Forces a re-render of the data rows. Should be called in cases where there has been an input
     * change that affects the evaluation of which rows should be rendered, e.g. toggling
     * `multiTemplateDataRows` or adding/removing row definitions.
     * @return {?}
     */
    function () {
        this._dataDiffer.diff([]);
        this._rowOutlet.viewContainer.clear();
        this.renderRows();
        this.updateStickyColumnStyles();
    };
    /**
     * Checks if there has been a change in sticky states since last check and applies the correct
     * sticky styles. Since checking resets the "dirty" state, this should only be performed once
     * during a change detection and after the inputs are settled (after content check).
     * @return {?}
     */
    CdkTable.prototype._checkStickyStates = /**
     * Checks if there has been a change in sticky states since last check and applies the correct
     * sticky styles. Since checking resets the "dirty" state, this should only be performed once
     * during a change detection and after the inputs are settled (after content check).
     * @return {?}
     */
    function () {
        var /** @type {?} */ stickyCheckReducer = function (acc, d) {
            return acc || d.hasStickyChanged();
        };
        // Note that the check needs to occur for every definition since it notifies the definition
        // that it can reset its dirty state. Using another operator like `some` may short-circuit
        // remaining definitions and leave them in an unchecked state.
        if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {
            this.updateStickyHeaderRowStyles();
        }
        if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {
            this.updateStickyFooterRowStyles();
        }
        if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {
            this.updateStickyColumnStyles();
        }
    };
    /**
     * Creates the sticky styler that will be used for sticky rows and columns. Listens
     * for directionality changes and provides the latest direction to the styler. Re-applies column
     * stickiness when directionality changes.
     * @return {?}
     */
    CdkTable.prototype._setupStickyStyler = /**
     * Creates the sticky styler that will be used for sticky rows and columns. Listens
     * for directionality changes and provides the latest direction to the styler. Re-applies column
     * stickiness when directionality changes.
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ direction = this._dir ? this._dir.value : 'ltr';
        this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, 
        // @breaking-change 8.0.0 remove the null check for `this._platform`.
        this.stickyCssClass, direction, this._platform ? this._platform.isBrowser : true);
        (this._dir ? this._dir.change : of())
            .pipe(takeUntil(this._onDestroy))
            .subscribe(function (value) {
            _this._stickyStyler.direction = value;
            _this.updateStickyColumnStyles();
        });
    };
    CdkTable.decorators = [
        { type: core.Component, args: [{selector: 'cdk-table, table[cdk-table]',
                    exportAs: 'cdkTable',
                    template: CDK_TABLE_TEMPLATE,
                    host: {
                        'class': 'cdk-table',
                    },
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                },] },
    ];
    /** @nocollapse */
    CdkTable.ctorParameters = function () { return [
        { type: core.IterableDiffers, },
        { type: core.ChangeDetectorRef, },
        { type: core.ElementRef, },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['role',] },] },
        { type: Directionality, decorators: [{ type: core.Optional },] },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] },] },
        { type: Platform, },
    ]; };
    CdkTable.propDecorators = {
        "trackBy": [{ type: core.Input },],
        "dataSource": [{ type: core.Input },],
        "multiTemplateDataRows": [{ type: core.Input },],
        "_rowOutlet": [{ type: core.ViewChild, args: [DataRowOutlet,] },],
        "_headerRowOutlet": [{ type: core.ViewChild, args: [HeaderRowOutlet,] },],
        "_footerRowOutlet": [{ type: core.ViewChild, args: [FooterRowOutlet,] },],
        "_contentColumnDefs": [{ type: core.ContentChildren, args: [CdkColumnDef,] },],
        "_contentRowDefs": [{ type: core.ContentChildren, args: [CdkRowDef,] },],
        "_contentHeaderRowDefs": [{ type: core.ContentChildren, args: [CdkHeaderRowDef,] },],
        "_contentFooterRowDefs": [{ type: core.ContentChildren, args: [CdkFooterRowDef,] },],
    };
    return CdkTable;
}());
/**
 * Utility function that gets a merged list of the entries in a QueryList and values of a Set.
 * @template T
 * @param {?} queryList
 * @param {?} set
 * @return {?}
 */
function mergeQueryListAndSet(queryList, set) {
    return queryList.toArray().concat(Array.from(set));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ EXPORTED_DECLARATIONS = [
    CdkTable,
    CdkRowDef,
    CdkCellDef,
    CdkCellOutlet,
    CdkHeaderCellDef,
    CdkFooterCellDef,
    CdkColumnDef,
    CdkCell,
    CdkRow,
    CdkHeaderCell,
    CdkFooterCell,
    CdkHeaderRow,
    CdkHeaderRowDef,
    CdkFooterRow,
    CdkFooterRowDef,
    DataRowOutlet,
    HeaderRowOutlet,
    FooterRowOutlet,
];
var CdkTableModule = /** @class */ (function () {
    function CdkTableModule() {
    }
    CdkTableModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule],
                    exports: EXPORTED_DECLARATIONS,
                    declarations: EXPORTED_DECLARATIONS
                },] },
    ];
    return CdkTableModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var TimePeriod = {
    AM: 'AM',
    PM: 'PM',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var TimeFormat = {
    TWELVE: 'hh:mm a',
    TWENTY_FOUR: 'HH:mm',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var moment$1 = moment__default;
var TimeAdapter = /** @class */ (function () {
    function TimeAdapter() {
    }
    /**
     * @param {?} time
     * @param {?=} format
     * @return {?}
     */
    TimeAdapter.formatTime = /**
     * @param {?} time
     * @param {?=} format
     * @return {?}
     */
    function (time, format) {
        if (format === void 0) { format = 12; }
        /** @type {?} */
        var timeFormat = format === 24 ? TimeFormat.TWENTY_FOUR : TimeFormat.TWELVE;
        return moment$1(time, TimeFormat.TWELVE).format(timeFormat);
    };
    /**
     * @param {?} time
     * @return {?}
     */
    TimeAdapter.convertTimeToMoment = /**
     * @param {?} time
     * @return {?}
     */
    function (time) {
        return moment$1(time, TimeFormat.TWELVE);
    };
    /**
     * @param {?} time
     * @param {?=} min
     * @param {?=} max
     * @param {?=} granularity
     * @param {?=} minutesGap
     * @return {?}
     */
    TimeAdapter.isTimeAvailable = /**
     * @param {?} time
     * @param {?=} min
     * @param {?=} max
     * @param {?=} granularity
     * @param {?=} minutesGap
     * @return {?}
     */
    function (time, min$$1, max$$1, granularity, minutesGap) {
        if (!time) {
            return;
        }
        /** @type {?} */
        var convertedTime = this.convertTimeToMoment(time);
        /** @type {?} */
        var minutes = convertedTime.minutes();
        if (minutesGap && (minutes % minutesGap !== 0)) {
            throw new Error("Your minutes - " + minutes + " doesn't match your minutesGap - " + minutesGap);
        }
        /** @type {?} */
        var isAfter = (min$$1 && !max$$1)
            && convertedTime.isSameOrAfter(min$$1, granularity);
        /** @type {?} */
        var isBefore = (max$$1 && !min$$1)
            && convertedTime.isSameOrBefore(max$$1, granularity);
        /** @type {?} */
        var isBetween = (min$$1 && max$$1)
            && convertedTime.isBetween(min$$1, max$$1, granularity, '[]');
        /** @type {?} */
        var isAvailable = !min$$1 && !max$$1;
        return isAfter || isBefore || isBetween || isAvailable;
    };
    /***
     *  Format hour according to time format (12 or 24)
     */
    /**
     *
     *  Format hour according to time format (12 or 24)
     * @param {?} currentHour
     * @param {?} format
     * @param {?} period
     * @return {?}
     */
    TimeAdapter.formatHour = /**
     *
     *  Format hour according to time format (12 or 24)
     * @param {?} currentHour
     * @param {?} format
     * @param {?} period
     * @return {?}
     */
    function (currentHour, format, period) {
        if (format === 24) {
            return currentHour;
        }
        /** @type {?} */
        var hour = period === TimePeriod.AM ? currentHour : currentHour + 12;
        if (period === TimePeriod.AM && hour === 12) {
            return 0;
        }
        else if (period === TimePeriod.PM && hour === 24) {
            return 12;
        }
        return hour;
    };
    return TimeAdapter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var moment$2 = moment__default;
/** @type {?} */
var DEFAULT_HOUR = {
    time: 12,
    angle: 360
};
/** @type {?} */
var DEFAULT_MINUTE = {
    time: 0,
    angle: 360
};
var NgxMaterialTimepickerService = /** @class */ (function () {
    function NgxMaterialTimepickerService() {
        this.hourSubject = new BehaviorSubject(DEFAULT_HOUR);
        this.minuteSubject = new BehaviorSubject(DEFAULT_MINUTE);
        this.periodSubject = new BehaviorSubject(TimePeriod.AM);
    }
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "defaultTime", {
        set: /**
         * @private
         * @param {?} time
         * @return {?}
         */
        function (time) {
            /** @type {?} */
            var defaultTime = moment$2(time, TimeFormat.TWENTY_FOUR).toDate();
            if (moment$2(defaultTime).isValid()) {
                this.hour = __assign({}, DEFAULT_HOUR, { time: defaultTime.getHours() });
                this.minute = __assign({}, DEFAULT_MINUTE, { time: defaultTime.getMinutes() });
                this.period = (/** @type {?} */ (time.substr(time.length - 2).toUpperCase()));
            }
            else {
                this.resetTime();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "hour", {
        set: /**
         * @param {?} hour
         * @return {?}
         */
        function (hour) {
            this.hourSubject.next(hour);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "selectedHour", {
        get: /**
         * @return {?}
         */
        function () {
            return this.hourSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "minute", {
        set: /**
         * @param {?} minute
         * @return {?}
         */
        function (minute) {
            this.minuteSubject.next(minute);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "selectedMinute", {
        get: /**
         * @return {?}
         */
        function () {
            return this.minuteSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "period", {
        set: /**
         * @param {?} period
         * @return {?}
         */
        function (period) {
            this.periodSubject.next(period);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerService.prototype, "selectedPeriod", {
        get: /**
         * @return {?}
         */
        function () {
            return this.periodSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} time
     * @param {?} min
     * @param {?} max
     * @param {?} format
     * @param {?=} minutesGap
     * @return {?}
     */
    NgxMaterialTimepickerService.prototype.setDefaultTimeIfAvailable = /**
     * @param {?} time
     * @param {?} min
     * @param {?} max
     * @param {?} format
     * @param {?=} minutesGap
     * @return {?}
     */
    function (time, min$$1, max$$1, format, minutesGap) {
        /* Workaround to double error message*/
        try {
            if (TimeAdapter.isTimeAvailable(time, min$$1, max$$1, 'minutes', minutesGap)) {
                this.defaultTime = TimeAdapter.formatTime(time, format);
            }
        }
        catch (e) {
            console.error(e);
        }
    };
    /**
     * @param {?} format
     * @return {?}
     */
    NgxMaterialTimepickerService.prototype.getFullTime = /**
     * @param {?} format
     * @return {?}
     */
    function (format) {
        /** @type {?} */
        var hour = this.hourSubject.getValue().time;
        /** @type {?} */
        var minute = this.minuteSubject.getValue().time;
        /** @type {?} */
        var period = format === 12 ? this.periodSubject.getValue() : '';
        return TimeAdapter.formatTime(hour + ":" + minute + " " + period, format);
    };
    /**
     * @private
     * @return {?}
     */
    NgxMaterialTimepickerService.prototype.resetTime = /**
     * @private
     * @return {?}
     */
    function () {
        this.hour = __assign({}, DEFAULT_HOUR);
        this.minute = __assign({}, DEFAULT_MINUTE);
        this.period = TimePeriod.AM;
    };
    NgxMaterialTimepickerService.decorators = [
        { type: core.Injectable }
    ];
    return NgxMaterialTimepickerService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var TimeUnit = {
    HOUR: 0,
    MINUTE: 1,
};
TimeUnit[TimeUnit.HOUR] = 'HOUR';
TimeUnit[TimeUnit.MINUTE] = 'MINUTE';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxMaterialTimepickerEventService = /** @class */ (function () {
    function NgxMaterialTimepickerEventService() {
        this.backdropClickSubject = new Subject();
        this.keydownEventSubject = new Subject();
    }
    Object.defineProperty(NgxMaterialTimepickerEventService.prototype, "backdropClick", {
        get: /**
         * @return {?}
         */
        function () {
            return this.backdropClickSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerEventService.prototype, "keydownEvent", {
        get: /**
         * @return {?}
         */
        function () {
            return this.keydownEventSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    NgxMaterialTimepickerEventService.prototype.dispatchEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        switch (event.type) {
            case 'click':
                this.backdropClickSubject.next((/** @type {?} */ (event)));
                break;
            case 'keydown':
                this.keydownEventSubject.next((/** @type {?} */ (event)));
                break;
            default:
                throw new Error('no such event type');
        }
    };
    NgxMaterialTimepickerEventService.decorators = [
        { type: core.Injectable }
    ];
    return NgxMaterialTimepickerEventService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var AnimationState = {
    ENTER: 'enter',
    LEAVE: 'leave',
};
/** @type {?} */
var ESCAPE$1 = 27;
var NgxMaterialTimepickerComponent = /** @class */ (function () {
    function NgxMaterialTimepickerComponent(timepickerService, eventService) {
        var _this = this;
        this.timepickerService = timepickerService;
        this.eventService = eventService;
        this.timeUnit = TimeUnit;
        this.activeTimeUnit = TimeUnit.HOUR;
        this.isOpened = false;
        this.isEsc = true;
        this.timeSet = new core.EventEmitter();
        this.opened = new core.EventEmitter();
        this.closed = new core.EventEmitter();
        this.hourSelected = new core.EventEmitter();
        this.subscriptions = [];
        this.subscriptions.push(merge(this.eventService.backdropClick, this.eventService.keydownEvent.pipe(filter(function (e) { return e.keyCode === ESCAPE$1 && _this.isEsc; })))
            .subscribe(function () { return _this.close(); }));
    }
    Object.defineProperty(NgxMaterialTimepickerComponent.prototype, "minutesGap", {
        get: /**
         * @return {?}
         */
        function () {
            return this._minutesGap;
        },
        set: /**
         * @param {?} gap
         * @return {?}
         */
        function (gap) {
            if (gap == null) {
                return;
            }
            gap = Math.floor(gap);
            this._minutesGap = gap <= 59 ? gap : 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerComponent.prototype, "defaultTime", {
        set: /**
         * @param {?} time
         * @return {?}
         */
        function (time) {
            this.setDefaultTime(time);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerComponent.prototype, "minTime", {
        get: /**
         * @return {?}
         */
        function () {
            return this.timepickerInput && this.timepickerInput.min;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerComponent.prototype, "maxTime", {
        get: /**
         * @return {?}
         */
        function () {
            return this.timepickerInput && this.timepickerInput.max;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerComponent.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.timepickerInput && this.timepickerInput.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxMaterialTimepickerComponent.prototype, "format", {
        get: /**
         * @return {?}
         */
        function () {
            return this.timepickerInput && this.timepickerInput.format;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subscriptions.push(this.timepickerService.selectedHour
            .subscribe(function (hour) { return _this.selectedHour = hour; }));
        this.subscriptions.push(this.timepickerService.selectedMinute
            .subscribe(function (minute) { return _this.selectedMinute = minute; }));
        this.subscriptions.push(this.timepickerService.selectedPeriod
            .subscribe(function (period) { return _this.selectedPeriod = period; }));
    };
    /***
     * Register an input with this timepicker.
     * input - The timepicker input to register with this timepicker
     */
    /**
     *
     * Register an input with this timepicker.
     * input - The timepicker input to register with this timepicker
     * @param {?} input
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.registerInput = /**
     *
     * Register an input with this timepicker.
     * input - The timepicker input to register with this timepicker
     * @param {?} input
     * @return {?}
     */
    function (input) {
        if (this.timepickerInput) {
            throw Error('A Timepicker can only be associated with a single input.');
        }
        this.timepickerInput = input;
    };
    /**
     * @param {?} hour
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.onHourChange = /**
     * @param {?} hour
     * @return {?}
     */
    function (hour) {
        this.timepickerService.hour = hour;
    };
    /**
     * @param {?} hour
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.onHourSelected = /**
     * @param {?} hour
     * @return {?}
     */
    function (hour) {
        this.changeTimeUnit(TimeUnit.MINUTE);
        this.hourSelected.next(hour);
    };
    /**
     * @param {?} minute
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.onMinuteChange = /**
     * @param {?} minute
     * @return {?}
     */
    function (minute) {
        this.timepickerService.minute = minute;
    };
    /**
     * @param {?} period
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.changePeriod = /**
     * @param {?} period
     * @return {?}
     */
    function (period) {
        this.timepickerService.period = period;
    };
    /**
     * @param {?} unit
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.changeTimeUnit = /**
     * @param {?} unit
     * @return {?}
     */
    function (unit) {
        this.activeTimeUnit = unit;
    };
    /**
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.setTime = /**
     * @return {?}
     */
    function () {
        this.timeSet.next(this.timepickerService.getFullTime(this.format));
        this.close();
    };
    /**
     * @param {?} time
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.setDefaultTime = /**
     * @param {?} time
     * @return {?}
     */
    function (time) {
        this.timepickerService.setDefaultTimeIfAvailable(time, (/** @type {?} */ (this.minTime)), (/** @type {?} */ (this.maxTime)), this.format, this.minutesGap);
    };
    /**
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.open = /**
     * @return {?}
     */
    function () {
        this.isOpened = true;
        this.animationState = AnimationState.ENTER;
        this.opened.next();
    };
    /**
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.close = /**
     * @return {?}
     */
    function () {
        this.animationState = AnimationState.LEAVE;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.animationDone = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.phaseName === 'done' && event.toState === AnimationState.LEAVE) {
            this.isOpened = false;
            this.activeTimeUnit = TimeUnit.HOUR;
            this.closed.next();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.onKeydown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.eventService.dispatchEvent(e);
        e.stopPropagation();
    };
    /**
     * @return {?}
     */
    NgxMaterialTimepickerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (subscription) { return subscription.unsubscribe(); });
    };
    NgxMaterialTimepickerComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-material-timepicker',
                    template: "<div class=\"timepicker-backdrop-overlay\" *ngIf=\"isOpened\" [overlay]=\"preventOverlayClick\"></div>\n<div class=\"timepicker-overlay\" *ngIf=\"isOpened\">\n    <div class=\"timepicker\" [@timepicker]=\"animationState\" (@timepicker.done)=\"animationDone($event)\" #timepicker>\n        <header class=\"timepicker__header\">\n            <ngx-material-timepicker-dial [format]=\"format\" [hour]=\"selectedHour?.time\"\n                                          [minute]=\"selectedMinute?.time\"\n                                          [period]=\"selectedPeriod\" [activeTimeUnit]=\"activeTimeUnit\"\n                                          [minTime]=\"minTime\" [maxTime]=\"maxTime\"\n                                          [isEditable]=\"enableKeyboardInput\"\n                                          [editableHintTmpl]=\"editableHintTmpl\"\n                                          [minutesGap]=\"minutesGap\"\n                                          (periodChanged)=\"changePeriod($event)\"\n                                          (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                          (hourChanged)=\"onHourChange($event)\"\n                                          (minuteChanged)=\"onMinuteChange($event)\"\n            ></ngx-material-timepicker-dial>\n        </header>\n        <div class=\"timepicker__main-content\">\n            <div class=\"timepicker__body\" [ngSwitch]=\"activeTimeUnit\">\n                <div *ngSwitchCase=\"timeUnit.HOUR\">\n                    <ngx-material-timepicker-24-hours-face *ngIf=\"format === 24;else ampmHours\"\n                                                           (hourChange)=\"onHourChange($event)\"\n                                                           [selectedHour]=\"selectedHour\"\n                                                           [minTime]=\"minTime\"\n                                                           [maxTime]=\"maxTime\"\n                                                           [format]=\"format\"\n                                                           (hourSelected)=\"onHourSelected($event)\"></ngx-material-timepicker-24-hours-face>\n                    <ng-template #ampmHours>\n                        <ngx-material-timepicker-12-hours-face\n                            (hourChange)=\"onHourChange($event)\"\n                            [selectedHour]=\"selectedHour\"\n                            [period]=\"selectedPeriod\"\n                            [minTime]=\"minTime\"\n                            [maxTime]=\"maxTime\"\n                            (hourSelected)=\"onHourSelected($event)\"></ngx-material-timepicker-12-hours-face>\n                    </ng-template>\n                </div>\n                <ngx-material-timepicker-minutes-face *ngSwitchCase=\"timeUnit.MINUTE\"\n                                                      [selectedMinute]=\"selectedMinute\"\n                                                      [selectedHour]=\"selectedHour?.time\"\n                                                      [minTime]=\"minTime\"\n                                                      [maxTime]=\"maxTime\"\n                                                      [format]=\"format\"\n                                                      [period]=\"selectedPeriod\"\n                                                      [minutesGap]=\"minutesGap\"\n                                                      (minuteChange)=\"onMinuteChange($event)\"></ngx-material-timepicker-minutes-face>\n            </div>\n            <div class=\"timepicker__actions\">\n                <div (click)=\"close()\">\n                    <!--suppress HtmlUnknownAttribute -->\n                    <ng-container *ngTemplateOutlet=\"cancelBtnTmpl ? cancelBtnTmpl : cancelBtnDefault\"></ng-container>\n                </div>\n                <div (click)=\"setTime()\">\n                    <!--suppress HtmlUnknownAttribute -->\n                    <ng-container\n                        *ngTemplateOutlet=\"confirmBtnTmpl ? confirmBtnTmpl : confirmBtnDefault\"></ng-container>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n<ng-template #cancelBtnDefault>\n    <ngx-material-timepicker-button>Cancel</ngx-material-timepicker-button>\n</ng-template>\n<ng-template #confirmBtnDefault>\n    <ngx-material-timepicker-button>Ok</ngx-material-timepicker-button>\n</ng-template>\n",
                    animations: [
                        animations$1.trigger('timepicker', [
                            animations$1.transition("* => " + AnimationState.ENTER, [
                                animations$1.style({ transform: 'translateY(-30%)' }),
                                animations$1.animate('0.2s ease-out', animations$1.style({ transform: 'translateY(0)' }))
                            ]),
                            animations$1.transition(AnimationState.ENTER + " => " + AnimationState.LEAVE, [
                                animations$1.style({ transform: 'translateY(0)', opacity: 1 }),
                                animations$1.animate('0.2s ease-out', animations$1.style({ transform: 'translateY(-30%)', opacity: 0 }))
                            ])
                        ])
                    ],
                    providers: [NgxMaterialTimepickerService],
                    styles: [":host{--body-background-color:#fff;--primary-font-family:'Roboto',sans-serif;--button-color:deepskyblue;--dial-active-color:#fff;--dial-inactive-color:rgba(255, 255, 255, .5);--dial-background-color:deepskyblue;--clock-face-time-active-color:#fff;--clock-face-time-inactive-color:#6c6c6c;--clock-face-inner-time-inactive-color:#929292;--clock-face-time-disabled-color:#c5c5c5;--clock-face-background-color:#f0f0f0;--clock-hand-color:deepskyblue}.timepicker-backdrop-overlay{position:fixed;top:0;bottom:0;right:0;left:0;background-color:rgba(0,0,0,.3);z-index:999;pointer-events:auto}.timepicker-overlay{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;justify-content:center;align-items:center;z-index:999;pointer-events:none}.timepicker{width:300px;border-radius:2px;box-shadow:rgba(0,0,0,.25) 0 14px 45px,rgba(0,0,0,.22) 0 10px 18px;outline:0;position:static;z-index:999;pointer-events:auto}.timepicker__header{padding:15px 30px;background-color:#00bfff}@supports (background-color:var(--dial-background-color)){.timepicker__header{background-color:var(--dial-background-color)}}.timepicker__body{padding:15px 5px;display:flex;justify-content:center;align-items:center;background-color:#fff}@supports (background-color:var(--body-background-color)){.timepicker__body{background-color:var(--body-background-color)}}.timepicker__actions{display:flex;justify-content:flex-end;padding:15px;background-color:#fff}@supports (background-color:var(--body-background-color)){.timepicker__actions{background-color:var(--body-background-color)}}@media (max-device-width:1023px) and (orientation:landscape){.timepicker{display:flex;width:515px}.timepicker__header{display:flex;align-items:center}.timepicker__main-content{display:flex;flex-direction:column;width:100%}.timepicker__actions{padding:5px;margin-top:-1px}}"]
                }] }
    ];
    /** @nocollapse */
    NgxMaterialTimepickerComponent.ctorParameters = function () { return [
        { type: NgxMaterialTimepickerService },
        { type: NgxMaterialTimepickerEventService }
    ]; };
    NgxMaterialTimepickerComponent.propDecorators = {
        cancelBtnTmpl: [{ type: core.Input }],
        editableHintTmpl: [{ type: core.Input }],
        confirmBtnTmpl: [{ type: core.Input }],
        isEsc: [{ type: core.Input, args: ['ESC',] }],
        enableKeyboardInput: [{ type: core.Input }],
        preventOverlayClick: [{ type: core.Input }],
        minutesGap: [{ type: core.Input }],
        defaultTime: [{ type: core.Input }],
        timeSet: [{ type: core.Output }],
        opened: [{ type: core.Output }],
        closed: [{ type: core.Output }],
        hourSelected: [{ type: core.Output }],
        timepickerComponent: [{ type: core.ViewChild, args: ['timepickerww',] }],
        onKeydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }]
    };
    return NgxMaterialTimepickerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* To override a default toggle icon */
var NgxMaterialTimepickerToggleIconDirective = /** @class */ (function () {
    function NgxMaterialTimepickerToggleIconDirective() {
    }
    NgxMaterialTimepickerToggleIconDirective.decorators = [
        { type: core.Directive, args: [{ selector: '[ngxMaterialTimepickerToggleIcon]' },] }
    ];
    return NgxMaterialTimepickerToggleIconDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxMaterialTimepickerToggleComponent = /** @class */ (function () {
    function NgxMaterialTimepickerToggleComponent() {
    }
    Object.defineProperty(NgxMaterialTimepickerToggleComponent.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._disabled === undefined ? this.timepicker.disabled : this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    NgxMaterialTimepickerToggleComponent.prototype.open = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.timepicker) {
            this.timepicker.open();
            event.stopPropagation();
        }
    };
    NgxMaterialTimepickerToggleComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-material-timepicker-toggle',
                    template: "<button class=\"ngx-material-timepicker-toggle\" (click)=\"open($event)\" [disabled]=\"disabled\" type=\"button\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" width=\"24px\" height=\"24px\" *ngIf=\"!customIcon\">\n        <path\n            d=\"M 12 2 C 6.4889971 2 2 6.4889971 2 12 C 2 17.511003                   6.4889971 22 12 22 C 17.511003 22 22 17.511003 22 12 C 22 6.4889971 17.511003 2 12 2 z M 12 4 C 16.430123 4 20 7.5698774 20 12 C 20 16.430123 16.430123 20 12 20 C 7.5698774 20 4 16.430123 4 12 C 4 7.5698774 7.5698774 4 12 4 z M 11 6 L 11 12.414062 L 15.292969 16.707031 L 16.707031 15.292969 L 13 11.585938 L 13 6 L 11 6 z\"/>\n    </svg>\n\n    <ng-content select=\"[ngxMaterialTimepickerToggleIcon]\"></ng-content>\n</button>\n",
                    styles: [".ngx-material-timepicker-toggle{display:flex;justify-content:center;align-items:center;padding:4px;background-color:transparent;border-radius:50%;text-align:center;border:none;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:background-color .3s;cursor:pointer}.ngx-material-timepicker-toggle:focus{background-color:rgba(0,0,0,.07)}"]
                }] }
    ];
    NgxMaterialTimepickerToggleComponent.propDecorators = {
        timepicker: [{ type: core.Input, args: ['for',] }],
        disabled: [{ type: core.Input }],
        customIcon: [{ type: core.ContentChild, args: [NgxMaterialTimepickerToggleIconDirective,] }]
    };
    return NgxMaterialTimepickerToggleComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var VALUE_ACCESSOR = {
    provide: forms.NG_VALUE_ACCESSOR,
    // tslint:disable-next-line
    useExisting: core.forwardRef(function () { return TimepickerDirective; }),
    multi: true
};
var TimepickerDirective = /** @class */ (function () {
    function TimepickerDirective(elementRef) {
        this.elementRef = elementRef;
        this._format = 12;
        this._value = '';
        this.timepickerSubscriptions = [];
        this.onTouched = function () { };
        this.onChange = function () { };
    }
    Object.defineProperty(TimepickerDirective.prototype, "format", {
        get: /**
         * @return {?}
         */
        function () {
            return this._format;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._format = value === 24 ? 24 : 12;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimepickerDirective.prototype, "min", {
        get: /**
         * @return {?}
         */
        function () {
            return this._min;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value === 'string') {
                this._min = TimeAdapter.convertTimeToMoment(value);
                return;
            }
            this._min = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimepickerDirective.prototype, "max", {
        get: /**
         * @return {?}
         */
        function () {
            return this._max;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value === 'string') {
                this._max = TimeAdapter.convertTimeToMoment(value);
                return;
            }
            this._max = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimepickerDirective.prototype, "timepicker", {
        set: /**
         * @param {?} picker
         * @return {?}
         */
        function (picker) {
            this.registerTimepicker(picker);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimepickerDirective.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!value) {
                this._value = '';
                this.updateInputValue();
                return;
            }
            /** @type {?} */
            var time = TimeAdapter.formatTime(value, this._format);
            if (TimeAdapter.isTimeAvailable(time, (/** @type {?} */ (this._min)), (/** @type {?} */ (this._max)), 'minutes', this._timepicker.minutesGap)) {
                this._value = time;
                this.updateInputValue();
                return;
            }
            console.warn('Selected time doesn\'t match min or max value');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimepickerDirective.prototype, "defaultTime", {
        set: /**
         * @private
         * @param {?} time
         * @return {?}
         */
        function (time) {
            this._timepicker.setDefaultTime(time);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    TimepickerDirective.prototype.onInput = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
        this.onChange(value);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    TimepickerDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes['value'] && changes['value'].currentValue) {
            this.defaultTime = changes['value'].currentValue;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TimepickerDirective.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.disableClick) {
            this._timepicker.open();
            event.stopPropagation();
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    TimepickerDirective.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
        this.defaultTime = value;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TimepickerDirective.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TimepickerDirective.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    TimepickerDirective.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    /**
     * @return {?}
     */
    TimepickerDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.timepickerSubscriptions.forEach(function (s) { return s.unsubscribe(); });
    };
    /**
     * @private
     * @param {?} picker
     * @return {?}
     */
    TimepickerDirective.prototype.registerTimepicker = /**
     * @private
     * @param {?} picker
     * @return {?}
     */
    function (picker) {
        var _this = this;
        if (picker) {
            this._timepicker = picker;
            this._timepicker.registerInput(this);
            this.timepickerSubscriptions.push(this._timepicker.timeSet.subscribe(function (time) {
                _this.value = time;
                _this.onChange(_this._value);
                _this.onTouched();
            }));
            this.timepickerSubscriptions.push(this._timepicker.closed.subscribe(function () { return _this.defaultTime = _this._value; }));
        }
        else {
            throw new Error('NgxMaterialTimepickerComponent is not defined.' +
                ' Please make sure you passed the timepicker to ngxTimepicker directive');
        }
    };
    /**
     * @private
     * @return {?}
     */
    TimepickerDirective.prototype.updateInputValue = /**
     * @private
     * @return {?}
     */
    function () {
        this.elementRef.nativeElement.value = this.value;
    };
    TimepickerDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[ngxTimepicker]',
                    providers: [VALUE_ACCESSOR],
                    host: {
                        '[disabled]': 'disabled',
                        '(input)': 'onInput($event.target.value)',
                        '(blur)': 'onTouched()',
                    },
                },] }
    ];
    /** @nocollapse */
    TimepickerDirective.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    TimepickerDirective.propDecorators = {
        format: [{ type: core.Input }],
        min: [{ type: core.Input }],
        max: [{ type: core.Input }],
        timepicker: [{ type: core.Input, args: ['ngxTimepicker',] }],
        value: [{ type: core.Input }],
        disabled: [{ type: core.Input }],
        disableClick: [{ type: core.Input }],
        onClick: [{ type: core.HostListener, args: ['click', ['$event'],] }]
    };
    return TimepickerDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxMaterialTimepickerThemeDirective = /** @class */ (function () {
    function NgxMaterialTimepickerThemeDirective(elementRef) {
        this.element = elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    NgxMaterialTimepickerThemeDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.theme) {
            this.setTheme(this.theme);
        }
    };
    /**
     * @private
     * @param {?} theme
     * @return {?}
     */
    NgxMaterialTimepickerThemeDirective.prototype.setTheme = /**
     * @private
     * @param {?} theme
     * @return {?}
     */
    function (theme) {
        for (var val in theme) {
            if (theme.hasOwnProperty(val)) {
                if (typeof theme[val] === 'string') {
                    for (var prop in theme) {
                        if (theme.hasOwnProperty(prop)) {
                            this.element.style.setProperty("--" + camelCaseToDash(prop), theme[prop]);
                        }
                    }
                    return;
                }
                this.setTheme(theme[val]);
            }
        }
    };
    NgxMaterialTimepickerThemeDirective.decorators = [
        { type: core.Directive, args: [{ selector: '[ngxMaterialTimepickerTheme]' },] }
    ];
    /** @nocollapse */
    NgxMaterialTimepickerThemeDirective.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    NgxMaterialTimepickerThemeDirective.propDecorators = {
        theme: [{ type: core.Input, args: ['ngxMaterialTimepickerTheme',] }]
    };
    return NgxMaterialTimepickerThemeDirective;
}());
/**
 * @param {?} myStr
 * @return {?}
 */
function camelCaseToDash(myStr) {
    return myStr.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var moment$3 = moment__default;
var TimepickerTime;
(function (TimepickerTime) {
    /**
     * @param {?} format
     * @return {?}
     */
    function getHours(format) {
        return Array(format).fill(1).map(function (v, i) {
            /** @type {?} */
            var angleStep = 30;
            /** @type {?} */
            var time = v + i;
            /** @type {?} */
            var angle = angleStep * time;
            return { time: time === 24 ? 0 : time, angle: angle };
        });
    }
    TimepickerTime.getHours = getHours;
    /**
     * @param {?} hours
     * @param {?} config
     * @return {?}
     */
    function disableHours(hours, config$$1) {
        if (config$$1.min || config$$1.max) {
            return hours.map(function (value) {
                /** @type {?} */
                var hour = config$$1.format === 24 ? value.time : TimeAdapter.formatHour(+value.time, config$$1.format, config$$1.period);
                /** @type {?} */
                var currentTime = moment$3().hour(+hour).format(TimeFormat.TWELVE);
                return __assign({}, value, { disabled: !TimeAdapter.isTimeAvailable(currentTime, config$$1.min, config$$1.max, 'hours') });
            });
        }
        return hours;
    }
    TimepickerTime.disableHours = disableHours;
    /**
     * @param {?=} gap
     * @return {?}
     */
    function getMinutes(gap) {
        if (gap === void 0) { gap = 1; }
        /** @type {?} */
        var minutesCount = 60;
        /** @type {?} */
        var angleStep = 360 / minutesCount;
        /** @type {?} */
        var minutes = [];
        for (var i = 0; i < minutesCount; i++) {
            /** @type {?} */
            var angle = angleStep * i;
            if (i % gap === 0) {
                minutes.push({ time: i, angle: angle !== 0 ? angle : 360 });
            }
        }
        return minutes;
    }
    TimepickerTime.getMinutes = getMinutes;
    /**
     * @param {?} minutes
     * @param {?} selectedHour
     * @param {?} config
     * @return {?}
     */
    function disableMinutes(minutes, selectedHour, config$$1) {
        if (config$$1.min || config$$1.max) {
            /** @type {?} */
            var hour_1 = TimeAdapter.formatHour(selectedHour, config$$1.format, config$$1.period);
            return minutes.map(function (value) {
                /** @type {?} */
                var currentTime = moment$3().hour(hour_1).minute(+value.time).format(TimeFormat.TWELVE);
                return __assign({}, value, { disabled: !TimeAdapter.isTimeAvailable(currentTime, config$$1.min, config$$1.max, 'minutes') });
            });
        }
        return minutes;
    }
    TimepickerTime.disableMinutes = disableMinutes;
})(TimepickerTime || (TimepickerTime = {}));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxMaterialTimepickerHoursFace = /** @class */ (function () {
    function NgxMaterialTimepickerHoursFace(format) {
        this.hourChange = new core.EventEmitter();
        this.hourSelected = new core.EventEmitter();
        this.hoursList = [];
        this.hoursList = TimepickerTime.getHours(format);
    }
    /**
     * @param {?} time
     * @return {?}
     */
    NgxMaterialTimepickerHoursFace.prototype.onTimeSelected = /**
     * @param {?} time
     * @return {?}
     */
    function (time) {
        this.hourSelected.next(time);
    };
    NgxMaterialTimepickerHoursFace.propDecorators = {
        selectedHour: [{ type: core.Input }],
        minTime: [{ type: core.Input }],
        maxTime: [{ type: core.Input }],
        format: [{ type: core.Input }],
        hourChange: [{ type: core.Output }],
        hourSelected: [{ type: core.Output }]
    };
    return NgxMaterialTimepickerHoursFace;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxMaterialTimepicker24HoursFaceComponent = /** @class */ (function (_super) {
    __extends(NgxMaterialTimepicker24HoursFaceComponent, _super);
    function NgxMaterialTimepicker24HoursFaceComponent() {
        return _super.call(this, 24) || this;
    }
    /**
     * @return {?}
     */
    NgxMaterialTimepicker24HoursFaceComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.hoursList = TimepickerTime.disableHours(this.hoursList, {
            min: this.minTime,
            max: this.maxTime,
            format: this.format
        });
    };
    NgxMaterialTimepicker24HoursFaceComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-material-timepicker-24-hours-face',
                    template: "<ngx-material-timepicker-face [selectedTime]=\"selectedHour\" [faceTime]=\"hoursList\" [format]=\"format\"\n                              (timeChange)=\"hourChange.next($event)\"\n                              (timeSelected)=\"onTimeSelected($event)\"></ngx-material-timepicker-face>\n"
                }] }
    ];
    /** @nocollapse */
    NgxMaterialTimepicker24HoursFaceComponent.ctorParameters = function () { return []; };
    return NgxMaterialTimepicker24HoursFaceComponent;
}(NgxMaterialTimepickerHoursFace));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxMaterialTimepicker12HoursFaceComponent = /** @class */ (function (_super) {
    __extends(NgxMaterialTimepicker12HoursFaceComponent, _super);
    function NgxMaterialTimepicker12HoursFaceComponent() {
        return _super.call(this, 12) || this;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    NgxMaterialTimepicker12HoursFaceComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes['period'] && changes['period'].currentValue) {
            this.hoursList = TimepickerTime.disableHours(this.hoursList, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    };
    NgxMaterialTimepicker12HoursFaceComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-material-timepicker-12-hours-face',
                    template: "<ngx-material-timepicker-face [selectedTime]=\"selectedHour\" [faceTime]=\"hoursList\"\n                              (timeChange)=\"hourChange.next($event)\" (timeSelected)=\"onTimeSelected($event)\"></ngx-material-timepicker-face>\n"
                }] }
    ];
    /** @nocollapse */
    NgxMaterialTimepicker12HoursFaceComponent.ctorParameters = function () { return []; };
    NgxMaterialTimepicker12HoursFaceComponent.propDecorators = {
        period: [{ type: core.Input }]
    };
    return NgxMaterialTimepicker12HoursFaceComponent;
}(NgxMaterialTimepickerHoursFace));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxMaterialTimepickerMinutesFaceComponent = /** @class */ (function () {
    function NgxMaterialTimepickerMinutesFaceComponent() {
        this.minutesList = [];
        this.timeUnit = TimeUnit;
        this.minuteChange = new core.EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    NgxMaterialTimepickerMinutesFaceComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes['period'] && changes['period'].currentValue) {
            /** @type {?} */
            var minutes = TimepickerTime.getMinutes(this.minutesGap);
            this.minutesList = TimepickerTime.disableMinutes(minutes, this.selectedHour, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    };
    NgxMaterialTimepickerMinutesFaceComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-material-timepicker-minutes-face',
                    template: "<ngx-material-timepicker-face [faceTime]=\"minutesList\" [selectedTime]=\"selectedMinute\"\n                              [minutesGap]=\"minutesGap\"\n                              (timeChange)=\"minuteChange.next($event)\" [unit]=\"timeUnit.MINUTE\"></ngx-material-timepicker-face>\n"
                }] }
    ];
    NgxMaterialTimepickerMinutesFaceComponent.propDecorators = {
        selectedMinute: [{ type: core.Input }],
        selectedHour: [{ type: core.Input }],
        period: [{ type: core.Input }],
        minTime: [{ type: core.Input }],
        maxTime: [{ type: core.Input }],
        format: [{ type: core.Input }],
        minutesGap: [{ type: core.Input }],
        minuteChange: [{ type: core.Output }]
    };
    return NgxMaterialTimepickerMinutesFaceComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var CLOCK_HAND_STYLES = {
    small: {
        height: '75px',
        top: 'calc(50% - 75px)'
    },
    large: {
        height: '103px',
        top: 'calc(50% - 103px)'
    }
};
var NgxMaterialTimepickerFaceComponent = /** @class */ (function () {
    function NgxMaterialTimepickerFaceComponent() {
        this.timeUnit = TimeUnit;
        this.innerClockFaceSize = 85;
        this.timeChange = new core.EventEmitter();
        this.timeSelected = new core.EventEmitter();
    }
    /**
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.setClockHandPosition();
        this.addTouchEvents();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        /** @type {?} */
        var faceTimeChanges = changes['faceTime'];
        /** @type {?} */
        var selectedTimeChanges = changes['selectedTime'];
        if ((faceTimeChanges && faceTimeChanges.currentValue)
            && (selectedTimeChanges && selectedTimeChanges.currentValue)) {
            /* Set time according to passed an input value */
            this.selectedTime = this.faceTime.find(function (time) { return time.time === _this.selectedTime.time; });
        }
        if (selectedTimeChanges && selectedTimeChanges.currentValue) {
            this.setClockHandPosition();
        }
        if (faceTimeChanges && faceTimeChanges.currentValue) {
            // To avoid an error ExpressionChangedAfterItHasBeenCheckedError
            setTimeout(function () { return _this.selectAvailableTime(); });
        }
    };
    /**
     * @param {?} _
     * @param {?} time
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.trackByTime = /**
     * @param {?} _
     * @param {?} time
     * @return {?}
     */
    function (_, time) {
        return time.time;
    };
    /**
     * @param {?} e
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.onMousedown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        e.preventDefault();
        this.isStarted = true;
    };
    /**
     * @param {?} e
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.selectTime = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!this.isStarted && (e instanceof MouseEvent && e.type !== 'click')) {
            return;
        }
        /** @type {?} */
        var clockFaceCords = this.clockFace.nativeElement.getBoundingClientRect();
        /* Get x0 and y0 of the circle */
        /** @type {?} */
        var centerX = clockFaceCords.left + clockFaceCords.width / 2;
        /** @type {?} */
        var centerY = clockFaceCords.top + clockFaceCords.height / 2;
        /* Counting the arctangent and convert it to from radian to deg */
        /** @type {?} */
        var arctangent = Math.atan(Math.abs(e.clientX - centerX) / Math.abs(e.clientY - centerY)) * 180 / Math.PI;
        /* Get angle according to quadrant */
        /** @type {?} */
        var circleAngle = countAngleByCords(centerX, centerY, e.clientX, e.clientY, arctangent);
        /* Check if selected time from the inner clock face (24 hours format only) */
        /** @type {?} */
        var isInnerClockChosen = this.format && this.isInnerClockFace(centerX, centerY, e.clientX, e.clientY);
        /* Round angle according to angle step */
        /** @type {?} */
        var angleStep = this.unit === TimeUnit.MINUTE ? 6 : 30;
        /** @type {?} */
        var roundedAngle = isInnerClockChosen
            ? roundAngle(circleAngle, angleStep) + 360
            : roundAngle(circleAngle, angleStep);
        /** @type {?} */
        var angle = roundedAngle === 0 ? 360 : roundedAngle;
        /** @type {?} */
        var selectedTime = this.faceTime.find(function (val) { return val.angle === angle; });
        if (selectedTime && !selectedTime.disabled) {
            this.timeChange.next(selectedTime);
            /* To let know whether user ended interaction with clock face */
            if (!this.isStarted) {
                this.timeSelected.next(selectedTime.time);
            }
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.onMouseup = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        e.preventDefault();
        this.isStarted = false;
    };
    /**
     * @param {?} hour
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.isHourSelected = /**
     * @param {?} hour
     * @return {?}
     */
    function (hour) {
        return (hour === this.selectedTime.time) && !this.isClockFaceDisabled;
    };
    /**
     * @param {?} minute
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.isMinuteSelected = /**
     * @param {?} minute
     * @return {?}
     */
    function (minute) {
        return ((this.selectedTime.time === minute) && (minute % (this.minutesGap || 5) === 0)) && !this.isClockFaceDisabled;
    };
    /**
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeTouchEvents();
    };
    /**
     * @private
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.addTouchEvents = /**
     * @private
     * @return {?}
     */
    function () {
        this.touchStartHandler = this.onMousedown.bind(this);
        this.touchEndHandler = this.onMouseup.bind(this);
        this.clockFace.nativeElement.addEventListener('touchstart', this.touchStartHandler);
        this.clockFace.nativeElement.addEventListener('touchend', this.touchEndHandler);
    };
    /**
     * @private
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.removeTouchEvents = /**
     * @private
     * @return {?}
     */
    function () {
        this.clockFace.nativeElement.removeEventListener('touchstart', this.touchStartHandler);
        this.clockFace.nativeElement.removeEventListener('touchend', this.touchEndHandler);
    };
    /**
     * @private
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.setClockHandPosition = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.format === 24) {
            if (this.selectedTime.time > 12 || this.selectedTime.time === 0) {
                this.decreaseClockHand();
            }
            else {
                this.increaseClockHand();
            }
        }
        this.clockHand.nativeElement.style.transform = "rotate(" + this.selectedTime.angle + "deg)";
    };
    /**
     * @private
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.selectAvailableTime = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var currentTime = this.faceTime.find(function (time) { return _this.selectedTime.time === time.time; });
        this.isClockFaceDisabled = this.faceTime.every(function (time) { return time.disabled; });
        if ((currentTime && currentTime.disabled) && !this.isClockFaceDisabled) {
            /** @type {?} */
            var availableTime = this.faceTime.find(function (time) { return !time.disabled; });
            this.timeChange.next(availableTime);
        }
    };
    /**
     * @private
     * @param {?} x0
     * @param {?} y0
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.isInnerClockFace = /**
     * @private
     * @param {?} x0
     * @param {?} y0
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    function (x0, y0, x, y) {
        /* Detect whether time from the inner clock face or not (24 format only) */
        return Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)) < this.innerClockFaceSize;
    };
    /**
     * @private
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.decreaseClockHand = /**
     * @private
     * @return {?}
     */
    function () {
        this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.small.height;
        this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.small.top;
    };
    /**
     * @private
     * @return {?}
     */
    NgxMaterialTimepickerFaceComponent.prototype.increaseClockHand = /**
     * @private
     * @return {?}
     */
    function () {
        this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.large.height;
        this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.large.top;
    };
    NgxMaterialTimepickerFaceComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-material-timepicker-face',
                    template: "<div class=\"clock-face\" #clockFace>\n    <div *ngIf=\"unit !== timeUnit.MINUTE;else minutesFace\" class=\"clock-face__container\">\n        <div class=\"clock-face__number clock-face__number--outer\"\n             [style.transform]=\"'rotateZ('+ time.angle +'deg) translateX(-50%)' | styleSanitizer\"\n             *ngFor=\"let time of faceTime.slice(0, 12); trackBy: trackByTime\">\n\t\t\t<span [style.transform]=\"'rotateZ(-'+ time.angle +'deg)' | styleSanitizer\"\n                  [ngClass]=\"{'active': isHourSelected(time.time), 'disabled': time.disabled}\">{{time.time}}</span>\n        </div>\n        <div class=\"clock-face__inner\" *ngIf=\"faceTime.length > 12\"\n             [style.top]=\"'calc(50% - ' + innerClockFaceSize + 'px)'\">\n            <div class=\"clock-face__number clock-face__number--inner\"\n                 [style.transform]=\"'rotateZ('+ time.angle +'deg) translateX(-50%)' | styleSanitizer\"\n                 [style.height.px]=\"innerClockFaceSize\"\n                 *ngFor=\"let time of faceTime.slice(12, 24); trackBy: trackByTime\">\n\t\t\t<span [style.transform]=\"'rotateZ(-'+ time.angle +'deg)' | styleSanitizer\"\n                  [ngClass]=\"{'active': isHourSelected(time.time), 'disabled': time.disabled}\">\n                {{time.time === 0 ? '00' : time.time}}</span>\n            </div>\n        </div>\n    </div>\n\n    <span class=\"clock-face__clock-hand\" [ngClass]=\"{'clock-face__clock-hand_minute': unit === timeUnit.MINUTE}\"\n          #clockHand [hidden]=\"isClockFaceDisabled\"></span>\n</div>\n<ng-template #minutesFace>\n    <div class=\"clock-face__container\">\n        <div class=\"clock-face__number clock-face__number--outer\"\n             [style.transform]=\"'rotateZ('+ time.angle +'deg) translateX(-50%)' | styleSanitizer\"\n             *ngFor=\"let time of faceTime; trackBy: trackByTime\">\n\t<span [style.transform]=\"'rotateZ(-'+ time.angle +'deg)' | styleSanitizer\"\n          [ngClass]=\"{'active': isMinuteSelected(time.time), 'disabled': time.disabled}\">\n\t{{time.time === 0 ? '00' : time.time | minutesFormatter: minutesGap}}</span>\n        </div>\n    </div>\n</ng-template>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [".clock-face{width:290px;height:290px;border-radius:50%;position:relative;display:flex;justify-content:center;padding:20px;box-sizing:border-box;background-color:#f0f0f0}@supports (background-color:var(--clock-face-background-color)){.clock-face{background-color:var(--clock-face-background-color)}}.clock-face__inner{position:absolute}.clock-face__container{margin-left:-2px}.clock-face__number{position:absolute;-webkit-transform-origin:0 100%;transform-origin:0 100%;width:50px;text-align:center;z-index:2}.clock-face__number--outer{height:calc(290px / 2 - 20px)}.clock-face__number--outer>span{font-size:16px;color:#6c6c6c}@supports (color:var(--clock-face-time-inactive-color)){.clock-face__number--outer>span{color:var(--clock-face-time-inactive-color)}}.clock-face__number--inner>span{font-size:14px;color:#929292}@supports (color:var(--clock-face-inner-time-inactive-color)){.clock-face__number--inner>span{color:var(--clock-face-inner-time-inactive-color)}}.clock-face__number>span{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:30px;height:30px;display:flex;justify-content:center;align-items:center;margin:auto;border-radius:50%;font-weight:500;font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.clock-face__number>span{font-family:var(--primary-font-family)}}.clock-face__number>span.active{background-color:#00bfff;color:#fff}@supports (background-color:var(--clock-hand-color)){.clock-face__number>span.active{background-color:var(--clock-hand-color);color:var(--clock-face-time-active-color)}}.clock-face__number>span.disabled{color:#c5c5c5}@supports (color:var(--clock-face-time-disabled-color)){.clock-face__number>span.disabled{color:var(--clock-face-time-disabled-color)}}.clock-face__clock-hand{height:103px;width:2px;-webkit-transform-origin:0 100%;transform-origin:0 100%;position:absolute;top:calc(50% - 103px);z-index:1;background-color:#00bfff}@supports (background-color:var(--clock-hand-color)){.clock-face__clock-hand{background-color:var(--clock-hand-color)}}.clock-face__clock-hand:after{content:'';width:7px;height:7px;border-radius:50%;background-color:inherit;position:absolute;bottom:-3px;left:-3.5px}.clock-face__clock-hand_minute:before{content:'';width:7px;height:7px;background-color:#fff;border-radius:50%;position:absolute;top:-8px;left:calc(50% - 8px);box-sizing:content-box;border:4px solid #00bfff}@supports (border-color:var(--clock-hand-color)){.clock-face__clock-hand_minute:before{border-color:var(--clock-hand-color)}}@media (max-device-width:1023px) and (orientation:landscape){.clock-face{width:225px;height:225px;padding:5px}.clock-face__number--outer{height:calc(225px / 2 - 5px)}.clock-face__clock-hand_minute:before{top:0}}"]
                }] }
    ];
    NgxMaterialTimepickerFaceComponent.propDecorators = {
        faceTime: [{ type: core.Input }],
        selectedTime: [{ type: core.Input }],
        unit: [{ type: core.Input }],
        format: [{ type: core.Input }],
        minutesGap: [{ type: core.Input }],
        timeChange: [{ type: core.Output }],
        timeSelected: [{ type: core.Output }],
        clockFace: [{ type: core.ViewChild, args: ['clockFace',] }],
        clockHand: [{ type: core.ViewChild, args: ['clockHand',] }],
        onMousedown: [{ type: core.HostListener, args: ['mousedown', ['$event'],] }],
        selectTime: [{ type: core.HostListener, args: ['click', ['$event'],] }, { type: core.HostListener, args: ['touchmove', ['$event.changedTouches[0]'],] }, { type: core.HostListener, args: ['touchend', ['$event.changedTouches[0]'],] }, { type: core.HostListener, args: ['mousemove', ['$event'],] }],
        onMouseup: [{ type: core.HostListener, args: ['mouseup', ['$event'],] }]
    };
    return NgxMaterialTimepickerFaceComponent;
}());
/**
 * @param {?} angle
 * @param {?} step
 * @return {?}
 */
function roundAngle(angle, step) {
    return Math.round(angle / step) * step;
}
/**
 * @param {?} x0
 * @param {?} y0
 * @param {?} x
 * @param {?} y
 * @param {?} currentAngle
 * @return {?}
 */
function countAngleByCords(x0, y0, x, y, currentAngle) {
    if (y > y0 && x >= x0) { // II quarter
        return 180 - currentAngle;
    }
    else if (y > y0 && x < x0) { // III quarter
        return 180 + currentAngle;
    }
    else if (y < y0 && x < x0) { // IV quarter
        return 360 - currentAngle;
    }
    else { // I quarter
        return currentAngle;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxMaterialTimepickerButtonComponent = /** @class */ (function () {
    function NgxMaterialTimepickerButtonComponent() {
    }
    NgxMaterialTimepickerButtonComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-material-timepicker-button',
                    template: "<button class=\"timepicker-button\" type=\"button\">\n  <span><ng-content></ng-content></span>\n</button>\n",
                    styles: [".timepicker-button{display:inline-block;height:36px;min-width:88px;line-height:36px;border:12px;border-radius:2px;background-color:transparent;text-align:center;transition:450ms cubic-bezier(.23,1,.32,1);overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;cursor:pointer;outline:0;color:#00bfff}@supports (color:var(--button-color)){.timepicker-button{color:var(--button-color)}}.timepicker-button:focus,.timepicker-button:hover{background-color:rgba(153,153,153,.2)}.timepicker-button>span{font-size:14px;text-transform:uppercase;font-weight:600;padding-left:16px;padding-right:16px;font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-button>span{font-family:var(--primary-font-family)}}"]
                }] }
    ];
    return NgxMaterialTimepickerButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxMaterialTimepickerDialComponent = /** @class */ (function () {
    function NgxMaterialTimepickerDialComponent() {
        this.timeUnit = TimeUnit;
        this.periodChanged = new core.EventEmitter();
        this.timeUnitChanged = new core.EventEmitter();
        this.hourChanged = new core.EventEmitter();
        this.minuteChanged = new core.EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    NgxMaterialTimepickerDialComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes['period'] && changes['period'].currentValue
            || changes['format'] && changes['format'].currentValue) {
            /** @type {?} */
            var hours = TimepickerTime.getHours(this.format);
            this.hours = TimepickerTime.disableHours(hours, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
        if (changes['period'] && changes['period'].currentValue
            || changes['hour'] && changes['hour'].currentValue) {
            /** @type {?} */
            var minutes = TimepickerTime.getMinutes(this.minutesGap);
            this.minutes = TimepickerTime.disableMinutes(minutes, +this.hour, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    };
    /**
     * @param {?} unit
     * @return {?}
     */
    NgxMaterialTimepickerDialComponent.prototype.changeTimeUnit = /**
     * @param {?} unit
     * @return {?}
     */
    function (unit) {
        this.timeUnitChanged.next(unit);
    };
    /**
     * @param {?} period
     * @return {?}
     */
    NgxMaterialTimepickerDialComponent.prototype.changePeriod = /**
     * @param {?} period
     * @return {?}
     */
    function (period) {
        this.periodChanged.next(period);
    };
    /**
     * @param {?} hour
     * @return {?}
     */
    NgxMaterialTimepickerDialComponent.prototype.changeHour = /**
     * @param {?} hour
     * @return {?}
     */
    function (hour) {
        this.hourChanged.next(hour);
    };
    /**
     * @param {?} minute
     * @return {?}
     */
    NgxMaterialTimepickerDialComponent.prototype.changeMinute = /**
     * @param {?} minute
     * @return {?}
     */
    function (minute) {
        this.minuteChanged.next(minute);
    };
    /**
     * @return {?}
     */
    NgxMaterialTimepickerDialComponent.prototype.showHint = /**
     * @return {?}
     */
    function () {
        this.isHintVisible = true;
    };
    /**
     * @return {?}
     */
    NgxMaterialTimepickerDialComponent.prototype.hideHint = /**
     * @return {?}
     */
    function () {
        this.isHintVisible = false;
    };
    NgxMaterialTimepickerDialComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-material-timepicker-dial',
                    template: "<div class=\"timepicker-dial\">\n    <div class=\"timepicker-dial__container\">\n        <div class=\"timepicker-dial__time\">\n            <ngx-material-timepicker-dial-control [timeList]=\"hours\" [time]=\"hour\" [timeUnit]=\"timeUnit.HOUR\"\n                                                  [isActive]=\"activeTimeUnit === timeUnit.HOUR\"\n                                                  [isEditable]=\"isEditable\"\n                                                  (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                                  (timeChanged)=\"changeHour($event)\"\n                                                  (focused)=\"showHint()\"\n                                                  (unfocused)=\"hideHint()\">\n\n            </ngx-material-timepicker-dial-control>\n            <span>:</span>\n            <ngx-material-timepicker-dial-control [timeList]=\"minutes\" [time]=\"minute\" [timeUnit]=\"timeUnit.MINUTE\"\n                                                  [isActive]=\"activeTimeUnit === timeUnit.MINUTE\"\n                                                  [isEditable]=\"isEditable\"\n                                                  [minutesGap]=\"minutesGap\"\n                                                  (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                                  (timeChanged)=\"changeMinute($event)\"\n                                                  (focused)=\"showHint()\"\n                                                  (unfocused)=\"hideHint()\">\n\n            </ngx-material-timepicker-dial-control>\n        </div>\n        <ngx-material-timepicker-period class=\"timepicker-dial__period\"\n                                        [ngClass]=\"{'timepicker-dial__period--hidden': format === 24}\"\n                                        [selectedPeriod]=\"period\" [activeTimeUnit]=\"activeTimeUnit\"\n                                        [maxTime]=\"maxTime\" [minTime]=\"minTime\" [format]=\"format\"\n                                        [hours]=\"hours\" [minutes]=\"minutes\" [selectedHour]=\"hour\"\n                                        (periodChanged)=\"changePeriod($event)\"></ngx-material-timepicker-period>\n    </div>\n    <div *ngIf=\"isEditable\" [ngClass]=\"{'timepicker-dial__hint-container--hidden': !isHintVisible}\">\n        <!--suppress HtmlUnknownAttribute -->\n        <ng-container *ngTemplateOutlet=\"editableHintTmpl ? editableHintTmpl : editableHintDefault\"></ng-container>\n        <ng-template #editableHintDefault>\n            <small class=\"timepicker-dial__hint\"> * use arrows (<span>&#8645;</span>) to change the time</small>\n        </ng-template>\n    </div>\n</div>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [".timepicker-dial{text-align:right}.timepicker-dial__container{display:flex;align-items:center;justify-content:flex-end;-webkit-tap-highlight-color:transparent}.timepicker-dial__time{display:flex;align-items:baseline;line-height:normal;font-size:50px;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-dial__time{font-family:var(--primary-font-family);color:var(--dial-inactive-color)}}.timepicker-dial__period{display:block;margin-left:10px}.timepicker-dial__hint-container--hidden,.timepicker-dial__period--hidden{visibility:hidden}.timepicker-dial__hint{display:inline-block;font-size:10px;color:#fff}@supports (color:var(--dial-active-color)){.timepicker-dial__hint{color:var(--dial-active-color)}}.timepicker-dial__hint span{font-size:14px}@media (max-device-width:1023px) and (orientation:landscape){.timepicker-dial__container{flex-direction:column}.timepicker-dial__period{margin-left:0}}"]
                }] }
    ];
    NgxMaterialTimepickerDialComponent.propDecorators = {
        editableHintTmpl: [{ type: core.Input }],
        hour: [{ type: core.Input }],
        minute: [{ type: core.Input }],
        format: [{ type: core.Input }],
        period: [{ type: core.Input }],
        activeTimeUnit: [{ type: core.Input }],
        minTime: [{ type: core.Input }],
        maxTime: [{ type: core.Input }],
        isEditable: [{ type: core.Input }],
        minutesGap: [{ type: core.Input }],
        periodChanged: [{ type: core.Output }],
        timeUnitChanged: [{ type: core.Output }],
        hourChanged: [{ type: core.Output }],
        minuteChanged: [{ type: core.Output }]
    };
    return NgxMaterialTimepickerDialComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TimeFormatterPipe = /** @class */ (function () {
    function TimeFormatterPipe() {
    }
    /**
     * @param {?} time
     * @param {?} timeUnit
     * @return {?}
     */
    TimeFormatterPipe.prototype.transform = /**
     * @param {?} time
     * @param {?} timeUnit
     * @return {?}
     */
    function (time, timeUnit) {
        if (time === undefined) {
            return time;
        }
        switch (timeUnit) {
            case TimeUnit.HOUR:
                return moment__default.utc(time * 3600 * 1000).format('HH');
            case TimeUnit.MINUTE:
                return moment__default.utc(time * 60 * 1000).format('mm');
            default:
                throw new Error('no such time unit');
        }
    };
    TimeFormatterPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'timeFormatter'
                },] }
    ];
    return TimeFormatterPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxMaterialTimepickerDialControlComponent = /** @class */ (function () {
    function NgxMaterialTimepickerDialControlComponent() {
        this.timeUnitChanged = new core.EventEmitter();
        this.timeChanged = new core.EventEmitter();
        this.focused = new core.EventEmitter();
        this.unfocused = new core.EventEmitter();
    }
    Object.defineProperty(NgxMaterialTimepickerDialControlComponent.prototype, "selectedTime", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (!!this.time) {
                return this.timeList.find(function (t) { return t.time === +_this.time; });
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    NgxMaterialTimepickerDialControlComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes['time'] && (changes['time'].currentValue !== undefined)) {
            if (this.isEditable && !changes['time'].firstChange) {
                return;
            }
            this.time = new TimeFormatterPipe().transform(+changes['time'].currentValue, this.timeUnit);
        }
    };
    /**
     * @param {?} event
     * @param {?} unit
     * @return {?}
     */
    NgxMaterialTimepickerDialControlComponent.prototype.saveTimeAndChangeTimeUnit = /**
     * @param {?} event
     * @param {?} unit
     * @return {?}
     */
    function (event, unit) {
        event.preventDefault();
        this.previousTime = this.time;
        this.timeUnitChanged.next(unit);
        this.focused.next();
    };
    /**
     * @return {?}
     */
    NgxMaterialTimepickerDialControlComponent.prototype.updateTime = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var time = this.selectedTime;
        if (time) {
            this.timeChanged.next(time);
            this.previousTime = time.time;
        }
    };
    /**
     * @return {?}
     */
    NgxMaterialTimepickerDialControlComponent.prototype.formatTime = /**
     * @return {?}
     */
    function () {
        if (this.isEditable) {
            /** @type {?} */
            var time = this.time || this.previousTime;
            this.time = new TimeFormatterPipe().transform(+time, this.timeUnit);
            this.unfocused.next();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    NgxMaterialTimepickerDialControlComponent.prototype.onKeyDown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        /** @type {?} */
        var char = String.fromCharCode(e.keyCode);
        if ((!isInputAllowed(e)) || isTimeDisabledToChange(this.time, char, this.timeList)) {
            e.preventDefault();
        }
        if (isInputAllowed(e)) {
            this.changeTimeByArrow(e.keyCode);
        }
    };
    /**
     * @private
     * @param {?} keyCode
     * @return {?}
     */
    NgxMaterialTimepickerDialControlComponent.prototype.changeTimeByArrow = /**
     * @private
     * @param {?} keyCode
     * @return {?}
     */
    function (keyCode) {
        /** @type {?} */
        var ARROW_UP = 38;
        /** @type {?} */
        var ARROW_DOWN = 40;
        /** @type {?} */
        var time;
        if (keyCode === ARROW_UP) {
            time = String(+this.time + (this.minutesGap || 1));
        }
        else if (keyCode === ARROW_DOWN) {
            time = String(+this.time - (this.minutesGap || 1));
        }
        if (!isTimeUnavailable(time, this.timeList)) {
            this.time = time;
            this.updateTime();
        }
    };
    NgxMaterialTimepickerDialControlComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-material-timepicker-dial-control',
                    template: "<!--suppress HtmlFormInputWithoutLabel -->\n<input class=\"timepicker-dial__control timepicker-dial__item\"\n       [ngClass]=\"{'timepicker-dial__item_active': isActive, 'timepicker-dial__control_editable': isEditable}\"\n       [(ngModel)]=\"time\" (input)=\"updateTime()\" (focus)=\"saveTimeAndChangeTimeUnit($event, timeUnit)\"\n       (blur)=\"formatTime()\" [readonly]=\"!isEditable\" [timepickerAutofocus]=\"isActive\" (keydown)=\"onKeyDown($event)\">\n",
                    styles: [".timepicker-dial__item{cursor:pointer;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-dial__item{font-family:var(--primary-font-family);color:var(--dial-inactive-color)}}.timepicker-dial__item_active{color:#fff}@supports (color:var(--dial-active-color)){.timepicker-dial__item_active{color:var(--dial-active-color)}}.timepicker-dial__control{border:none;background-color:transparent;font-size:50px;width:60px;padding:0;border-radius:3px}.timepicker-dial__control_editable:focus{color:#00bfff;background-color:#fff;outline:#00bfff}"]
                }] }
    ];
    NgxMaterialTimepickerDialControlComponent.propDecorators = {
        timeList: [{ type: core.Input }],
        timeUnit: [{ type: core.Input }],
        time: [{ type: core.Input }],
        isActive: [{ type: core.Input }],
        isEditable: [{ type: core.Input }],
        minutesGap: [{ type: core.Input }],
        timeUnitChanged: [{ type: core.Output }],
        timeChanged: [{ type: core.Output }],
        focused: [{ type: core.Output }],
        unfocused: [{ type: core.Output }]
    };
    return NgxMaterialTimepickerDialControlComponent;
}());
/**
 * @param {?} e
 * @return {?}
 */
function isInputAllowed(e) {
    // Allow: backspace, delete, tab, escape, enter
    if ([46, 8, 9, 27, 13].some(function (n) { return n === e.keyCode; }) ||
        // Allow: Ctrl/cmd+A
        (e.keyCode == 65 && (e.ctrlKey === true || e.metaKey === true)) ||
        // Allow: Ctrl/cmd+C
        (e.keyCode == 67 && (e.ctrlKey === true || e.metaKey === true)) ||
        // Allow: Ctrl/cmd+X
        (e.keyCode == 88 && (e.ctrlKey === true || e.metaKey === true)) ||
        // Allow: home, end, left, right, up, down
        (e.keyCode >= 35 && e.keyCode <= 40)) {
        return true;
    }
    return !((e.keyCode < 48 || e.keyCode > 57) && (e.keyCode < 96 || e.keyCode > 105));
}
/**
 * @param {?} currentTime
 * @param {?} nextTime
 * @param {?} timeList
 * @return {?}
 */
function isTimeDisabledToChange(currentTime, nextTime, timeList) {
    /** @type {?} */
    var isNumber = /\d/.test(nextTime);
    if (isNumber) {
        /** @type {?} */
        var time = currentTime + nextTime;
        return isTimeUnavailable(time, timeList);
    }
}
/**
 * @param {?} time
 * @param {?} timeList
 * @return {?}
 */
function isTimeUnavailable(time, timeList) {
    /** @type {?} */
    var selectedTime = timeList.find(function (value) { return value.time === +time; });
    return !selectedTime || (selectedTime && selectedTime.disabled);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxMaterialTimepickerPeriodComponent = /** @class */ (function () {
    function NgxMaterialTimepickerPeriodComponent() {
        this.timePeriod = TimePeriod;
        this.isPeriodAvailable = true;
        this.periodChanged = new core.EventEmitter();
    }
    /**
     * @param {?} period
     * @return {?}
     */
    NgxMaterialTimepickerPeriodComponent.prototype.changePeriod = /**
     * @param {?} period
     * @return {?}
     */
    function (period) {
        this.isPeriodAvailable = this.isSwitchPeriodAvailable(period);
        if (this.isPeriodAvailable) {
            this.periodChanged.next(period);
        }
    };
    /**
     * @return {?}
     */
    NgxMaterialTimepickerPeriodComponent.prototype.animationDone = /**
     * @return {?}
     */
    function () {
        this.isPeriodAvailable = true;
    };
    /**
     * @private
     * @param {?} period
     * @return {?}
     */
    NgxMaterialTimepickerPeriodComponent.prototype.isSwitchPeriodAvailable = /**
     * @private
     * @param {?} period
     * @return {?}
     */
    function (period) {
        /** @type {?} */
        var time = this.getDisabledTimeByPeriod(period);
        return !time.every(function (t) { return t.disabled; });
    };
    /**
     * @private
     * @param {?} period
     * @return {?}
     */
    NgxMaterialTimepickerPeriodComponent.prototype.getDisabledTimeByPeriod = /**
     * @private
     * @param {?} period
     * @return {?}
     */
    function (period) {
        switch (this.activeTimeUnit) {
            case TimeUnit.HOUR:
                return TimepickerTime.disableHours(this.hours, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period: period
                });
            case TimeUnit.MINUTE:
                return TimepickerTime.disableMinutes(this.minutes, +this.selectedHour, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period: period
                });
            default:
                throw new Error('no such TimeUnit');
        }
    };
    NgxMaterialTimepickerPeriodComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-material-timepicker-period',
                    template: "<div class=\"timepicker-period\">\n\t\t\t<button class=\"timepicker-dial__item timepicker-period__btn\"\n                  [ngClass]=\"{'timepicker-dial__item_active': selectedPeriod === timePeriod.AM}\"\n                  (click)=\"changePeriod(timePeriod.AM)\"\n                  type=\"button\">AM</button>\n    <button class=\"timepicker-dial__item timepicker-period__btn\"\n          [ngClass]=\"{'timepicker-dial__item_active': selectedPeriod === timePeriod.PM}\"\n          (click)=\"changePeriod(timePeriod.PM)\"\n          type=\"button\">PM</button>\n    <div class=\"timepicker-period__warning\" [@scaleInOut] (@scaleInOut.done)=\"animationDone()\" *ngIf=\"!isPeriodAvailable\">\n        <p>Current time would be invalid in this period.</p>\n    </div>\n</div>\n",
                    animations: [
                        animations$1.trigger('scaleInOut', [
                            animations$1.transition(':enter', [
                                animations$1.style({ transform: 'scale(0)' }),
                                animations$1.animate('.2s', animations$1.style({ transform: 'scale(1)' })),
                                animations$1.sequence([
                                    animations$1.animate('3s', animations$1.style({ opacity: 1 })),
                                    animations$1.animate('.3s', animations$1.style({ opacity: 0 }))
                                ])
                            ])
                        ])
                    ],
                    styles: [".timepicker-dial__item{cursor:pointer;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-dial__item{font-family:var(--primary-font-family);color:var(--dial-inactive-color)}}.timepicker-dial__item_active{color:#fff}@supports (color:var(--dial-active-color)){.timepicker-dial__item_active{color:var(--dial-active-color)}}.timepicker-period{display:flex;flex-direction:column;position:relative}.timepicker-period__btn{padding:1px 3px;border:0;background-color:transparent;font-size:18px;font-weight:500;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border-radius:3px;transition:background-color .5s;font-family:Roboto,sans-serif}.timepicker-period__btn:focus{background-color:rgba(0,0,0,.07)}.timepicker-period__warning{padding:5px 10px;border-radius:3px;background-color:rgba(0,0,0,.55);color:#fff;position:absolute;width:200px;left:-20px;top:40px}.timepicker-period__warning>p{margin:0;font-size:12px;font-family:Roboto,sans-serif}@supports (font-family:var(--primary-font-family)){.timepicker-period__btn,.timepicker-period__warning>p{font-family:var(--primary-font-family)}}"]
                }] }
    ];
    NgxMaterialTimepickerPeriodComponent.propDecorators = {
        selectedPeriod: [{ type: core.Input }],
        format: [{ type: core.Input }],
        activeTimeUnit: [{ type: core.Input }],
        hours: [{ type: core.Input }],
        minutes: [{ type: core.Input }],
        minTime: [{ type: core.Input }],
        maxTime: [{ type: core.Input }],
        selectedHour: [{ type: core.Input }],
        periodChanged: [{ type: core.Output }]
    };
    return NgxMaterialTimepickerPeriodComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StyleSanitizerPipe = /** @class */ (function () {
    function StyleSanitizerPipe(domSanitizer) {
        this.domSanitizer = domSanitizer;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    StyleSanitizerPipe.prototype.transform = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!value) {
            return value;
        }
        return this.domSanitizer.bypassSecurityTrustStyle(value);
    };
    StyleSanitizerPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'styleSanitizer'
                },] }
    ];
    /** @nocollapse */
    StyleSanitizerPipe.ctorParameters = function () { return [
        { type: platformBrowser.DomSanitizer }
    ]; };
    return StyleSanitizerPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OverlayDirective = /** @class */ (function () {
    function OverlayDirective(eventService) {
        this.eventService = eventService;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    OverlayDirective.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!this.preventClick) {
            this.eventService.dispatchEvent(e);
        }
        e.preventDefault();
    };
    OverlayDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[overlay]'
                },] }
    ];
    /** @nocollapse */
    OverlayDirective.ctorParameters = function () { return [
        { type: NgxMaterialTimepickerEventService }
    ]; };
    OverlayDirective.propDecorators = {
        preventClick: [{ type: core.Input, args: ['overlay',] }],
        onClick: [{ type: core.HostListener, args: ['click', ['$event'],] }]
    };
    return OverlayDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MinutesFormatterPipe = /** @class */ (function () {
    function MinutesFormatterPipe() {
    }
    /**
     * @param {?} minute
     * @param {?=} gap
     * @return {?}
     */
    MinutesFormatterPipe.prototype.transform = /**
     * @param {?} minute
     * @param {?=} gap
     * @return {?}
     */
    function (minute, gap) {
        if (gap === void 0) { gap = 5; }
        if (!minute) {
            return minute;
        }
        return minute % gap === 0 ? minute : '';
    };
    MinutesFormatterPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'minutesFormatter'
                },] }
    ];
    return MinutesFormatterPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AutofocusDirective = /** @class */ (function () {
    function AutofocusDirective(element, document) {
        this.element = element;
        this.document = document;
        this.activeElement = this.document.activeElement;
    }
    /**
     * @return {?}
     */
    AutofocusDirective.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isFocusActive) {
            // To avoid ExpressionChangedAfterItHasBeenCheckedError;
            setTimeout(function () { return _this.element.nativeElement.focus(); });
        }
    };
    /**
     * @return {?}
     */
    AutofocusDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // To avoid ExpressionChangedAfterItHasBeenCheckedError;
        setTimeout(function () { return _this.activeElement.focus(); });
    };
    AutofocusDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[timepickerAutofocus]'
                },] }
    ];
    /** @nocollapse */
    AutofocusDirective.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
    ]; };
    AutofocusDirective.propDecorators = {
        isFocusActive: [{ type: core.Input, args: ['timepickerAutofocus',] }]
    };
    return AutofocusDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxMaterialTimepickerModule = /** @class */ (function () {
    function NgxMaterialTimepickerModule() {
    }
    /**
     * @return {?}
     */
    NgxMaterialTimepickerModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: NgxMaterialTimepickerModule,
            providers: [NgxMaterialTimepickerService, NgxMaterialTimepickerEventService]
        };
    };
    NgxMaterialTimepickerModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule
                    ],
                    exports: [
                        NgxMaterialTimepickerComponent,
                        NgxMaterialTimepickerToggleComponent,
                        TimepickerDirective,
                        NgxMaterialTimepickerToggleIconDirective,
                        NgxMaterialTimepickerThemeDirective
                    ],
                    declarations: [
                        NgxMaterialTimepickerComponent,
                        NgxMaterialTimepicker24HoursFaceComponent,
                        NgxMaterialTimepicker12HoursFaceComponent,
                        NgxMaterialTimepickerMinutesFaceComponent,
                        NgxMaterialTimepickerFaceComponent,
                        NgxMaterialTimepickerToggleComponent,
                        NgxMaterialTimepickerButtonComponent,
                        NgxMaterialTimepickerDialComponent,
                        NgxMaterialTimepickerDialControlComponent,
                        NgxMaterialTimepickerPeriodComponent,
                        StyleSanitizerPipe,
                        TimeFormatterPipe,
                        TimepickerDirective,
                        OverlayDirective,
                        NgxMaterialTimepickerToggleIconDirective,
                        AutofocusDirective,
                        MinutesFormatterPipe,
                        NgxMaterialTimepickerThemeDirective
                    ]
                },] }
    ];
    return NgxMaterialTimepickerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function noop$1() {
    //nothing to do
}
var ObservableWrapper = /** @class */ (function () {
    function ObservableWrapper() {
    }
    // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg
    /**
     * @template T
     * @param {?} emitter
     * @param {?} onNext
     * @param {?=} onError
     * @param {?=} onComplete
     * @return {?}
     */
    ObservableWrapper.subscribe = /**
     * @template T
     * @param {?} emitter
     * @param {?} onNext
     * @param {?=} onError
     * @param {?=} onComplete
     * @return {?}
     */
    function (emitter, onNext, onError, onComplete) {
        if (onComplete === void 0) { onComplete = function () {
            //nothing to do
        }; }
        onError = (typeof onError === 'function') && onError || noop$1;
        onComplete = (typeof onComplete === 'function') && onComplete || noop$1;
        return emitter.subscribe({ next: onNext, error: onError, complete: onComplete });
    };
    /**
     * @param {?} obs
     * @return {?}
     */
    ObservableWrapper.isObservable = /**
     * @param {?} obs
     * @return {?}
     */
    function (obs) { return !!obs.subscribe; };
    /**
     * Returns whether `obs` has any subscribers listening to events.
     */
    /**
     * Returns whether `obs` has any subscribers listening to events.
     * @param {?} obs
     * @return {?}
     */
    ObservableWrapper.hasSubscribers = /**
     * Returns whether `obs` has any subscribers listening to events.
     * @param {?} obs
     * @return {?}
     */
    function (obs) { return obs.observers.length > 0; };
    /**
     * @param {?} subscription
     * @return {?}
     */
    ObservableWrapper.dispose = /**
     * @param {?} subscription
     * @return {?}
     */
    function (subscription) { subscription.unsubscribe(); };
    /**
     * @deprecated - use callEmit() instead
     */
    /**
     * @deprecated - use callEmit() instead
     * @param {?} emitter
     * @param {?} value
     * @return {?}
     */
    ObservableWrapper.callNext = /**
     * @deprecated - use callEmit() instead
     * @param {?} emitter
     * @param {?} value
     * @return {?}
     */
    function (emitter, value) { emitter.emit(value); };
    /**
     * @param {?} emitter
     * @param {?} value
     * @return {?}
     */
    ObservableWrapper.callEmit = /**
     * @param {?} emitter
     * @param {?} value
     * @return {?}
     */
    function (emitter, value) { emitter.emit(value); };
    /**
     * @param {?} emitter
     * @param {?} error
     * @return {?}
     */
    ObservableWrapper.callError = /**
     * @param {?} emitter
     * @param {?} error
     * @return {?}
     */
    function (emitter, error) { emitter.error(error); };
    /**
     * @param {?} emitter
     * @return {?}
     */
    ObservableWrapper.callComplete = /**
     * @param {?} emitter
     * @return {?}
     */
    function (emitter) { emitter.complete(); };
    return ObservableWrapper;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var Base64 = /** @class */ (function () {
    function Base64() {
    }
    /**
     * @param {?} s
     * @return {?}
     */
    Base64.decode = /**
     * @param {?} s
     * @return {?}
     */
    function (s) {
        /** @type {?} */
        var pads = 0;
        /** @type {?} */
        var i;
        /** @type {?} */
        var b10;
        /** @type {?} */
        var imax = s.length;
        /** @type {?} */
        var x = [];
        s = String(s);
        if (imax === 0) {
            return s;
        }
        if (s.charAt(imax - 1) === this.PADCHAR) {
            pads = 1;
            if (s.charAt(imax - 2) === this.PADCHAR) {
                pads = 2;
            }
            imax -= 4;
        }
        for (i = 0; i < imax; i += 4) {
            b10 = (this.getByte64(s, i) << 18) | (this.getByte64(s, i + 1) << 12) | (this.getByte64(s, i + 2) << 6) | this.getByte64(s, i + 3);
            x.push(String.fromCharCode(b10 >> 16, (b10 >> 8) & 255, b10 & 255));
        }
        switch (pads) {
            case 1:
                b10 = (this.getByte64(s, i) << 18) | (this.getByte64(s, i + 1) << 12) | (this.getByte64(s, i + 2) << 6);
                x.push(String.fromCharCode(b10 >> 16, (b10 >> 8) & 255));
                break;
            case 2:
                b10 = (this.getByte64(s, i) << 18) | (this.getByte64(s, i + 1) << 12);
                x.push(String.fromCharCode(b10 >> 16));
                break;
        }
        return x.join('');
    };
    /**
     * @param {?} s
     * @return {?}
     */
    Base64.encode = /**
     * @param {?} s
     * @return {?}
     */
    function (s) {
        s = String(s);
        /** @type {?} */
        var i;
        /** @type {?} */
        var b10;
        /** @type {?} */
        var x = [];
        /** @type {?} */
        var imax = s.length - s.length % 3;
        if (s.length === 0) {
            return s;
        }
        for (i = 0; i < imax; i += 3) {
            b10 = (this.getByte(s, i) << 16) | (this.getByte(s, i + 1) << 8) | this.getByte(s, i + 2);
            x.push(this.ALPHA.charAt(b10 >> 18));
            x.push(this.ALPHA.charAt((b10 >> 12) & 63));
            x.push(this.ALPHA.charAt((b10 >> 6) & 63));
            x.push(this.ALPHA.charAt(b10 & 63));
        }
        switch (s.length - imax) {
            case 1:
                b10 = this.getByte(s, i) << 16;
                x.push(this.ALPHA.charAt(b10 >> 18) + this.ALPHA.charAt((b10 >> 12) & 63) + this.PADCHAR + this.PADCHAR);
                break;
            case 2:
                b10 = (this.getByte(s, i) << 16) | (this.getByte(s, i + 1) << 8);
                x.push(this.ALPHA.charAt(b10 >> 18) + this.ALPHA.charAt((b10 >> 12) & 63) + this.ALPHA.charAt((b10 >> 6) & 63) + this.PADCHAR);
                break;
        }
        return x.join('');
    };
    /**
     * @param {?} s
     * @param {?} i
     * @return {?}
     */
    Base64.getByte = /**
     * @param {?} s
     * @param {?} i
     * @return {?}
     */
    function (s, i) {
        /** @type {?} */
        var x = s.charCodeAt(i);
        return x;
    };
    /**
     * @param {?} s
     * @param {?} i
     * @return {?}
     */
    Base64.getByte64 = /**
     * @param {?} s
     * @param {?} i
     * @return {?}
     */
    function (s, i) {
        /** @type {?} */
        var idx = this.ALPHA.indexOf(s.charAt(i));
        return idx;
    };
    Base64.PADCHAR = '=';
    Base64.ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    return Base64;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Events is a pub/sub style event system for sending and responding to application-level
 * events across your app.
 * \@usage
 * ```ts
 * // first page (publish an event when a user is created)
 * function createUser(user) {
 *   console.log('User created!')
 *   events.publish('user:created', user);
 * }
 *
 * // second page (listen for the user created event)
 * events.subscribe('user:created', (user) => {
 *   console.log('Welcome', user);
 * });
 *
 * ```
 */
var   /**
 * Events is a pub/sub style event system for sending and responding to application-level
 * events across your app.
 * \@usage
 * ```ts
 * // first page (publish an event when a user is created)
 * function createUser(user) {
 *   console.log('User created!')
 *   events.publish('user:created', user);
 * }
 *
 * // second page (listen for the user created event)
 * events.subscribe('user:created', (user) => {
 *   console.log('Welcome', user);
 * });
 *
 * ```
 */
Events = /** @class */ (function () {
    function Events() {
        this._channels = [];
    }
    /**
     * Subscribe to an event topic. Events that get posted to that topic
     * will trigger the provided handler.
     *
     * @param topic the topic to subscribe to
     * @param handler the event handler
     */
    /**
     * Subscribe to an event topic. Events that get posted to that topic
     * will trigger the provided handler.
     *
     * @param {?} topic the topic to subscribe to
     * @param {...?} handlers
     * @return {?}
     */
    Events.prototype.subscribe = /**
     * Subscribe to an event topic. Events that get posted to that topic
     * will trigger the provided handler.
     *
     * @param {?} topic the topic to subscribe to
     * @param {...?} handlers
     * @return {?}
     */
    function (topic) {
        var _this = this;
        var handlers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            handlers[_i - 1] = arguments[_i];
        }
        if (!this._channels[topic]) {
            this._channels[topic] = [];
        }
        handlers.forEach(function (handler) {
            _this._channels[topic].push(handler);
        });
    };
    /**
     * Unsubscribe from the given topic. Your handler will
     * no longer receive events published to this topic.
     *
     * @param topic the topic to unsubscribe from
     * @param handler the event handler
     *
     * @return true if a handler was removed
     */
    /**
     * Unsubscribe from the given topic. Your handler will
     * no longer receive events published to this topic.
     *
     * @param {?} topic the topic to unsubscribe from
     * @param {?} handler the event handler
     *
     * @return {?} true if a handler was removed
     */
    Events.prototype.unsubscribe = /**
     * Unsubscribe from the given topic. Your handler will
     * no longer receive events published to this topic.
     *
     * @param {?} topic the topic to unsubscribe from
     * @param {?} handler the event handler
     *
     * @return {?} true if a handler was removed
     */
    function (topic, handler) {
        /** @type {?} */
        var t = this._channels[topic];
        if (!t) {
            // Wasn't found, wasn't removed
            return false;
        }
        if (!handler) {
            // Remove all handlers for this topic
            delete this._channels[topic];
            return true;
        }
        /** @type {?} */
        var i = t.indexOf(handler);
        if (i < 0) {
            // Wasn't found, wasn't removed
            return false;
        }
        t.splice(i, 1);
        // If the channel is empty now, remove it from the channel map
        if (!t.length) {
            delete this._channels[topic];
        }
        return true;
    };
    /**
     * Publish an event to the given topic.
     *
     * @param topic the topic to publish to
     * @param eventData the data to send as the event
     */
    /**
     * Publish an event to the given topic.
     *
     * @param {?} topic the topic to publish to
     * @param {...?} args
     * @return {?}
     */
    Events.prototype.publish = /**
     * Publish an event to the given topic.
     *
     * @param {?} topic the topic to publish to
     * @param {...?} args
     * @return {?}
     */
    function (topic) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        /** @type {?} */
        var t = this._channels[topic];
        if (!t) {
            return null;
        }
        /** @type {?} */
        var responses = [];
        t.forEach(function (handler) {
            responses.push(handler(args));
        });
        return responses;
    };
    return Events;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var Codes = /** @class */ (function () {
    function Codes() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    Codes.isDoubleClickMode = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return Codes.DETAIL_MODE_DBLCLICK_VALUES.indexOf(value) !== -1;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    Codes.isValidRowHeight = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return Codes.AVAILABLE_ROW_HEIGHTS_VALUES.indexOf(value) !== -1;
    };
    /**
     * @return {?}
     */
    Codes.getIsDetailObject = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var res = {};
        res[Codes.IS_DETAIL] = 'true';
        return res;
    };
    /**
     * @param {?} format
     * @return {?}
     */
    Codes.formatString = /**
     * @param {?} format
     * @return {?}
     */
    function (format) {
        return (format === Codes.TWENTY_FOUR_HOUR_FORMAT ? Codes.HourFormat.TWENTY_FOUR : Codes.HourFormat.TWELVE);
    };
    /**
     * @param {?} e
     * @return {?}
     */
    Codes.isHourInputAllowed = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        // Allow: backspace, delete, tab, escape, enter
        if ([46, 8, 9, 27, 13].some(function (n) { return n === e.keyCode; }) ||
            (e.key === ':') ||
            // Allow: Ctrl/cmd+A
            (e.keyCode === 65 && (e.ctrlKey === true || e.metaKey === true)) ||
            // Allow: Ctrl/cmd+C
            (e.keyCode === 67 && (e.ctrlKey === true || e.metaKey === true)) ||
            // Allow: Ctrl/cmd+X
            (e.keyCode === 88 && (e.ctrlKey === true || e.metaKey === true)) ||
            // Allow: home, end, left, right, up, down
            (e.keyCode >= 35 && e.keyCode <= 40)) {
            return true;
        }
        return !((e.keyCode < 48 || e.keyCode > 57) && (e.keyCode < 96 || e.keyCode > 105));
    };
    Codes.PAGINATED_QUERY_METHOD = 'advancedQuery';
    Codes.DELETE_METHOD = 'delete';
    Codes.INSERT_METHOD = 'insert';
    Codes.UPDATE_METHOD = 'update';
    Codes.QUERY_METHOD = 'query';
    Codes.DEFAULT_QUERY_ROWS = 10;
    Codes.DETAIL_ICON = 'chevron_right';
    Codes.EDIT_ICON = 'mode_edit';
    Codes.DEFAULT_ROW_HEIGHT = 'medium';
    Codes.AVAILABLE_ROW_HEIGHTS_VALUES = ['small', 'medium', 'large'];
    Codes.DETAIL_MODE_NONE = 'none';
    Codes.DETAIL_MODE_CLICK = 'click';
    Codes.DETAIL_MODE_DBLCLICK_VALUES = ['dblclick', 'doubleclick'];
    Codes.EDITION_MODE_NONE = 'none';
    Codes.EDITION_MODE_CLICK = 'click';
    Codes.EDITION_MODE_DBLCLICK_VALUES = ['dblclick', 'doubleclick'];
    Codes.SELECTION_MODE_NONE = 'none';
    Codes.SELECTION_MODE_SINGLE = 'single';
    Codes.SELECTION_MODE_MULTIPLE = 'multiple';
    Codes.EXPORT_MODE_VISIBLE = 'visible';
    Codes.EXPORT_MODE_ALL = 'all';
    Codes.HYPHEN_SEPARATOR = '-';
    Codes.SPACE_SEPARATOR = ' ';
    Codes.COLUMNS_ALIAS_SEPARATOR = ':';
    Codes.ARRAY_INPUT_SEPARATOR = ';';
    Codes.TYPE_SEPARATOR = ':';
    Codes.VALUES_SEPARATOR = '=';
    Codes.ASC_SORT = 'asc';
    Codes.DESC_SORT = 'desc';
    Codes.TYPE_INT = 'int';
    Codes.ROUTE_SEPARATOR = '/';
    Codes.ROUTE_VARIABLE_CHAR = ':';
    Codes.PARENT_KEYS_KEY = 'pk';
    Codes.QUERY_PARAMS = 'queryParams';
    Codes.IS_DETAIL = 'isdetail';
    Codes.SESSION_KEY = 'session';
    Codes.SESSION_EXPIRED_KEY = 'session-expired';
    Codes.LOGIN_ROUTE = '/login';
    Codes.FORBIDDEN_ROUTE = '403';
    Codes.DEFAULT_EDIT_ROUTE = 'edit';
    Codes.DEFAULT_DETAIL_ROUTE = undefined;
    Codes.DEFAULT_INSERT_ROUTE = 'new';
    Codes.IGNORE_CAN_DEACTIVATE = 'ignore_can_deactivate';
    Codes.ONTIMIZE_SUCCESSFUL_CODE = 0;
    Codes.ONTIMIZE_FAILED_CODE = 1;
    Codes.ONTIMIZE_UNAUTHORIZED_CODE = 3;
    Codes.ICON_POSITION_LEFT = 'left';
    Codes.ICON_POSITION_RIGHT = 'right';
    Codes.COLUMN_TITLE_ALIGN_START = 'start';
    Codes.COLUMN_TITLE_ALIGN_CENTER = 'center';
    Codes.COLUMN_TITLE_ALIGN_END = 'end';
    Codes.COLUMN_TITLE_ALIGN_AUTO = 'auto';
    Codes.AVAILABLE_COLUMN_TITLE_ALIGNS = [Codes.COLUMN_TITLE_ALIGN_START, Codes.COLUMN_TITLE_ALIGN_CENTER, Codes.COLUMN_TITLE_ALIGN_END, Codes.COLUMN_TITLE_ALIGN_AUTO];
    Codes.O_MAT_ERROR_STANDARD = 'standard';
    Codes.O_MAT_ERROR_LITE = 'lite';
    Codes.O_INPUTS_OPTIONS_COLOR_ACCENT = 'accent';
    Codes.HourFormat = {
        TWELVE: 'hh:mm a',
        TWENTY_FOUR: 'HH:mm a',
    };
    Codes.TWENTY_FOUR_HOUR_FORMAT = 24;
    Codes.TWELVE_FOUR_HOUR_FORMAT = 12;
    return Codes;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var Util = /** @class */ (function () {
    function Util() {
    }
    /**
     * @param {?} val
     * @return {?}
     */
    Util.isObject = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        /** @type {?} */
        var valType = typeof val;
        return valType === 'object';
    };
    /**
     * @param {?} val
     * @return {?}
     */
    Util.isArray = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        return val instanceof Array;
    };
    /**
     * @param {?} value
     * @param {?=} defaultValue
     * @return {?}
     */
    Util.parseBoolean = /**
     * @param {?} value
     * @param {?=} defaultValue
     * @return {?}
     */
    function (value, defaultValue) {
        if ((typeof value === 'string') && (value.toUpperCase() === 'TRUE' || value.toUpperCase() === 'YES')) {
            return true;
        }
        else if ((typeof value === 'string') && (value.toUpperCase() === 'FALSE' || value.toUpperCase() === 'NO')) {
            return false;
        }
        else if (Util.isDefined(defaultValue)) {
            return defaultValue;
        }
        return false;
    };
    /**
     * @param {?} value
     * @param {?=} excludeRepeated
     * @return {?}
     */
    Util.parseArray = /**
     * @param {?} value
     * @param {?=} excludeRepeated
     * @return {?}
     */
    function (value, excludeRepeated) {
        if (excludeRepeated === void 0) { excludeRepeated = false; }
        /** @type {?} */
        var result = [];
        if (value) {
            result = value.split(Codes.ARRAY_INPUT_SEPARATOR);
        }
        if (excludeRepeated && result.length > 0) {
            result = Array.from(new Set(result));
        }
        return result;
    };
    /**
     * Returns an object with parent keys equivalences.
     * @param  pKeysArray Array of strings. Accepted format: key | key:alias
     * @returns Object
     */
    /**
     * Returns an object with parent keys equivalences.
     * @param {?} pKeysArray Array of strings. Accepted format: key | key:alias
     * @param {?=} separator
     * @return {?} Object
     */
    Util.parseParentKeysEquivalences = /**
     * Returns an object with parent keys equivalences.
     * @param {?} pKeysArray Array of strings. Accepted format: key | key:alias
     * @param {?=} separator
     * @return {?} Object
     */
    function (pKeysArray, separator) {
        if (separator === void 0) { separator = ':'; }
        /** @type {?} */
        var equivalences = {};
        if (pKeysArray && pKeysArray.length > 0) {
            pKeysArray.forEach(function (item) {
                /** @type {?} */
                var aux = item.split(separator);
                if (aux && aux.length === 2) {
                    if (/.+\[.+\]/.test(aux[1])) {
                        /** @type {?} */
                        var equivKey = aux[1].substring(0, aux[1].indexOf('['));
                        /** @type {?} */
                        var equivValue = aux[1].substring(aux[1].indexOf('[') + 1, aux[1].indexOf(']'));
                        /** @type {?} */
                        var equiv = {};
                        equiv[equivKey] = equivValue;
                        equivalences[aux[0]] = equiv;
                    }
                    else {
                        equivalences[aux[0]] = aux[1];
                    }
                }
                else if (aux && aux.length === 1) {
                    equivalences[item] = item;
                }
            });
        }
        return equivalences;
    };
    /**
     * @param {?} parentKeys
     * @return {?}
     */
    Util.encodeParentKeys = /**
     * @param {?} parentKeys
     * @return {?}
     */
    function (parentKeys) {
        /** @type {?} */
        var encoded = '';
        if (parentKeys) {
            encoded = Base64.encode(JSON.stringify(parentKeys));
        }
        return encoded;
    };
    /**
     * @param {?} parentKeys
     * @return {?}
     */
    Util.decodeParentKeys = /**
     * @param {?} parentKeys
     * @return {?}
     */
    function (parentKeys) {
        /** @type {?} */
        var decoded = {};
        if (parentKeys && parentKeys.length > 0) {
            /** @type {?} */
            var d = Base64.decode(parentKeys);
            decoded = JSON.parse(d);
        }
        return decoded;
    };
    /**
     * @param {?} array
     * @return {?}
     */
    Util.isArrayEmpty = /**
     * @param {?} array
     * @return {?}
     */
    function (array) {
        if (array && array.length === 0) {
            return true;
        }
        return false;
    };
    /**
     * Checks wether specified service as argument implements 'IDataService' interface
     * @param arg The service instance for checking.
     * @returns boolean
     */
    /**
     * Checks wether specified service as argument implements 'IDataService' interface
     * @param {?} arg The service instance for checking.
     * @return {?} boolean
     */
    Util.isDataService = /**
     * Checks wether specified service as argument implements 'IDataService' interface
     * @param {?} arg The service instance for checking.
     * @return {?} boolean
     */
    function (arg) {
        if (arg === undefined || arg === null) {
            return false;
        }
        return ((/** @type {?} */ (arg)).getDefaultServiceConfiguration !== undefined &&
            (/** @type {?} */ (arg)).configureService !== undefined);
    };
    /**
     * Checks wether specified service as argument implements 'IDataService' interface
     * @param arg The service instance for checking.
     * @returns boolean
     */
    /**
     * Checks wether specified service as argument implements 'IDataService' interface
     * @param {?} arg The service instance for checking.
     * @return {?} boolean
     */
    Util.isPermissionsService = /**
     * Checks wether specified service as argument implements 'IDataService' interface
     * @param {?} arg The service instance for checking.
     * @return {?} boolean
     */
    function (arg) {
        if (arg === undefined || arg === null) {
            return false;
        }
        return ((/** @type {?} */ (arg)).loadPermissions !== undefined);
    };
    /**
     * Checks wether specified component as argument implements 'IFormDataComponent' interface
     * @param arg The component instance for checking.
     * @returns boolean
     */
    /**
     * Checks wether specified component as argument implements 'IFormDataComponent' interface
     * @param {?} arg The component instance for checking.
     * @return {?} boolean
     */
    Util.isFormDataComponent = /**
     * Checks wether specified component as argument implements 'IFormDataComponent' interface
     * @param {?} arg The component instance for checking.
     * @return {?} boolean
     */
    function (arg) {
        if (arg === undefined || arg === null) {
            return false;
        }
        return ((/** @type {?} */ (arg)).isAutomaticBinding !== undefined);
    };
    /**
     * Compare is equal two objects
     * @param a Object 1
     * @param b Object 2
     *
     */
    /**
     * Compare is equal two objects
     * @param {?} a Object 1
     * @param {?} b Object 2
     *
     * @return {?}
     */
    Util.isEquivalent = /**
     * Compare is equal two objects
     * @param {?} a Object 1
     * @param {?} b Object 2
     *
     * @return {?}
     */
    function (a, b) {
        /** @type {?} */
        var aProps = Object.getOwnPropertyNames(a);
        /** @type {?} */
        var bProps = Object.getOwnPropertyNames(b);
        // If number of properties is different, objects are not equivalent
        if (aProps.length !== bProps.length) {
            return false;
        }
        for (var i = 0; i < aProps.length; i++) {
            /** @type {?} */
            var propName = aProps[i];
            /** @type {?} */
            var bValue = b[propName];
            if (typeof a[propName] === 'number') {
                /** @type {?} */
                var intB = parseInt(bValue);
                bValue = isNaN(intB) ? bValue : intB;
            }
            if (a[propName] !== bValue) {
                return false;
            }
        }
        // If we made it this far, objects are considered equivalent
        return true;
    };
    /**
     * @param {?} o1
     * @param {?} o2
     * @return {?}
     */
    Util.equals = /**
     * @param {?} o1
     * @param {?} o2
     * @return {?}
     */
    function (o1, o2) {
        if (o1 === o2) {
            return true;
        }
        if (o1 === null || o2 === null) {
            return false;
        }
        if (o1 !== o1 && o2 !== o2) {
            // NaN === NaN
            return true;
        }
        /** @type {?} */
        var t1 = typeof o1;
        /** @type {?} */
        var t2 = typeof o2;
        /** @type {?} */
        var length;
        /** @type {?} */
        var key;
        /** @type {?} */
        var keySet;
        if (t1 === t2 && t1 === 'object') {
            if (Array.isArray(o1)) {
                if (!Array.isArray(o2)) {
                    return false;
                }
                length = o1.length;
                if (length === o2.length) {
                    for (key = 0; key < length; key++) {
                        if (!Util.equals(o1[key], o2[key])) {
                            return false;
                        }
                    }
                    return true;
                }
            }
            else {
                if (Array.isArray(o2)) {
                    return false;
                }
                keySet = Object.create(null);
                for (key in o1) {
                    if (!Util.equals(o1[key], o2[key])) {
                        return false;
                    }
                    keySet[key] = true;
                }
                for (key in o2) {
                    if (!(key in keySet) && typeof o2[key] !== 'undefined') {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    Util.isDefined = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return typeof value !== 'undefined' && value !== null;
    };
    /**
     * Returns the provided string in lowercase and without accent marks.
     * @param value the text to normalize
     */
    /**
     * Returns the provided string in lowercase and without accent marks.
     * @param {?} value the text to normalize
     * @param {?=} toLowerCase
     * @return {?}
     */
    Util.normalizeString = /**
     * Returns the provided string in lowercase and without accent marks.
     * @param {?} value the text to normalize
     * @param {?=} toLowerCase
     * @return {?}
     */
    function (value, toLowerCase) {
        if (toLowerCase === void 0) { toLowerCase = true; }
        if (value && value.length) {
            /** @type {?} */
            var result = value.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            if (toLowerCase) {
                result = result.toLowerCase();
            }
            return result;
        }
        return '';
    };
    /**
     * Returns the provided array flattend.
     * @param array the array to flat
     */
    /**
     * Returns the provided array flattend.
     * @param {?} array the array to flat
     * @return {?}
     */
    Util.flatten = /**
     * Returns the provided array flattend.
     * @param {?} array the array to flat
     * @return {?}
     */
    function (array) {
        return [].concat.apply([], array);
    };
    /**
     * Returns a list with all the values from the provided object.
     * @param obj the object
     */
    /**
     * Returns a list with all the values from the provided object.
     * @param {?=} obj the object
     * @return {?}
     */
    Util.getValuesFromObject = /**
     * Returns a list with all the values from the provided object.
     * @param {?=} obj the object
     * @return {?}
     */
    function (obj) {
        if (obj === void 0) { obj = {}; }
        /** @type {?} */
        var array = [];
        Object.keys(obj).forEach(function (key) {
            if (typeof obj[key] === 'object') {
                array.push(Util.getValuesFromObject(obj[key]));
            }
            array.push(obj[key]);
        });
        return Util.flatten(array);
    };
    /**
     * @param {?} value
     * @param {?=} defaultValue
     * @return {?}
     */
    Util.parseIconPosition = /**
     * @param {?} value
     * @param {?=} defaultValue
     * @return {?}
     */
    function (value, defaultValue) {
        /** @type {?} */
        var result = defaultValue || Codes.ICON_POSITION_LEFT;
        /** @type {?} */
        var availablePositions = [Codes.ICON_POSITION_LEFT, Codes.ICON_POSITION_RIGHT];
        if (value && value.length) {
            result = value.toLowerCase();
        }
        if (availablePositions.indexOf(result) === -1) {
            result = defaultValue || Codes.ICON_POSITION_LEFT;
        }
        return result;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    Util.copyToClipboard = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        document.addEventListener('copy', function (e) {
            e.clipboardData.setData('text/plain', data);
            e.preventDefault();
            document.removeEventListener('copy', null);
        });
        document.execCommand('copy');
    };
    /**
     * @param {?} value
     * @return {?}
     */
    Util.checkPixelsValueString = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return typeof value === 'string' ? value.toLowerCase().endsWith('px') : false;
    };
    /**
     * @param {?} value
     * @param {?=} defaultValue
     * @return {?}
     */
    Util.extractPixelsValue = /**
     * @param {?} value
     * @param {?=} defaultValue
     * @return {?}
     */
    function (value, defaultValue) {
        if (defaultValue === void 0) { defaultValue = undefined; }
        /** @type {?} */
        var result = typeof value === 'number' ? value : undefined;
        if (Util.checkPixelsValueString(value)) {
            /** @type {?} */
            var parsed = parseFloat(value.substr(0, value.length - 'px'.length));
            result = isNaN(parsed) ? defaultValue : parsed;
        }
        return Util.isDefined(result) ? result : defaultValue;
    };
    /**
     * Added class 'accent' in <mat-form-field> and set the color  accent in the icons
     * @param elRef
     * @param oInputsOptions
     */
    /**
     * Added class 'accent' in <mat-form-field> and set the color  accent in the icons
     * @param {?} elRef
     * @param {?} oInputsOptions
     * @return {?}
     */
    Util.parseOInputsOptions = /**
     * Added class 'accent' in <mat-form-field> and set the color  accent in the icons
     * @param {?} elRef
     * @param {?} oInputsOptions
     * @return {?}
     */
    function (elRef, oInputsOptions) {
        if (oInputsOptions.iconColor === Codes.O_INPUTS_OPTIONS_COLOR_ACCENT) {
            /** @type {?} */
            var matFormFieldEL = elRef.nativeElement.getElementsByTagName('mat-form-field')[0];
            if (Util.isDefined(matFormFieldEL)) {
                matFormFieldEL.classList.add('accent');
            }
        }
    };
    /**
     *  Return string with escaped special character
     * */
    /**
     *  Return string with escaped special character
     *
     * @param {?} S
     * @return {?}
     */
    Util.escapeSpecialCharacter = /**
     *  Return string with escaped special character
     *
     * @param {?} S
     * @return {?}
     */
    function (S$$1) {
        /** @type {?} */
        var str = String(S$$1);
        /** @type {?} */
        var cpList = Array.from(str[Symbol.iterator]());
        /** @type {?} */
        var cuList = [];
        for (var _i = 0, cpList_1 = cpList; _i < cpList_1.length; _i++) {
            var c = cpList_1[_i];
            // i. If c is a SpecialCharacter then do:
            if ('^$\\.*+?()[]{}|'.indexOf(c) !== -1) {
                // a. Append "\" to cuList.
                cuList.push('\\');
            }
            // Append c to cpList.
            cuList.push(c);
        }
        /** @type {?} */
        var L$$1 = cuList.join('');
        return L$$1;
    };
    /**
     * @param {?} array1
     * @param {?} array2
     * @return {?}
     */
    Util.differenceArrays = /**
     * @param {?} array1
     * @param {?} array2
     * @return {?}
     */
    function (array1, array2) {
        var _this = this;
        /** @type {?} */
        var difference = array1.filter(function (obj) {
            return !array2.some(function (obj2) {
                return _this.equals(obj, obj2);
            });
        });
        return difference;
    };
    return Util;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var PermissionsUtils = /** @class */ (function () {
    function PermissionsUtils() {
    }
    /**
     * @param {?} permission
     * @return {?}
     */
    PermissionsUtils.checkEnabledPermission = /**
     * @param {?} permission
     * @return {?}
     */
    function (permission) {
        if (Util.isDefined(permission) && permission.enabled === false) {
            console.warn('MESSAGES.OPERATION_NOT_ALLOWED_PERMISSION');
            return false;
        }
        return true;
    };
    /**
     * @param {?} nativeElement
     * @param {?=} args
     * @return {?}
     */
    PermissionsUtils.registerDisabledChangesInDom = /**
     * @param {?} nativeElement
     * @param {?=} args
     * @return {?}
     */
    function (nativeElement, args) {
        /** @type {?} */
        var callback = args && args.callback ? args.callback : PermissionsUtils.setDisabledDOMElement;
        /** @type {?} */
        var checkStringValue = args && args.checkStringValue ? true : false;
        if (!Util.isDefined(nativeElement)) {
            return undefined;
        }
        /** @type {?} */
        var mutationObserver = new MutationObserver(function (mutations) {
            /** @type {?} */
            var mutation = mutations[0];
            if (mutation.type === 'attributes' && mutation.attributeName === 'disabled') {
                /** @type {?} */
                var attribute = (/** @type {?} */ (mutation.target)).attributes.getNamedItem('disabled');
                if (attribute === null || (checkStringValue && attribute.value !== 'true')) {
                    callback(mutation);
                }
            }
        });
        mutationObserver.observe(nativeElement, {
            attributes: true,
            attributeFilter: ['disabled']
        });
        return mutationObserver;
    };
    /**
     * @param {?} mutation
     * @return {?}
     */
    PermissionsUtils.setDisabledDOMElement = /**
     * @param {?} mutation
     * @return {?}
     */
    function (mutation) {
        /** @type {?} */
        var element = /** @type {?} */ (mutation.target);
        element.setAttribute('disabled', 'true');
    };
    PermissionsUtils.ACTION_REFRESH = 'refresh';
    PermissionsUtils.ACTION_INSERT = 'insert';
    PermissionsUtils.ACTION_UPDATE = 'update';
    PermissionsUtils.ACTION_DELETE = 'delete';
    PermissionsUtils.STANDARD_ACTIONS = [
        PermissionsUtils.ACTION_REFRESH,
        PermissionsUtils.ACTION_INSERT,
        PermissionsUtils.ACTION_UPDATE,
        PermissionsUtils.ACTION_DELETE
    ];
    return PermissionsUtils;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var SQLTypes = /** @class */ (function () {
    function SQLTypes() {
    }
    /**
     * @param {?} type
     * @return {?}
     */
    SQLTypes.getSQLTypeValue = /**
     * @param {?} type
     * @return {?}
     */
    function (type) {
        /** @type {?} */
        var value;
        type = type ? type.toUpperCase() : '';
        switch (type) {
            case 'BIT':
                value = SQLTypes.BIT;
                break;
            case 'TINYINT':
                value = SQLTypes.TINYINT;
                break;
            case 'SMALLINT':
                value = SQLTypes.SMALLINT;
                break;
            case 'INTEGER':
                value = SQLTypes.INTEGER;
                break;
            case 'BIGINT':
                value = SQLTypes.BIGINT;
                break;
            case 'FLOAT':
                value = SQLTypes.FLOAT;
                break;
            case 'REAL':
                value = SQLTypes.REAL;
                break;
            case 'DOUBLE':
                value = SQLTypes.DOUBLE;
                break;
            case 'NUMERIC':
                value = SQLTypes.NUMERIC;
                break;
            case 'DECIMAL':
                value = SQLTypes.DECIMAL;
                break;
            case 'CHAR':
                value = SQLTypes.CHAR;
                break;
            case 'VARCHAR':
                value = SQLTypes.VARCHAR;
                break;
            case 'LONGVARCHAR':
                value = SQLTypes.LONGVARCHAR;
                break;
            case 'DATE':
                value = SQLTypes.DATE;
                break;
            case 'TIME':
                value = SQLTypes.TIME;
                break;
            case 'TIMESTAMP':
                value = SQLTypes.TIMESTAMP;
                break;
            case 'BINARY':
                value = SQLTypes.BINARY;
                break;
            case 'VARBINARY':
                value = SQLTypes.VARBINARY;
                break;
            case 'LONGVARBINARY':
                value = SQLTypes.LONGVARBINARY;
                break;
            case 'NULL':
                value = SQLTypes.NULL;
                break;
            case 'OTHER':
                value = SQLTypes.OTHER;
                break;
            case 'JAVA_OBJECT':
                value = SQLTypes.JAVA_OBJECT;
                break;
            case 'DISTINCT':
                value = SQLTypes.DISTINCT;
                break;
            case 'STRUCT':
                value = SQLTypes.STRUCT;
                break;
            case 'ARRAY':
                value = SQLTypes.ARRAY;
                break;
            case 'BLOB':
                value = SQLTypes.BLOB;
                break;
            case 'CLOB':
                value = SQLTypes.CLOB;
                break;
            case 'REF':
                value = SQLTypes.REF;
                break;
            case 'DATALINK':
                value = SQLTypes.DATALINK;
                break;
            case 'BOOLEAN':
                value = SQLTypes.BOOLEAN;
                break;
            case 'ROWID':
                value = SQLTypes.ROWID;
                break;
            case 'NCHAR':
                value = SQLTypes.NCHAR;
                break;
            case 'NVARCHAR':
                value = SQLTypes.NVARCHAR;
                break;
            case 'LONGNVARCHAR':
                value = SQLTypes.LONGNVARCHAR;
                break;
            case 'NCLOB':
                value = SQLTypes.NCLOB;
                break;
            case 'SQLXML':
                value = SQLTypes.SQLXML;
                break;
            case 'BASE64':
                value = SQLTypes.BASE64;
                break;
            default:
                value = SQLTypes.OTHER;
                break;
        }
        return value;
    };
    /**
     * @param {?} type
     * @return {?}
     */
    SQLTypes.getSQLTypeKey = /**
     * @param {?} type
     * @return {?}
     */
    function (type) {
        /** @type {?} */
        var value;
        switch (type) {
            case SQLTypes.BIT:
                value = 'BIT';
                break;
            case SQLTypes.TINYINT:
                value = 'TINYINT';
                break;
            case SQLTypes.SMALLINT:
                value = 'SMALLINT';
                break;
            case SQLTypes.INTEGER:
                value = 'INTEGER';
                break;
            case SQLTypes.BIGINT:
                value = 'BIGINT';
                break;
            case SQLTypes.FLOAT:
                value = 'FLOAT';
                break;
            case SQLTypes.REAL:
                value = 'REAL';
                break;
            case SQLTypes.DOUBLE:
                value = 'DOUBLE';
                break;
            case SQLTypes.NUMERIC:
                value = 'NUMERIC';
                break;
            case SQLTypes.DECIMAL:
                value = 'DECIMAL';
                break;
            case SQLTypes.CHAR:
                value = 'CHAR';
                break;
            case SQLTypes.VARCHAR:
                value = 'VARCHAR';
                break;
            case SQLTypes.LONGVARCHAR:
                value = 'LONGVARCHAR';
                break;
            case SQLTypes.DATE:
                value = 'DATE';
                break;
            case SQLTypes.TIME:
                value = 'TIME';
                break;
            case SQLTypes.TIMESTAMP:
                value = 'TIMESTAMP';
                break;
            case SQLTypes.BINARY:
                value = 'BINARY';
                break;
            case SQLTypes.VARBINARY:
                value = 'VARBINARY';
                break;
            case SQLTypes.LONGVARBINARY:
                value = 'LONGVARBINARY';
                break;
            case SQLTypes.NULL:
                value = 'NULL';
                break;
            case SQLTypes.OTHER:
                value = 'OTHER';
                break;
            case SQLTypes.JAVA_OBJECT:
                value = 'JAVA_OBJECT';
                break;
            case SQLTypes.DISTINCT:
                value = 'DISTINCT';
                break;
            case SQLTypes.STRUCT:
                value = 'STRUCT';
                break;
            case SQLTypes.ARRAY:
                value = 'ARRAY';
                break;
            case SQLTypes.BLOB:
                value = 'BLOB';
                break;
            case SQLTypes.CLOB:
                value = 'CLOB';
                break;
            case SQLTypes.REF:
                value = 'REF';
                break;
            case SQLTypes.DATALINK:
                value = 'DATALINK';
                break;
            case SQLTypes.BOOLEAN:
                value = 'BOOLEAN';
                break;
            case SQLTypes.ROWID:
                value = 'ROWID';
                break;
            case SQLTypes.NCHAR:
                value = 'NCHAR';
                break;
            case SQLTypes.NVARCHAR:
                value = 'NVARCHAR';
                break;
            case SQLTypes.LONGNVARCHAR:
                value = 'LONGNVARCHAR';
                break;
            case SQLTypes.NCLOB:
                value = 'NCLOB';
                break;
            case SQLTypes.SQLXML:
                value = 'SQLXML';
                break;
            case SQLTypes.BASE64:
                value = 'BASE64';
                break;
            default:
                value = 'OTHER';
                break;
        }
        return value;
    };
    /**
     * @param {?} arg
     * @param {?} type
     * @return {?}
     */
    SQLTypes.parseUsingSQLType = /**
     * @param {?} arg
     * @param {?} type
     * @return {?}
     */
    function (arg, type) {
        /** @type {?} */
        var value = arg;
        type = type ? type.toUpperCase() : '';
        try {
            switch (type) {
                case 'TINYINT':
                case 'SMALLINT':
                case 'INTEGER':
                case 'BIGINT':
                    value = Number(arg);
                    break;
                case 'FLOAT':
                case 'REAL':
                case 'DOUBLE':
                case 'NUMERIC':
                case 'DECIMAL':
                    value = parseFloat(arg);
                default:
                    break;
            }
        }
        catch (err) {
            console.error('SQLTypes.parseUsingSQLType error');
        }
        return value;
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    SQLTypes.isNumericSQLType = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        return [
            SQLTypes.TINYINT,
            SQLTypes.SMALLINT,
            SQLTypes.INTEGER,
            SQLTypes.BIGINT,
            SQLTypes.FLOAT,
            SQLTypes.REAL,
            SQLTypes.DOUBLE,
            SQLTypes.NUMERIC,
            SQLTypes.DECIMAL
        ].indexOf(arg) !== -1;
    };
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>BIT</code>.
     */
    SQLTypes.BIT = -7;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>TINYINT</code>.
     */
    SQLTypes.TINYINT = -6;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>SMALLINT</code>.
     */
    SQLTypes.SMALLINT = 5;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>INTEGER</code>.
     */
    SQLTypes.INTEGER = 4;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>BIGINT</code>.
     */
    SQLTypes.BIGINT = -5;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>FLOAT</code>.
     */
    SQLTypes.FLOAT = 6;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>REAL</code>.
     */
    SQLTypes.REAL = 7;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>DOUBLE</code>.
     */
    SQLTypes.DOUBLE = 8;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>NUMERIC</code>.
     */
    SQLTypes.NUMERIC = 2;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>DECIMAL</code>.
     */
    SQLTypes.DECIMAL = 3;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>CHAR</code>.
     */
    SQLTypes.CHAR = 1;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>VARCHAR</code>.
     */
    SQLTypes.VARCHAR = 12;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>LONGVARCHAR</code>.
     */
    SQLTypes.LONGVARCHAR = -1;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>DATE</code>.
     */
    SQLTypes.DATE = 91;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>TIME</code>.
     */
    SQLTypes.TIME = 92;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>TIMESTAMP</code>.
     */
    SQLTypes.TIMESTAMP = 93;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>BINARY</code>.
     */
    SQLTypes.BINARY = -2;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>VARBINARY</code>.
     */
    SQLTypes.VARBINARY = -3;
    /**
     * <P>The constant in the Java programming language, sometimes referred
     * to as a type code, that identifies the generic SQL type
     * <code>LONGVARBINARY</code>.
     */
    SQLTypes.LONGVARBINARY = -4;
    /**
     * <P>The constant in the Java programming language
     * that identifies the generic SQL value
     * <code>NULL</code>.
     */
    SQLTypes.NULL = 0;
    /**
     * The constant in the Java programming language that indicates
     * that the SQL type is database-specific and
     * gets mapped to a Java object that can be accessed via
     * the methods <code>getObject</code> and <code>setObject</code>.
     */
    SQLTypes.OTHER = 1111;
    /**
     * The constant in the Java programming language, sometimes referred to
     * as a type code, that identifies the generic SQL type
     * <code>JAVA_OBJECT</code>.
     * \@since 1.2
     */
    SQLTypes.JAVA_OBJECT = 2000;
    /**
     * The constant in the Java programming language, sometimes referred to
     * as a type code, that identifies the generic SQL type
     * <code>DISTINCT</code>.
     * \@since 1.2
     */
    SQLTypes.DISTINCT = 2001;
    /**
     * The constant in the Java programming language, sometimes referred to
     * as a type code, that identifies the generic SQL type
     * <code>STRUCT</code>.
     * \@since 1.2
     */
    SQLTypes.STRUCT = 2002;
    /**
     * The constant in the Java programming language, sometimes referred to
     * as a type code, that identifies the generic SQL type
     * <code>ARRAY</code>.
     * \@since 1.2
     */
    SQLTypes.ARRAY = 2003;
    /**
     * The constant in the Java programming language, sometimes referred to
     * as a type code, that identifies the generic SQL type
     * <code>BLOB</code>.
     * \@since 1.2
     */
    SQLTypes.BLOB = 2004;
    /**
     * The constant in the Java programming language, sometimes referred to
     * as a type code, that identifies the generic SQL type
     * <code>CLOB</code>.
     * \@since 1.2
     */
    SQLTypes.CLOB = 2005;
    /**
     * The constant in the Java programming language, sometimes referred to
     * as a type code, that identifies the generic SQL type
     * <code>REF</code>.
     * \@since 1.2
     */
    SQLTypes.REF = 2006;
    /**
     * The constant in the Java programming language, somtimes referred to
     * as a type code, that identifies the generic SQL type <code>DATALINK</code>.
     *
     * \@since 1.4
     */
    SQLTypes.DATALINK = 70;
    /**
     * The constant in the Java programming language, somtimes referred to
     * as a type code, that identifies the generic SQL type <code>BOOLEAN</code>.
     *
     * \@since 1.4
     */
    SQLTypes.BOOLEAN = 16;
    /**
     * The constant in the Java programming language, sometimes referred to
     * as a type code, that identifies the generic SQL type <code>ROWID</code>
     *
     * \@since 1.6
     *
     */
    SQLTypes.ROWID = -8;
    /**
     * The constant in the Java programming language, sometimes referred to
     * as a type code, that identifies the generic SQL type <code>NCHAR</code>
     *
     * \@since 1.6
     */
    SQLTypes.NCHAR = -15;
    /**
     * The constant in the Java programming language, sometimes referred to
     * as a type code, that identifies the generic SQL type <code>NVARCHAR</code>.
     *
     * \@since 1.6
     */
    SQLTypes.NVARCHAR = -9;
    /**
     * The constant in the Java programming language, sometimes referred to
     * as a type code, that identifies the generic SQL type <code>LONGNVARCHAR</code>.
     *
     * \@since 1.6
     */
    SQLTypes.LONGNVARCHAR = -16;
    /**
     * The constant in the Java programming language, sometimes referred to
     * as a type code, that identifies the generic SQL type <code>NCLOB</code>.
     *
     * \@since 1.6
     */
    SQLTypes.NCLOB = 2011;
    SQLTypes.BASE64 = 6464;
    /**
     * The constant in the Java programming language, sometimes referred to
     * as a type code, that identifies the generic SQL type <code>XML</code>.
     *
     * \@since 1.6
     */
    SQLTypes.SQLXML = 2009;
    return SQLTypes;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OFormValue = /** @class */ (function () {
    function OFormValue(value) {
        this.value = value;
    }
    return OFormValue;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ServiceUtils$$1 = /** @class */ (function () {
    function ServiceUtils$$1() {
    }
    /**
     * @param {?} parentKeysObject
     * @param {?} form
     * @return {?}
     */
    ServiceUtils$$1.getParentKeysFromForm = /**
     * @param {?} parentKeysObject
     * @param {?} form
     * @return {?}
     */
    function (parentKeysObject, form) {
        /** @type {?} */
        var result = {};
        /** @type {?} */
        var ownKeys = Object.keys(parentKeysObject || {});
        /** @type {?} */
        var formComponents = form ? form.getComponents() : {};
        /** @type {?} */
        var existsComponents = Object.keys(formComponents).length > 0;
        /** @type {?} */
        var formDataProperties = form ? form.getDataValues() : {};
        /** @type {?} */
        var existsProperties = Object.keys(formDataProperties).length > 0;
        /** @type {?} */
        var urlData = form ? form.getFormNavigation().getFilterFromUrlParams() : {};
        /** @type {?} */
        var existsUrlData = Object.keys(urlData).length > 0;
        if (existsUrlData) {
            form.keysArray.forEach(function (key, i) {
                if (urlData.hasOwnProperty(key)) {
                    urlData[key] = SQLTypes.parseUsingSQLType(urlData[key], form.keysSqlTypesArray[i]);
                }
            });
        }
        if (existsComponents || existsProperties || existsUrlData) {
            ownKeys.forEach(function (ownKey) {
                /** @type {?} */
                var keyValue = parentKeysObject[ownKey];
                /** @type {?} */
                var isEquivObject = Util.isObject(keyValue);
                /** @type {?} */
                var formFieldAttr = isEquivObject ? Object.keys(keyValue)[0] : keyValue;
                /** @type {?} */
                var currentData;
                if (formComponents.hasOwnProperty(formFieldAttr)) {
                    /** @type {?} */
                    var component = formComponents[formFieldAttr];
                    // Is service component (combo, listpicker, radio)
                    if ('getSelectedRecord' in component && isEquivObject) {
                        currentData = ((/** @type {?} */ (component)).getSelectedRecord() || {})[keyValue[formFieldAttr]];
                    }
                    else {
                        currentData = component.getValue();
                    }
                }
                else if (formDataProperties.hasOwnProperty(formFieldAttr)) {
                    /** @type {?} */
                    var formPropValue = formDataProperties[formFieldAttr];
                    currentData = formPropValue instanceof OFormValue ? formPropValue.value : formPropValue;
                }
                else if (urlData.hasOwnProperty(formFieldAttr)) {
                    currentData = urlData[formFieldAttr];
                }
                if (Util.isDefined(currentData)) {
                    switch (typeof (currentData)) {
                        case 'string':
                            if (currentData.trim().length > 0) {
                                result[ownKey] = currentData.trim();
                            }
                            break;
                        case 'number':
                            if (!isNaN(currentData)) {
                                result[ownKey] = currentData;
                            }
                            break;
                    }
                }
            });
        }
        return result;
    };
    /**
     * @param {?} parentKeysFilter
     * @param {?} parentKeys
     * @return {?}
     */
    ServiceUtils$$1.filterContainsAllParentKeys = /**
     * @param {?} parentKeysFilter
     * @param {?} parentKeys
     * @return {?}
     */
    function (parentKeysFilter, parentKeys) {
        /** @type {?} */
        var pkKeys = Object.keys(parentKeys);
        if ((pkKeys.length > 0) && Util.isDefined(parentKeysFilter)) {
            /** @type {?} */
            var parentKeysFilterKeys_1 = Object.keys(parentKeysFilter);
            return pkKeys.every(function (a) { return parentKeysFilterKeys_1.indexOf(a) !== -1; });
        }
        return true;
    };
    /**
     * @param {?} parentItem
     * @param {?} parentKeysObject
     * @return {?}
     */
    ServiceUtils$$1.getFilterUsingParentKeys = /**
     * @param {?} parentItem
     * @param {?} parentKeysObject
     * @return {?}
     */
    function (parentItem, parentKeysObject) {
        /** @type {?} */
        var filter$$1 = {};
        /** @type {?} */
        var ownKeys = Object.keys(parentKeysObject);
        if (ownKeys.length > 0 && Util.isDefined(parentItem)) {
            ownKeys.forEach(function (ownKey) {
                /** @type {?} */
                var parentKey = parentKeysObject[ownKey];
                if (parentItem.hasOwnProperty(parentKey)) {
                    /** @type {?} */
                    var currentData = parentItem[parentKey];
                    if (currentData instanceof OFormValue) {
                        currentData = currentData.value;
                    }
                    filter$$1[ownKey] = currentData;
                }
            });
        }
        return filter$$1;
    };
    /**
     * @param {?} array
     * @param {?} properties
     * @return {?}
     */
    ServiceUtils$$1.getArrayProperties = /**
     * @param {?} array
     * @param {?} properties
     * @return {?}
     */
    function (array, properties) {
        /** @type {?} */
        var result = array.map(function (item) {
            return ServiceUtils$$1.getObjectProperties(item, properties);
        });
        return result;
    };
    /**
     * @param {?} object
     * @param {?} properties
     * @return {?}
     */
    ServiceUtils$$1.getObjectProperties = /**
     * @param {?} object
     * @param {?} properties
     * @return {?}
     */
    function (object, properties) {
        /** @type {?} */
        var objectProperties = {};
        properties.forEach(function (key) {
            objectProperties[key] = object[key];
        });
        return objectProperties;
    };
    /**
     * @param {?} sortColumns
     * @return {?}
     */
    ServiceUtils$$1.parseSortColumns = /**
     * @param {?} sortColumns
     * @return {?}
     */
    function (sortColumns) {
        /** @type {?} */
        var sortColArray = [];
        if (sortColumns) {
            /** @type {?} */
            var cols = Util.parseArray(sortColumns);
            cols.forEach(function (col) {
                /** @type {?} */
                var colDef = col.split(Codes.TYPE_SEPARATOR);
                if (colDef.length > 0) {
                    /** @type {?} */
                    var colName = colDef[0];
                    /** @type {?} */
                    var colSort = colDef[1] || Codes.ASC_SORT;
                    sortColArray.push({
                        columnName: colName,
                        ascendent: colSort === Codes.ASC_SORT
                    });
                }
            });
        }
        return sortColArray;
    };
    /**
     * @param {?} router
     * @param {?=} sessionExpired
     * @return {?}
     */
    ServiceUtils$$1.redirectLogin = /**
     * @param {?} router
     * @param {?=} sessionExpired
     * @return {?}
     */
    function (router$$1, sessionExpired) {
        if (sessionExpired === void 0) { sessionExpired = false; }
        /** @type {?} */
        var arg = {};
        arg[Codes.SESSION_EXPIRED_KEY] = sessionExpired;
        /** @type {?} */
        var extras = {};
        extras[Codes.QUERY_PARAMS] = arg;
        router$$1.navigate([Codes.LOGIN_ROUTE], extras);
    };
    return ServiceUtils$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Utility class for building basic and filter expressions.
 */
var FilterExpressionUtils = /** @class */ (function () {
    function FilterExpressionUtils() {
    }
    /**
     * Evaluates if the the expression provided is an instance of `IBasicExpression`..
     * @param arg the expression to evaluate.
     * @returns `true` if the provided expression is an instance of `IBasicExpression`, `false` otherwise.
     */
    /**
     * Evaluates if the the expression provided is an instance of `IBasicExpression`..
     * @param {?} arg the expression to evaluate.
     * @return {?} `true` if the provided expression is an instance of `IBasicExpression`, `false` otherwise.
     */
    FilterExpressionUtils.instanceofBasicExpression = /**
     * Evaluates if the the expression provided is an instance of `IBasicExpression`..
     * @param {?} arg the expression to evaluate.
     * @return {?} `true` if the provided expression is an instance of `IBasicExpression`, `false` otherwise.
     */
    function (arg) {
        return arg.hasOwnProperty(FilterExpressionUtils.BASIC_EXPRESSION_KEY)
            && FilterExpressionUtils.instanceofExpression(arg[FilterExpressionUtils.BASIC_EXPRESSION_KEY]);
    };
    /**
     * Builds a `BasicExpression` instance from the filtering expression (`IExpression`) provided.
     * @param exp the filtering expression.
     * @returns the basic expression.
     */
    /**
     * Builds a `BasicExpression` instance from the filtering expression (`IExpression`) provided.
     * @param {?} exp the filtering expression.
     * @return {?} the basic expression.
     */
    FilterExpressionUtils.buildBasicExpression = /**
     * Builds a `BasicExpression` instance from the filtering expression (`IExpression`) provided.
     * @param {?} exp the filtering expression.
     * @return {?} the basic expression.
     */
    function (exp) {
        if (exp) {
            if (!FilterExpressionUtils.instanceofExpression(exp)) {
                console.error('The expression provided is not an instance of \'IExpression\'');
            }
            /** @type {?} */
            var be = {
                '@basic_expression': exp
            };
            return be;
        }
        return undefined;
    };
    /**
     * Evaluates if an expresion is instance of `IFilterExpression`.
     * @param exp the expression to evaluate.
     * @returns `true` if the provided expression is an instance of `IFilterExpression`, `false` otherwise.
     */
    /**
     * Evaluates if an expresion is instance of `IFilterExpression`.
     * @param {?} exp the expression to evaluate.
     * @return {?} `true` if the provided expression is an instance of `IFilterExpression`, `false` otherwise.
     */
    FilterExpressionUtils.instanceofFilterExpression = /**
     * Evaluates if an expresion is instance of `IFilterExpression`.
     * @param {?} exp the expression to evaluate.
     * @return {?} `true` if the provided expression is an instance of `IFilterExpression`, `false` otherwise.
     */
    function (exp) {
        return exp.hasOwnProperty(FilterExpressionUtils.FILTER_EXPRESSION_KEY)
            && FilterExpressionUtils.instanceofExpression(exp[FilterExpressionUtils.FILTER_EXPRESSION_KEY]);
    };
    /**
     * Builds an `IFilterExpression` instance from the filtering expression (`IExpression`) provided.
     * @param exp the filtering expression.
     * @returns the `IFilterExpression`.
     */
    /**
     * Builds an `IFilterExpression` instance from the filtering expression (`IExpression`) provided.
     * @param {?} exp the filtering expression.
     * @return {?} the `IFilterExpression`.
     */
    FilterExpressionUtils.buildFilterExpression = /**
     * Builds an `IFilterExpression` instance from the filtering expression (`IExpression`) provided.
     * @param {?} exp the filtering expression.
     * @return {?} the `IFilterExpression`.
     */
    function (exp) {
        if (exp) {
            if (!FilterExpressionUtils.instanceofExpression(exp)) {
                console.error('The expression provided is not an instance of \'IExpression\'');
            }
            /** @type {?} */
            var be = {
                '@filter_expression': exp
            };
            return be;
        }
        return undefined;
    };
    /**
     * Evaluates if an expresion is instance of `IExpression`.
     * @param exp the expression to evaluate.
     * @returns `true` if the provided expression is an instance of `IExpression`, `false` otherwise.
     */
    /**
     * Evaluates if an expresion is instance of `IExpression`.
     * @param {?} exp the expression to evaluate.
     * @return {?} `true` if the provided expression is an instance of `IExpression`, `false` otherwise.
     */
    FilterExpressionUtils.instanceofExpression = /**
     * Evaluates if an expresion is instance of `IExpression`.
     * @param {?} exp the expression to evaluate.
     * @return {?} `true` if the provided expression is an instance of `IExpression`, `false` otherwise.
     */
    function (exp) {
        return exp.hasOwnProperty('lop') && exp.hasOwnProperty('op');
    };
    /**
     * Builds a complex `IExpression` instance joining two expressions with the provided operator.
     * @param expr1 the first `IExpression` to join.
     * @param expr2 the second `IExpression` to join.
     * @param op the joining operator.
     * @returns the complex `IExpression`.
     */
    /**
     * Builds a complex `IExpression` instance joining two expressions with the provided operator.
     * @param {?} expr1 the first `IExpression` to join.
     * @param {?} expr2 the second `IExpression` to join.
     * @param {?} op the joining operator.
     * @return {?} the complex `IExpression`.
     */
    FilterExpressionUtils.buildComplexExpression = /**
     * Builds a complex `IExpression` instance joining two expressions with the provided operator.
     * @param {?} expr1 the first `IExpression` to join.
     * @param {?} expr2 the second `IExpression` to join.
     * @param {?} op the joining operator.
     * @return {?} the complex `IExpression`.
     */
    function (expr1, expr2, op) {
        if (expr1.lop === undefined && expr1.op === undefined) {
            return expr2;
        }
        if (expr2.lop === undefined && expr2.op === undefined) {
            return expr1;
        }
        /** @type {?} */
        var expr = {
            lop: expr1,
            op: op,
            rop: expr2
        };
        return expr;
    };
    /**
     * Builds an `IExpression` instance for filtering the provided key EQUAL to the provided value.
     * @param key the key.
     * @param value the value.
     * @returns the `IExpression`.
     */
    /**
     * Builds an `IExpression` instance for filtering the provided key EQUAL to the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionEquals = /**
     * Builds an `IExpression` instance for filtering the provided key EQUAL to the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    function (key, value) {
        /** @type {?} */
        var expr = {
            lop: key,
            op: FilterExpressionUtils.OP_EQUAL,
            rop: value
        };
        return expr;
    };
    /**
     * Builds an `IExpression` instance for filtering the provided key with a NOT NULL value.
     * @param key the key.
     * @returns the `IExpression`.
     */
    /**
     * Builds an `IExpression` instance for filtering the provided key with a NOT NULL value.
     * @param {?} key the key.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionIsNotNull = /**
     * Builds an `IExpression` instance for filtering the provided key with a NOT NULL value.
     * @param {?} key the key.
     * @return {?} the `IExpression`.
     */
    function (key) {
        /** @type {?} */
        var expr = {
            lop: key,
            op: FilterExpressionUtils.OP_NOT_NULL
        };
        return expr;
    };
    /**
     * Builds an `IExpression` instance for filtering the provided key with a NULL value.
     * @param key the key.
     * @returns the `IExpression`.
     */
    /**
     * Builds an `IExpression` instance for filtering the provided key with a NULL value.
     * @param {?} key the key.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionIsNull = /**
     * Builds an `IExpression` instance for filtering the provided key with a NULL value.
     * @param {?} key the key.
     * @return {?} the `IExpression`.
     */
    function (key) {
        /** @type {?} */
        var expr = {
            lop: key,
            op: FilterExpressionUtils.OP_NULL
        };
        return expr;
    };
    /**
     * Builds an `IExpression` instance for filtering the provided key LESS than the provided value.
     * @param key the key.
     * @param value the value.
     * @returns the `IExpression`.
     */
    /**
     * Builds an `IExpression` instance for filtering the provided key LESS than the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionLess = /**
     * Builds an `IExpression` instance for filtering the provided key LESS than the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    function (key, value) {
        /** @type {?} */
        var expr = {
            lop: key,
            op: FilterExpressionUtils.OP_LESS,
            rop: value
        };
        return expr;
    };
    /**
     * Builds an `IExpression` instance for filtering the provided key LESS OR EQUAL to the provided value.
     * @param key the key.
     * @param value the value.
     * @returns the `IExpression`.
     */
    /**
     * Builds an `IExpression` instance for filtering the provided key LESS OR EQUAL to the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionLessEqual = /**
     * Builds an `IExpression` instance for filtering the provided key LESS OR EQUAL to the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    function (key, value) {
        /** @type {?} */
        var expr = {
            lop: key,
            op: FilterExpressionUtils.OP_LESS_EQUAL,
            rop: value
        };
        return expr;
    };
    /**
     * Builds an `IExpression` instance for filtering the provided key MORE than the provided value.
     * @param key the key.
     * @param value the value.
     * @returns the `IExpression`.
     */
    /**
     * Builds an `IExpression` instance for filtering the provided key MORE than the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionMore = /**
     * Builds an `IExpression` instance for filtering the provided key MORE than the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    function (key, value) {
        /** @type {?} */
        var expr = {
            lop: key,
            op: FilterExpressionUtils.OP_MORE,
            rop: value
        };
        return expr;
    };
    /**
     * Builds an `IExpression` instance for filtering the provided key MORE OR EQUAL to the provided value.
     * @param key the key.
     * @param value the value.
     * @returns the `IExpression`.
     */
    /**
     * Builds an `IExpression` instance for filtering the provided key MORE OR EQUAL to the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionMoreEqual = /**
     * Builds an `IExpression` instance for filtering the provided key MORE OR EQUAL to the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    function (key, value) {
        /** @type {?} */
        var expr = {
            lop: key,
            op: FilterExpressionUtils.OP_MORE_EQUAL,
            rop: value
        };
        return expr;
    };
    /**
     * @param {?} key
     * @param {?} values
     * @return {?}
     */
    FilterExpressionUtils.buildExpressionIn = /**
     * @param {?} key
     * @param {?} values
     * @return {?}
     */
    function (key, values) {
        /** @type {?} */
        var expr = {
            lop: key,
            op: FilterExpressionUtils.OP_IN,
            rop: values
        };
        return expr;
    };
    /**
     * Builds an `IExpression` instance for filtering the provided key NOT LIKE the provided value.
     * @param key the key.
     * @param value the value.
     * @returns the `IExpression`.
     */
    /**
     * Builds an `IExpression` instance for filtering the provided key NOT LIKE the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionNotLike = /**
     * Builds an `IExpression` instance for filtering the provided key NOT LIKE the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    function (key, value) {
        if (value !== undefined) {
            value = value.replace(new RegExp('\\*', 'g'), '%');
            if (value.indexOf('%') === -1) {
                value = '%' + value + '%';
            }
        }
        /** @type {?} */
        var expr = {
            lop: key,
            op: FilterExpressionUtils.OP_NOT_LIKE,
            rop: value
        };
        return expr;
    };
    /**
     * Builds an `IExpression` instance for filtering the provided key LIKE the provided value.
     * @param key the key.
     * @param value the value.
     * @returns the `IExpression`.
     */
    /**
     * Builds an `IExpression` instance for filtering the provided key LIKE the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionLike = /**
     * Builds an `IExpression` instance for filtering the provided key LIKE the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    function (key, value) {
        if (value !== undefined) {
            value = value.replace(new RegExp('\\*', 'g'), '%');
            if (value.indexOf('%') === -1) {
                value = '%' + value + '%';
            }
        }
        /** @type {?} */
        var expr = {
            lop: key,
            op: FilterExpressionUtils.OP_LIKE,
            rop: value
        };
        return expr;
    };
    /**
     * Builds an `IExpression` instance for filtering the provided key ENDS LIKE the provided value.
     * @param key the key.
     * @param value the value.
     * @returns the `IExpression`.
     */
    /**
     * Builds an `IExpression` instance for filtering the provided key ENDS LIKE the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionLikeEnd = /**
     * Builds an `IExpression` instance for filtering the provided key ENDS LIKE the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    function (key, value) {
        if (value !== undefined) {
            value = '%' + value;
        }
        /** @type {?} */
        var expr = {
            lop: key,
            op: FilterExpressionUtils.OP_LIKE,
            rop: value
        };
        return expr;
    };
    /**
     * Builds an `IExpression` instance for filtering the provided key STARTS LIKE the provided value.
     * @param key the key.
     * @param value the value.
     * @returns the `IExpression`.
     */
    /**
     * Builds an `IExpression` instance for filtering the provided key STARTS LIKE the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionLikeStart = /**
     * Builds an `IExpression` instance for filtering the provided key STARTS LIKE the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    function (key, value) {
        if (value !== undefined) {
            value = value + '%';
        }
        /** @type {?} */
        var expr = {
            lop: key,
            op: FilterExpressionUtils.OP_LIKE,
            rop: value
        };
        return expr;
    };
    /**
     * Builds an `IExpression` instance for filtering the provided key NOT EQUAL the provided value.
     * @param key the key.
     * @param value the value.
     * @returns the `IExpression`.
     */
    /**
     * Builds an `IExpression` instance for filtering the provided key NOT EQUAL the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionNotEquals = /**
     * Builds an `IExpression` instance for filtering the provided key NOT EQUAL the provided value.
     * @param {?} key the key.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    function (key, value) {
        /** @type {?} */
        var expr = {
            lop: key,
            op: FilterExpressionUtils.OP_NOT_EQUAL,
            rop: value
        };
        return expr;
    };
    /**
     * Builds a complex `IExpression` for filtering the provided key with two conditions:
     * * The first filter the provided key with a NULL value.
     * * The second filter the provided key EQUAL to the provided value.
     *
     * Both expressions are joined using the provided operator.
     * @param key the key.
     * @param value the value.
     * @param op the operator.
     * @returns the `IExpression`.
     */
    /**
     * Builds a complex `IExpression` for filtering the provided key with two conditions:
     * * The first filter the provided key with a NULL value.
     * * The second filter the provided key EQUAL to the provided value.
     *
     * Both expressions are joined using the provided operator.
     * @param {?} key the key.
     * @param {?} value the value.
     * @param {?} op the operator.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionNullAndValue = /**
     * Builds a complex `IExpression` for filtering the provided key with two conditions:
     * * The first filter the provided key with a NULL value.
     * * The second filter the provided key EQUAL to the provided value.
     *
     * Both expressions are joined using the provided operator.
     * @param {?} key the key.
     * @param {?} value the value.
     * @param {?} op the operator.
     * @return {?} the `IExpression`.
     */
    function (key, value, op) {
        /** @type {?} */
        var isNull = FilterExpressionUtils.buildExpressionIsNull(key);
        /** @type {?} */
        var equals = FilterExpressionUtils.buildExpressionEquals(key, value);
        /** @type {?} */
        var expr = {
            lop: isNull,
            op: op,
            rop: equals
        };
        return expr;
    };
    /**
     * Builds a complex `IExpression` for filtering the provided keys LIKE the value provided.
     * @param keys the keys.
     * @param value the value.
     * @returns the `IExpression`.
     */
    /**
     * Builds a complex `IExpression` for filtering the provided keys LIKE the value provided.
     * @param {?} keys the keys.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildArrayExpressionLike = /**
     * Builds a complex `IExpression` for filtering the provided keys LIKE the value provided.
     * @param {?} keys the keys.
     * @param {?} value the value.
     * @return {?} the `IExpression`.
     */
    function (keys, value) {
        /** @type {?} */
        var result = {
            lop: undefined,
            op: undefined
        };
        keys.forEach(function (col) {
            result = FilterExpressionUtils.stackExpressionLikeOR(col, value, result);
        });
        return result;
    };
    /**
     * Builds an `IExpression` instance from the provided object.
     * @param obj the object.
     * @returns the `IExpression`.
     */
    /**
     * Builds an `IExpression` instance from the provided object.
     * @param {?} obj the object.
     * @return {?} the `IExpression`.
     */
    FilterExpressionUtils.buildExpressionFromObject = /**
     * Builds an `IExpression` instance from the provided object.
     * @param {?} obj the object.
     * @return {?} the `IExpression`.
     */
    function (obj) {
        /** @type {?} */
        var result = {
            lop: undefined,
            op: undefined
        };
        Object.keys(obj || {}).forEach(function (key) {
            result = FilterExpressionUtils.stackExpressionEqualsAND(key, obj[key], result);
        });
        return result;
    };
    /**
     * @param {?} key
     * @param {?} value
     * @param {?} expr
     * @return {?}
     */
    FilterExpressionUtils.stackExpressionLikeOR = /**
     * @param {?} key
     * @param {?} value
     * @param {?} expr
     * @return {?}
     */
    function (key, value, expr) {
        /** @type {?} */
        var likeExpr = FilterExpressionUtils.buildExpressionLike(key, value);
        if (expr.lop === undefined && expr.op === undefined) {
            return likeExpr;
        }
        else {
            expr = FilterExpressionUtils.buildComplexExpression(expr, likeExpr, FilterExpressionUtils.OP_OR);
        }
        return expr;
    };
    /**
     * @param {?} key
     * @param {?} value
     * @param {?} expr
     * @return {?}
     */
    FilterExpressionUtils.stackExpressionEqualsAND = /**
     * @param {?} key
     * @param {?} value
     * @param {?} expr
     * @return {?}
     */
    function (key, value, expr) {
        /** @type {?} */
        var equalsExpr = FilterExpressionUtils.buildExpressionEquals(key, value);
        if (expr.lop === undefined && expr.op === undefined) {
            return equalsExpr;
        }
        else {
            expr = FilterExpressionUtils.buildComplexExpression(expr, equalsExpr, FilterExpressionUtils.OP_AND);
        }
        return expr;
    };
    /**
     * The basic expresion key.
     */
    FilterExpressionUtils.BASIC_EXPRESSION_KEY = '@basic_expression';
    /**
     * The filter expresion key.
     */
    FilterExpressionUtils.FILTER_EXPRESSION_KEY = '@filter_expression';
    /**
     * The `OR` operator.
     */
    FilterExpressionUtils.OP_OR = 'OR';
    /**
     * The `AND` operator.
     */
    FilterExpressionUtils.OP_AND = 'AND';
    /**
     * The `LIKE` operator
     */
    FilterExpressionUtils.OP_LIKE = 'LIKE';
    /**
     * The `NOT LIKE` operator.
     */
    FilterExpressionUtils.OP_NOT_LIKE = 'NOT LIKE';
    /**
     * The `EQUAL` operator.
     */
    FilterExpressionUtils.OP_EQUAL = '=';
    /**
     * The `NOT EQUAL` operator.
     */
    FilterExpressionUtils.OP_NOT_EQUAL = '<>';
    /**
     * The `IS NULL` operator.
     */
    FilterExpressionUtils.OP_NULL = 'IS NULL';
    /**
     * The `IS NOT NULL` operator.
     */
    FilterExpressionUtils.OP_NOT_NULL = 'IS NOT NULL';
    /**
     * The `LESS` operator.
     */
    FilterExpressionUtils.OP_LESS = '<';
    /**
     * The `LES EQUAL` operator.
     */
    FilterExpressionUtils.OP_LESS_EQUAL = '<=';
    /**
     * The `MORE` operator.
     */
    FilterExpressionUtils.OP_MORE = '>';
    /**
     * The `MORE EQUAL` operator.
     */
    FilterExpressionUtils.OP_MORE_EQUAL = '>=';
    /**
     * The `IN` operator.
     */
    FilterExpressionUtils.OP_IN = 'IN';
    return FilterExpressionUtils;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_LOCAL_STORAGE_KEY = undefined;
/** @type {?} */
var DEFAULT_CONFIG = {
    uuid: DEFAULT_LOCAL_STORAGE_KEY,
    title: 'Ontimize Web App'
};
/** @type {?} */
var O_INPUTS_OPTIONS = new core.InjectionToken('o-inputs-options');
/** @type {?} */
var APP_CONFIG = new core.InjectionToken('app.config');
var AppConfig = /** @class */ (function () {
    function AppConfig(config$$1) {
        this._config = (config$$1 && Util.isObject(config$$1) && !Array.isArray(config$$1)) ? config$$1 : {};
    }
    /**
     * @return {?}
     */
    AppConfig.prototype.getConfiguration = /**
     * @return {?}
     */
    function () {
        return Object.assign(DEFAULT_CONFIG, this._config);
    };
    /**
     * @return {?}
     */
    AppConfig.prototype.getServiceConfiguration = /**
     * @return {?}
     */
    function () {
        return this._config.servicesConfiguration || {};
    };
    /**
     * @return {?}
     */
    AppConfig.prototype.getMenuConfiguration = /**
     * @return {?}
     */
    function () {
        return this._config.appMenuConfiguration || [];
    };
    /**
     * @return {?}
     */
    AppConfig.prototype.useRemoteBundle = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this._config.bundle);
    };
    /**
     * @return {?}
     */
    AppConfig.prototype.getBundleEndpoint = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result;
        /** @type {?} */
        var existsBundleConf = this.useRemoteBundle();
        if (existsBundleConf && Util.isDefined(this._config.bundle.endpoint)) {
            result = this._config.bundle.endpoint;
        }
        else if (existsBundleConf && Util.isDefined(this._config.bundle.path)) {
            result = this._config.apiEndpoint + '/' + this._config.bundle.path;
        }
        return result;
    };
    /**
     * @return {?}
     */
    AppConfig.prototype.getI18nAssetsConfiguration = /**
     * @return {?}
     */
    function () {
        if (Util.isDefined(this._config.assets) && Util.isDefined(this._config.assets.i18n)) {
            return this._config.assets.i18n;
        }
        return undefined;
    };
    /**
     * @return {?}
     */
    AppConfig.prototype.getCssAssetsConfiguration = /**
     * @return {?}
     */
    function () {
        if (Util.isDefined(this._config.assets) && Util.isDefined(this._config.assets.css)) {
            return this._config.assets.css;
        }
        return undefined;
    };
    /**
     * @return {?}
     */
    AppConfig.prototype.getImagesAssetsConfiguration = /**
     * @return {?}
     */
    function () {
        if (Util.isDefined(this._config.assets) && Util.isDefined(this._config.assets.images)) {
            return this._config.assets.images;
        }
        return undefined;
    };
    /**
     * @return {?}
     */
    AppConfig.prototype.getJsAssetsConfiguration = /**
     * @return {?}
     */
    function () {
        if (Util.isDefined(this._config.assets) && Util.isDefined(this._config.assets.js)) {
            return this._config.assets.js;
        }
        return undefined;
    };
    /**
     * @return {?}
     */
    AppConfig.prototype.getRemoteConfigurationConfig = /**
     * @return {?}
     */
    function () {
        return this._config.remoteConfig;
    };
    /**
     * @return {?}
     */
    AppConfig.prototype.useRemoteConfiguration = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this._config.remoteConfig);
    };
    /**
     * @return {?}
     */
    AppConfig.prototype.getRemoteConfigurationEndpoint = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result;
        /** @type {?} */
        var existsRemoteConf = this.useRemoteConfiguration();
        if (existsRemoteConf && Util.isDefined(this._config.remoteConfig.endpoint)) {
            result = this._config.remoteConfig.endpoint;
        }
        else if (existsRemoteConf && Util.isDefined(this._config.remoteConfig.path)) {
            result = this._config.apiEndpoint + '/' + this._config.remoteConfig.path;
        }
        return result;
    };
    return AppConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var LoginService$$1 = /** @class */ (function () {
    function LoginService$$1(injector) {
        this.injector = injector;
        this.onLogin = new core.EventEmitter();
        this.onLogout = new core.EventEmitter();
        this._config = this.injector.get(AppConfig).getConfiguration();
        this.router = this.injector.get(router.Router);
        this._localStorageKey = this._config['uuid'];
        /** @type {?} */
        var sessionInfo = this.getSessionInfo();
        if (sessionInfo && sessionInfo.id && sessionInfo.user && sessionInfo.user.length > 0) {
            this._user = sessionInfo.user;
        }
        this.dialogService = injector.get(DialogService);
    }
    Object.defineProperty(LoginService$$1.prototype, "user", {
        get: /**
         * @return {?}
         */
        function () {
            return this._user;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoginService$$1.prototype, "localStorageKey", {
        get: /**
         * @return {?}
         */
        function () {
            return this._localStorageKey;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} config
     * @return {?}
     */
    LoginService$$1.prototype.configureOntimizeAuthService = /**
     * @param {?} config
     * @return {?}
     */
    function (config$$1) {
        this.ontService = this.injector.get(OntimizeService$$1);
        /** @type {?} */
        var servConf = {};
        servConf[Codes.SESSION_KEY] = this.getSessionInfo();
        this.ontService.configureService(servConf);
    };
    /**
     * @return {?}
     */
    LoginService$$1.prototype.retrieveAuthService = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this.ontService !== undefined) {
                resolve(_this.ontService);
            }
            else {
                _this.configureOntimizeAuthService(_this._config);
                resolve(_this.ontService);
            }
        });
    };
    /**
     * @param {?} user
     * @param {?} password
     * @return {?}
     */
    LoginService$$1.prototype.login = /**
     * @param {?} user
     * @param {?} password
     * @return {?}
     */
    function (user, password) {
        this._user = user;
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var innerObserver;
        /** @type {?} */
        var dataObservable = new Observable(function (observer) { return innerObserver = observer; }).pipe(share());
        this.retrieveAuthService().then(function (service) {
            service.startsession(user, password).subscribe(function (resp) {
                self.onLoginSuccess(resp);
                /** @type {?} */
                var permissionsService = self.injector.get(PermissionsService);
                /** @type {?} */
                var remoteConfigService = self.injector.get(ORemoteConfigurationService);
                /** @type {?} */
                var pendingArray = [];
                pendingArray.push(permissionsService.getUserPermissionsAsPromise());
                pendingArray.push(remoteConfigService.initialize());
                combineLatest(pendingArray).subscribe(function () {
                    innerObserver.next();
                    innerObserver.complete();
                });
            }, function (error) {
                self.onLoginError(error);
                innerObserver.error(error);
            });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?} sessionId
     * @return {?}
     */
    LoginService$$1.prototype.onLoginSuccess = /**
     * @param {?} sessionId
     * @return {?}
     */
    function (sessionId) {
        /** @type {?} */
        var session = {
            user: this._user,
            id: sessionId
        };
        this.storeSessionInfo(session);
        ObservableWrapper.callEmit(this.onLogin, session);
    };
    /**
     * @param {?} error
     * @return {?}
     */
    LoginService$$1.prototype.onLoginError = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        this.dialogService.alert('ERROR', 'MESSAGES.ERROR_LOGIN');
    };
    /**
     * @return {?}
     */
    LoginService$$1.prototype.logout = /**
     * @return {?}
     */
    function () {
        ObservableWrapper.callEmit(this.onLogout, null);
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var sessionInfo = this.getSessionInfo();
        /** @type {?} */
        var dataObservable = new Observable(function (innerObserver) {
            self.retrieveAuthService().then(function (service) {
                service.endsession(sessionInfo.user, sessionInfo.id).subscribe(function (resp) {
                    /** @type {?} */
                    var remoteConfigService = self.injector.get(ORemoteConfigurationService);
                    remoteConfigService.finalize().subscribe(function () {
                        self.onLogoutSuccess(resp);
                        innerObserver.next();
                        innerObserver.complete();
                    });
                }, function (error) {
                    self.onLogoutError(error);
                    innerObserver.error(error);
                });
            });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?} sessionId
     * @return {?}
     */
    LoginService$$1.prototype.onLogoutSuccess = /**
     * @param {?} sessionId
     * @return {?}
     */
    function (sessionId) {
        if (sessionId === 0) {
            this.sessionExpired();
        }
    };
    /**
     * @param {?} error
     * @return {?}
     */
    LoginService$$1.prototype.onLogoutError = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        console.error('Error on logout');
    };
    /**
     * @return {?}
     */
    LoginService$$1.prototype.sessionExpired = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var sessionInfo = this.getSessionInfo();
        delete sessionInfo.id;
        delete sessionInfo.user;
        this.storeSessionInfo(sessionInfo);
    };
    /**
     * @return {?}
     */
    LoginService$$1.prototype.isLoggedIn = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var sessionInfo = this.getSessionInfo();
        if (sessionInfo && sessionInfo.id && sessionInfo.user && sessionInfo.user.length > 0) {
            if (isNaN(sessionInfo.id) && sessionInfo.id < 0) {
                return false;
            }
            return true;
        }
        return false;
    };
    /**
     * @param {?} sessionInfo
     * @return {?}
     */
    LoginService$$1.prototype.storeSessionInfo = /**
     * @param {?} sessionInfo
     * @return {?}
     */
    function (sessionInfo) {
        if (sessionInfo !== undefined) {
            /** @type {?} */
            var info = localStorage.getItem(this._localStorageKey);
            /** @type {?} */
            var stored = null;
            if (info && info.length > 0) {
                stored = JSON.parse(info);
            }
            else {
                stored = {};
            }
            stored[Codes.SESSION_KEY] = sessionInfo;
            localStorage.setItem(this._localStorageKey, JSON.stringify(stored));
        }
    };
    /**
     * @return {?}
     */
    LoginService$$1.prototype.getSessionInfo = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var info = localStorage.getItem(this._localStorageKey);
        if (!info) {
            return {};
        }
        /** @type {?} */
        var stored = JSON.parse(info);
        return stored[Codes.SESSION_KEY] || {};
    };
    /**
     * @return {?}
     */
    LoginService$$1.prototype.logoutAndRedirect = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.logout().subscribe(function () {
            ServiceUtils$$1.redirectLogin(_this.router, false);
        });
    };
    /**
     * @return {?}
     */
    LoginService$$1.prototype.logoutWithConfirmationAndRedirect = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.dialogService.confirm('CONFIRM', 'MESSAGES.CONFIRM_LOGOUT').then(function (res) {
            if (res) {
                _this.logoutAndRedirect();
            }
        });
    };
    LoginService$$1.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    LoginService$$1.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return LoginService$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var LocalStorageService = /** @class */ (function () {
    function LocalStorageService(injector) {
        this.injector = injector;
        this.onRouteChange = new core.EventEmitter();
        this.onSetLocalStorage = new core.EventEmitter();
        this._config = this.injector.get(AppConfig).getConfiguration();
        this._router = this.injector.get(router.Router);
        this.loginService = this.injector.get(LoginService$$1);
        /** @type {?} */
        var self = this;
        this._router.events.subscribe(function (event) {
            if (event instanceof router.NavigationStart) {
                ObservableWrapper.callEmit(self.onRouteChange, {});
            }
        });
    }
    /**
     * @param {?} comp
     * @param {?=} routeKey
     * @return {?}
     */
    LocalStorageService.prototype.getComponentStorage = /**
     * @param {?} comp
     * @param {?=} routeKey
     * @return {?}
     */
    function (comp, routeKey) {
        if (routeKey === void 0) { routeKey = undefined; }
        /** @type {?} */
        var componentKey = comp.getComponentKey();
        /** @type {?} */
        var completeKey = componentKey;
        if (routeKey) {
            completeKey += '_' + routeKey;
        }
        return this.getAppComponentData(completeKey) || {};
    };
    /**
     * @param {?} comp
     * @param {?=} routeKey
     * @return {?}
     */
    LocalStorageService.prototype.updateComponentStorage = /**
     * @param {?} comp
     * @param {?=} routeKey
     * @return {?}
     */
    function (comp, routeKey) {
        if (routeKey === void 0) { routeKey = undefined; }
        /** @type {?} */
        var dataToStore = comp.getDataToStore();
        /** @type {?} */
        var componentKey = comp.getComponentKey();
        if (!Util.isDefined(componentKey)) {
            return;
        }
        /** @type {?} */
        var completeKey = componentKey;
        if (routeKey) {
            completeKey += '_' + routeKey;
        }
        /** @type {?} */
        var storedObject = {};
        for (var prop in dataToStore) {
            if (dataToStore.hasOwnProperty(prop)) {
                storedObject[prop] = dataToStore[prop];
            }
        }
        this.updateAppComponentStorage(completeKey, storedObject);
    };
    /**
     * @param {?} key
     * @return {?}
     */
    LocalStorageService.prototype.getAppComponentData = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        /** @type {?} */
        var componentData = undefined;
        /** @type {?} */
        var storedComponents = this.getSessionUserComponentsData() || {};
        if (storedComponents[key]) {
            /** @type {?} */
            var decoded = atob(storedComponents[key]);
            try {
                componentData = JSON.parse(decoded);
            }
            catch (e) {
                componentData = undefined;
            }
        }
        return componentData;
    };
    /**
     * @param {?} componentKey
     * @param {?} componentData
     * @return {?}
     */
    LocalStorageService.prototype.updateAppComponentStorage = /**
     * @param {?} componentKey
     * @param {?} componentData
     * @return {?}
     */
    function (componentKey, componentData) {
        /** @type {?} */
        var componentDataB64 = undefined;
        try {
            componentDataB64 = btoa(JSON.stringify(componentData));
        }
        catch (e) {
            componentDataB64 = undefined;
        }
        this.storeComponentInSessionUser(componentKey, componentDataB64);
    };
    /**
     * @return {?}
     */
    LocalStorageService.prototype.getSessionUserComponentsData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var storedComponentsByUser = {};
        /** @type {?} */
        var appData = this.getStoredData();
        /** @type {?} */
        var session = appData[LocalStorageService.SESSION_STORAGE_KEY] || {};
        /** @type {?} */
        var users = appData[LocalStorageService.USERS_STORAGE_KEY] || {};
        storedComponentsByUser = (users[session.user] || {})[LocalStorageService.COMPONENTS_STORAGE_KEY] || {};
        return storedComponentsByUser;
    };
    /**
     * @param {?} componentsData
     * @return {?}
     */
    LocalStorageService.prototype.storeSessionUserComponentsData = /**
     * @param {?} componentsData
     * @return {?}
     */
    function (componentsData) {
        /** @type {?} */
        var appData = this.getStoredData();
        /** @type {?} */
        var session = appData[LocalStorageService.SESSION_STORAGE_KEY] || {};
        if (!Util.isDefined(appData[LocalStorageService.USERS_STORAGE_KEY])) {
            appData[LocalStorageService.USERS_STORAGE_KEY] = {};
        }
        /** @type {?} */
        var userData = appData[LocalStorageService.USERS_STORAGE_KEY][session.user] || {};
        userData[LocalStorageService.COMPONENTS_STORAGE_KEY] = componentsData;
        appData[LocalStorageService.USERS_STORAGE_KEY][session.user] = userData;
        this.setLocalStorage(appData);
    };
    /**
     * @param {?} componentKey
     * @param {?} componentDataB64
     * @return {?}
     */
    LocalStorageService.prototype.storeComponentInSessionUser = /**
     * @param {?} componentKey
     * @param {?} componentDataB64
     * @return {?}
     */
    function (componentKey, componentDataB64) {
        /** @type {?} */
        var appData = this.getStoredData();
        /** @type {?} */
        var session = appData[LocalStorageService.SESSION_STORAGE_KEY] || {}; // uuid -> session
        if (!Util.isDefined(session) || !Util.isDefined(session.user)) {
            return;
        }
        /** @type {?} */
        var users = appData[LocalStorageService.USERS_STORAGE_KEY] || {};
        /** @type {?} */
        var idUser = session.user || this.loginService.getSessionInfo().user;
        /** @type {?} */
        var user = users[idUser] || {};
        /** @type {?} */
        var componentData = {};
        if (users[idUser]) {
            componentData = users[idUser][LocalStorageService.COMPONENTS_STORAGE_KEY];
        }
        componentData[componentKey] = componentDataB64 || {};
        user[LocalStorageService.COMPONENTS_STORAGE_KEY] = componentData;
        users[idUser] = user;
        appData[LocalStorageService.USERS_STORAGE_KEY] = users;
        this.setLocalStorage(appData);
    };
    /**
     * @return {?}
     */
    LocalStorageService.prototype.getStoredData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var appData = {};
        /** @type {?} */
        var appStoredData = localStorage.getItem(this._config['uuid']);
        if (appStoredData) {
            try {
                appData = JSON.parse(appStoredData);
            }
            catch (e) {
                appData = {};
            }
        }
        return appData;
    };
    /**
     * @return {?}
     */
    LocalStorageService.prototype.setBackwardCompatibility = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var appData = this.getStoredData();
        /** @type {?} */
        var session = appData[LocalStorageService.SESSION_STORAGE_KEY];
        if (!Util.isDefined(session) || !Util.isDefined(session.user)) {
            return;
        }
        /** @type {?} */
        var componentsInfo = appData[LocalStorageService.COMPONENTS_STORAGE_KEY] || {};
        /** @type {?} */
        var usersObject = {};
        /** @type {?} */
        var existsUsersTag = Util.isDefined(appData[LocalStorageService.USERS_STORAGE_KEY]);
        /** @type {?} */
        var createUserInfo = existsUsersTag;
        if (existsUsersTag) {
            usersObject = appData[LocalStorageService.USERS_STORAGE_KEY];
            createUserInfo = !Util.isDefined(appData[LocalStorageService.USERS_STORAGE_KEY][session.user]);
        }
        if (createUserInfo) {
            usersObject[session.user] = {};
            usersObject[session.user][LocalStorageService.COMPONENTS_STORAGE_KEY] = componentsInfo;
            appData[LocalStorageService.USERS_STORAGE_KEY] = usersObject;
            localStorage.setItem(this._config['uuid'], JSON.stringify(appData));
        }
    };
    /**
     * @param {?} appData
     * @return {?}
     */
    LocalStorageService.prototype.setLocalStorage = /**
     * @param {?} appData
     * @return {?}
     */
    function (appData) {
        this.onSetLocalStorage.emit();
        localStorage.setItem(this._config['uuid'], JSON.stringify(appData));
    };
    LocalStorageService.COMPONENTS_STORAGE_KEY = 'components';
    LocalStorageService.USERS_STORAGE_KEY = 'users';
    LocalStorageService.SESSION_STORAGE_KEY = 'session';
    return LocalStorageService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ONavigationItem = /** @class */ (function () {
    function ONavigationItem(value) {
        this.url = value['url'] ? value['url'] : '';
        this.queryParams = value[Codes.QUERY_PARAMS] ? value[Codes.QUERY_PARAMS] : {};
        this.text = value['text'] ? value['text'] : '';
        this.displayText = value['displayText'] ? value['displayText'] : '';
        this.formRoutes = value['formRoutes'];
        this.activeFormMode = value['activeFormMode'];
        this.keysValues = value['keysValues'];
        this.queryConfiguration = value['queryConfiguration'];
    }
    /**
     * @return {?}
     */
    ONavigationItem.prototype.getActiveModePath = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result;
        if (Util.isDefined(this.activeFormMode)) {
            result = (this.formRoutes || {})[this.activeFormMode];
        }
        return result;
    };
    /**
     * @param {?=} storageData
     * @return {?}
     */
    ONavigationItem.prototype.findAndMergeNavigationItem = /**
     * @param {?=} storageData
     * @return {?}
     */
    function (storageData) {
        var _this = this;
        if (storageData === void 0) { storageData = []; }
        /** @type {?} */
        var storedItem = storageData.find(function (element) { return element.url === _this.url; });
        if (storedItem) {
            this[Codes.QUERY_PARAMS] = storedItem[Codes.QUERY_PARAMS];
            this.displayText = storedItem.displayText;
            this.formRoutes = storedItem.formRoutes;
            this.formLayoutRoutes = storedItem.formLayoutRoutes;
            this.activeFormMode = storedItem.activeFormMode;
            this.keysValues = storedItem.keysValues;
            this.queryConfiguration = storedItem.queryConfiguration;
        }
    };
    /**
     * @return {?}
     */
    ONavigationItem.prototype.isInsertFormRoute = /**
     * @return {?}
     */
    function () {
        return this.activeFormMode === 'insertFormRoute';
    };
    /**
     * @return {?}
     */
    ONavigationItem.prototype.getInsertFormRoute = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var routes = this.formRoutes;
        return routes ? (routes.insertFormRoute || Codes.DEFAULT_INSERT_ROUTE) : Codes.DEFAULT_INSERT_ROUTE;
    };
    /**
     * @return {?}
     */
    ONavigationItem.prototype.getEditFormRoute = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var routes = this.formRoutes;
        return routes ? (routes.editFormRoute || Codes.DEFAULT_EDIT_ROUTE) : Codes.DEFAULT_EDIT_ROUTE;
    };
    /**
     * @return {?}
     */
    ONavigationItem.prototype.getDetailFormRoute = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var routes = this.formRoutes;
        return routes ? (routes.detailFormRoute || Codes.DEFAULT_DETAIL_ROUTE) : Codes.DEFAULT_DETAIL_ROUTE;
    };
    /**
     * @return {?}
     */
    ONavigationItem.prototype.isMainFormLayoutManagerComponent = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this.formLayoutRoutes);
    };
    /**
     * @return {?}
     */
    ONavigationItem.prototype.getFormRoutes = /**
     * @return {?}
     */
    function () {
        return this.formRoutes;
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    ONavigationItem.prototype.setFormRoutes = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        if (arg && arg.mainFormLayoutManagerComponent) {
            this.formLayoutRoutes = arg;
        }
        else {
            this.formRoutes = arg;
        }
    };
    /**
     * @return {?}
     */
    ONavigationItem.prototype.deleteActiveFormMode = /**
     * @return {?}
     */
    function () {
        this.activeFormMode = undefined;
    };
    return ONavigationItem;
}());
/** @type {?} */
var MAXIMIUM_NAVIGATION_HEAP_SIZE = 15;
var NavigationService = /** @class */ (function () {
    function NavigationService(injector) {
        var _this = this;
        this.injector = injector;
        this.currentTitle = null;
        this.visible = true;
        this.navigationItems = [];
        this.allNavigationItems = [];
        this.navigationEventsSource = new ReplaySubject(1);
        this.navigationEvents$ = this.navigationEventsSource.asObservable();
        this._titleEmitter = new core.EventEmitter();
        this._visibleEmitter = new core.EventEmitter();
        this._sidenavEmitter = new core.EventEmitter();
        this.router = this.injector.get(router.Router);
        this.localStorageService = this.injector.get(LocalStorageService);
        this.location = this.injector.get(common.Location);
        this.location.subscribe(function (val) {
            /** @type {?} */
            var previousRoute = _this.getPreviousRouteData();
            /** @type {?} */
            var qParams = Object.keys(previousRoute.queryParams);
            /** @type {?} */
            var arr = [];
            qParams.forEach(function (p) {
                arr.push(p + "=" + previousRoute.queryParams[p]);
            });
            /** @type {?} */
            var fullUrl = "/" + previousRoute.url;
            if (arr.length > 0) {
                fullUrl = "/" + previousRoute.url + "?" + arr.join('&');
            }
            if (fullUrl === val.url) {
                _this.navigationItems.pop();
            }
        });
    }
    /**
     * @return {?}
     */
    NavigationService.prototype.initialize = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var navEndEvents = this.router.events.pipe(filter(function (event) { return event instanceof router.NavigationEnd; }));
        navEndEvents
            .pipe(map(function () { return _this.router.routerState.root; }))
            .pipe(map(function (route) {
            while (route.firstChild) {
                route = route.firstChild;
            }
            return route;
        }))
            .pipe(filter(function (route) { return route.outlet === 'primary'; }))
            .subscribe(self.parseNavigationItems.bind(self));
    };
    /**
     * @param {?} activatedRoute
     * @return {?}
     */
    NavigationService.prototype.parseNavigationItems = /**
     * @param {?} activatedRoute
     * @return {?}
     */
    function (activatedRoute) {
        /** @type {?} */
        var storedNavigation = this.getStoredData();
        /** @type {?} */
        var route = this.router.routerState.root.snapshot;
        /** @type {?} */
        var url = '';
        /** @type {?} */
        var navigationItems = [];
        while (Util.isDefined(route.firstChild)) {
            route = route.firstChild;
            if (!route || !route.url || route.routeConfig === null || !route.routeConfig.path) {
                continue;
            }
            /** @type {?} */
            var lastNavData = navigationItems[navigationItems.length - 1];
            /** @type {?} */
            var parsedRoute = this.parseRoute(url, route.url, lastNavData);
            url = parsedRoute.url;
            if (storedNavigation.length > 1 && parsedRoute.routeArr.length > 0) {
                /** @type {?} */
                var lastStored = storedNavigation[storedNavigation.length - 1];
                if (lastStored.url === url) {
                    /** @type {?} */
                    var newItem = new ONavigationItem(lastStored);
                    /** @type {?} */
                    var newItemActivePath = newItem.getActiveModePath();
                    if (!newItemActivePath || parsedRoute.routeArr.length > newItemActivePath.split('/').length) {
                        navigationItems.push(newItem);
                        /** @type {?} */
                        var parsed = this.parseRoute(url, parsedRoute.routeArr, newItem);
                        url = parsed.url;
                        parsedRoute.text = parsed.text;
                    }
                }
            }
            /** @type {?} */
            var formRoutes = undefined;
            if (lastNavData && lastNavData.formLayoutRoutes) {
                formRoutes = Object.assign({}, lastNavData.formLayoutRoutes);
            }
            /** @type {?} */
            var navigationItem = new ONavigationItem({
                url: url,
                queryParams: route.queryParams,
                text: parsedRoute.text,
                formRoutes: formRoutes,
                activeFormMode: formRoutes ? (lastNavData && lastNavData.activeFormMode) : undefined
            });
            navigationItem.findAndMergeNavigationItem(storedNavigation);
            navigationItems.push(navigationItem);
        }
        if (navigationItems.length > 1) {
            navigationItems[navigationItems.length - 1].terminal = true;
        }
        /** @type {?} */
        var mergedNavigation = this.mergeNavigationItems(navigationItems, storedNavigation);
        this.setNavigationItems(navigationItems, mergedNavigation);
    };
    /**
     * @param {?} url
     * @param {?} routeSegments
     * @param {?} navData
     * @return {?}
     */
    NavigationService.prototype.parseRoute = /**
     * @param {?} url
     * @param {?} routeSegments
     * @param {?} navData
     * @return {?}
     */
    function (url, routeSegments, navData) {
        /** @type {?} */
        var text = '';
        /** @type {?} */
        var modePathArr = [];
        /** @type {?} */
        var modePath = navData ? navData.getActiveModePath() : undefined;
        if (modePath && modePath.length > 0) {
            modePathArr = modePath.split('/');
            /** @type {?} */
            var detailRoute = navData.getDetailFormRoute();
            if (Util.isDefined(detailRoute)) {
                url += url.length > 0 ? ('/' + detailRoute) : detailRoute;
            }
        }
        /** @type {?} */
        var routeArr = [];
        for (var i = 0, len = routeSegments.length; i < len; i++) {
            /** @type {?} */
            var s = routeSegments[i];
            /** @type {?} */
            var notModePath = modePathArr.indexOf(s.path) === -1;
            if (notModePath && text.length === 0) {
                text = text.length > 0 ? ('/' + s.path) : s.path;
                url += url.length > 0 ? ('/' + s.path) : s.path;
            }
            else if (notModePath) {
                url += url.length > 0 ? ('/' + s.path) : s.path;
            }
            else {
                routeArr.push(s);
            }
        }
        /** @type {?} */
        var activeMode = navData ? navData.activeFormMode : undefined;
        if (modePath && modePath.length > 0 && (activeMode === 'editFormRoute') || (activeMode === 'insertFormRoute')) {
            url += url.length > 0 ? ('/' + modePath) : modePath;
        }
        return {
            url: url,
            text: text,
            routeArr: routeArr
        };
    };
    /**
     * @param {?} navigationItems
     * @param {?} mergedNavigationItems
     * @return {?}
     */
    NavigationService.prototype.setNavigationItems = /**
     * @param {?} navigationItems
     * @param {?} mergedNavigationItems
     * @return {?}
     */
    function (navigationItems, mergedNavigationItems) {
        this.navigationItems = mergedNavigationItems;
        this.storeNavigation();
        this.navigationEventsSource.next(navigationItems);
    };
    /**
     * @return {?}
     */
    NavigationService.prototype.getDataToStore = /**
     * @return {?}
     */
    function () {
        return this.navigationItems;
    };
    /**
     * @return {?}
     */
    NavigationService.prototype.getComponentKey = /**
     * @return {?}
     */
    function () {
        return NavigationService.NAVIGATION_STORAGE_KEY;
    };
    /**
     * @return {?}
     */
    NavigationService.prototype.storeNavigation = /**
     * @return {?}
     */
    function () {
        if (this.localStorageService) {
            this.localStorageService.updateComponentStorage(this);
        }
    };
    /**
     * @param {?} title
     * @return {?}
     */
    NavigationService.prototype.setTitle = /**
     * @param {?} title
     * @return {?}
     */
    function (title) {
        this.currentTitle = title;
        this._emitTitleChanged(this.currentTitle);
    };
    /**
     * @param {?} visible
     * @return {?}
     */
    NavigationService.prototype.setVisible = /**
     * @param {?} visible
     * @return {?}
     */
    function (visible) {
        this.visible = visible;
        this._emitVisibleChanged(this.visible);
    };
    /**
     * @return {?}
     */
    NavigationService.prototype.openSidenav = /**
     * @return {?}
     */
    function () {
        this._emitOpenSidenav();
    };
    /**
     * @return {?}
     */
    NavigationService.prototype.closeSidenav = /**
     * @return {?}
     */
    function () {
        this._emitCloseSidenav();
    };
    /**
     * Subscribe to title updates
     * @param {?} onNext
     * @return {?}
     */
    NavigationService.prototype.onTitleChange = /**
     * Subscribe to title updates
     * @param {?} onNext
     * @return {?}
     */
    function (onNext) {
        return ObservableWrapper.subscribe(this._titleEmitter, onNext);
    };
    /**
     * @param {?} onNext
     * @return {?}
     */
    NavigationService.prototype.onVisibleChange = /**
     * @param {?} onNext
     * @return {?}
     */
    function (onNext) {
        return ObservableWrapper.subscribe(this._visibleEmitter, onNext);
    };
    /**
     * @param {?} onNext
     * @return {?}
     */
    NavigationService.prototype.onSidenavChange = /**
     * @param {?} onNext
     * @return {?}
     */
    function (onNext) {
        return ObservableWrapper.subscribe(this._sidenavEmitter, onNext);
    };
    /**
     * @param {?} title
     * @return {?}
     */
    NavigationService.prototype._emitTitleChanged = /**
     * @param {?} title
     * @return {?}
     */
    function (title) {
        ObservableWrapper.callEmit(this._titleEmitter, title);
    };
    /**
     * @param {?} visible
     * @return {?}
     */
    NavigationService.prototype._emitVisibleChanged = /**
     * @param {?} visible
     * @return {?}
     */
    function (visible) {
        ObservableWrapper.callEmit(this._visibleEmitter, visible);
    };
    /**
     * @return {?}
     */
    NavigationService.prototype._emitOpenSidenav = /**
     * @return {?}
     */
    function () {
        ObservableWrapper.callEmit(this._sidenavEmitter, 'open');
    };
    /**
     * @return {?}
     */
    NavigationService.prototype._emitCloseSidenav = /**
     * @return {?}
     */
    function () {
        ObservableWrapper.callEmit(this._sidenavEmitter, 'close');
    };
    /**
     * @param {?} routes
     * @param {?} activeMode
     * @param {?=} queryConf
     * @return {?}
     */
    NavigationService.prototype.storeFormRoutes = /**
     * @param {?} routes
     * @param {?} activeMode
     * @param {?=} queryConf
     * @return {?}
     */
    function (routes, activeMode, queryConf) {
        if (queryConf === void 0) { queryConf = undefined; }
        if (this.navigationItems.length > 0) {
            this.navigationItems[this.navigationItems.length - 1].setFormRoutes(routes);
            this.navigationItems[this.navigationItems.length - 1].activeFormMode = activeMode;
            if (queryConf) {
                this.navigationItems[this.navigationItems.length - 1].keysValues = queryConf.keysValues;
                delete queryConf.keysValues;
                if (Object.keys(queryConf).length > 0) {
                    this.navigationItems[this.navigationItems.length - 1].queryConfiguration = queryConf;
                }
            }
            this.storeNavigation();
        }
    };
    /**
     * @return {?}
     */
    NavigationService.prototype.getStoredData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var storageData = this.localStorageService.getComponentStorage(this);
        /** @type {?} */
        var result = [];
        Object.keys(storageData).forEach(function (key) { return result.push(new ONavigationItem(storageData[key])); });
        return result;
    };
    /**
     * @return {?}
     */
    NavigationService.prototype.getPreviousRouteData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result;
        /** @type {?} */
        var len = this.navigationItems.length;
        if (len >= 2) {
            result = this.navigationItems[len - 2];
            if (result && result.formRoutes && result.formRoutes.mainFormLayoutManagerComponent && this.navigationItems[len - 3]) {
                /** @type {?} */
                var parent_1 = this.navigationItems[len - 3];
                if (parent_1.isMainFormLayoutManagerComponent()) {
                    result = parent_1;
                }
            }
        }
        return result;
    };
    /**
     * @return {?}
     */
    NavigationService.prototype.removeLastItem = /**
     * @return {?}
     */
    function () {
        this.navigationItems.pop();
        this.storeNavigation();
    };
    /**
     * @return {?}
     */
    NavigationService.prototype.getLastItem = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result;
        if (this.navigationItems.length > 0) {
            result = this.navigationItems[this.navigationItems.length - 1];
        }
        return result;
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    NavigationService.prototype.deleteActiveFormMode = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        arg.deleteActiveFormMode();
        this.storeNavigation();
    };
    /**
     * @param {?} navigationItems
     * @param {?} storedNavigation
     * @return {?}
     */
    NavigationService.prototype.mergeNavigationItems = /**
     * @param {?} navigationItems
     * @param {?} storedNavigation
     * @return {?}
     */
    function (navigationItems, storedNavigation) {
        if (storedNavigation.length === 0 || storedNavigation.length > MAXIMIUM_NAVIGATION_HEAP_SIZE) {
            return navigationItems;
        }
        /** @type {?} */
        var result = [];
        /** @type {?} */
        var lastCommonIndex;
        for (var i = navigationItems.length - 1; i >= 0; i--) {
            for (var j = storedNavigation.length - 1; j >= 0; j--) {
                if (storedNavigation[j].url === navigationItems[i].url && i !== navigationItems.length - 1) {
                    lastCommonIndex = i;
                    break;
                }
            }
            if (lastCommonIndex !== undefined) {
                break;
            }
        }
        storedNavigation.forEach(function (s) { return result.push(s); });
        if (lastCommonIndex !== undefined) {
            for (var j = lastCommonIndex + 1, len = navigationItems.length; j < len; j++) {
                if (storedNavigation[storedNavigation.length - 1].url !== navigationItems[j].url) {
                    result.push(navigationItems[j]);
                }
            }
        }
        return result;
    };
    NavigationService.NAVIGATION_STORAGE_KEY = 'nav_service';
    NavigationService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    NavigationService.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return NavigationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OntimizeServiceResponseParser = /** @class */ (function () {
    function OntimizeServiceResponseParser(injector) {
        this.injector = injector;
    }
    /**
     * @param {?} resp
     * @param {?} subscriber
     * @param {?} service
     * @return {?}
     */
    OntimizeServiceResponseParser.prototype.parseSuccessfulResponse = /**
     * @param {?} resp
     * @param {?} subscriber
     * @param {?} service
     * @return {?}
     */
    function (resp, subscriber, service) {
        if (resp && resp.code === Codes.ONTIMIZE_UNAUTHORIZED_CODE) {
            service.redirectLogin(true);
        }
        else if (resp && resp.code === Codes.ONTIMIZE_FAILED_CODE) {
            subscriber.error(resp.message);
        }
        else if (resp && resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
            subscriber.next(resp);
        }
        else {
            // Unknow state -> error
            subscriber.error('Service unavailable');
        }
    };
    /**
     * @param {?} error
     * @param {?} subscriber
     * @param {?} service
     * @return {?}
     */
    OntimizeServiceResponseParser.prototype.parseUnsuccessfulResponse = /**
     * @param {?} error
     * @param {?} subscriber
     * @param {?} service
     * @return {?}
     */
    function (error, subscriber, service) {
        if (error.status !== 500 && (error.status === 401 || error.status === 0) && !error.ok) {
            service.redirectLogin(true);
        }
        else {
            subscriber.error(error);
        }
    };
    OntimizeServiceResponseParser.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OntimizeServiceResponseParser.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OntimizeServiceResponseParser;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OntimizeService$$1 = /** @class */ (function () {
    function OntimizeService$$1(injector) {
        this.injector = injector;
        this.entity = '';
        this.kv = {};
        this.av = [];
        this.sqltypes = {};
        this.pagesize = 10;
        this.offset = 0;
        this.orderby = [];
        this.totalsize = -1;
        this._sessionid = -1;
        this.httpClient = this.injector.get(http.HttpClient);
        this._config = this.injector.get(AppConfig);
        this._appConfig = this._config.getConfiguration();
        this.responseParser = this.injector.get(OntimizeServiceResponseParser);
    }
    /**
     * @param {?=} serviceName
     * @return {?}
     */
    OntimizeService$$1.prototype.getDefaultServiceConfiguration = /**
     * @param {?=} serviceName
     * @return {?}
     */
    function (serviceName) {
        /** @type {?} */
        var loginService = this.injector.get(LoginService$$1);
        /** @type {?} */
        var configuration = this._config.getServiceConfiguration();
        /** @type {?} */
        var servConfig = {};
        if (serviceName && configuration.hasOwnProperty(serviceName)) {
            servConfig = configuration[serviceName];
        }
        servConfig[Codes.SESSION_KEY] = loginService.getSessionInfo();
        return servConfig;
    };
    /**
     * @param {?} config
     * @return {?}
     */
    OntimizeService$$1.prototype.configureService = /**
     * @param {?} config
     * @return {?}
     */
    function (config$$1) {
        this._urlBase = config$$1.urlBase ? config$$1.urlBase : this._appConfig['apiEndpoint'];
        this._sessionid = config$$1.session ? config$$1.session.id : -1;
        this._user = config$$1.session ? config$$1.session.user : '';
        this._startSessionPath = this._appConfig['startSessionPath'] ? this._appConfig['startSessionPath'] : '/startsession';
        if (config$$1.entity !== undefined) {
            this.entity = config$$1.entity;
        }
        //TODO init other params like 'kv', 'av', etc.
    };
    Object.defineProperty(OntimizeService$$1.prototype, "urlBase", {
        get: /**
         * @return {?}
         */
        function () {
            return this._urlBase;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._urlBase = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} user
     * @param {?} password
     * @return {?}
     */
    OntimizeService$$1.prototype.startsession = /**
     * @param {?} user
     * @param {?} password
     * @return {?}
     */
    function (user, password) {
        /** @type {?} */
        var encodedPassword = encodeURIComponent(password);
        /** @type {?} */
        var url = this._urlBase + this._startSessionPath + '?user=' + user + '&password=' + encodedPassword;
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_startSessionObserver) {
            self.httpClient.get(url).subscribe(function (resp) {
                if (resp >= 0) {
                    _startSessionObserver.next(resp);
                }
                else {
                    //Invalid sessionId...
                    _startSessionObserver.error('Invalid user or password');
                }
            }, function (error) { return _startSessionObserver.error(error); });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?} user
     * @param {?} sessionId
     * @return {?}
     */
    OntimizeService$$1.prototype.endsession = /**
     * @param {?} user
     * @param {?} sessionId
     * @return {?}
     */
    function (user, sessionId) {
        /** @type {?} */
        var url = this._urlBase + '/endsession?user=' + user + '&sessionid=' + sessionId;
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_closeSessionObserver) {
            self.httpClient.get(url).subscribe(function (resp) {
                _closeSessionObserver.next(resp);
            }, function (error) {
                if (error.status === 401 || error.status === 0 || !error.ok) {
                    _closeSessionObserver.next(0);
                }
                else {
                    _closeSessionObserver.error(error);
                }
            });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?} user
     * @param {?} sessionId
     * @return {?}
     */
    OntimizeService$$1.prototype.hassession = /**
     * @param {?} user
     * @param {?} sessionId
     * @return {?}
     */
    function (user, sessionId) {
        /** @type {?} */
        var url = this._urlBase + '/hassession?user=' + user + '&sessionid=' + sessionId;
        /** @type {?} */
        var _innerObserver;
        /** @type {?} */
        var dataObservable = new Observable(function (observer) { return _innerObserver = observer; }).pipe(share());
        this.httpClient.get(url).subscribe(function (resp) {
            _innerObserver.next(resp);
        }, function (error) { return _innerObserver.error(error); });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?=} kv
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    OntimizeService$$1.prototype.query = /**
     * @param {?=} kv
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    function (kv, av, entity, sqltypes) {
        entity = (Util.isDefined(entity)) ? entity : this.entity;
        //TODO improve this -> merge between global conf and specific params of method calling
        kv = (Util.isDefined(kv)) ? kv : this.kv;
        av = (Util.isDefined(av)) ? av : this.av;
        sqltypes = (Util.isDefined(sqltypes)) ? sqltypes : this.sqltypes;
        /** @type {?} */
        var url = this._urlBase + '/query';
        /** @type {?} */
        var options = {
            headers: this.buildHeaders()
        };
        /** @type {?} */
        var body = JSON.stringify({
            user: this._user,
            sessionid: this._sessionid,
            type: 1,
            entity: entity,
            kv: kv,
            av: av,
            sqltypes: sqltypes
        });
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_innerObserver) {
            self.httpClient.post(url, body, options).subscribe(function (resp) {
                self.parseSuccessfulQueryResponse(resp, _innerObserver);
            }, function (error) {
                self.parseUnsuccessfulQueryResponse(error, _innerObserver);
            }, function () { return _innerObserver.complete(); });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?=} kv
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @param {?=} offset
     * @param {?=} pagesize
     * @param {?=} orderby
     * @return {?}
     */
    OntimizeService$$1.prototype.advancedQuery = /**
     * @param {?=} kv
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @param {?=} offset
     * @param {?=} pagesize
     * @param {?=} orderby
     * @return {?}
     */
    function (kv, av, entity, sqltypes, offset, pagesize, orderby) {
        entity = (Util.isDefined(entity)) ? entity : this.entity;
        //TODO improve this -> merge between global conf and specific params of method calling
        kv = (Util.isDefined(kv)) ? kv : this.kv;
        av = (Util.isDefined(av)) ? av : this.av;
        sqltypes = (Util.isDefined(sqltypes)) ? sqltypes : this.sqltypes;
        orderby = (Util.isDefined(orderby)) ? orderby : this.orderby;
        offset = (Util.isDefined(offset)) ? offset : this.offset;
        pagesize = (Util.isDefined(pagesize)) ? pagesize : this.pagesize;
        /** @type {?} */
        var url = this._urlBase + '/advancedquery';
        /** @type {?} */
        var options = {
            headers: this.buildHeaders()
        };
        /** @type {?} */
        var body = JSON.stringify({
            user: this._user,
            sessionid: this._sessionid,
            type: 1,
            entity: entity,
            kv: kv,
            av: av,
            sqltypes: sqltypes,
            offset: offset,
            pageSize: pagesize,
            orderBy: orderby
        });
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_innerObserver) {
            self.httpClient.post(url, body, options).subscribe(function (resp) {
                self.parseSuccessfulAdvancedQueryResponse(resp, _innerObserver);
            }, function (error) {
                self.parseUnsuccessfulAdvancedQueryResponse(error, _innerObserver);
            }, function () { return _innerObserver.complete(); });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    OntimizeService$$1.prototype.insert = /**
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    function (av, entity, sqltypes) {
        if (av === void 0) { av = {}; }
        entity = (Util.isDefined(entity)) ? entity : this.entity;
        av = (Util.isDefined(av)) ? av : this.av;
        sqltypes = (Util.isDefined(sqltypes)) ? sqltypes : this.sqltypes;
        /** @type {?} */
        var url = this._urlBase + '/insert';
        /** @type {?} */
        var options = {
            headers: this.buildHeaders()
        };
        /** @type {?} */
        var body = JSON.stringify({
            user: this._user,
            sessionid: this._sessionid,
            entity: entity,
            av: av,
            sqltypes: sqltypes
        });
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_innerObserver) {
            self.httpClient.post(url, body, options).subscribe(function (resp) {
                self.parseSuccessfulInsertResponse(resp, _innerObserver);
            }, function (error) {
                self.parseUnsuccessfulInsertResponse(error, _innerObserver);
            }, function () { return _innerObserver.complete(); });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?=} kv
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    OntimizeService$$1.prototype.update = /**
     * @param {?=} kv
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    function (kv, av, entity, sqltypes) {
        if (kv === void 0) { kv = {}; }
        if (av === void 0) { av = {}; }
        entity = (Util.isDefined(entity)) ? entity : this.entity;
        kv = (Util.isDefined(kv)) ? kv : this.kv;
        av = (Util.isDefined(av)) ? av : this.av;
        sqltypes = (Util.isDefined(sqltypes)) ? sqltypes : this.sqltypes;
        /** @type {?} */
        var url = this._urlBase + '/update';
        /** @type {?} */
        var options = {
            headers: this.buildHeaders()
        };
        /** @type {?} */
        var body = JSON.stringify({
            user: this._user,
            sessionid: this._sessionid,
            entity: entity,
            kv: kv,
            av: av,
            sqltypes: sqltypes
        });
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_innerObserver) {
            self.httpClient.post(url, body, options).subscribe(function (resp) {
                self.parseSuccessfulUpdateResponse(resp, _innerObserver);
            }, function (error) {
                self.parseUnsuccessfulUpdateResponse(error, _innerObserver);
            }, function () { return _innerObserver.complete(); });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?=} kv
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    OntimizeService$$1.prototype.delete = /**
     * @param {?=} kv
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    function (kv, entity, sqltypes) {
        if (kv === void 0) { kv = {}; }
        entity = (Util.isDefined(entity)) ? entity : this.entity;
        kv = (Util.isDefined(kv)) ? kv : this.kv;
        sqltypes = (Util.isDefined(sqltypes)) ? sqltypes : this.sqltypes;
        /** @type {?} */
        var url = this._urlBase + '/delete';
        /** @type {?} */
        var options = {
            headers: this.buildHeaders()
        };
        /** @type {?} */
        var body = JSON.stringify({
            user: this._user,
            sessionid: this._sessionid,
            entity: entity,
            kv: kv,
            sqltypes: sqltypes
        });
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_innerObserver) {
            self.httpClient.post(url, body, options).subscribe(function (resp) {
                self.parseSuccessfulDeleteResponse(resp, _innerObserver);
            }, function (error) {
                self.parseUnsuccessfulDeleteResponse(error, _innerObserver);
            }, function () { return _innerObserver.complete(); });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?=} sessionExpired
     * @return {?}
     */
    OntimizeService$$1.prototype.redirectLogin = /**
     * @param {?=} sessionExpired
     * @return {?}
     */
    function (sessionExpired) {
        if (sessionExpired === void 0) { sessionExpired = false; }
        /** @type {?} */
        var router$$1 = this.injector.get(router.Router);
        /** @type {?} */
        var loginService = this.injector.get(LoginService$$1);
        if (sessionExpired) {
            loginService.sessionExpired();
        }
        ServiceUtils$$1.redirectLogin(router$$1, sessionExpired);
    };
    /**
     * @return {?}
     */
    OntimizeService$$1.prototype.buildHeaders = /**
     * @return {?}
     */
    function () {
        return new http.HttpHeaders({
            'Access-Control-Allow-Origin': '*',
            'Content-Type': 'application/json;charset=UTF-8'
        });
    };
    /*
     * Successful response parsers, there is one parser for each CRUD method which calls to the common parser.
     * User can overwrite the chosen methods parsers or the common parser
     */
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeService$$1.prototype.parseSuccessfulResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.responseParser.parseSuccessfulResponse(resp, _innerObserver, this);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeService$$1.prototype.parseSuccessfulQueryResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseSuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeService$$1.prototype.parseSuccessfulAdvancedQueryResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseSuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeService$$1.prototype.parseSuccessfulInsertResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseSuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeService$$1.prototype.parseSuccessfulUpdateResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseSuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeService$$1.prototype.parseSuccessfulDeleteResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseSuccessfulResponse(resp, _innerObserver);
    };
    /*
     * Unsuccessful response parsers, there is one parser for each CRUD method which calls to the common parser.
     * User can overwrite the chosen methods parsers or the common parser
     */
    /**
     * @param {?} error
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeService$$1.prototype.parseUnsuccessfulResponse = /**
     * @param {?} error
     * @param {?} _innerObserver
     * @return {?}
     */
    function (error, _innerObserver) {
        this.responseParser.parseUnsuccessfulResponse(error, _innerObserver, this);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeService$$1.prototype.parseUnsuccessfulQueryResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseUnsuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeService$$1.prototype.parseUnsuccessfulAdvancedQueryResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseUnsuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeService$$1.prototype.parseUnsuccessfulInsertResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseUnsuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeService$$1.prototype.parseUnsuccessfulUpdateResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseUnsuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeService$$1.prototype.parseUnsuccessfulDeleteResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseUnsuccessfulResponse(resp, _innerObserver);
    };
    OntimizeService$$1.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OntimizeService$$1.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OntimizeService$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OntimizeEEService$$1 = /** @class */ (function () {
    function OntimizeEEService$$1(injector) {
        this.injector = injector;
        this.path = '';
        this.kv = {};
        this.av = [];
        this.sqltypes = {};
        this.pagesize = 10;
        this.offset = 0;
        this.orderby = [];
        this.totalsize = -1;
        this.httpClient = this.injector.get(http.HttpClient);
        this._config = this.injector.get(AppConfig);
        this._appConfig = this._config.getConfiguration();
        this.responseParser = this.injector.get(OntimizeServiceResponseParser);
    }
    /**
     * @param {?=} serviceName
     * @return {?}
     */
    OntimizeEEService$$1.prototype.getDefaultServiceConfiguration = /**
     * @param {?=} serviceName
     * @return {?}
     */
    function (serviceName) {
        /** @type {?} */
        var loginService = this.injector.get(LoginService$$1);
        /** @type {?} */
        var configuration = this._config.getServiceConfiguration();
        /** @type {?} */
        var servConfig = {};
        if (serviceName && configuration.hasOwnProperty(serviceName)) {
            servConfig = configuration[serviceName];
        }
        servConfig[Codes.SESSION_KEY] = loginService.getSessionInfo();
        return servConfig;
    };
    /**
     * @param {?} config
     * @return {?}
     */
    OntimizeEEService$$1.prototype.configureService = /**
     * @param {?} config
     * @return {?}
     */
    function (config$$1) {
        this._urlBase = config$$1.urlBase ? config$$1.urlBase : this._appConfig['apiEndpoint'];
        this._sessionid = config$$1.session ? config$$1.session.id : -1;
        this.path = config$$1.path;
        this._startSessionPath = this._appConfig['startSessionPath'] ? this._appConfig['startSessionPath'] : '/users/login';
        //TODO init other params
    };
    Object.defineProperty(OntimizeEEService$$1.prototype, "urlBase", {
        get: /**
         * @return {?}
         */
        function () {
            return this._urlBase;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._urlBase = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} user
     * @param {?} password
     * @return {?}
     */
    OntimizeEEService$$1.prototype.startsession = /**
     * @param {?} user
     * @param {?} password
     * @return {?}
     */
    function (user, password) {
        /** @type {?} */
        var url = this.urlBase + this._startSessionPath;
        /** @type {?} */
        var options = {
            headers: new http.HttpHeaders({
                'Authorization': 'Basic ' + btoa(user + ':' + password)
            }),
            'observe': 'response'
        };
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var startSessionObservable = new Observable(function (_startSessionObserver) {
            self.httpClient.post(url, null, options).subscribe(function (resp) {
                if (Util.isDefined(resp) && Util.isDefined(resp.headers) && Util.isDefined(resp.headers.get('X-Auth-Token'))) {
                    _startSessionObserver.next(resp.headers.get('X-Auth-Token'));
                }
                else {
                    // Invalid sessionId...
                    _startSessionObserver.error('Invalid user or password');
                }
            }, function (error) { return _startSessionObserver.error(error); });
        });
        return startSessionObservable;
    };
    /**
     * @param {?} user
     * @param {?} sessionId
     * @return {?}
     */
    OntimizeEEService$$1.prototype.endsession = /**
     * @param {?} user
     * @param {?} sessionId
     * @return {?}
     */
    function (user, sessionId) {
        /** @type {?} */
        var _closeSessionObserver;
        /** @type {?} */
        var closeSessionObservable = new Observable(function (observer) { return _closeSessionObserver = observer; }).pipe(share());
        setTimeout(function () {
            _closeSessionObserver.next(0);
        }, 0);
        return closeSessionObservable;
    };
    /**
     * @param {?} user
     * @param {?} sessionId
     * @return {?}
     */
    OntimizeEEService$$1.prototype.hassession = /**
     * @param {?} user
     * @param {?} sessionId
     * @return {?}
     */
    function (user, sessionId) {
        /** @type {?} */
        var _observer;
        /** @type {?} */
        var observable$$1 = new Observable(function (observer) { return _observer = observer; }).pipe(share());
        return observable$$1;
    };
    /**
     * @param {?=} kv
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    OntimizeEEService$$1.prototype.query = /**
     * @param {?=} kv
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    function (kv, av, entity, sqltypes) {
        //TODO improve this -> merge between global conf and specific params of method calling
        kv = (Util.isDefined(kv)) ? kv : this.kv;
        av = (Util.isDefined(av)) ? av : this.av;
        sqltypes = (Util.isDefined(sqltypes)) ? sqltypes : this.sqltypes;
        /** @type {?} */
        var url = this._urlBase + this.path + '/' + entity + '/search';
        /** @type {?} */
        var options = {
            headers: this.buildHeaders()
        };
        /** @type {?} */
        var body = JSON.stringify({
            filter: kv,
            columns: av,
            sqltypes: sqltypes
        });
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_innerObserver) {
            self.httpClient.post(url, body, options).subscribe(function (resp) {
                self.parseSuccessfulQueryResponse(resp, _innerObserver);
            }, function (error) {
                self.parseUnsuccessfulQueryResponse(error, _innerObserver);
            }, function () { return _innerObserver.complete(); });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?=} kv
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @param {?=} offset
     * @param {?=} pagesize
     * @param {?=} orderby
     * @return {?}
     */
    OntimizeEEService$$1.prototype.advancedQuery = /**
     * @param {?=} kv
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @param {?=} offset
     * @param {?=} pagesize
     * @param {?=} orderby
     * @return {?}
     */
    function (kv, av, entity, sqltypes, offset, pagesize, orderby) {
        //TODO improve this -> merge between global conf and specific params of method calling
        kv = (Util.isDefined(kv)) ? kv : this.kv;
        av = (Util.isDefined(av)) ? av : this.av;
        sqltypes = (Util.isDefined(sqltypes)) ? sqltypes : this.sqltypes;
        orderby = (Util.isDefined(orderby)) ? orderby : this.orderby;
        offset = (Util.isDefined(offset)) ? offset : this.offset;
        pagesize = (Util.isDefined(pagesize)) ? pagesize : this.pagesize;
        /** @type {?} */
        var url = this._urlBase + this.path + '/' + entity + '/advancedsearch';
        /** @type {?} */
        var options = {
            headers: this.buildHeaders()
        };
        /** @type {?} */
        var body = JSON.stringify({
            filter: kv,
            columns: av,
            sqltypes: sqltypes,
            offset: offset,
            pageSize: pagesize,
            orderBy: orderby
        });
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_innerObserver) {
            self.httpClient.post(url, body, options).subscribe(function (resp) {
                self.parseSuccessfulAdvancedQueryResponse(resp, _innerObserver);
            }, function (error) {
                self.parseUnsuccessfulAdvancedQueryResponse(error, _innerObserver);
            }, function () { return _innerObserver.complete(); });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    OntimizeEEService$$1.prototype.insert = /**
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    function (av, entity, sqltypes) {
        if (av === void 0) { av = {}; }
        /** @type {?} */
        var url = this._urlBase + this.path + '/' + entity;
        /** @type {?} */
        var options = {
            headers: this.buildHeaders()
        };
        /** @type {?} */
        var body = JSON.stringify({
            data: av,
            sqltypes: sqltypes
        });
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_innerObserver) {
            self.httpClient.post(url, body, options).subscribe(function (resp) {
                self.parseSuccessfulInsertResponse(resp, _innerObserver);
            }, function (error) {
                self.parseUnsuccessfulInsertResponse(error, _innerObserver);
            }, function () { return _innerObserver.complete(); });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?=} kv
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    OntimizeEEService$$1.prototype.update = /**
     * @param {?=} kv
     * @param {?=} av
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    function (kv, av, entity, sqltypes) {
        if (kv === void 0) { kv = {}; }
        if (av === void 0) { av = {}; }
        /** @type {?} */
        var url = this._urlBase + this.path + '/' + entity;
        /** @type {?} */
        var options = {
            headers: this.buildHeaders()
        };
        /** @type {?} */
        var body = JSON.stringify({
            filter: kv,
            data: av,
            sqltypes: sqltypes
        });
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_innerObserver) {
            self.httpClient.put(url, body, options).subscribe(function (resp) {
                self.parseSuccessfulUpdateResponse(resp, _innerObserver);
            }, function (error) {
                self.parseUnsuccessfulUpdateResponse(error, _innerObserver);
            }, function () { return _innerObserver.complete(); });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?=} kv
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    OntimizeEEService$$1.prototype.delete = /**
     * @param {?=} kv
     * @param {?=} entity
     * @param {?=} sqltypes
     * @return {?}
     */
    function (kv, entity, sqltypes) {
        if (kv === void 0) { kv = {}; }
        /** @type {?} */
        var url = this._urlBase + this.path + '/' + entity;
        /** @type {?} */
        var headers = this.buildHeaders();
        /** @type {?} */
        var options = {
            headers: headers,
            body: JSON.stringify({
                filter: kv,
                sqltypes: sqltypes
            })
        };
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_innerObserver) {
            self.httpClient.delete(url, options).subscribe(function (resp) {
                self.parseSuccessfulDeleteResponse(resp, _innerObserver);
            }, function (error) {
                self.parseUnsuccessfulDeleteResponse(error, _innerObserver);
            }, function () { return _innerObserver.complete(); });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?=} sessionExpired
     * @return {?}
     */
    OntimizeEEService$$1.prototype.redirectLogin = /**
     * @param {?=} sessionExpired
     * @return {?}
     */
    function (sessionExpired) {
        if (sessionExpired === void 0) { sessionExpired = false; }
        /** @type {?} */
        var router$$1 = this.injector.get(router.Router);
        /** @type {?} */
        var loginService = this.injector.get(LoginService$$1);
        if (sessionExpired) {
            loginService.sessionExpired();
        }
        ServiceUtils$$1.redirectLogin(router$$1, sessionExpired);
    };
    /**
     * @return {?}
     */
    OntimizeEEService$$1.prototype.buildHeaders = /**
     * @return {?}
     */
    function () {
        return new http.HttpHeaders({
            'Access-Control-Allow-Origin': '*',
            'Content-Type': 'application/json;charset=UTF-8',
            'Authorization': 'Bearer ' + this._sessionid
        });
    };
    /*
     * Successful response parsers, there is one parser for each CRUD method which calls to the common parser.
     * User can overwrite the chosen methods parsers or the common parser
     */
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeEEService$$1.prototype.parseSuccessfulResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.responseParser.parseSuccessfulResponse(resp, _innerObserver, this);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeEEService$$1.prototype.parseSuccessfulQueryResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseSuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeEEService$$1.prototype.parseSuccessfulAdvancedQueryResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseSuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeEEService$$1.prototype.parseSuccessfulInsertResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseSuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeEEService$$1.prototype.parseSuccessfulUpdateResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseSuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeEEService$$1.prototype.parseSuccessfulDeleteResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseSuccessfulResponse(resp, _innerObserver);
    };
    /*
     * Unsuccessful response parsers, there is one parser for each CRUD method which calls to the common parser.
     * User can overwrite the chosen methods parsers or the common parser
     */
    /**
     * @param {?} error
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeEEService$$1.prototype.parseUnsuccessfulResponse = /**
     * @param {?} error
     * @param {?} _innerObserver
     * @return {?}
     */
    function (error, _innerObserver) {
        this.responseParser.parseUnsuccessfulResponse(error, _innerObserver, this);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeEEService$$1.prototype.parseUnsuccessfulQueryResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseUnsuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeEEService$$1.prototype.parseUnsuccessfulAdvancedQueryResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseUnsuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeEEService$$1.prototype.parseUnsuccessfulInsertResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseUnsuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeEEService$$1.prototype.parseUnsuccessfulUpdateResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseUnsuccessfulResponse(resp, _innerObserver);
    };
    /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    OntimizeEEService$$1.prototype.parseUnsuccessfulDeleteResponse = /**
     * @param {?} resp
     * @param {?} _innerObserver
     * @return {?}
     */
    function (resp, _innerObserver) {
        this.parseUnsuccessfulResponse(resp, _innerObserver);
    };
    OntimizeEEService$$1.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OntimizeEEService$$1.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OntimizeEEService$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var EXPORT_PATH_DEFAULT$$1 = '/export';
/** @type {?} */
var DOWNLOAD_PATH_DEFAULT$$1 = EXPORT_PATH_DEFAULT$$1 + '/download';
var OExportExtension$$1 = /** @class */ (function () {
    function OExportExtension$$1() {
    }
    OExportExtension$$1.Excel = 'xlsx';
    OExportExtension$$1.HTML = 'html';
    OExportExtension$$1.PDF = 'pdf';
    return OExportExtension$$1;
}());
var OntimizeExportService$$1 = /** @class */ (function () {
    function OntimizeExportService$$1(injector) {
        this.injector = injector;
        this.EXPORT_PATH_DEFAULT = EXPORT_PATH_DEFAULT$$1;
        this.DOWNLOAD_PATH_DEFAULT = DOWNLOAD_PATH_DEFAULT$$1;
        this.exportPath = EXPORT_PATH_DEFAULT$$1;
        this.downloadPath = DOWNLOAD_PATH_DEFAULT$$1;
        this.httpClient = this.injector.get(http.HttpClient);
        this._config = this.injector.get(AppConfig);
        this._appConfig = this._config.getConfiguration();
    }
    /**
     * @param {?=} serviceName
     * @return {?}
     */
    OntimizeExportService$$1.prototype.getDefaultServiceConfiguration = /**
     * @param {?=} serviceName
     * @return {?}
     */
    function (serviceName) {
        /** @type {?} */
        var loginService = this.injector.get(LoginService$$1);
        /** @type {?} */
        var configuration = this._config.getServiceConfiguration();
        /** @type {?} */
        var servConfig = {};
        if (serviceName && configuration.hasOwnProperty(serviceName)) {
            servConfig = configuration[serviceName];
        }
        servConfig[Codes.SESSION_KEY] = loginService.getSessionInfo();
        return servConfig;
    };
    /**
     * @param {?} config
     * @return {?}
     */
    OntimizeExportService$$1.prototype.configureService = /**
     * @param {?} config
     * @return {?}
     */
    function (config$$1) {
        this._urlBase = config$$1.urlBase ? config$$1.urlBase : this._appConfig['apiEndpoint'];
        this._sessionid = config$$1.session ? config$$1.session.id : -1;
        if (config$$1.exportPath) {
            this.exportPath = config$$1.exportPath;
        }
        if (config$$1.downloadPath) {
            this.downloadPath = config$$1.downloadPath;
        }
    };
    Object.defineProperty(OntimizeExportService$$1.prototype, "urlBase", {
        get: /**
         * @return {?}
         */
        function () {
            return this._urlBase;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._urlBase = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} data
     * @param {?} format
     * @return {?}
     */
    OntimizeExportService$$1.prototype.exportData = /**
     * @param {?} data
     * @param {?} format
     * @return {?}
     */
    function (data, format) {
        /** @type {?} */
        var url = this._urlBase + this.exportPath + '/' + format;
        /** @type {?} */
        var options = {
            headers: new http.HttpHeaders({
                'Access-Control-Allow-Origin': '*',
                'Content-Type': 'application/json;charset=UTF-8',
                'Authorization': 'Bearer ' + this._sessionid
            })
        };
        /** @type {?} */
        var body = JSON.stringify(data);
        /** @type {?} */
        var _innerObserver;
        /** @type {?} */
        var dataObservable = new Observable(function (observer) { return _innerObserver = observer; }).pipe(share());
        /** @type {?} */
        var self = this;
        // TODO: try multipart
        this.httpClient.post(url, body, options).subscribe(function (resp) {
            if (resp && resp.code === Codes.ONTIMIZE_UNAUTHORIZED_CODE) {
                self.redirectLogin(true);
            }
            else if (resp.code === Codes.ONTIMIZE_FAILED_CODE) {
                _innerObserver.error(resp.message);
            }
            else if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                _innerObserver.next(resp);
            }
            else {
                // Unknow state -> error
                _innerObserver.error('Service unavailable');
            }
        }, function (error) { return _innerObserver.error(error); }, function () { return _innerObserver.complete(); });
        return dataObservable;
    };
    /**
     * @param {?} fileId
     * @param {?} fileExtension
     * @return {?}
     */
    OntimizeExportService$$1.prototype.downloadFile = /**
     * @param {?} fileId
     * @param {?} fileExtension
     * @return {?}
     */
    function (fileId, fileExtension) {
        /** @type {?} */
        var url = this._urlBase + this.downloadPath + '/' + fileExtension + '/' + fileId;
        /** @type {?} */
        var _innerObserver;
        /** @type {?} */
        var dataObservable = new Observable(function (observer) { return _innerObserver = observer; }).pipe(share());
        /** @type {?} */
        var options = {
            headers: new http.HttpHeaders({
                'Access-Control-Allow-Origin': '*',
                'Authorization': 'Bearer ' + this._sessionid
            }),
            'observe': 'response',
            'responseType': 'blob'
        };
        // .map((res: any) => new Blob([res.blob()], { type: responseType }))
        this.httpClient.get(url, options).subscribe(function (resp) {
            /** @type {?} */
            var fileData = resp.body;
            /** @type {?} */
            var fileURL = URL.createObjectURL(fileData);
            /** @type {?} */
            var a = document.createElement('a');
            document.body.appendChild(a);
            a.href = fileURL;
            a.download = fileId + '.' + fileExtension;
            a.click();
            document.body.removeChild(a);
            _innerObserver.next(fileData);
            URL.revokeObjectURL(fileURL);
        }, function (error) { return _innerObserver.error(error); }, function () { return _innerObserver.complete(); });
        return dataObservable;
    };
    /**
     * @param {?=} sessionExpired
     * @return {?}
     */
    OntimizeExportService$$1.prototype.redirectLogin = /**
     * @param {?=} sessionExpired
     * @return {?}
     */
    function (sessionExpired) {
        if (sessionExpired === void 0) { sessionExpired = false; }
        /** @type {?} */
        var router$$1 = this.injector.get(router.Router);
        /** @type {?} */
        var loginService = this.injector.get(LoginService$$1);
        if (sessionExpired) {
            loginService.sessionExpired();
        }
        ServiceUtils$$1.redirectLogin(router$$1, sessionExpired);
    };
    OntimizeExportService$$1.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OntimizeExportService$$1.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OntimizeExportService$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OntimizeFileService$$1 = /** @class */ (function () {
    function OntimizeFileService$$1(injector) {
        this.injector = injector;
        this.path = '';
        this.httpClient = this.injector.get(http.HttpClient);
        this._config = this.injector.get(AppConfig);
        this._appConfig = this._config.getConfiguration();
    }
    /**
     * @param {?=} serviceName
     * @return {?}
     */
    OntimizeFileService$$1.prototype.getDefaultServiceConfiguration = /**
     * @param {?=} serviceName
     * @return {?}
     */
    function (serviceName) {
        /** @type {?} */
        var loginService = this.injector.get(LoginService$$1);
        /** @type {?} */
        var configuration = this._config.getServiceConfiguration();
        /** @type {?} */
        var servConfig = {};
        if (serviceName && configuration.hasOwnProperty(serviceName)) {
            servConfig = configuration[serviceName];
        }
        servConfig[Codes.SESSION_KEY] = loginService.getSessionInfo();
        return servConfig;
    };
    /**
     * @param {?} config
     * @return {?}
     */
    OntimizeFileService$$1.prototype.configureService = /**
     * @param {?} config
     * @return {?}
     */
    function (config$$1) {
        this._urlBase = config$$1.urlBase ? config$$1.urlBase : this._appConfig['apiEndpoint'];
        this._sessionid = config$$1.session ? config$$1.session.id : -1;
        this.path = config$$1.path;
    };
    Object.defineProperty(OntimizeFileService$$1.prototype, "urlBase", {
        get: /**
         * @return {?}
         */
        function () {
            return this._urlBase;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._urlBase = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sends file/s upload request/s
     *
     * @param {?} files the array of files to upload
     * @param {?} entity the entity
     * @param {?=} data
     * @return {?}
     */
    OntimizeFileService$$1.prototype.upload = /**
     * Sends file/s upload request/s
     *
     * @param {?} files the array of files to upload
     * @param {?} entity the entity
     * @param {?=} data
     * @return {?}
     */
    function (files, entity, data) {
        /** @type {?} */
        var url = this._urlBase + this.path + '/' + entity;
        /** @type {?} */
        var headers = new http.HttpHeaders({
            'Access-Control-Allow-Origin': '*',
            'Authorization': 'Bearer ' + this._sessionid
        });
        /** @type {?} */
        var _innerObserver;
        /** @type {?} */
        var dataObservable = new Observable(function (observer) { return _innerObserver = observer; }).pipe(share());
        /** @type {?} */
        var toUpload = new FormData();
        files.forEach(function (item) {
            item.prepareToUpload();
            item.isUploading = true;
            toUpload.append('name', item.name);
            toUpload.append('file', item.file);
        });
        if (data) {
            toUpload.append('data', JSON.stringify(data));
        }
        /** @type {?} */
        var request = new http.HttpRequest('POST', url, toUpload, {
            headers: headers,
            reportProgress: true
        });
        /** @type {?} */
        var self = this;
        this.httpClient.request(request).subscribe(function (resp) {
            if (http.HttpEventType.UploadProgress === resp.type) {
                /** @type {?} */
                var progressData = {
                    loaded: resp.loaded,
                    total: resp.total
                };
                _innerObserver.next(progressData);
            }
            else if (http.HttpEventType.Response === resp.type) {
                // Full response received
                if (resp.body) {
                    if (resp.body['code'] === 3) {
                        self.redirectLogin(true);
                    }
                    else if (resp.body['code'] === 1) {
                        _innerObserver.error(resp.body['message']);
                    }
                    else if (resp.body['code'] === 0) {
                        // RESPONSE
                        _innerObserver.next(resp.body);
                    }
                    else {
                        // Unknow state -> error
                        _innerObserver.error('Service unavailable');
                    }
                }
                else {
                    _innerObserver.next(resp.body);
                }
            }
        }, function (error) {
            console.error(error);
            if (error.status === 401) {
                self.redirectLogin(true);
            }
            else {
                _innerObserver.error(error);
            }
        }, function () { return _innerObserver.complete(); });
        return dataObservable;
    };
    /**
     * @param {?=} sessionExpired
     * @return {?}
     */
    OntimizeFileService$$1.prototype.redirectLogin = /**
     * @param {?=} sessionExpired
     * @return {?}
     */
    function (sessionExpired) {
        if (sessionExpired === void 0) { sessionExpired = false; }
        /** @type {?} */
        var router$$1 = this.injector.get(router.Router);
        /** @type {?} */
        var loginService = this.injector.get(LoginService$$1);
        if (sessionExpired) {
            loginService.sessionExpired();
        }
        ServiceUtils$$1.redirectLogin(router$$1, sessionExpired);
    };
    OntimizeFileService$$1.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OntimizeFileService$$1.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OntimizeFileService$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var MomentService = /** @class */ (function () {
    function MomentService(injector) {
        this.injector = injector;
        this._config = this.injector.get(AppConfig).getConfiguration();
        this.load(this._config.locale);
    }
    /**
     * @param {?} locale
     * @return {?}
     */
    MomentService.prototype.load = /**
     * @param {?} locale
     * @return {?}
     */
    function (locale) {
        this._locale = locale;
    };
    /**
     * @param {?} value
     * @param {?=} format
     * @param {?=} locale
     * @return {?}
     */
    MomentService.prototype.parseDate = /**
     * @param {?} value
     * @param {?=} format
     * @param {?=} locale
     * @return {?}
     */
    function (value, format, locale) {
        /** @type {?} */
        var result = '';
        if (!locale) {
            locale = this._locale;
        }
        if (typeof value === 'number') {
            result = moment__default__default(new Date(value)).locale(locale).format(format ? format : MomentService.defaultFormat);
        }
        else {
            result = moment__default__default(value, MomentService.DATE_FORMATS, locale).format(format ? format : MomentService.defaultFormat);
        }
        result = (result === 'Invalid date') ? '' : result;
        return result;
    };
    /**
     * @return {?}
     */
    MomentService.prototype.getLocale = /**
     * @return {?}
     */
    function () {
        return this._locale;
    };
    // HTML5 input date: YYYY-MM-DD // locale ES-es: DD-MM-YYYY // locale EN-en: MM-DD-YYYY // ISO 8601:
    // YYYY-MM-DDThh:mm:ss.S // UTC: YYYY-MM-DD hh:mm:ssZ
    MomentService.DATE_FORMATS = ['YYYY-MM-DD', 'DD-MM-YYYY', 'MM-DD-YYYY', 'YYYY-MM-DDThh:mm:ss.S', 'YYYY-MM-DDThh:mm:ss.SSSZ', 'YYYY-MM-DD hh:mm:ssZ'];
    MomentService.defaultFormat = 'L';
    return MomentService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NumberService = /** @class */ (function () {
    function NumberService(injector) {
        this.injector = injector;
        this._config = this.injector.get(AppConfig).getConfiguration();
        //TODO: initialize from config
        this._minDecimalDigits = NumberService.DEFAULT_DECIMAL_DIGITS;
        this._maxDecimalDigits = NumberService.DEFAULT_DECIMAL_DIGITS;
        this._grouping = true;
        this._locale = this._config.locale;
    }
    Object.defineProperty(NumberService.prototype, "grouping", {
        get: /**
         * @return {?}
         */
        function () {
            return this._grouping;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._grouping = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberService.prototype, "minDecimalDigits", {
        get: /**
         * @return {?}
         */
        function () {
            return this._minDecimalDigits;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._minDecimalDigits = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberService.prototype, "maxDecimalDigits", {
        get: /**
         * @return {?}
         */
        function () {
            return this._maxDecimalDigits;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._maxDecimalDigits = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberService.prototype, "locale", {
        get: /**
         * @return {?}
         */
        function () {
            return this._locale;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._locale = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    NumberService.prototype.getIntegerValue = /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    function (value, args) {
        /** @type {?} */
        var grouping = args ? args.grouping : undefined;
        if (!Util.isDefined(value) && !Util.isDefined(grouping) || !grouping) {
            return value;
        }
        /** @type {?} */
        var thousandSeparator = args ? args.thousandSeparator : undefined;
        /** @type {?} */
        var locale = args ? args.locale : undefined;
        /** @type {?} */
        var intValue = parseInt(value, 10);
        if (isNaN(intValue)) {
            return void 0;
        }
        /** @type {?} */
        var formattedIntValue = intValue;
        if (Util.isDefined(locale)) {
            formattedIntValue = new Intl.NumberFormat(locale).format(intValue);
        }
        else if (!Util.isDefined(thousandSeparator)) {
            formattedIntValue = new Intl.NumberFormat(this._locale).format(intValue);
        }
        else {
            formattedIntValue = String(intValue).toString().replace(/\B(?=(\d{3})+(?!\d))/g, thousandSeparator);
        }
        return formattedIntValue;
    };
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    NumberService.prototype.getRealValue = /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    function (value, args) {
        /** @type {?} */
        var grouping = args ? args.grouping : undefined;
        if (!Util.isDefined(value) && !Util.isDefined(grouping) || !grouping) {
            return value;
        }
        /** @type {?} */
        var locale = args ? args.locale : undefined;
        /** @type {?} */
        var thousandSeparator = args ? args.thousandSeparator : undefined;
        /** @type {?} */
        var decimalSeparator = args ? args.decimalSeparator : undefined;
        /** @type {?} */
        var minDecimalDigits = args ? args.minDecimalDigits : undefined;
        /** @type {?} */
        var maxDecimalDigits = args ? args.maxDecimalDigits : undefined;
        if (!Util.isDefined(minDecimalDigits)) {
            minDecimalDigits = this._minDecimalDigits;
        }
        if (!Util.isDefined(maxDecimalDigits)) {
            maxDecimalDigits = this._maxDecimalDigits;
        }
        /** @type {?} */
        var formattedRealValue = value;
        /** @type {?} */
        var formatterArgs = {
            minimumFractionDigits: minDecimalDigits,
            maximumFractionDigits: maxDecimalDigits
        };
        if (Util.isDefined(locale)) {
            formattedRealValue = new Intl.NumberFormat(locale, formatterArgs).format(value);
        }
        else if (!Util.isDefined(thousandSeparator) || !Util.isDefined(decimalSeparator)) {
            formattedRealValue = new Intl.NumberFormat(this._locale, formatterArgs).format(value);
        }
        else {
            /** @type {?} */
            var realValue = parseFloat(value);
            if (!isNaN(realValue)) {
                formattedRealValue = String(realValue);
                /** @type {?} */
                var tmpStr = realValue.toFixed(maxDecimalDigits);
                tmpStr = tmpStr.replace('.', decimalSeparator);
                if (grouping) {
                    /** @type {?} */
                    var parts = tmpStr.split(decimalSeparator);
                    if (parts.length > 0) {
                        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, thousandSeparator);
                        formattedRealValue = parts.join(decimalSeparator);
                    }
                }
                else {
                    formattedRealValue = tmpStr;
                }
            }
        }
        return formattedRealValue;
    };
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    NumberService.prototype.getPercentValue = /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    function (value, args) {
        /** @type {?} */
        var valueBase = args ? args.valueBase : undefined;
        /** @type {?} */
        var parsedValue = value;
        switch (valueBase) {
            case 100:
                break;
            case 1:
            default:
                parsedValue = parsedValue * 100;
                break;
        }
        /** @type {?} */
        var formattedPercentValue = this.getRealValue(parsedValue, args) + ' %';
        return formattedPercentValue;
    };
    NumberService.DEFAULT_DECIMAL_DIGITS = 2;
    return NumberService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CurrencyService = /** @class */ (function () {
    function CurrencyService(injector) {
        this.injector = injector;
        this._numberService = this.injector.get(NumberService);
        //TODO: initialize from config
        this._symbol = CurrencyService.DEFAULT_CURRENCY_SYMBOL;
        this._symbolPosition = CurrencyService.DEFAULT_CURRENCY_SYMBOL_POSITION;
    }
    Object.defineProperty(CurrencyService.prototype, "symbol", {
        get: /**
         * @return {?}
         */
        function () {
            return this._symbol;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._symbol = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CurrencyService.prototype, "symbolPosition", {
        get: /**
         * @return {?}
         */
        function () {
            return this._symbolPosition;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._symbolPosition = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    CurrencyService.prototype.getCurrencyValue = /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    function (value, args) {
        /** @type {?} */
        var symbol = args ? args.currencySimbol : undefined;
        /** @type {?} */
        var symbolPosition = args ? args.currencySymbolPosition : undefined;
        if (!Util.isDefined(symbol)) {
            symbol = this._symbol;
        }
        if (!Util.isDefined(symbolPosition)) {
            symbolPosition = this._symbolPosition;
        }
        /** @type {?} */
        var currencyValue = this._numberService.getRealValue(value, args);
        switch (symbolPosition) {
            case 'left':
                currencyValue = symbol + ' ' + currencyValue;
                break;
            case 'right':
                currencyValue = currencyValue + ' ' + symbol;
                break;
        }
        return currencyValue;
    };
    CurrencyService.DEFAULT_CURRENCY_SYMBOL = '$';
    CurrencyService.DEFAULT_CURRENCY_SYMBOL_POSITION = 'left';
    return CurrencyService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DialogService = /** @class */ (function () {
    function DialogService(injector) {
        this.injector = injector;
        this.ng2Dialog = this.injector.get(material.MatDialog);
    }
    Object.defineProperty(DialogService.prototype, "dialog", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.dialogRef) {
                return this.dialogRef.componentInstance;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    DialogService.prototype.alert = /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    function (title, message, config$$1) {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var observable$$1 = Observable.create(function (observer) {
            self.openDialog(observer);
            self.dialogRef.componentInstance.alert(title, message, config$$1);
        });
        return observable$$1.toPromise();
    };
    /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    DialogService.prototype.info = /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    function (title, message, config$$1) {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var observable$$1 = Observable.create(function (observer) {
            self.openDialog(observer);
            self.dialogRef.componentInstance.info(title, message, config$$1);
        });
        return observable$$1.toPromise();
    };
    /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    DialogService.prototype.warn = /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    function (title, message, config$$1) {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var observable$$1 = Observable.create(function (observer) {
            self.openDialog(observer);
            self.dialogRef.componentInstance.warn(title, message, config$$1);
        });
        return observable$$1.toPromise();
    };
    /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    DialogService.prototype.error = /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    function (title, message, config$$1) {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var observable$$1 = Observable.create(function (observer) {
            self.openDialog(observer);
            self.dialogRef.componentInstance.error(title, message, config$$1);
        });
        return observable$$1.toPromise();
    };
    /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    DialogService.prototype.confirm = /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    function (title, message, config$$1) {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var observable$$1 = Observable.create(function (observer) {
            self.openDialog(observer);
            self.dialogRef.componentInstance.confirm(title, message, config$$1);
        });
        return observable$$1.toPromise();
    };
    /**
     * @param {?} observer
     * @return {?}
     */
    DialogService.prototype.openDialog = /**
     * @param {?} observer
     * @return {?}
     */
    function (observer) {
        var _this = this;
        /** @type {?} */
        var cfg = {
            role: 'alertdialog',
            disableClose: true,
            panelClass: ['o-dialog-class', 'o-dialog-service']
        };
        this.dialogRef = this.ng2Dialog.open(ODialogComponent, cfg);
        this.dialogRef.afterClosed().subscribe(function (result) {
            result = result === undefined ? false : result;
            observer.next(result);
            observer.complete();
            _this.dialogRef = null;
        });
    };
    DialogService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    DialogService.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return DialogService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTranslatePipe = /** @class */ (function () {
    function OTranslatePipe(injector) {
        this.injector = injector;
        this.value = '';
        this._ref = this.injector.get(core.ChangeDetectorRef);
        this.oTranslateService = this.injector.get(OTranslateService$$1);
    }
    /**
     * @return {?}
     */
    OTranslatePipe.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._dispose();
    };
    /**
     * @param {?} text
     * @param {?} args
     * @return {?}
     */
    OTranslatePipe.prototype.transform = /**
     * @param {?} text
     * @param {?} args
     * @return {?}
     */
    function (text, args) {
        var _this = this;
        if (!text || text.length === 0) {
            return text;
        }
        // if we ask another time for the same key, return the last value
        if (Util.equals(text, this.lastKey) && Util.equals(args, this.lastParams)) {
            return this.value;
        }
        // store the query, in case it changes
        this.lastKey = text;
        // store the params, in case they change
        this.lastParams = args;
        // set the value
        this.updateValue(text);
        // if there is a subscription to onLanguageChanged, clean it
        this._dispose();
        // subscribe to onLanguageChanged event, in case the language changes
        if (!this.onLanguageChanged) {
            this.onLanguageChanged = this.oTranslateService.onLanguageChanged.subscribe(function (lang) {
                if (_this.lastKey) {
                    _this.lastKey = null; // we want to make sure it doesn't return the same value until it's been updated
                    _this.updateValue(text);
                }
            });
        }
        return this.value;
    };
    /**
     * @param {?} key
     * @return {?}
     */
    OTranslatePipe.prototype.updateValue = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        /** @type {?} */
        var args = Util.isDefined(this.lastParams) ? this.lastParams.values || [] : [];
        /** @type {?} */
        var res = this.oTranslateService.get(key, args);
        this.value = res !== undefined ? res : key;
        this.lastKey = key;
        this._ref.markForCheck();
    };
    /**
     * @return {?}
     */
    OTranslatePipe.prototype._dispose = /**
     * @return {?}
     */
    function () {
        if (typeof this.onLanguageChanged !== 'undefined') {
            this.onLanguageChanged.unsubscribe();
            this.onLanguageChanged = undefined;
        }
    };
    OTranslatePipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'oTranslate',
                    pure: false // required to update the value when the promise is resolved
                },] },
    ];
    /** @nocollapse */
    OTranslatePipe.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OTranslatePipe;
}());
var OTranslateModule = /** @class */ (function () {
    function OTranslateModule() {
    }
    /**
     * @return {?}
     */
    OTranslateModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: OTranslateModule,
            providers: []
        };
    };
    OTranslateModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OTranslatePipe],
                    imports: [],
                    exports: [OTranslatePipe]
                },] },
    ];
    return OTranslateModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OntimizeMatDateFormats = /** @class */ (function () {
    function OntimizeMatDateFormats() {
        this.DEFAULT_DATE_FORMATS = {
            parse: { dateInput: 'L' },
            display: { dateInput: 'L', monthYearLabel: 'Y', dateA11yLabel: 'LL', monthYearA11yLabel: 'MMMM Y' }
        };
    }
    /**
     * @return {?}
     */
    OntimizeMatDateFormats.prototype.factory = /**
     * @return {?}
     */
    function () {
        return this.DEFAULT_DATE_FORMATS;
    };
    return OntimizeMatDateFormats;
}());
/**
 * @return {?}
 */
function dateFormatFactory() {
    return new OntimizeMatDateFormats().factory();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OntimizeMatIconRegistry = /** @class */ (function () {
    function OntimizeMatIconRegistry(domSanitizer, matIconRegistry) {
        this.domSanitizer = domSanitizer;
        this.matIconRegistry = matIconRegistry;
    }
    /**
     * @return {?}
     */
    OntimizeMatIconRegistry.prototype.initialize = /**
     * @return {?}
     */
    function () {
        this.matIconRegistry.addSvgIconSetInNamespace(OntimizeMatIconRegistry.ONTIMIZE_NAMESPACE, this.domSanitizer.bypassSecurityTrustResourceUrl(OntimizeMatIconRegistry.ONTIMIZE_ICON_SET_PATH));
    };
    /**
     * @param {?} iconName
     * @param {?} url
     * @return {?}
     */
    OntimizeMatIconRegistry.prototype.addOntimizeSvgIcon = /**
     * @param {?} iconName
     * @param {?} url
     * @return {?}
     */
    function (iconName, url) {
        this.matIconRegistry.addSvgIconInNamespace(OntimizeMatIconRegistry.ONTIMIZE_NAMESPACE, iconName, this.domSanitizer.bypassSecurityTrustResourceUrl(url));
        return this.matIconRegistry;
    };
    /**
     * @param {?} iconName
     * @return {?}
     */
    OntimizeMatIconRegistry.prototype.getSVGElement = /**
     * @param {?} iconName
     * @return {?}
     */
    function (iconName) {
        return this.matIconRegistry.getNamedSvgIcon(iconName, OntimizeMatIconRegistry.ONTIMIZE_NAMESPACE);
    };
    /**
     * @param {?} iconName
     * @return {?}
     */
    OntimizeMatIconRegistry.prototype.existsIcon = /**
     * @param {?} iconName
     * @return {?}
     */
    function (iconName) {
        /** @type {?} */
        var self = this;
        return new Observable(function (observer) {
            self.getSVGElement(iconName).subscribe(function (value) {
                observer.next(true);
            }, function (error) {
                observer.next(false);
            }, function () { return observer.complete(); });
        });
    };
    OntimizeMatIconRegistry.ONTIMIZE_ICON_SET_PATH = 'assets/svg/ontimize-icon-set.svg';
    OntimizeMatIconRegistry.ONTIMIZE_NAMESPACE = 'ontimize';
    OntimizeMatIconRegistry.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OntimizeMatIconRegistry.ctorParameters = function () { return [
        { type: platformBrowser.DomSanitizer },
        { type: material.MatIconRegistry }
    ]; };
    return OntimizeMatIconRegistry;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var MATERIAL_MODULES = [
    material.MatAutocompleteModule,
    material.MatButtonModule,
    material.MatButtonToggleModule,
    material.MatCardModule,
    material.MatChipsModule,
    material.MatCheckboxModule,
    material.MatDatepickerModule,
    material.MatDialogModule,
    material.MatExpansionModule,
    material.MatGridListModule,
    material.MatIconModule,
    material.MatInputModule,
    material.MatFormFieldModule,
    material.MatListModule,
    material.MatMenuModule,
    material.MatProgressBarModule,
    material.MatProgressSpinnerModule,
    material.MatRadioModule,
    material.MatRippleModule,
    material.MatSelectModule,
    material.MatSidenavModule,
    material.MatSliderModule,
    material.MatSlideToggleModule,
    material.MatSnackBarModule,
    material.MatTabsModule,
    material.MatToolbarModule,
    material.MatTooltipModule,
    materialMomentAdapter.MatMomentDateModule,
    material.MatTableModule,
    material.MatPaginatorModule,
    material.MatSortModule,
    OverlayModule
];
var OntimizeMomentDateAdapter = /** @class */ (function (_super) {
    __extends(OntimizeMomentDateAdapter, _super);
    function OntimizeMomentDateAdapter(dateLocale) {
        return _super.call(this, dateLocale) || this;
    }
    /**
     * @param {?} date
     * @param {?} displayFormat
     * @return {?}
     */
    OntimizeMomentDateAdapter.prototype.format = /**
     * @param {?} date
     * @param {?} displayFormat
     * @return {?}
     */
    function (date, displayFormat) {
        return _super.prototype.format.call(this, date, this.oFormat || displayFormat);
    };
    /**
     * @param {?} value
     * @param {?} parseFormat
     * @return {?}
     */
    OntimizeMomentDateAdapter.prototype.parse = /**
     * @param {?} value
     * @param {?} parseFormat
     * @return {?}
     */
    function (value, parseFormat) {
        return _super.prototype.parse.call(this, value, this.oFormat || parseFormat);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OntimizeMomentDateAdapter.prototype.deserialize = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var date;
        if (typeof value === 'number') {
            date = moment__default__default(value);
        }
        if (date && this.isValid(date)) {
            return date;
        }
        return _super.prototype.deserialize.call(this, value);
    };
    OntimizeMomentDateAdapter.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OntimizeMomentDateAdapter.ctorParameters = function () { return [
        { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [material.MAT_DATE_LOCALE,] }] }
    ]; };
    return OntimizeMomentDateAdapter;
}(materialMomentAdapter.MomentDateAdapter));
var 0$3 = dateFormatFactory;
var OCustomMaterialModule = /** @class */ (function () {
    function OCustomMaterialModule() {
    }
    OCustomMaterialModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    exports: MATERIAL_MODULES,
                    providers: [{
                            provide: material.DateAdapter,
                            useClass: OntimizeMomentDateAdapter,
                            deps: [material.MAT_DATE_LOCALE]
                        }, {
                            provide: material.MAT_DATE_FORMATS,
                            useFactory: 0$3
                        }, {
                            provide: OntimizeMatIconRegistry,
                            useClass: OntimizeMatIconRegistry
                        }]
                },] },
    ];
    return OCustomMaterialModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OrderByPipe = /** @class */ (function () {
    function OrderByPipe() {
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    OrderByPipe._orderByComparator = /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (a, b) {
        if ((isNaN(parseFloat(a)) || !isFinite(a)) || (isNaN(parseFloat(b)) || !isFinite(b))) {
            //Isn't a number so lowercase the string to properly compare
            if (a.toLowerCase() < b.toLowerCase()) {
                return -1;
            }
            if (a.toLowerCase() > b.toLowerCase()) {
                return 1;
            }
        }
        else {
            //Parse strings as numbers to compare properly
            if (parseFloat(a) < parseFloat(b)) {
                return -1;
            }
            if (parseFloat(a) > parseFloat(b)) {
                return 1;
            }
        }
        return 0; //equal each other
    };
    /**
     * @param {?} input
     * @param {?} __1
     * @return {?}
     */
    OrderByPipe.prototype.transform = /**
     * @param {?} input
     * @param {?} __1
     * @return {?}
     */
    function (input, _a) {
        var _b = _a[0], config$$1 = _b === void 0 ? '+' : _b;
        if (!Array.isArray(input)) {
            return input;
        }
        if (!Array.isArray(config$$1) || (Array.isArray(config$$1) && config$$1.length === 1)) {
            /** @type {?} */
            var propertyToCheck = !Array.isArray(config$$1) ? config$$1 : config$$1[0];
            /** @type {?} */
            var desc = propertyToCheck.substr(0, 1) === '-';
            //Basic array
            if (!propertyToCheck || propertyToCheck === '-' || propertyToCheck === '+') {
                return !desc ? input.sort() : input.sort().reverse();
            }
            else {
                /** @type {?} */
                var property = propertyToCheck.substr(0, 1) === '+' || propertyToCheck.substr(0, 1) === '-'
                    ? propertyToCheck.substr(1)
                    : propertyToCheck;
                return input.sort(function (a, b) {
                    return !desc
                        ? OrderByPipe._orderByComparator(a[property], b[property])
                        : -OrderByPipe._orderByComparator(a[property], b[property]);
                });
            }
        }
        else {
            //Loop over property of the array in order and sort
            return input.sort(function (a, b) {
                for (var i = 0; i < config$$1.length; i++) {
                    /** @type {?} */
                    var desc = config$$1[i].substr(0, 1) === '-';
                    /** @type {?} */
                    var property = config$$1[i].substr(0, 1) === '+' || config$$1[i].substr(0, 1) === '-'
                        ? config$$1[i].substr(1)
                        : config$$1[i];
                    /** @type {?} */
                    var comparison = !desc
                        ? OrderByPipe._orderByComparator(a[property], b[property])
                        : -OrderByPipe._orderByComparator(a[property], b[property]);
                    //Don't return 0 yet in case of needing to sort by next property
                    if (comparison = 0) {
                        return comparison;
                    }
                }
                return 0; //equal each other
            });
        }
    };
    OrderByPipe.decorators = [
        { type: core.Pipe, args: [{ name: 'orderBy', pure: false },] },
    ];
    return OrderByPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ColumnsFilterPipe = /** @class */ (function () {
    function ColumnsFilterPipe() {
    }
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    ColumnsFilterPipe.prototype.transform = /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    function (value, args) {
        var _this = this;
        if (!args || args.length <= 1) {
            return value;
        }
        this.filterValue = args['filtervalue'] ? args['filtervalue'] : '';
        this.filterColumns = args['filtercolumns'];
        if (!this.filterColumns || !this.filterValue || this.filterValue.length === 0) {
            return value;
        }
        if (value === undefined || value === null) {
            return value;
        }
        /** @type {?} */
        var that = this;
        return value.filter(function (item) {
            for (var i = 0; i < that.filterColumns.length; i++) {
                /** @type {?} */
                var colName = that.filterColumns[i];
                if (_this._isBlank(colName)) {
                    continue;
                }
                /** @type {?} */
                var origValue = item[colName];
                if (origValue) {
                    origValue = origValue.toString();
                    if (_this._isBlank(origValue)) {
                        continue;
                    }
                    if (origValue.toUpperCase().indexOf(that.filterValue.toUpperCase()) > -1) {
                        return item;
                    }
                }
            }
        });
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ColumnsFilterPipe.prototype._isBlank = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value === undefined || value === null
            || value.length === 0) {
            return true;
        }
        return false;
    };
    ColumnsFilterPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'columnsfilter'
                },] },
    ];
    return ColumnsFilterPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OIntegerPipe = /** @class */ (function () {
    function OIntegerPipe(injector) {
        this.injector = injector;
        this.numberService = this.injector.get(NumberService);
    }
    /**
     * @param {?} text
     * @param {?} args
     * @return {?}
     */
    OIntegerPipe.prototype.transform = /**
     * @param {?} text
     * @param {?} args
     * @return {?}
     */
    function (text, args) {
        return this.numberService.getIntegerValue(text, args);
    };
    OIntegerPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'oInteger'
                },] },
    ];
    /** @nocollapse */
    OIntegerPipe.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OIntegerPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ORealPipe = /** @class */ (function (_super) {
    __extends(ORealPipe, _super);
    function ORealPipe(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        return _this;
    }
    /**
     * @param {?} text
     * @param {?} args
     * @return {?}
     */
    ORealPipe.prototype.transform = /**
     * @param {?} text
     * @param {?} args
     * @return {?}
     */
    function (text, args) {
        return this.numberService.getRealValue(text, args);
    };
    ORealPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'oReal'
                },] },
    ];
    /** @nocollapse */
    ORealPipe.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return ORealPipe;
}(OIntegerPipe));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OMomentPipe = /** @class */ (function () {
    function OMomentPipe(injector) {
        this.injector = injector;
        this.momentService = this.injector.get(MomentService);
    }
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    OMomentPipe.prototype.transform = /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    function (value, args) {
        /** @type {?} */
        var format = args.format;
        return this.momentService.parseDate(value, format);
    };
    OMomentPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'oMoment'
                },] },
    ];
    /** @nocollapse */
    OMomentPipe.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OMomentPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OCurrencyPipe = /** @class */ (function () {
    function OCurrencyPipe(injector) {
        this.injector = injector;
        this.currencyService = this.injector.get(CurrencyService);
    }
    /**
     * @param {?} text
     * @param {?} args
     * @return {?}
     */
    OCurrencyPipe.prototype.transform = /**
     * @param {?} text
     * @param {?} args
     * @return {?}
     */
    function (text, args) {
        return this.currencyService.getCurrencyValue(text, args);
    };
    OCurrencyPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'oCurrency'
                },] },
    ];
    /** @nocollapse */
    OCurrencyPipe.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OCurrencyPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OPercentPipe = /** @class */ (function (_super) {
    __extends(OPercentPipe, _super);
    function OPercentPipe(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        return _this;
    }
    /**
     * @param {?} text
     * @param {?} args
     * @return {?}
     */
    OPercentPipe.prototype.transform = /**
     * @param {?} text
     * @param {?} args
     * @return {?}
     */
    function (text, args) {
        return this.numberService.getPercentValue(text, args);
    };
    OPercentPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'oPercent'
                },] },
    ];
    /** @nocollapse */
    OPercentPipe.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OPercentPipe;
}(ORealPipe));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTabGroupDirective = /** @class */ (function () {
    function OTabGroupDirective(renderer, el) {
        this.renderer = renderer;
        this.el = el;
        this._mode = 'ontimize';
        this._defaultMode = 'ontimize';
    }
    Object.defineProperty(OTabGroupDirective.prototype, "mode", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mode;
        },
        set: /**
         * @param {?} mode
         * @return {?}
         */
        function (mode) {
            this._mode = mode;
            this.applyMode();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?=} mode
     * @return {?}
     */
    OTabGroupDirective.prototype.applyMode = /**
     * @param {?=} mode
     * @return {?}
     */
    function (mode) {
        this.renderer.removeClass(this.el.nativeElement, OTabGroupDirective.OTabModes.material);
        this.renderer.removeClass(this.el.nativeElement, OTabGroupDirective.OTabModes.ontimize);
        this.renderer.addClass(this.el.nativeElement, OTabGroupDirective.OTabModes[this.mode || this._defaultMode]);
    };
    OTabGroupDirective.OTabModes = {
        ontimize: 'o-tab-ontimize',
        material: 'o-tab-material'
    };
    OTabGroupDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[oTabGroup]'
                },] },
    ];
    /** @nocollapse */
    OTabGroupDirective.ctorParameters = function () { return [
        { type: core.Renderer2 },
        { type: core.ElementRef }
    ]; };
    OTabGroupDirective.propDecorators = {
        mode: [{ type: core.Input, args: ['oTabGroup',] }]
    };
    return OTabGroupDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OKeyboardListenerDirective = /** @class */ (function () {
    function OKeyboardListenerDirective() {
        this.onKeysPressed = new core.EventEmitter();
        this.keyboardNumberKeysArray = [];
        this.activeKeys = {};
    }
    /**
     * @param {?} e
     * @return {?}
     */
    OKeyboardListenerDirective.prototype.keyDown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        /** @type {?} */
        var pressedCode = e.keyCode;
        if (this.keyboardNumberKeysArray.indexOf(pressedCode) !== -1) {
            this.activeKeys[pressedCode] = true;
            this.checkNeededKeys(e);
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OKeyboardListenerDirective.prototype.keyUp = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        /** @type {?} */
        var pressedCode = e.keyCode;
        if (this.keyboardNumberKeysArray.indexOf(pressedCode) !== -1) {
            this.activeKeys[pressedCode] = false;
        }
    };
    /**
     * @return {?}
     */
    OKeyboardListenerDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.parseKeyboardKeys();
    };
    /**
     * @return {?}
     */
    OKeyboardListenerDirective.prototype.parseKeyboardKeys = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var keysAsStringArray = Util.parseArray(this.keyboardKeys);
        keysAsStringArray.forEach(function (key) {
            try {
                _this.keyboardNumberKeysArray.push(parseInt(key));
            }
            catch (e) {
                console.error(e);
            }
        });
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OKeyboardListenerDirective.prototype.checkNeededKeys = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        var _this = this;
        /** @type {?} */
        var trigger$$1 = true;
        this.keyboardNumberKeysArray.forEach(function (key) {
            trigger$$1 = trigger$$1 && _this.activeKeys[key];
        });
        if (trigger$$1) {
            e.preventDefault();
            e.stopPropagation();
            // this.activeKeys = {};
            this.onKeysPressed.emit();
        }
    };
    OKeyboardListenerDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[oKeyboardListener]'
                },] },
    ];
    OKeyboardListenerDirective.propDecorators = {
        keyboardKeys: [{ type: core.Input }],
        onKeysPressed: [{ type: core.Output }],
        keyDown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
        keyUp: [{ type: core.HostListener, args: ['keyup', ['$event'],] }]
    };
    return OKeyboardListenerDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OListItemDirective = /** @class */ (function () {
    function OListItemDirective(_el, renderer, actRoute) {
        this._el = _el;
        this.renderer = renderer;
        this.actRoute = actRoute;
        this.mdClick = new core.EventEmitter();
        this.mdDoubleClick = new core.EventEmitter();
        this.selectable = false;
    }
    /**
     * @return {?}
     */
    OListItemDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subcription = this.actRoute.params.subscribe(function (params) { return _this.updateActiveState(params); });
    };
    /**
     * @return {?}
     */
    OListItemDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.subcription) {
            this.subcription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OListItemDirective.prototype.onMouseEnter = /**
     * @return {?}
     */
    function () {
        if (!this.selectable && this._list.detailMode !== Codes.DETAIL_MODE_NONE) {
            this.renderer.setStyle(this._el.nativeElement, 'cursor', 'pointer');
        }
    };
    /**
     * @param {?} params
     * @return {?}
     */
    OListItemDirective.prototype.updateActiveState = /**
     * @param {?} params
     * @return {?}
     */
    function (params) {
        if (this._list) {
            /** @type {?} */
            var aKeys = this._list.getKeys();
            if (this.modelData) {
                /** @type {?} */
                var _act = false;
                if (aKeys.length > 0) {
                    for (var k = 0; k < aKeys.length; ++k) {
                        /** @type {?} */
                        var key = aKeys[k];
                        /** @type {?} */
                        var id = params[key];
                        _act = (this.modelData[key] === id);
                        if (_act === false) {
                            break;
                        }
                    }
                }
                if (_act) {
                    this._el.nativeElement.classList.add('mat-active');
                }
                else {
                    this._el.nativeElement.classList.remove('mat-active');
                }
            }
            else {
                this._el.nativeElement.classList.remove('mat-active');
            }
        }
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OListItemDirective.prototype.onItemClicked = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (!this.selectable) {
            ObservableWrapper.callEmit(this.mdClick, this);
        }
    };
    /**
     * @param {?} onNext
     * @return {?}
     */
    OListItemDirective.prototype.onClick = /**
     * @param {?} onNext
     * @return {?}
     */
    function (onNext) {
        return ObservableWrapper.subscribe(this.mdClick, onNext);
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OListItemDirective.prototype.onItemDoubleClicked = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (!this.selectable) {
            ObservableWrapper.callEmit(this.mdDoubleClick, this);
        }
    };
    /**
     * @param {?} onNext
     * @return {?}
     */
    OListItemDirective.prototype.onDoubleClick = /**
     * @param {?} onNext
     * @return {?}
     */
    function (onNext) {
        return ObservableWrapper.subscribe(this.mdDoubleClick, onNext);
    };
    /**
     * @return {?}
     */
    OListItemDirective.prototype.isSelected = /**
     * @return {?}
     */
    function () {
        return this._list.isItemSelected(this.modelData);
    };
    /**
     * @return {?}
     */
    OListItemDirective.prototype.onSelect = /**
     * @return {?}
     */
    function () {
        this._list.setSelected(this.modelData);
    };
    /**
     * @param {?} list
     * @return {?}
     */
    OListItemDirective.prototype.setListComponent = /**
     * @param {?} list
     * @return {?}
     */
    function (list) {
        this._list = list;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OListItemDirective.prototype.setItemData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (!this.modelData) {
            this.modelData = data;
        }
    };
    /**
     * @return {?}
     */
    OListItemDirective.prototype.getItemData = /**
     * @return {?}
     */
    function () {
        return this.modelData;
    };
    OListItemDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: 'o-list-item, mat-list-item[o-list-item], mat-card[o-list-item]',
                    exportAs: 'olistitem',
                    host: {
                        '[class.o-list-item]': 'true',
                        '(click)': 'onItemClicked($event)',
                        '(dblclick)': 'onItemDoubleClicked($event)'
                    }
                },] },
    ];
    /** @nocollapse */
    OListItemDirective.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: router.ActivatedRoute }
    ]; };
    OListItemDirective.propDecorators = {
        modelData: [{ type: core.Input, args: ['o-list-item',] }],
        selectable: [{ type: core.Input, args: ['selectable',] }],
        onMouseEnter: [{ type: core.HostListener, args: ['mouseenter',] }]
    };
    return OListItemDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_LOCKER = [
    'oLockerMode',
    'oLockerDelay'
];
var OLockerDirective = /** @class */ (function () {
    function OLockerDirective(element, renderer, parent) {
        var _this = this;
        this.element = element;
        this.renderer = renderer;
        this.parent = parent;
        this._oLockerMode = 'disable';
        if (parent) {
            this.subscription = parent.loadingSubject.subscribe(function (x) { return _this.manageLockerMode(x); });
        }
    }
    /**
     * @return {?}
     */
    OLockerDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    /**
     * @param {?} loading
     * @return {?}
     */
    OLockerDirective.prototype.manageLockerMode = /**
     * @param {?} loading
     * @return {?}
     */
    function (loading) {
        if (this._oLockerMode === 'load') {
            this.manageLoadMode(loading);
        }
        else {
            this.manageDisableMode(loading);
        }
    };
    /**
     * @param {?} loading
     * @return {?}
     */
    OLockerDirective.prototype.manageDisableMode = /**
     * @param {?} loading
     * @return {?}
     */
    function (loading) {
        if (loading) {
            this.parent.enabled = false;
        }
        else {
            this.parent.enabled = true;
        }
    };
    /**
     * @param {?} loading
     * @return {?}
     */
    OLockerDirective.prototype.manageLoadMode = /**
     * @param {?} loading
     * @return {?}
     */
    function (loading) {
        if (loading) {
            this.addLoading();
        }
        else {
            this.removeLoading();
        }
    };
    /**
     * @return {?}
     */
    OLockerDirective.prototype.addLoading = /**
     * @return {?}
     */
    function () {
        this.componentDiv = this.element.nativeElement.children[0]; // set opacity in componentDiv
        this.loadingParentDiv = this.renderer.createElement('div');
        /** @type {?} */
        var loaderChild1 = this.renderer.createElement('div');
        /** @type {?} */
        var loaderChild2 = this.renderer.createElement('div');
        /** @type {?} */
        var loaderChild3 = this.renderer.createElement('div');
        /** @type {?} */
        var loaderChild4 = this.renderer.createElement('div');
        this.renderer.appendChild(this.loadingParentDiv, loaderChild4);
        this.renderer.appendChild(this.loadingParentDiv, loaderChild3);
        this.renderer.appendChild(this.loadingParentDiv, loaderChild2);
        this.renderer.appendChild(this.loadingParentDiv, loaderChild1);
        this.renderer.insertBefore(this.element.nativeElement, this.loadingParentDiv, this.componentDiv);
        this.renderer.addClass(this.loadingParentDiv, 'o-loading');
        this.renderer.addClass(this.element.nativeElement, 'relative');
        this.renderer.setStyle(this.componentDiv, 'opacity', '0.6');
    };
    /**
     * @return {?}
     */
    OLockerDirective.prototype.removeLoading = /**
     * @return {?}
     */
    function () {
        if (this.loadingParentDiv) {
            this.renderer.removeChild(this.element.nativeElement, this.loadingParentDiv);
            this.renderer.removeClass(this.element.nativeElement, 'relative');
            this.renderer.removeStyle(this.componentDiv, 'opacity');
        }
    };
    Object.defineProperty(OLockerDirective.prototype, "oLockerMode", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._oLockerMode = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OLockerDirective.prototype, "oLockerDelay", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.parent.delayLoad = value;
        },
        enumerable: true,
        configurable: true
    });
    OLockerDirective.DEFAULT_INPUTS_O_LOCKER = DEFAULT_INPUTS_O_LOCKER;
    OLockerDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[oLocker]',
                    inputs: DEFAULT_INPUTS_O_LOCKER
                },] },
    ];
    /** @nocollapse */
    OLockerDirective.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: OFormServiceComponent, decorators: [{ type: core.Optional }, { type: core.Host }] }
    ]; };
    OLockerDirective.propDecorators = {
        oLockerMode: [{ type: core.Input }],
        oLockerDelay: [{ type: core.Input }]
    };
    return OLockerDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OHiddenDirective = /** @class */ (function () {
    function OHiddenDirective(el, renderer) {
        renderer.setStyle(el.nativeElement, 'display', 'none');
    }
    OHiddenDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[oHidden]'
                },] },
    ];
    /** @nocollapse */
    OHiddenDirective.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 }
    ]; };
    return OHiddenDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var ONTIMIZE_DIRECTIVES = [
    OKeyboardListenerDirective,
    OListItemDirective,
    OTabGroupDirective,
    OLockerDirective,
    OHiddenDirective
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var O_MAT_ERROR_OPTIONS = new core.InjectionToken('o-mat-error-options');
/** @type {?} */
var nextUniqueId$1 = 0;
var OMatErrorComponent = /** @class */ (function () {
    function OMatErrorComponent(injector, elementRef, cd, errorOptions) {
        this.injector = injector;
        this.elementRef = elementRef;
        this.cd = cd;
        this.id = "mat-error-" + nextUniqueId$1++;
        this.text = '';
        this.errorOptions = errorOptions ? errorOptions : {};
        this.errorType = this.errorOptions.type || 'standard';
    }
    Object.defineProperty(OMatErrorComponent.prototype, "isStandardError", {
        get: /**
         * @return {?}
         */
        function () {
            return this.errorType === Codes.O_MAT_ERROR_STANDARD;
        },
        enumerable: true,
        configurable: true
    });
    OMatErrorComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'mat-error',
                    template: "\n    <ng-container *ngIf=\"isStandardError\">\n      {{ text }}\n    </ng-container>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    host: {
                        'class': 'mat-error',
                        'role': 'alert',
                        '[attr.id]': 'id'
                    }
                },] },
    ];
    /** @nocollapse */
    OMatErrorComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: core.ElementRef },
        { type: core.ChangeDetectorRef },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [O_MAT_ERROR_OPTIONS,] }] }
    ]; };
    OMatErrorComponent.propDecorators = {
        id: [{ type: core.Input }],
        text: [{ type: core.Input }]
    };
    return OMatErrorComponent;
}());
var OMatErrorModule = /** @class */ (function () {
    function OMatErrorModule() {
    }
    OMatErrorModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OMatErrorComponent],
                    imports: [material.MatTooltipModule, material.MatFormFieldModule, common.CommonModule],
                    exports: [OMatErrorComponent]
                },] },
    ];
    return OMatErrorModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OSharedModule = /** @class */ (function () {
    function OSharedModule() {
    }
    OSharedModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        flexLayout.FlexLayoutModule,
                        OMatErrorModule
                    ],
                    declarations: [
                        ColumnsFilterPipe,
                        OrderByPipe,
                        OIntegerPipe,
                        ORealPipe,
                        OMomentPipe,
                        OCurrencyPipe,
                        OPercentPipe,
                        ONTIMIZE_DIRECTIVES
                    ],
                    exports: [
                        flexLayout.FlexLayoutModule,
                        OMatErrorModule,
                        forms.FormsModule,
                        forms.ReactiveFormsModule,
                        OTranslateModule,
                        ColumnsFilterPipe,
                        OrderByPipe,
                        OIntegerPipe,
                        ORealPipe,
                        OMomentPipe,
                        OCurrencyPipe,
                        OPercentPipe,
                        ONTIMIZE_DIRECTIVES,
                        OCustomMaterialModule
                    ]
                },] },
    ];
    return OSharedModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Configuration for showing a SnackBar with the SnackBar service.
 */
var   /**
 * Configuration for showing a SnackBar with the SnackBar service.
 */
OSnackBarConfig = /** @class */ (function () {
    function OSnackBarConfig() {
    }
    return OSnackBarConfig;
}());
var OSnackBarComponent = /** @class */ (function () {
    function OSnackBarComponent(injector) {
        this.injector = injector;
        this.iconPosition = 'left';
        this.snackBarRef = this.injector.get(material.MatSnackBarRef);
    }
    /**
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    OSnackBarComponent.prototype.open = /**
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    function (message, config$$1) {
        this.message = message;
        if (config$$1) {
            if (config$$1.action) {
                this.action = config$$1.action;
            }
            if (config$$1.icon) {
                this.icon = config$$1.icon;
            }
            if (config$$1.iconPosition) {
                this.iconPosition = config$$1.iconPosition;
            }
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OSnackBarComponent.prototype.onAction = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.snackBarRef.closeWithAction();
    };
    OSnackBarComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-snackbar',
                    template: "\n    <div fxLayout=\"row\" fxLayoutAlign=\"start center\">\n      <mat-icon *ngIf=\"icon && iconPosition==='left'\" class=\"o-snackbar-icon\">{{ icon }}</mat-icon>\n      <span fxFlex class=\"o-snackbar-message\">\n        {{ message | oTranslate }}\n      </span>\n      <mat-icon *ngIf=\"icon && iconPosition==='right'\" class=\"o-snackbar-icon\">{{ icon }}</mat-icon>\n      <button type=\"button\" *ngIf=\"action\" (click)=\"onAction($event)\" class=\"mat-simple-snackbar-action\">{{ action | oTranslate }}</button>\n    </div>\n  ",
                    styles: ["\n    .o-snackbar-message{padding:0 8px}.mat-simple-snackbar-action{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;background:transparent}\n  "],
                    host: {
                        '[class.o-snackbar]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OSnackBarComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OSnackBarComponent;
}());
var OSnackBarModule = /** @class */ (function () {
    function OSnackBarModule() {
    }
    OSnackBarModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OSnackBarComponent],
                    imports: [common.CommonModule, OSharedModule, OTranslateModule],
                    exports: [common.CommonModule, OSnackBarComponent]
                },] },
    ];
    return OSnackBarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var SnackBarService = /** @class */ (function () {
    function SnackBarService(injector) {
        this.injector = injector;
        this.matSnackBar = this.injector.get(material.MatSnackBar);
    }
    /**
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    SnackBarService.prototype.open = /**
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    function (message, config$$1) {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var observable$$1 = Observable.create(function (observer) {
            /** @type {?} */
            var containerClasses = [SnackBarService.DEFAULT_CONTAINER_CLASS];
            if (config$$1 && config$$1.cssClass) {
                containerClasses.push(config$$1.cssClass);
            }
            /** @type {?} */
            var matConfig = {
                duration: config$$1 && config$$1.milliseconds ? config$$1.milliseconds : SnackBarService.DEFAULT_DURATION,
                panelClass: containerClasses
            };
            self.snackBarRef = self.matSnackBar.openFromComponent(OSnackBarComponent, matConfig);
            self.snackBarRef.onAction().subscribe(function (arg) {
                observer.next(arg);
            });
            self.snackBarRef.afterDismissed().subscribe(function () {
                observer.complete();
                self.snackBarRef = null;
            });
            self.snackBarRef.instance.open(message, config$$1);
        });
        return observable$$1.toPromise();
    };
    SnackBarService.DEFAULT_DURATION = 2000;
    SnackBarService.DEFAULT_CONTAINER_CLASS = 'o-snackbar-container';
    SnackBarService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    SnackBarService.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return SnackBarService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var MAP = {
    // English
    'en': {
        'LANGUAGE': 'Language',
        'LOCALE_en': 'EN',
        'LOCALE_es': 'ES',
        'LOCALE_pt': 'PT',
        'USERNAME': 'Username',
        'PASSWORD': 'Password',
        'LOGIN': 'Login',
        'LOGOUT': 'Logout',
        'OK': 'Ok',
        'ACCEPT': 'Accept',
        'CANCEL': 'Cancel',
        'CLOSE': 'Close',
        'YES': 'Yes',
        'NO': 'No',
        'RESET': 'Reset',
        'CONFIRM': 'Confirm',
        'NEXT': 'Next',
        'PREVIOUS': 'Previous',
        'FINISH': 'Finish',
        'SAVE': 'Save',
        'INSERT': 'Ok',
        'REFRESH': 'Refresh',
        'SEARCH': 'Search',
        'FILTER': 'Filter',
        'DELETE': 'Delete',
        'ADD': 'New',
        'SELECT': 'Select',
        'SELECT_ALL': 'Select all',
        'INFO': 'Information',
        'ERROR': 'Error',
        'FOUND': 'Found',
        'RESULTS': 'Results',
        'TOTAL': 'Total',
        'MONEY': 'Money',
        'HOME': 'Home',
        'SHOW_CONSOLE': 'Show console',
        'FILE': 'File',
        'OPTIONS': 'Options',
        'EDIT': 'Edit',
        'UNDO': 'Undo',
        'REDO': 'Redo',
        'COPY': 'Copy',
        'PASTE': 'Paste',
        'LOCK': 'Lock',
        'EXIT': 'Exit',
        'SETTINGS': 'Settings',
        'FORM': 'Form',
        'LIST': 'List',
        'LIST.EMPTY': 'No results found',
        'LIST.EMPTY_USING_FILTER': ' using filter "{0}"',
        'TABLE': 'Table',
        'DETAIL': 'Detail',
        'PAGE': 'Page',
        'FIRST_PAGE': 'First',
        'LAST_PAGE': 'Last',
        'PREVIOUS_PAGE': 'Previous',
        'NEXT_PAGE': 'Next',
        'PHOTO': 'Picture',
        'CHOOSE_FILE': 'Choose file',
        'FORM_VALIDATION.REQUIRED': 'Required',
        'FORM_VALIDATION.LENGTH': 'Invalid length',
        'FORM_VALIDATION.MIN_LENGTH': 'Minimum length',
        'FORM_VALIDATION.MAX_LENGTH': 'Maximum length',
        'FORM_VALIDATION.MIN_DECIMAL_DIGITS': 'Minimum number of decimal digits',
        'FORM_VALIDATION.MAX_DECIMAL_DIGITS': 'Maximum number of decimal digits',
        'FORM_VALIDATION.EMAIL_FORMAT': 'Invalid email',
        'FORM_VALIDATION.NIF_FORMAT': 'Invalid format (DNI: 12345678-A, NIE: X-1234567-A)',
        'FORM_VALIDATION.DNI_LETTER': 'Invalid DNI letter',
        'FORM_VALIDATION.DATE_RANGE': 'Date outside valid range',
        'FORM_VALIDATION.MIN_VALUE': 'Minimum value',
        'FORM_VALIDATION.MAX_VALUE': 'Maximum value',
        'FORM_VALIDATION.DATE_PARSE': 'Date not valid format',
        'FORM_VALIDATION.DATE_FILTER': 'Date is not valid for the defined filter',
        'FORM_VALIDATION.DATE_MIN': 'Date min',
        'FORM_VALIDATION.DATE_MAX': 'Date max',
        'FORM_VALIDATION.DATERANGE_MIN': 'Date min is not in the range',
        'FORM_VALIDATION.DATERANGE_MAX': 'Date max is not in the range',
        'FORM_VALIDATION.DATERANGE_INVALID': 'Date range invalid',
        'FORM_VALIDATION.FILE_TYPE': 'Invalid format',
        'FORM_VALIDATION.FILE_MAXSIZE': 'Maximum file size',
        'FORM_VALIDATION.FILE_MAXNUM': 'Max. files',
        'FORM_VALIDATION.HOUR_FORMAT': 'Format not valid format',
        'MESSAGES.FORM_VALIDATION_ERROR': 'Form values are not valid!',
        'MESSAGES.FORM_NOTHING_TO_UPDATE_INFO': 'There are no values to update!',
        'MESSAGES.FORM_CHANGES_WILL_BE_LOST': 'Are you sure you want to continue? All unsaved changes will be lost',
        'MESSAGES.ERROR_LOGIN': 'Login failed. Check username and/or password.',
        'MESSAGES.ERROR_SESSION': 'Session expired.',
        'MESSAGES.ERROR_INSERT': 'Failed to insert data.',
        'MESSAGES.ERROR_QUERY': 'Failed to get data from the server.',
        'MESSAGES.ERROR_UPDATE': 'Failed to save data.',
        'MESSAGES.ERROR_DELETE': 'Failed to delete data.',
        'MESSAGES.ERROR_ATTRIBUTE_REQUIRED': 'Required attribute not set.',
        'MESSAGES.ERROR_FILE_LOAD': 'Failed to load file.',
        'MESSAGES.CONFIRM_ACTION': 'Are you sure you want to continue?',
        'MESSAGES.CONFIRM_LOGOUT': 'Are you sure you want to leave?',
        'MESSAGES.CONFIRM_DELETE': 'Are you sure you want to delete the selected items?',
        'MESSAGES.CONFIRM_CANCEL': 'Are you sure you want to cancel without saving changes?',
        'MESSAGES.SAVING': 'Saving, please wait...',
        'MESSAGES.SAVED': 'Saved',
        'MESSAGES.DELETED': 'Deleted',
        'MESSAGES.INSERTED': 'Inserted',
        'MESSAGES.UPDATED': 'Updated',
        'MESSAGES.NO_RESULTS': 'No results were obtained.',
        'MESSAGES.ERROR_MISSING_LANG': 'Selected language bundle file not found',
        'MESSAGES.CONFIRM_DISCARD_FILTER_BY_COLUMN': 'Are you sure you want to discard all active columns filters?',
        'MESSAGES.ERROR_EXPORT_TABLE_DATA': 'Failed to export table data.',
        'MESSAGES.SUCCESS_EXPORT_TABLE_DATA': 'Table data exported successfully.',
        'MESSAGES.OPERATION_NOT_ALLOWED_PERMISSION': 'Operation is not allowed due to permissions restrictions',
        'MESSAGES.NAVIGATION_NOT_ALLOWED_PERMISSION': 'Navigation is not allowed due to permissions restrictions',
        'MESSAGES.NAVIGATION_REDIRECTED_PERMISSION': 'Navigation redirected due to permissions restrictions',
        'MESSAGES.ERROR_403_TEXT': 'You are not authorized to view this page.',
        'MESSAGES.ERROR_403_TEXT_BUTTON': 'Navigate back',
        'MESSAGES.AVOID_QUERY_WITHOUT_QUICKFILTER_COLUMNS': 'No column has been selected to perform the search.',
        'INPUT.COMBO.EMPTY': 'No results found',
        'INPUT.COMBO.MESSAGE_TRIGGER': ' (+{0} others)',
        'TABLE.FILTER_BY_COLUMN.CHECK_ALL': 'Select all',
        'TABLE.FILTER_BY_COLUMN.EMPTY_VALUE': '(empty value)',
        'TABLE.FILTER_BY_COLUMN.HINT_STAR': 'Use * to search for any character string',
        'TABLE.FILTER_BY_COLUMN.BY_VALUE': 'Filter by value',
        'TABLE.FILTER_BY_COLUMN.CUSTOM_FILTER': 'Custom filter',
        'TABLE.FILTER_BY_COLUMN.FROM': 'From',
        'TABLE.FILTER_BY_COLUMN.TO': 'To',
        'TABLE.FILTER_BY_COLUMN.LIST_EMPTY': 'No values',
        'TABLE.FILTER_BY_COLUMN.LIST_EMPTY_FILTER': 'Insert a filter',
        'TABLE.FILTER': 'Filter',
        'TABLE.FILTER.CASE_SENSITIVE': 'Match uppercase and lowercase',
        'TABLE.EMPTY': 'No results found',
        'TABLE.EMPTY_USING_FILTER': ' using filter "{0}"',
        'TABLE.INFO': '_START_ - _END_ of _TOTAL_',
        'TABLE.INFO_EMPTY': '0 - 0 of 0',
        'TABLE.INFO_FILTERED': '(filtered from _MAX_ total entries)',
        'TABLE.INFO_POST_FIX': ' ',
        'TABLE.LENGTH_MENU': 'Rows per page: _MENU_',
        'TABLE.LOADING_RECORDS': 'Loading...',
        'TABLE.PROCESSING': 'Processing...',
        'TABLE.SEARCH': ' ',
        'TABLE.ZERO_RECORDS': 'No matching records found',
        'TABLE.PAGINATE.FIRST': 'First',
        'TABLE.PAGINATE.LAST': 'Last',
        'TABLE.PAGINATE.NEXT': 'Next',
        'TABLE.PAGINATE.PREVIOUS': 'Previous',
        'TABLE.PAGINATE.RANGE_LABEL': 'of',
        'TABLE.PAGINATE.ITEMSPERPAGELABEL': 'Items per page',
        'TABLE.ARIA.SORT_ASCENDING': ': activate to sort column ascending',
        'TABLE.ARIA.SORT_DESCENDING': ': activate to sort column descending',
        'TABLE.BUTTONS.COLVIS': 'Show / hide columns',
        'TABLE.BUTTONS.COPY_TITLE': 'Added to clipboard',
        'TABLE.BUTTONS.COPY_SUCCESS._': '%d rows copied',
        'TABLE.BUTTONS.COPY_SUCCESS.1': '1 row copied',
        'TABLE.BUTTONS.COPY_TO_CLIPBOARD': 'Copy to clipboard',
        'TABLE.BUTTONS.PRINT': 'Print',
        'TABLE.BUTTONS.EXPORT': 'Export',
        'TABLE.BUTTONS.EXCEL': 'Excel',
        'TABLE.BUTTONS.HTML': 'HTML',
        'TABLE.BUTTONS.PDF': 'PDF',
        'TABLE.BUTTONS.GROUP_ROWS': 'Group rows',
        'TABLE.BUTTONS.RESIZE_COLUMNS': 'Resize columns',
        'TABLE.BUTTONS.FILTER': 'Filter',
        'TABLE.BUTTONS.FILTER_SAVE': 'Save filter',
        'TABLE.BUTTONS.FILTER_LOAD': 'Load filter',
        'TABLE.BUTTONS.FILTER_CLEAR': 'Clear filter',
        'TABLE.BUTTONS.REFRESH': 'Refresh',
        'TABLE.BUTTONS.DELETE': 'Delete',
        'TABLE.BUTTONS.ADD': 'New',
        'TABLE.BUTTONS.SELECT': 'Select...',
        'TABLE.BUTTONS.FILTER_BY_COLUMN': 'Filter by column',
        'TABLE.BUTTONS.SAVE_FILTER': 'Save filter',
        'TABLE.BUTTONS.CONFIGURATION': 'Configuration',
        'TABLE.BUTTONS.SAVE_CONFIGURATION': 'Save configuration',
        'TABLE.BUTTONS.APPLY_CONFIGURATION': 'Load configuration',
        'TABLE.BUTTONS.APPLY': 'Load',
        'TABLE.SELECT.ROWS._': '%d selected rows',
        'TABLE.SELECT.ROWS.0': ' ',
        'TABLE.SELECT.ROWS.1': '1 row selected',
        'TABLE.SHOW_ALL': 'All',
        'TABLE.SELECT_DATE': 'Select date',
        'TABLE.ROW_VALIDATION_ERROR': 'Row data is not valid!',
        'TABLE.DIALOG.SAVE_FILTER': 'Select a name for the filter.',
        'TABLE.DIALOG.FILTER_NAME': 'Name',
        'TABLE.DIALOG.FILTER_DESCRIPTION': 'Description',
        'TABLE.DIALOG.LOAD_FILTER': 'Select a filter to apply to the table',
        'TABLE.DIALOG.CONFIRM_CLEAR_FILTER': 'This acction will clear every filter on the table. Are you sure you want to continue?',
        'TABLE.DIALOG.CONFIRM_REMOVE_FILTER': 'Are you sure you want to delete the selected filter?',
        'TABLE.DIALOG.EMPTY_FILTER_LIST': 'There are no filters stored',
        'TABLE.DIALOG.FILTER_NAME_ALREADY_EXISTS': 'Already exists a filter with that name',
        'TABLE.DIALOG.SAVE_CONFIGURATION': 'Enter a name and description for the configuration',
        'TABLE.DIALOG.CONFIGURATION_NAME': 'Name',
        'TABLE.DIALOG.CONFIGURATION_DESCRIPTION': 'Description',
        'TABLE.DIALOG.APPLY_CONFIGURATION': 'Select a configuration to apply to the table',
        'TABLE.DIALOG.APPLY_CONFIGURATION_DEFAULT': 'Default configuration',
        'TABLE.DIALOG.APPLY_CONFIGURATION_DEFAULT_DESCRIPTION': 'Restores the initial configuration of the table',
        'TABLE.DIALOG.CONFIGURATION_PROPERTIES': 'Select which properties you want to store',
        'TABLE.DIALOG.PROPERTIES.SORT': 'Columns sort',
        'TABLE.DIALOG.PROPERTIES.SORT.INFO': 'Stores the sort of each column',
        'TABLE.DIALOG.PROPERTIES.COLUMNS_DISPLAY': 'Columns visibility',
        'TABLE.DIALOG.PROPERTIES.COLUMNS_DISPLAY.INFO': 'Stores the columns displayed and its order and width',
        'TABLE.DIALOG.PROPERTIES.QUICK_FILTER': 'Filter state',
        'TABLE.DIALOG.PROPERTIES.QUICK_FILTER.INFO': 'Stores the current value of the filter',
        'TABLE.DIALOG.PROPERTIES.COLUMNS_FILTER': 'Filter by column',
        'TABLE.DIALOG.PROPERTIES.COLUMNS_FILTER.INFO': 'Stores the filter configured on each column',
        'TABLE.DIALOG.PROPERTIES.PAGE': 'Pagination status',
        'TABLE.DIALOG.PROPERTIES.PAGE.INFO': 'Stores the pagination status',
        'TABLE.DIALOG.CONFIRM_REMOVE_CONFIGURATION': 'Are you sure you want to delete the selected configuration?',
        'TABLE.DIALOG.EXPORT.DESCRIPTION': 'Select the format you want to export the table information.',
        'LAYOUT_MANANGER.MAIN_TAB_LABEL': 'Home',
        'LAYOUT_MANANGER.DIALOG_TITLE': 'Detail',
        'LAYOUT_MANANGER.INSERTION_MODE_TITLE': 'New',
        'APP_LAYOUT.USER_PROFILE': 'My profile',
        'CARD_MENU_LAYOUT.BUTTON_TEXT': 'View list',
        'GRID.ITEMS_PER_PAGE': 'Items per page',
        'GRID.SORT_BY': 'Sort by',
        'GRID.SORT_BY_ASC': 'Sort by {0} ascending',
        'GRID.SORT_BY_DESC': 'Sort by {0} descending',
        'GRID.BUTTON_NEXT': 'Show more',
        'GRID.TEXT_SHOWN_ITEMS': '{0} / {1}',
        'GRID.EMPTY': 'No results found',
        'GRID.EMPTY_USING_FILTER': ' using filter "{0}"',
        'TABLE_CONTEXT_MENU.VIEW_DETAIL': 'View detail',
        'TABLE_CONTEXT_MENU.EDIT': 'Edit',
        'TABLE_CONTEXT_MENU.INSERT': 'Insert',
        'TABLE_CONTEXT_MENU.COPY': 'Copy',
        'TABLE_CONTEXT_MENU.COPY_CELL': 'Copy cell',
        'TABLE_CONTEXT_MENU.COPY_ROW': 'Copy row',
        'TABLE_CONTEXT_MENU.COPY_ALL': 'Copy all',
        'TABLE_CONTEXT_MENU.COPY_SELECTION': 'Copy selection',
        'TABLE_CONTEXT_MENU.SELECT_ALL': 'Select all',
        'TABLE_CONTEXT_MENU.DESELECT_ALL': 'Deselect all',
        'TABLE_CONTEXT_MENU.REFRESH': 'Refresh',
        'TABLE_CONTEXT_MENU.DELETE': 'Delete',
        'TABLE_CONTEXT_MENU.FILTER': 'Filter',
        'TABLE_CONTEXT_MENU.FILTER_BY': 'Filter by:',
        'TABLE_CONTEXT_MENU.FILTER_BY_VALUE': 'Filter by this value',
        'DATERANGE.today': 'Today',
        'DATERANGE.yesterday': 'Yesterday',
        'DATERANGE.last_7days': 'Last 7 days',
        'DATERANGE.last_30days': 'Last 30 days',
        'DATERANGE.this_month': 'This month',
        'DATERANGE.last_month': 'Last month',
        'DATERANGE.this_year': 'This year',
        'DATERANGE.APPLYLABEL': 'Select dates',
        'DATERANGE.W': 'W'
    },
    // Spanish
    'es': {
        'LANGUAGE': 'Idioma',
        'LOCALE_en': 'EN',
        'LOCALE_es': 'ES',
        'LOCALE_pt': 'PT',
        'USERNAME': 'Usuario',
        'PASSWORD': 'Contrasea',
        'LOGIN': 'Entrar',
        'LOGOUT': 'Salir',
        'OK': 'Ok',
        'ACCEPT': 'Aceptar',
        'CANCEL': 'Cancelar',
        'CLOSE': 'Cerrar',
        'YES': 'S',
        'NO': 'No',
        'RESET': 'Resetear',
        'CONFIRM': 'Confirmar',
        'NEXT': 'Siguiente',
        'PREVIOUS': 'Anterior',
        'FINISH': 'Finalizar',
        'SAVE': 'Guardar',
        'INSERT': 'Ok',
        'REFRESH': 'Refrescar',
        'SEARCH': 'Buscar',
        'FILTER': 'Filtrar',
        'DELETE': 'Borrar',
        'ADD': 'Nuevo',
        'SELECT': 'Seleccionar',
        'SELECT_ALL': 'Seleccionar todo',
        'INFO': 'Informacin',
        'ERROR': 'Error',
        'FOUND': 'Encontrados',
        'RESULTS': 'Resultados',
        'TOTAL': 'Total',
        'MONEY': 'Dinero',
        'HOME': 'Inicio',
        'SHOW_CONSOLE': 'Mostrar consola',
        'FILE': 'Archivo',
        'OPTIONS': 'Opciones',
        'EDIT': 'Editar',
        'UNDO': 'Deshacer',
        'REDO': 'Rehacer',
        'COPY': 'Copiar',
        'PASTE': 'Pegar',
        'LOCK': 'Bloquear',
        'EXIT': 'Salir',
        'SETTINGS': 'Configuracin',
        'FEATURES': 'Caractersticas',
        'FORM': 'Formulario',
        'LIST': 'Lista',
        'LIST.EMPTY': 'No se han obtenido resultados',
        'LIST.EMPTY_USING_FILTER': ' usando el filtro "{0}"',
        'TABLE': 'Tabla',
        'DETAIL': 'Detalle',
        'PAGE': 'Pgina',
        'FIRST_PAGE': 'Primera',
        'LAST_PAGE': 'ltima',
        'PREVIOUS_PAGE': 'Anterior',
        'NEXT_PAGE': 'Siguiente',
        'PHOTO': 'Fotografa',
        'CHOOSE_FILE': 'Escoger fichero',
        'FORM_VALIDATION.REQUIRED': 'Requerido',
        'FORM_VALIDATION.LENGTH': 'Longitud no vlida',
        'FORM_VALIDATION.MIN_LENGTH': 'Longitud mnima',
        'FORM_VALIDATION.MAX_LENGTH': 'Longitud mxima',
        'FORM_VALIDATION.MIN_DECIMAL_DIGITS': 'Mnimo nmero de cifras decimales',
        'FORM_VALIDATION.MAX_DECIMAL_DIGITS': 'Mximo nmero de cifras decimales',
        'FORM_VALIDATION.EMAIL_FORMAT': 'Email no vlido',
        'FORM_VALIDATION.NIF_FORMAT': 'Formato no vlido (DNI: 12345678-A, NIE: X-1234567-A)',
        'FORM_VALIDATION.DNI_LETTER': 'Letra de DNI no vlida',
        'FORM_VALIDATION.DATE_RANGE': 'Fecha fuera del rango vlido',
        'FORM_VALIDATION.MIN_VALUE': 'Valor mnimo',
        'FORM_VALIDATION.MAX_VALUE': 'Valor mximo',
        'FORM_VALIDATION.DATE_PARSE': 'Formato no vlido',
        'FORM_VALIDATION.DATE_FILTER': 'Fecha no es vlida para el filtro definido',
        'FORM_VALIDATION.DATE_MIN': 'Fecha mnima',
        'FORM_VALIDATION.DATE_MAX': 'Fecha mxima',
        'FORM_VALIDATION.DATERANGE_INVALID': 'Rango de fechas invlido',
        'FORM_VALIDATION.FILE_TYPE': 'Formato no vlido',
        'FORM_VALIDATION.FILE_MAXSIZE': 'Tamao de fichero mximo',
        'FORM_VALIDATION.FILE_MAXNUM': 'Nmero mximo de ficheros',
        'FORM_VALIDATION.HOUR_FORMAT': 'Formato no vlido',
        'MESSAGES.FORM_VALIDATION_ERROR': 'El formulario contiene campos con valores no vlidos',
        'MESSAGES.FORM_NOTHING_TO_UPDATE_INFO': 'No existen valores para actualizar!',
        'MESSAGES.FORM_CHANGES_WILL_BE_LOST': 'Est seguro de que quiere continuar? Perder los cambios realizados',
        'MESSAGES.ERROR_LOGIN': 'Error de inicio de sesin. Compruebe nombre de usuario y/o contrasea.',
        'MESSAGES.ERROR_SESSION': 'La sesin ha caducado',
        'MESSAGES.ERROR_INSERT': 'Error al insertar datos.',
        'MESSAGES.ERROR_QUERY': 'Error al consultar datos del servidor.',
        'MESSAGES.ERROR_UPDATE': 'Error al actualizar datos.',
        'MESSAGES.ERROR_DELETE': 'Error al borrar datos.',
        'MESSAGES.ERROR_ATTRIBUTE_REQUIRED': 'Atributo requerido no proporcionado.',
        'MESSAGES.ERROR_FILE_LOAD': 'Error al cargar el archivo.',
        'MESSAGES.CONFIRM_ACTION': 'Est seguro de que quiere continuar?',
        'MESSAGES.CONFIRM_LOGOUT': 'Est seguro de que quiere salir?',
        'MESSAGES.CONFIRM_DELETE': 'Est seguro de que quiere borrar los items seleccionados?',
        'MESSAGES.CONFIRM_CANCEL': 'Est seguro de que quiere cancelar sin guardar los cambios?',
        'MESSAGES.SAVING': 'Guardando, espere...',
        'MESSAGES.SAVED': 'Guardado',
        'MESSAGES.DELETED': 'Borrado',
        'MESSAGES.INSERTED': 'Insertado',
        'MESSAGES.UPDATED': 'Actualizado',
        'MESSAGES.NO_RESULTS': 'No se obtuvieron resultados.',
        'MESSAGES.ERROR_MISSING_LANG': 'No se ha encontrado el fichero de configuracin del idioma seleccionado',
        'MESSAGES.CONFIRM_DISCARD_FILTER_BY_COLUMN': 'Est seguro de que quiere descartar todos los filtros de columna activos?',
        'MESSAGES.ERROR_EXPORT_TABLE_DATA': 'Error al exportar los datos de la tabla.',
        'MESSAGES.SUCCESS_EXPORT_TABLE_DATA': 'Se han exportado los datos de la tabla correctamente.',
        'MESSAGES.OPERATION_NOT_ALLOWED_PERMISSION': 'Operacin no permitida debido a restricciones de permisos.',
        'MESSAGES.NAVIGATION_NOT_ALLOWED_PERMISSION': 'Navegacin no permitida debido a restricciones de permisos.',
        'MESSAGES.NAVIGATION_REDIRECTED_PERMISSION': 'Navegacin redirigida debido a restricciones de permisos.',
        'MESSAGES.ERROR_403_TEXT': 'No est autorizado para ver esta pgina.',
        'MESSAGES.ERROR_403_TEXT_BUTTON': 'Volver atrs',
        'MESSAGES.AVOID_QUERY_WITHOUT_QUICKFILTER_COLUMNS': 'No se ha seleccionado ninguna columna por la que realizar la bsqueda.',
        'INPUT.COMBO.EMPTY': 'No hay resultados',
        'INPUT.COMBO.MESSAGE_TRIGGER': ' (+ otros {0})',
        'TABLE.FILTER_BY_COLUMN.CHECK_ALL': 'Seleccionar todos',
        'TABLE.FILTER_BY_COLUMN.EMPTY_VALUE': '(valor vaco)',
        'TABLE.FILTER_BY_COLUMN.HINT_STAR': 'Use * para buscar por cualquier valor',
        'TABLE.FILTER_BY_COLUMN.BY_VALUE': 'Filtro por valor',
        'TABLE.FILTER_BY_COLUMN.CUSTOM_FILTER': 'Filtro personalizado',
        'TABLE.FILTER_BY_COLUMN.FROM': 'Desde',
        'TABLE.FILTER_BY_COLUMN.TO': 'Hasta',
        'TABLE.FILTER_BY_COLUMN.LIST_EMPTY': 'No hay valores',
        'TABLE.FILTER_BY_COLUMN.LIST_EMPTY_FILTER': 'Introduzca un filtro',
        'TABLE.FILTER': 'Filtrar',
        'TABLE.FILTER.CASE_SENSITIVE': 'Coincidir maysculas y minsculas',
        'TABLE.EMPTY': 'No se han obtenido resultados',
        'TABLE.EMPTY_USING_FILTER': ' usando el filtro "{0}"',
        'TABLE.INFO': '_START_ - _END_ de _TOTAL_',
        'TABLE.INFO_EMPTY': '0 - 0 de 0',
        'TABLE.INFO_FILTERED': '(filtrados de un total de _MAX_ registros)',
        'TABLE.INFO_POST_FIX': ' ',
        'TABLE.LENGTH_MENU': 'Registros por pgina: _MENU_',
        'TABLE.LOADING_RECORDS': 'Cargando...',
        'TABLE.PROCESSING': 'Procesando...',
        'TABLE.SEARCH': ' ',
        'TABLE.ZERO_RECORDS': 'No se encontraron coincidencias',
        'TABLE.PAGINATE.FIRST': 'Primero',
        'TABLE.PAGINATE.LAST': 'ltimo',
        'TABLE.PAGINATE.NEXT': 'Siguiente',
        'TABLE.PAGINATE.PREVIOUS': 'Anterior',
        'TABLE.PAGINATE.RANGE_LABEL': 'de',
        'TABLE.PAGINATE.ITEMSPERPAGELABEL': 'Registros por pgina',
        'TABLE.ARIA.SORT_ASCENDING': ': activar para ordenar la columna de forma ascendente',
        'TABLE.ARIA.SORT_DESCENDING': ': activar para ordenar la columna de forma descendente',
        'TABLE.BUTTONS.COLVIS': 'Mostrar / ocultar columnas',
        'TABLE.BUTTONS.COPY_TITLE': 'Copiado al portapapeles',
        'TABLE.BUTTONS.COPY_SUCCESS._': '%d registros copiados',
        'TABLE.BUTTONS.COPY_SUCCESS.1': '1 registro copiado',
        'TABLE.BUTTONS.COPY_TO_CLIPBOARD': 'Copiar al portapapeles',
        'TABLE.BUTTONS.PRINT': 'Imprimir',
        'TABLE.BUTTONS.EXPORT': 'Exportar',
        'TABLE.BUTTONS.EXCEL': 'Excel',
        'TABLE.BUTTONS.HTML': 'HTML',
        'TABLE.BUTTONS.PDF': 'PDF',
        'TABLE.BUTTONS.GROUP_ROWS': 'Agrupar registros',
        'TABLE.BUTTONS.RESIZE_COLUMNS': 'Cambiar tamao de columnas',
        'TABLE.BUTTONS.FILTER': 'Filtrar',
        'TABLE.BUTTONS.FILTER_SAVE': 'Guardar filtro',
        'TABLE.BUTTONS.FILTER_LOAD': 'Aplicar filtro',
        'TABLE.BUTTONS.FILTER_CLEAR': 'Limpiar filtro',
        'TABLE.BUTTONS.REFRESH': 'Refrescar',
        'TABLE.BUTTONS.DELETE': 'Eliminar',
        'TABLE.BUTTONS.ADD': 'Nuevo',
        'TABLE.BUTTONS.SELECT': 'Seleccionar...',
        'TABLE.BUTTONS.FILTER_BY_COLUMN': 'Filtrado por columnas',
        'TABLE.BUTTONS.SAVE_FILTER': 'Guardar filtro',
        'TABLE.BUTTONS.CONFIGURATION': 'Configuracin',
        'TABLE.BUTTONS.SAVE_CONFIGURATION': 'Guardar configuracin',
        'TABLE.BUTTONS.APPLY_CONFIGURATION': 'Aplicar configuracin',
        'TABLE.BUTTONS.APPLY': 'Aplicar',
        'TABLE.SELECT.ROWS._': '%d registros seleccionados',
        'TABLE.SELECT.ROWS.0': ' ',
        'TABLE.SELECT.ROWS.1': '1 registro seleccionado',
        'TABLE.SHOW_ALL': 'Todo',
        'TABLE.SELECT_DATE': 'Seleccionar fecha',
        'TABLE.ROW_VALIDATION_ERROR': 'La fila contiene campos con valores no vlidos',
        'TABLE.DIALOG.SAVE_FILTER': 'Seleccione un nombre para el filtro.',
        'TABLE.DIALOG.FILTER_NAME': 'Nombre',
        'TABLE.DIALOG.FILTER_DESCRIPTION': 'Descripcin',
        'TABLE.DIALOG.LOAD_FILTER': 'Seleccione un filtro para aplicar a la tabla',
        'TABLE.DIALOG.CONFIRM_CLEAR_FILTER': 'Esta accin limpiar todos los filtros aplicados a la tabla. Desea continuar?',
        'TABLE.DIALOG.CONFIRM_REMOVE_FILTER': 'Est seguro de que quiere eliminar el filtro seleccionado?',
        'TABLE.DIALOG.EMPTY_FILTER_LIST': 'No hay filtros almacenados',
        'TABLE.DIALOG.FILTER_NAME_ALREADY_EXISTS': 'Ya existe un filtro con ese nombre',
        'TABLE.DIALOG.SAVE_CONFIGURATION': 'Introduzca un nombre y una descripcin para la configuracin',
        'TABLE.DIALOG.CONFIGURATION_NAME': 'Nombre',
        'TABLE.DIALOG.CONFIGURATION_DESCRIPTION': 'Descripcin',
        'TABLE.DIALOG.APPLY_CONFIGURATION': 'Seleccione una configuracin para aplicar a la tabla',
        'TABLE.DIALOG.APPLY_CONFIGURATION_DEFAULT': 'Configuracin por defecto',
        'TABLE.DIALOG.APPLY_CONFIGURATION_DEFAULT_DESCRIPTION': 'Restaura la configuracin inicial de la tabla',
        'TABLE.DIALOG.CONFIGURATION_PROPERTIES': 'Seleccione qu propiedades desea almacenar',
        'TABLE.DIALOG.PROPERTIES.SORT': 'Ordenacin de columnas',
        'TABLE.DIALOG.PROPERTIES.SORT.INFO': 'Almacena la ordenacin de cada columna',
        'TABLE.DIALOG.PROPERTIES.COLUMNS_DISPLAY': 'Visibilidad de columnas',
        'TABLE.DIALOG.PROPERTIES.COLUMNS_DISPLAY.INFO': 'Almacena las columnas que se muestran, el orden en el que se muestran y el ancho de cada una',
        'TABLE.DIALOG.PROPERTIES.QUICK_FILTER': 'Estado del filtro',
        'TABLE.DIALOG.PROPERTIES.QUICK_FILTER.INFO': 'Almacena el valor actual del filtro',
        'TABLE.DIALOG.PROPERTIES.COLUMNS_FILTER': 'Filtrado por columnas',
        'TABLE.DIALOG.PROPERTIES.COLUMNS_FILTER.INFO': 'Almacena los filtros configurados en cada una de las columnas',
        'TABLE.DIALOG.PROPERTIES.PAGE': 'Estado de paginacin',
        'TABLE.DIALOG.PROPERTIES.PAGE.INFO': 'Almacena el estado de la paginacin',
        'TABLE.DIALOG.CONFIRM_REMOVE_CONFIGURATION': 'Est seguro de que quiere eliminar la configuracin seleccionada?',
        'TABLE.DIALOG.EXPORT.DESCRIPTION': 'Seleccione el formato al que desea exportar la informacin de la tabla.',
        'LAYOUT_MANANGER.MAIN_TAB_LABEL': 'Inicio',
        'LAYOUT_MANANGER.DIALOG_TITLE': 'Detalle',
        'LAYOUT_MANANGER.INSERTION_MODE_TITLE': 'Nuevo',
        'APP_LAYOUT.USER_PROFILE': 'Mi perfil',
        'CARD_MENU_LAYOUT.BUTTON_TEXT': 'Acceder',
        'GRID.ITEMS_PER_PAGE': 'Elementos por pgina',
        'GRID.SORT_BY': 'Ordenado por',
        'GRID.SORT_BY_ASC': 'Ordenado por {0} ascendente',
        'GRID.SORT_BY_DESC': 'Ordenado por {0} descendente',
        'GRID.BUTTON_NEXT': 'Ver ms',
        'GRID.TEXT_SHOWN_ITEMS': '{0} / {1}',
        'GRID.EMPTY': 'No se han obtenido resultados',
        'GRID.EMPTY_USING_FILTER': ' usando el filtro "{0}"',
        'TABLE_CONTEXT_MENU.VIEW_DETAIL': 'Ver detalle',
        'TABLE_CONTEXT_MENU.EDIT': 'Editar',
        'TABLE_CONTEXT_MENU.INSERT': 'Insertar',
        'TABLE_CONTEXT_MENU.COPY': 'Copiar',
        'TABLE_CONTEXT_MENU.COPY_CELL': 'Copiar celda',
        'TABLE_CONTEXT_MENU.COPY_ROW': 'Copiar celda',
        'TABLE_CONTEXT_MENU.COPY_ALL': 'Copy all',
        'TABLE_CONTEXT_MENU.COPY_SELECTION': 'Copiar seleccin',
        'TABLE_CONTEXT_MENU.SELECT_ALL': 'Seleccionar todos',
        'TABLE_CONTEXT_MENU.DESELECT_ALL': 'Deseleccionar todos',
        'TABLE_CONTEXT_MENU.REFRESH': 'Refrescar',
        'TABLE_CONTEXT_MENU.DELETE': 'Borrar',
        'TABLE_CONTEXT_MENU.FILTER': 'Filtrar',
        'TABLE_CONTEXT_MENU.FILTER_BY': 'Filter by:',
        'TABLE_CONTEXT_MENU.FILTER_BY_VALUE': 'Filtrar por este valor'
    },
    //Portuguese - BRAZIL
    'pt': {
        'LANGUAGE': 'Idioma',
        'LOCALE_en': 'EN',
        'LOCALE_es': 'ES',
        'LOCALE_pt': 'PT',
        'USERNAME': 'Usurio',
        'PASSWORD': 'Senha',
        'LOGIN': 'Entrar',
        'LOGOUT': 'Sair',
        'OK': 'Ok',
        'ACCEPT': 'Aceitar',
        'CANCEL': 'Cancelar',
        'CLOSE': 'Fechar',
        'YES': 'Sim',
        'NO': 'No',
        'RESET': 'Resetar',
        'CONFIRM': 'Confirmar',
        'NEXT': 'Prximo',
        'PREVIOUS': 'Anterior',
        'FINISH': 'Finalizar',
        'SAVE': 'Salvar',
        'INSERT': 'Ok',
        'REFRESH': 'Recarregar',
        'SEARCH': 'Buscar',
        'FILTER': 'Filtrar',
        'DELETE': 'Apagar',
        'ADD': 'Novo',
        'SELECT': 'Selecionar',
        'SELECT_ALL': 'Selecionar Tudo',
        'INFO': 'Informao',
        'ERROR': 'Erro',
        'FOUND': 'Encontrados',
        'RESULTS': 'Resultados',
        'TOTAL': 'Total',
        'MONEY': 'Dinheiro',
        'HOME': 'Incio',
        'SHOW_CONSOLE': 'Mostrar console',
        'FILE': 'Arquivo',
        'OPTIONS': 'Opes',
        'EDIT': 'Editar',
        'UNDO': 'Desfazer',
        'REDO': 'Refazer',
        'COPY': 'Copiar',
        'PASTE': 'Colar',
        'LOCK': 'Bloquear',
        'EXIT': 'Sair',
        'SETTINGS': 'Configurao',
        'FEATURES': 'Caractersticas',
        'FORM': 'Formulrio',
        'LIST': 'Lista',
        'LIST.EMPTY': 'Nenhum resultado encontrado',
        'LIST.EMPTY_USING_FILTER': ' usando o filtro "{0}"',
        'TABLE': 'Tabela',
        'DETAIL': 'Detalhe',
        'PAGE': 'Pgina',
        'FIRST_PAGE': 'Primeira',
        'LAST_PAGE': 'ltima',
        'PREVIOUS_PAGE': 'Anterior',
        'NEXT_PAGE': 'Prxima',
        'PHOTO': 'Fotografia',
        'CHOOSE_FILE': 'Escolher Arquivo',
        'FORM_VALIDATION.REQUIRED': 'Requerido',
        'FORM_VALIDATION.LENGTH': 'Longitude invlida',
        'FORM_VALIDATION.MIN_LENGTH': 'Longitude mnima',
        'FORM_VALIDATION.MAX_LENGTH': 'Longitude mxima',
        'FORM_VALIDATION.MIN_DECIMAL_DIGITS': 'Mnimo nmero de cifras decimais',
        'FORM_VALIDATION.MAX_DECIMAL_DIGITS': 'Mximo nmero de cifras decimais',
        'FORM_VALIDATION.EMAIL_FORMAT': 'Email invlido',
        'FORM_VALIDATION.NIF_FORMAT': 'Formato invlido (DNI: 12345678-A, NIE: X-1234567-A)',
        'FORM_VALIDATION.DNI_LETTER': 'Letra de RG invlida',
        'FORM_VALIDATION.DATE_RANGE': 'Data invlida',
        'FORM_VALIDATION.MIN_VALUE': 'Valor mnimo',
        'FORM_VALIDATION.MAX_VALUE': 'Valor mximo',
        'FORM_VALIDATION.DATE_PARSE': 'Data invlida para o filtro definido',
        'FORM_VALIDATION.DATE_FILTER': 'Fecha no es vlida para el filtro definido',
        'FORM_VALIDATION.DATE_MIN': 'Data mnima',
        'FORM_VALIDATION.DATE_MAX': 'Data mxima',
        'FORM_VALIDATION.FILE_TYPE': 'Formato no vlido',
        'FORM_VALIDATION.FILE_MAXSIZE': 'Tamanho de arquivo mximo',
        'FORM_VALIDATION.FILE_MAXNUM': 'Nmero mximo de arquivos',
        'FORM_VALIDATION.HOUR_FORMAT': 'Formato invlido',
        'MESSAGES.FORM_VALIDATION_ERROR': 'O formulrio apresenta campos com valores invlidos',
        'MESSAGES.FORM_NOTHING_TO_UPDATE_INFO': 'No existem valores a serem atualizados!',
        'MESSAGES.FORM_CHANGES_WILL_BE_LOST': 'Tem certeza que quer continuar? Perder todas as alteraes realizadas',
        'MESSAGES.ERROR_LOGIN': 'Erro de incio de sesso. Comprove nome de usurio e/ou senha.',
        'MESSAGES.ERROR_SESSION': 'A sesso foi encerrada',
        'MESSAGES.ERROR_INSERT': 'Erro ao inserir os dados.',
        'MESSAGES.ERROR_QUERY': 'Erro na consulta de dados do servidor.',
        'MESSAGES.ERROR_UPDATE': 'Erro de atualizao dos dados.',
        'MESSAGES.ERROR_DELETE': 'Erro ao apagar os dados.',
        'MESSAGES.ERROR_ATTRIBUTE_REQUIRED': 'Atributo requerido no fornecido.',
        'MESSAGES.ERROR_FILE_LOAD': 'Erro ao carregar o arquivo.',
        'MESSAGES.CONFIRM_ACTION': 'Tem certeza que quer continuar?',
        'MESSAGES.CONFIRM_LOGOUT': 'Tem certeza que quer sair?',
        'MESSAGES.CONFIRM_DELETE': 'Tem certeza que quer apagar os tens selecionados?',
        'MESSAGES.CONFIRM_CANCEL': 'Tem certeza que quer cancelar sem salvar as alteraes?',
        'MESSAGES.SAVING': 'Salvando, aguarde...',
        'MESSAGES.SAVED': 'Salvado',
        'MESSAGES.DELETED': 'Apagado',
        'MESSAGES.INSERTED': 'Inserido',
        'MESSAGES.UPDATED': 'Atualizado',
        'MESSAGES.NO_RESULTS': 'Nenhum resultado encontrado.',
        'MESSAGES.ERROR_MISSING_LANG': 'No foi encontrado o arquivo de configurao do idioma selecionado',
        'MESSAGES.CONFIRM_DISCARD_FILTER_BY_COLUMN': 'Tem certeza que quer descartar todos os filtros de coluna ativos?',
        'MESSAGES.ERROR_EXPORT_TABLE_DATA': 'Erro na exportao dos dados da tabela.',
        'MESSAGES.SUCCESS_EXPORT_TABLE_DATA': 'Os dados da tabela foram exportados corretamente.',
        'MESSAGES.OPERATION_NOT_ALLOWED_PERMISSION': 'Operao no permitida por falta de permisses.',
        'MESSAGES.NAVIGATION_NOT_ALLOWED_PERMISSION': 'Navegao no permitida por falta de permisses.',
        'MESSAGES.NAVIGATION_REDIRECTED_PERMISSION': 'Navego redirecionada por falta de permisses.',
        'MESSAGES.ERROR_403_TEXT': 'No tem autorizao para ver esta pgina.',
        'MESSAGES.ERROR_403_TEXT_BUTTON': 'Voltar',
        'MESSAGES.AVOID_QUERY_WITHOUT_QUICKFILTER_COLUMNS': 'No foi selecionada nenhuma coluna para realizar a busca.',
        'INPUT.COMBO.EMPTY': 'No existem resultados',
        'INPUT.COMBO.MESSAGE_TRIGGER': '(+ outros {0})',
        'TABLE.FILTER_BY_COLUMN.CHECK_ALL': 'Selecionar todos',
        'TABLE.FILTER_BY_COLUMN.EMPTY_VALUE': '(valor vazo)',
        'TABLE.FILTER_BY_COLUMN.HINT_STAR': 'Use * para buscar por quaisquer valores',
        'TABLE.FILTER_BY_COLUMN.BY_VALUE': 'Filtro por valor',
        'TABLE.FILTER_BY_COLUMN.CUSTOM_FILTER': 'Filtro personalizado',
        'TABLE.FILTER_BY_COLUMN.FROM': 'De',
        'TABLE.FILTER_BY_COLUMN.TO': 'At',
        'TABLE.FILTER_BY_COLUMN.LIST_EMPTY': 'No existem valores',
        'TABLE.FILTER_BY_COLUMN.LIST_EMPTY_FILTER': 'Introduza um filtro',
        'TABLE.FILTER': 'Filtrar',
        'TABLE.FILTER.CASE_SENSITIVE': 'Coincidir maisculas e minsculas',
        'TABLE.EMPTY': 'Nenhum resultado encontrado.',
        'TABLE.EMPTY_USING_FILTER': 'usando o filtro \'{0}',
        'TABLE.INFO': '_START_ - _END_ de _TOTAL_',
        'TABLE.INFO_EMPTY': '0 - 0 de 0',
        'TABLE.INFO_FILTERED': '(filtrados de um total de _MAX_ registros)',
        'TABLE.INFO_POST_FIX': '',
        'TABLE.LENGTH_MENU': 'Registros por pgina: _MENU_',
        'TABLE.LOADING_RECORDS': 'Carregando...',
        'TABLE.PROCESSING': 'Processando...',
        'TABLE.SEARCH': '',
        'TABLE.ZERO_RECORDS': 'No foram encontradas coincidncias',
        'TABLE.PAGINATE.FIRST': 'Primeiro',
        'TABLE.PAGINATE.LAST': 'ltimo',
        'TABLE.PAGINATE.NEXT': 'Prximo',
        'TABLE.PAGINATE.PREVIOUS': 'Anterior',
        'TABLE.PAGINATE.RANGE_LABEL': 'de',
        'TABLE.PAGINATE.ITEMSPERPAGELABEL': 'Registros por pgina',
        'TABLE.ARIA.SORT_ASCENDING': ': ativar para ordenar a coluna de forma ascendente',
        'TABLE.ARIA.SORT_DESCENDING': ': ativar para ordenar a coluna de forma descendente',
        'TABLE.BUTTONS.COLVIS': 'Mostrar / ocultar colunas',
        'TABLE.BUTTONS.COPY_TITLE': 'Copiado na rea de transferncia (clipboard)',
        'TABLE.BUTTONS.COPY_SUCCESS._': '%d registros copiados',
        'TABLE.BUTTONS.COPY_SUCCESS.1': '1 registro copiado',
        'TABLE.BUTTONS.COPY_TO_CLIPBOARD': 'Copia para a rea de transferncia (clipboard)',
        'TABLE.BUTTONS.PRINT': 'Imprimir',
        'TABLE.BUTTONS.EXPORT': 'Exportar',
        'TABLE.BUTTONS.EXCEL': 'Excel',
        'TABLE.BUTTONS.HTML': 'HTML',
        'TABLE.BUTTONS.PDF': 'PDF',
        'TABLE.BUTTONS.GROUP_ROWS': 'Agrupar registros',
        'TABLE.BUTTONS.RESIZE_COLUMNS': 'Alterar tamanho de colunas',
        'TABLE.BUTTONS.FILTER': 'Filtrar',
        'TABLE.BUTTONS.FILTER_SAVE': 'Guardar filtro',
        'TABLE.BUTTONS.FILTER_LOAD': 'Aplicar filtro',
        'TABLE.BUTTONS.FILTER_CLEAR': 'Limpar filtro',
        'TABLE.BUTTONS.REFRESH': 'Recarregar',
        'TABLE.BUTTONS.DELETE': 'Eliminar',
        'TABLE.BUTTONS.ADD': 'Novo',
        'TABLE.BUTTONS.SELECT': 'Selecionar...',
        'TABLE.BUTTONS.FILTER_BY_COLUMN': 'Filtrado por colunas',
        'TABLE.BUTTONS.SAVE_FILTER': 'Guardar filtro',
        'TABLE.BUTTONS.CONFIGURATION': 'Configurao',
        'TABLE.BUTTONS.SAVE_CONFIGURATION': 'Guardar configurao',
        'TABLE.BUTTONS.APPLY_CONFIGURATION': 'Aplicar configurao',
        'TABLE.BUTTONS.APPLY': 'Aplicar',
        'TABLE.SELECT.ROWS._': '%d registros selecionados',
        'TABLE.SELECT.ROWS.0': '',
        'TABLE.SELECT.ROWS.1': '1 registro selecionado',
        'TABLE.SHOW_ALL': 'Tudo',
        'TABLE.SELECT_DATE': 'Selecionar data',
        'TABLE.ROW_VALIDATION_ERROR': 'A linha apresenta campos com valores invlidos',
        'TABLE.DIALOG.SAVE_FILTER': 'Selecione um nome para o filtro.',
        'TABLE.DIALOG.FILTER_NAME': 'Nome',
        'TABLE.DIALOG.FILTER_DESCRIPTION': 'Descrio',
        'TABLE.DIALOG.LOAD_FILTER': 'Selecione um filtro para aplicar  tabela',
        'TABLE.DIALOG.CONFIRM_CLEAR_FILTER': 'Esta ao limpar todos os filtros aplicados  tabela. Deseja continuar?',
        'TABLE.DIALOG.CONFIRM_REMOVE_FILTER': 'Tem certeza que quer eliminar o filtro selecionado?',
        'TABLE.DIALOG.EMPTY_FILTER_LIST': 'No existem filtros armazenados',
        'TABLE.DIALOG.FILTER_NAME_ALREADY_EXISTS': 'J existe um filtro com esse nome',
        'TABLE.DIALOG.SAVE_CONFIGURATION': 'Introduza um nome e uma descrio para a configurao',
        'TABLE.DIALOG.CONFIGURATION_NAME': 'Nome',
        'TABLE.DIALOG.CONFIGURATION_DESCRIPTION': 'Descrio',
        'TABLE.DIALOG.APPLY_CONFIGURATION': 'Selecione uma configurao para aplicar  tabela',
        'TABLE.DIALOG.APPLY_CONFIGURATION_DEFAULT': 'Configurao padro',
        'TABLE.DIALOG.APPLY_CONFIGURATION_DEFAULT_DESCRIPTION': 'Restaura a configurao inicial da tabela',
        'TABLE.DIALOG.CONFIGURATION_PROPERTIES': 'Selecione que propriedades deseja armazenar',
        'TABLE.DIALOG.PROPERTIES.SORT': 'Ordenao de colunas',
        'TABLE.DIALOG.PROPERTIES.SORT.INFO': 'Armazena a ordenao de cada coluna',
        'TABLE.DIALOG.PROPERTIES.COLUMNS_DISPLAY': 'Visibilidade de colunas',
        'TABLE.DIALOG.PROPERTIES.COLUMNS_DISPLAY.INFO': 'Armazena as colunas mostradas, a ordem em que so mostradas e a largura de cada uma',
        'TABLE.DIALOG.PROPERTIES.QUICK_FILTER': 'Estado do filtro',
        'TABLE.DIALOG.PROPERTIES.QUICK_FILTER.INFO': 'Armazena o valor atual do filtro',
        'TABLE.DIALOG.PROPERTIES.COLUMNS_FILTER': 'Filtrado por colunas',
        'TABLE.DIALOG.PROPERTIES.COLUMNS_FILTER.INFO': 'Armazena os filtros configurados em cada uma das colunas',
        'TABLE.DIALOG.PROPERTIES.PAGE': 'Estado de paginao',
        'TABLE.DIALOG.PROPERTIES.PAGE.INFO': 'Armazena o estado da paginao',
        'TABLE.DIALOG.CONFIRM_REMOVE_CONFIGURATION': 'Tem certeza que quer eliminar a configurao selecionada?',
        'TABLE.DIALOG.EXPORT.DESCRIPTION': 'Selecione o formato de exportao da informao da tabela.',
        'LAYOUT_MANANGER.MAIN_TAB_LABEL': 'Incio',
        'LAYOUT_MANANGER.DIALOG_TITLE': 'Detalhe',
        'LAYOUT_MANANGER.INSERTION_MODE_TITLE': 'Novo',
        'APP_LAYOUT.USER_PROFILE': 'Meu perfil',
        'CARD_MENU_LAYOUT.BUTTON_TEXT': 'Acessar',
        'GRID.ITEMS_PER_PAGE': 'Elementos por pgina',
        'GRID.SORT_BY': 'Ordenado por',
        'GRID.SORT_BY_ASC': 'Ordenado por {0} ascendente',
        'GRID.SORT_BY_DESC': 'Ordenado por {0} descendente',
        'GRID.BUTTON_NEXT': 'Ver mais',
        'GRID.TEXT_SHOWN_ITEMS': '{0} / {1}',
        'GRID.EMPTY': 'No existem resultados',
        'GRID.EMPTY_USING_FILTER': 'usando o filtro \'{0}',
        'TABLE_CONTEXT_MENU.VIEW_DETAIL': 'Ver detalhes',
        'TABLE_CONTEXT_MENU.EDIT': 'Editar',
        'TABLE_CONTEXT_MENU.INSERT': 'Inserir',
        'TABLE_CONTEXT_MENU.COPY': 'Copiar',
        'TABLE_CONTEXT_MENU.COPY_CELL': 'Copiar clula',
        'TABLE_CONTEXT_MENU.COPY_ROW': 'Copiar clula',
        'TABLE_CONTEXT_MENU.COPY_ALL': 'Copiar todos',
        'TABLE_CONTEXT_MENU.COPY_SELECTION': 'Copiar seleo',
        'TABLE_CONTEXT_MENU.SELECT_ALL': 'Selecionar todos',
        'TABLE_CONTEXT_MENU.DESELECT_ALL': 'Desselecionar todos',
        'TABLE_CONTEXT_MENU.REFRESH': 'Recarregar',
        'TABLE_CONTEXT_MENU.DELETE': 'Apagar',
        'TABLE_CONTEXT_MENU.FILTER': 'Filtrar',
        'TABLE_CONTEXT_MENU.FILTER_BY': 'Filtrar por:',
        'TABLE_CONTEXT_MENU.FILTER_BY_VALUE': 'Filtrar por esse valor'
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTranslateService$$1 = /** @class */ (function () {
    function OTranslateService$$1(injector) {
        this.injector = injector;
        this.DEFAULT_LANG = 'en';
        this.onLanguageChanged = new core.EventEmitter();
        this.notFoundLang = [];
        this.existingLangFiles = [];
        this.ngxTranslateService = this.injector.get(core$1.TranslateService);
        this.momentService = this.injector.get(MomentService);
        this.httpClient = this.injector.get(http.HttpClient);
        this.appConfig = this.injector.get(AppConfig);
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    OTranslateService$$1.prototype.checkExistingLangFile = /**
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        var _this = this;
        /** @type {?} */
        var self = this;
        return new Promise(function (resolve) {
            if (self.existingLangFiles.indexOf(lang) !== -1) {
                resolve(true);
                return;
            }
            /** @type {?} */
            var localeAssetsPath = (/** @type {?} */ (_this.ngxTranslateService.currentLoader)).prefix;
            /** @type {?} */
            var localeAssetsExtension = (/** @type {?} */ (_this.ngxTranslateService.currentLoader)).suffix;
            self.httpClient.get(localeAssetsPath + lang + localeAssetsExtension).subscribe(function () {
                if (self.existingLangFiles.indexOf(lang) === -1) {
                    self.existingLangFiles.push(lang);
                }
                // I18N File loaded successfully
                resolve(true);
            }, function () {
                // I18N File failed to load
                if (self.notFoundLang.indexOf(lang) === -1) {
                    self.notFoundLang.push(lang);
                }
                resolve(false);
            });
        });
    };
    /**
     * @param {?} lang
     * @return {?}
     */
    OTranslateService$$1.prototype.setDefaultLang = /**
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        this.ngxTranslateService.defaultLang = lang;
        this.checkExistingLangFile(lang).then(function (exists) {
            if (!exists) {
                console.error('Default language(' + lang + ') has no bundle file defined');
            }
        });
    };
    /**
     * @param {?} text
     * @param {?=} values
     * @return {?}
     */
    OTranslateService$$1.prototype.get = /**
     * @param {?} text
     * @param {?=} values
     * @return {?}
     */
    function (text, values) {
        if (values === void 0) { values = []; }
        /** @type {?} */
        var textTranslated = undefined;
        try {
            /** @type {?} */
            var bundle = this.ngxTranslateService.get(text, values);
            if (bundle && bundle['value']) {
                textTranslated = bundle['value'];
            }
            textTranslated = textTranslated === text ? undefined : textTranslated;
        }
        catch (e) {
            textTranslated = undefined;
        }
        if (!textTranslated) {
            /** @type {?} */
            var bundle = MAP[this.ngxTranslateService.currentLang] || MAP[this.DEFAULT_LANG];
            if (bundle && bundle[text]) {
                textTranslated = bundle[text];
            }
            else {
                textTranslated = text;
            }
        }
        return textTranslated;
    };
    /**
     * @param {?} lang
     * @return {?}
     */
    OTranslateService$$1.prototype.setAppLang = /**
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        var _this = this;
        /** @type {?} */
        var observable$$1 = new Observable(function (observer) {
            _this.use(lang, observer);
        });
        return observable$$1;
    };
    /**
     * @param {?} lang
     * @param {?=} observer
     * @return {?}
     */
    OTranslateService$$1.prototype.use = /**
     * @param {?} lang
     * @param {?=} observer
     * @return {?}
     */
    function (lang, observer) {
        var _this = this;
        if (lang === undefined) {
            /** @type {?} */
            var newLang = lang || this.DEFAULT_LANG;
            //setting lang for initializING moment and other components
            this.propagateLang(newLang, {}, observer);
        }
        else {
            this.checkExistingLangFile(lang).then(function (exists) {
                /** @type {?} */
                var newLang = lang;
                if (!exists) {
                    newLang = _this.ngxTranslateService.getDefaultLang();
                    /** @type {?} */
                    var msg = MAP[newLang || _this.DEFAULT_LANG]['MESSAGES.ERROR_MISSING_LANG'];
                    _this.injector.get(SnackBarService).open(msg, {
                        milliseconds: 2500
                    });
                }
                _this.ngxTranslateService.use(newLang).subscribe(function (res) {
                    _this.propagateLang(newLang, res, observer);
                });
            });
        }
    };
    /**
     * @param {?} lang
     * @param {?=} langRes
     * @param {?=} observer
     * @return {?}
     */
    OTranslateService$$1.prototype.propagateLang = /**
     * @param {?} lang
     * @param {?=} langRes
     * @param {?=} observer
     * @return {?}
     */
    function (lang, langRes, observer) {
        /** @type {?} */
        var coreBundle = MAP[lang || this.DEFAULT_LANG];
        if (coreBundle !== undefined) {
            /** @type {?} */
            var mixed = Object.assign({}, coreBundle, langRes);
            this.ngxTranslateService.translations[lang] = mixed;
        }
        this.momentService.load(lang);
        ObservableWrapper.callEmit(this.onLanguageChanged, lang);
        if (observer) {
            observer.next(langRes);
        }
    };
    /**
     * @return {?}
     */
    OTranslateService$$1.prototype.getCurrentLang = /**
     * @return {?}
     */
    function () {
        return this.ngxTranslateService.currentLang;
    };
    /**
     * @return {?}
     */
    OTranslateService$$1.prototype.getBrowserLang = /**
     * @return {?}
     */
    function () {
        // copying this.ngxTranslateService.getBrowserLang() but with a fix for default selected language (browserLang)
        if (typeof window === 'undefined' || typeof window.navigator === 'undefined') {
            return undefined;
        }
        /** @type {?} */
        var navigator = window.navigator;
        /** @type {?} */
        var browserLang = navigator.languages ? navigator.languages[0] : null;
        browserLang = navigator.language || browserLang || navigator.browserLanguage || navigator.userLanguage;
        if (browserLang.indexOf('-') !== -1) {
            browserLang = browserLang.split('-')[0];
        }
        if (browserLang.indexOf('_') !== -1) {
            browserLang = browserLang.split('_')[0];
        }
        return browserLang;
    };
    OTranslateService$$1.ASSETS_PATH = './assets/i18n/';
    OTranslateService$$1.ASSETS_EXTENSION = '.json';
    OTranslateService$$1.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OTranslateService$$1.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OTranslateService$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DataServiceFactory = /** @class */ (function () {
    function DataServiceFactory(injector) {
        this.injector = injector;
        this.config = this.injector.get(AppConfig).getConfiguration();
    }
    /**
     * @return {?}
     */
    DataServiceFactory.prototype.factory = /**
     * @return {?}
     */
    function () {
        if (typeof (this.config.serviceType) === 'undefined') {
            return new OntimizeService$$1(this.injector);
        }
        else if ('OntimizeEE' === this.config.serviceType) {
            return new OntimizeEEService$$1(this.injector);
        }
        else {
            /** @type {?} */
            var newInstance = Object.create((/** @type {?} */ (this.config.serviceType)).prototype);
            this.config.serviceType.apply(newInstance, new Array(this.injector));
            return newInstance;
        }
    };
    return DataServiceFactory;
}());
/**
 * @param {?} injector
 * @return {?}
 */
function dataServiceFactory(injector) {
    return new DataServiceFactory(injector).factory();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OntimizePermissionsService$$1 = /** @class */ (function () {
    function OntimizePermissionsService$$1(injector) {
        this.injector = injector;
        this.entity = '';
        this._sessionid = -1;
        this.httpClient = this.injector.get(http.HttpClient);
        this._config = this.injector.get(AppConfig);
        this._appConfig = this._config.getConfiguration();
    }
    /**
     * @return {?}
     */
    OntimizePermissionsService$$1.prototype.getDefaultServiceConfiguration = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var loginService = this.injector.get(LoginService$$1);
        /** @type {?} */
        var servConfig = {};
        servConfig[Codes.SESSION_KEY] = loginService.getSessionInfo();
        return servConfig;
    };
    /**
     * @param {?} permissionsConfig
     * @return {?}
     */
    OntimizePermissionsService$$1.prototype.configureService = /**
     * @param {?} permissionsConfig
     * @return {?}
     */
    function (permissionsConfig) {
        /** @type {?} */
        var config$$1 = this.getDefaultServiceConfiguration();
        this._urlBase = config$$1.urlBase ? config$$1.urlBase : this._appConfig['apiEndpoint'];
        this._sessionid = config$$1.session ? config$$1.session.id : -1;
        this._user = config$$1.session ? config$$1.session.user : '';
        if (Util.isDefined(permissionsConfig)) {
            if (permissionsConfig.entity !== undefined) {
                this.entity = permissionsConfig.entity;
            }
            if (permissionsConfig.keyColumn !== undefined) {
                this.keyColumn = permissionsConfig.keyColumn;
            }
            if (permissionsConfig.valueColumn !== undefined) {
                this.valueColumn = permissionsConfig.valueColumn;
            }
        }
    };
    /**
     * @return {?}
     */
    OntimizePermissionsService$$1.prototype.loadPermissions = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var kv = {};
        kv[this.keyColumn] = this._user;
        /** @type {?} */
        var av = [this.valueColumn];
        /** @type {?} */
        var url = this._urlBase + '/query';
        /** @type {?} */
        var options = {
            headers: this.buildHeaders()
        };
        /** @type {?} */
        var body = JSON.stringify({
            user: this._user,
            sessionid: this._sessionid,
            type: 1,
            entity: this.entity,
            kv: kv,
            av: av
        });
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_innerObserver) {
            self.httpClient.post(url, body, options).subscribe(function (res) {
                /** @type {?} */
                var permissions = {};
                if ((res.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) && Util.isDefined(res.data)) {
                    /** @type {?} */
                    var response = res.data;
                    if ((response.length === 1) && Util.isObject(response[0])) {
                        /** @type {?} */
                        var permissionsResp = response[0];
                        try {
                            permissions = permissionsResp.hasOwnProperty(self.valueColumn) ? JSON.parse(permissionsResp[self.valueColumn]) : {};
                        }
                        catch (e) {
                            console.warn('[OntimizePermissionsService: permissions parsing failed]');
                        }
                    }
                }
                _innerObserver.next(permissions);
            }, function (error) {
                _innerObserver.error(error);
            }, function () { return _innerObserver.complete(); });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @return {?}
     */
    OntimizePermissionsService$$1.prototype.buildHeaders = /**
     * @return {?}
     */
    function () {
        return new http.HttpHeaders({
            'Access-Control-Allow-Origin': '*',
            'Content-Type': 'application/json;charset=UTF-8'
        });
    };
    OntimizePermissionsService$$1.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OntimizePermissionsService$$1.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OntimizePermissionsService$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OntimizeEEPermissionsService$$1 = /** @class */ (function () {
    function OntimizeEEPermissionsService$$1(injector) {
        this.injector = injector;
        this.path = '';
        this._sessionid = -1;
        this.httpClient = this.injector.get(http.HttpClient);
        this._config = this.injector.get(AppConfig);
        this._appConfig = this._config.getConfiguration();
    }
    /**
     * @param {?} permissionsConfig
     * @return {?}
     */
    OntimizeEEPermissionsService$$1.prototype.getDefaultServiceConfiguration = /**
     * @param {?} permissionsConfig
     * @return {?}
     */
    function (permissionsConfig) {
        /** @type {?} */
        var serviceName = permissionsConfig ? permissionsConfig.service : undefined;
        /** @type {?} */
        var loginService = this.injector.get(LoginService$$1);
        /** @type {?} */
        var configuration = this._config.getServiceConfiguration();
        /** @type {?} */
        var servConfig = {};
        if (serviceName && configuration.hasOwnProperty(serviceName)) {
            servConfig = configuration[serviceName];
        }
        servConfig[Codes.SESSION_KEY] = loginService.getSessionInfo();
        return servConfig;
    };
    /**
     * @param {?} permissionsConfig
     * @return {?}
     */
    OntimizeEEPermissionsService$$1.prototype.configureService = /**
     * @param {?} permissionsConfig
     * @return {?}
     */
    function (permissionsConfig) {
        /** @type {?} */
        var config$$1 = this.getDefaultServiceConfiguration(permissionsConfig);
        this._urlBase = config$$1.urlBase ? config$$1.urlBase : this._appConfig['apiEndpoint'];
        this._sessionid = config$$1.session ? config$$1.session.id : -1;
        this._user = config$$1.session ? config$$1.session.user : '';
        this.path = config$$1.path ? config$$1.path : OntimizeEEPermissionsService$$1.DEFAULT_PERMISSIONS_PATH;
    };
    /**
     * @return {?}
     */
    OntimizeEEPermissionsService$$1.prototype.loadPermissions = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var url = this._urlBase + this.path;
        /** @type {?} */
        var options = {
            headers: this.buildHeaders()
        };
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (_innerObserver) {
            self.httpClient.get(url, options).subscribe(function (res) {
                /** @type {?} */
                var permissions = {};
                if ((res.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) && Util.isDefined(res.data)) {
                    /** @type {?} */
                    var response = res.data;
                    if ((response.length === 1) && Util.isObject(response[0])) {
                        try {
                            permissions = JSON.parse(response[0][OntimizeEEPermissionsService$$1.PERMISSIONS_KEY]);
                        }
                        catch (e) {
                            console.warn('[OntimizeEEPermissionsService: permissions parsing failed]');
                        }
                    }
                }
                _innerObserver.next(permissions);
            }, function (error) {
                _innerObserver.error(error);
            }, function () { return _innerObserver.complete(); });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @return {?}
     */
    OntimizeEEPermissionsService$$1.prototype.buildHeaders = /**
     * @return {?}
     */
    function () {
        return new http.HttpHeaders({
            'Access-Control-Allow-Origin': '*',
            'Content-Type': 'application/json;charset=UTF-8',
            'Authorization': 'Bearer ' + this._sessionid
        });
    };
    OntimizeEEPermissionsService$$1.DEFAULT_PERMISSIONS_PATH = '/loadPermissions';
    OntimizeEEPermissionsService$$1.PERMISSIONS_KEY = 'permission';
    OntimizeEEPermissionsService$$1.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OntimizeEEPermissionsService$$1.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OntimizeEEPermissionsService$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var PermissionsService = /** @class */ (function () {
    function PermissionsService(injector) {
        this.injector = injector;
        /** @type {?} */
        var appConfig = this.injector.get(AppConfig).getConfiguration();
        if (Util.isDefined(appConfig.permissionsConfiguration)) {
            this.ontimizePermissionsConfig = appConfig.permissionsConfiguration;
        }
    }
    /**
     * @return {?}
     */
    PermissionsService.prototype.configureService = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var loadingService = OntimizePermissionsService$$1;
        try {
            this.permissionsService = this.injector.get(loadingService);
            if (Util.isPermissionsService(this.permissionsService)) {
                if (this.permissionsService instanceof OntimizePermissionsService$$1) {
                    (/** @type {?} */ (this.permissionsService)).configureService(this.ontimizePermissionsConfig);
                }
                else if (this.permissionsService instanceof OntimizeEEPermissionsService$$1) {
                    (/** @type {?} */ (this.permissionsService)).configureService(this.ontimizePermissionsConfig);
                }
            }
        }
        catch (e) {
            console.error(e);
        }
    };
    /**
     * @return {?}
     */
    PermissionsService.prototype.restart = /**
     * @return {?}
     */
    function () {
        this.permissions = undefined;
    };
    /**
     * @return {?}
     */
    PermissionsService.prototype.hasPermissions = /**
     * @return {?}
     */
    function () {
        return this.permissions !== undefined;
    };
    /**
     * @return {?}
     */
    PermissionsService.prototype.getUserPermissionsAsPromise = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        return new Promise(function (resolve, reject) {
            self.permissions = {};
            if (Util.isDefined(self.ontimizePermissionsConfig)) {
                self.configureService();
                self.queryPermissions().subscribe(function () {
                    resolve(true);
                }, function (error) {
                    resolve(true);
                });
            }
            else {
                resolve(true);
            }
        });
    };
    /**
     * @return {?}
     */
    PermissionsService.prototype.queryPermissions = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var dataObservable = new Observable(function (innerObserver) {
            self.permissionsService.loadPermissions().subscribe(function (res) {
                self.permissions = res;
                innerObserver.next(res);
            }, function (err) {
                console.error('[Permissions.queryPermissions]: error', err);
                innerObserver.error(err);
            }, function () {
                innerObserver.complete();
            });
        });
        return dataObservable.pipe(share());
    };
    /**
     * @param {?} actRoute
     * @return {?}
     */
    PermissionsService.prototype.getPermissionIdFromActRoute = /**
     * @param {?} actRoute
     * @return {?}
     */
    function (actRoute) {
        /** @type {?} */
        var result;
        /** @type {?} */
        var snapshot = actRoute.snapshot;
        result = ((snapshot.data || {})['oPermission'] || {})['permissionId'];
        while (Util.isDefined(snapshot.firstChild) && !Util.isDefined(result)) {
            snapshot = snapshot.firstChild;
            result = ((snapshot.data || {})['oPermission'] || {})['permissionId'];
        }
        return result;
    };
    /**
     * @param {?} attr
     * @param {?} actRoute
     * @return {?}
     */
    PermissionsService.prototype.getComponentPermissionsUsingRoute = /**
     * @param {?} attr
     * @param {?} actRoute
     * @return {?}
     */
    function (attr, actRoute) {
        /** @type {?} */
        var result;
        /** @type {?} */
        var permissionId = this.getPermissionIdFromActRoute(actRoute);
        if (Util.isDefined(permissionId)) {
            /** @type {?} */
            var routePermissions = (this.permissions.routes || []).find(function (route) { return route.permissionId === permissionId; });
            if (Util.isDefined(routePermissions)) {
                result = (routePermissions.components || []).find(function (comp) { return comp.attr === attr; });
            }
        }
        return result;
    };
    /**
     * @param {?} attr
     * @param {?} actRoute
     * @param {?} selector
     * @return {?}
     */
    PermissionsService.prototype.getOComponentPermissions = /**
     * @param {?} attr
     * @param {?} actRoute
     * @param {?} selector
     * @return {?}
     */
    function (attr, actRoute, selector) {
        if (!Util.isDefined(this.permissions)) {
            return undefined;
        }
        /** @type {?} */
        var routePermissions;
        /** @type {?} */
        var genericRoutePerm = this.getComponentPermissionsUsingRoute(attr, actRoute);
        if (genericRoutePerm && genericRoutePerm.selector === selector) {
            routePermissions = genericRoutePerm;
        }
        /** @type {?} */
        var compPermissions;
        /** @type {?} */
        var attrPermissions = (this.permissions.components || []).find(function (comp) { return comp.attr === attr; });
        if (attrPermissions && attrPermissions.selector === selector) {
            compPermissions = attrPermissions;
        }
        return {
            route: routePermissions,
            component: compPermissions
        };
    };
    /**
     * @param {?} attr
     * @param {?} actRoute
     * @return {?}
     */
    PermissionsService.prototype.getTablePermissions = /**
     * @param {?} attr
     * @param {?} actRoute
     * @return {?}
     */
    function (attr, actRoute) {
        if (!Util.isDefined(this.permissions)) {
            return undefined;
        }
        /** @type {?} */
        var perm = this.getOComponentPermissions(attr, actRoute, 'o-table');
        /** @type {?} */
        var routePerm = /** @type {?} */ (perm.route);
        /** @type {?} */
        var compPerm = /** @type {?} */ (perm.component);
        if (!Util.isDefined(routePerm) || !Util.isDefined(compPerm)) {
            return compPerm || routePerm;
        }
        /** @type {?} */
        var permissions = {
            selector: 'o-table',
            attr: routePerm.attr,
            menu: this.mergeOTableMenuPermissions(compPerm.menu, routePerm.menu),
            columns: this.mergeOPermissionsArrays(compPerm.columns, routePerm.columns),
            actions: this.mergeOPermissionsArrays(compPerm.actions, routePerm.actions),
            contextMenu: this.mergeOPermissionsArrays(compPerm.contextMenu, routePerm.contextMenu)
        };
        return permissions;
    };
    /**
     * @param {?} attr
     * @param {?} actRoute
     * @return {?}
     */
    PermissionsService.prototype.getFormPermissions = /**
     * @param {?} attr
     * @param {?} actRoute
     * @return {?}
     */
    function (attr, actRoute) {
        if (!Util.isDefined(this.permissions)) {
            return undefined;
        }
        /** @type {?} */
        var perm = this.getOComponentPermissions(attr, actRoute, 'o-form');
        /** @type {?} */
        var routePerm = /** @type {?} */ (perm.route);
        /** @type {?} */
        var compPerm = /** @type {?} */ (perm.component);
        if (!Util.isDefined(routePerm) || !Util.isDefined(compPerm)) {
            return compPerm || routePerm;
        }
        /** @type {?} */
        var permissions = {
            selector: 'o-form',
            attr: routePerm.attr,
            components: this.mergeOPermissionsArrays(compPerm.components, routePerm.components),
            actions: this.mergeOPermissionsArrays(compPerm.actions, routePerm.actions)
        };
        return permissions;
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    PermissionsService.prototype.getMenuPermissions = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        /** @type {?} */
        var permissions;
        if (!Util.isDefined(this.permissions)) {
            return undefined;
        }
        /** @type {?} */
        var allMenu = this.permissions.menu || [];
        permissions = allMenu.find(function (comp) { return comp.attr === attr; });
        return permissions;
    };
    /**
     * @param {?} permissionsA
     * @param {?} permissionsB
     * @return {?}
     */
    PermissionsService.prototype.mergeOPermissionsArrays = /**
     * @param {?} permissionsA
     * @param {?} permissionsB
     * @return {?}
     */
    function (permissionsA, permissionsB) {
        if (!Util.isDefined(permissionsA) || !Util.isDefined(permissionsB)) {
            return permissionsA || permissionsB;
        }
        /** @type {?} */
        var result = Object.assign([], permissionsA);
        permissionsB.forEach(function (perm) {
            /** @type {?} */
            var found = result.find(function (r) { return r.attr === perm.attr; });
            if (found) {
                found.visible = perm.visible;
                found.enabled = perm.enabled;
            }
            else {
                result.push(perm);
            }
        });
        return result;
    };
    /**
     * @param {?} permissionsA
     * @param {?} permissionsB
     * @return {?}
     */
    PermissionsService.prototype.mergeOTableMenuPermissions = /**
     * @param {?} permissionsA
     * @param {?} permissionsB
     * @return {?}
     */
    function (permissionsA, permissionsB) {
        if (!Util.isDefined(permissionsA) || !Util.isDefined(permissionsB)) {
            return permissionsA || permissionsB;
        }
        /** @type {?} */
        var result = {
            visible: permissionsB.visible,
            enabled: permissionsB.enabled,
            items: this.mergeOPermissionsArrays(permissionsA.items, permissionsB.items)
        };
        return result;
    };
    /**
     * @param {?} permissionId
     * @return {?}
     */
    PermissionsService.prototype.isPermissionIdRouteRestricted = /**
     * @param {?} permissionId
     * @return {?}
     */
    function (permissionId) {
        /** @type {?} */
        var routeData = (this.permissions.routes || []).find(function (route) { return route.permissionId === permissionId; });
        return Util.isDefined(routeData) && routeData.enabled === false;
    };
    PermissionsService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    PermissionsService.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return PermissionsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var AuthGuardService$$1 = /** @class */ (function () {
    function AuthGuardService$$1(injector) {
        this.injector = injector;
        this.router = this.injector.get(router.Router);
        this.loginService = this.injector.get(LoginService$$1);
        this.oUserInfoService = this.injector.get(OUserInfoService);
        this.permissionsService = this.injector.get(PermissionsService);
    }
    /**
     * @param {?} next
     * @param {?} state
     * @return {?}
     */
    AuthGuardService$$1.prototype.canActivate = /**
     * @param {?} next
     * @param {?} state
     * @return {?}
     */
    function (next, state$$1) {
        /** @type {?} */
        var isLoggedIn = this.loginService.isLoggedIn();
        /** @type {?} */
        var result = isLoggedIn;
        if (!isLoggedIn) {
            this.permissionsService.restart();
            this.router.navigate([Codes.LOGIN_ROUTE]);
        }
        if (isLoggedIn) {
            this.setUserInformation();
            if (!this.permissionsService.hasPermissions()) {
                result = this.permissionsService.getUserPermissionsAsPromise();
            }
        }
        return result;
    };
    /**
     * @return {?}
     */
    AuthGuardService$$1.prototype.setUserInformation = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var sessionInfo = this.loginService.getSessionInfo();
        // TODO query user information
        this.oUserInfoService.setUserInfo({
            username: sessionInfo.user,
            avatar: './assets/images/user_profile.png'
        });
    };
    AuthGuardService$$1.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    AuthGuardService$$1.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return AuthGuardService$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var AppConfigFactory = /** @class */ (function () {
    function AppConfigFactory(injector) {
        this.injector = injector;
        this.config = this.injector.get(APP_CONFIG);
    }
    /**
     * @return {?}
     */
    AppConfigFactory.prototype.factory = /**
     * @return {?}
     */
    function () {
        return new AppConfig(this.config);
    };
    return AppConfigFactory;
}());
/**
 * @param {?} injector
 * @return {?}
 */
function appConfigFactory(injector) {
    return new AppConfigFactory(injector).factory();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var AppMenuService = /** @class */ (function () {
    function AppMenuService(injector) {
        this.injector = injector;
        this._config = this.injector.get(AppConfig);
        this.MENU_ROOTS = this._config.getMenuConfiguration();
        this.ALL_MENU_ITEMS = [];
        for (var i = 0, len = this.MENU_ROOTS.length; i < len; i++) {
            /** @type {?} */
            var item = this.MENU_ROOTS[i];
            this.ALL_MENU_ITEMS = this.ALL_MENU_ITEMS.concat(this.getMenuItems(item));
        }
        //this.ALL_MENU_ITEMS = this.MENU_ROOTS.reduce((result, category) => result.concat(category.items), []);
    }
    /**
     * @return {?}
     */
    AppMenuService.prototype.getMenuRoots = /**
     * @return {?}
     */
    function () {
        return this.MENU_ROOTS;
    };
    /**
     * @param {?} id
     * @return {?}
     */
    AppMenuService.prototype.getMenuRootById = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return this.MENU_ROOTS.find(function (c) { return c.id === id; });
    };
    /**
     * @return {?}
     */
    AppMenuService.prototype.getAllMenuItems = /**
     * @return {?}
     */
    function () {
        return this.ALL_MENU_ITEMS;
    };
    /**
     * @param {?} id
     * @return {?}
     */
    AppMenuService.prototype.getMenuItemById = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return this.ALL_MENU_ITEMS.find(function (i) { return i.id === id; });
    };
    /**
     * @param {?} item
     * @return {?}
     */
    AppMenuService.prototype.getMenuItemType = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var type;
        switch (true) {
            case ((/** @type {?} */ (item)).route === Codes.LOGIN_ROUTE):
                type = 'logout';
                break;
            case ((/** @type {?} */ (item)).route !== undefined):
                type = 'route';
                break;
            case ((/** @type {?} */ (item)).action !== undefined):
                type = 'action';
                break;
            case ((/** @type {?} */ (item)).locale !== undefined):
                type = 'locale';
                break;
            case ((/** @type {?} */ (item)).user !== undefined):
                type = 'user-info';
                break;
            case ((/** @type {?} */ (item)).items !== undefined):
                type = 'group';
                break;
            default:
                type = 'default';
                break;
        }
        return type;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    AppMenuService.prototype.isMenuGroup = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.getMenuItemType(item) === 'group';
    };
    /**
     * @param {?} item
     * @return {?}
     */
    AppMenuService.prototype.getMenuItems = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if ((/** @type {?} */ (item)).items !== undefined) {
            return (/** @type {?} */ (item)).items;
        }
        return [item];
    };
    AppMenuService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    AppMenuService.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return AppMenuService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OUserInfoService = /** @class */ (function () {
    function OUserInfoService(injector) {
        this.injector = injector;
        this.subject = new Subject();
    }
    /**
     * @param {?} info
     * @return {?}
     */
    OUserInfoService.prototype.setUserInfo = /**
     * @param {?} info
     * @return {?}
     */
    function (info) {
        this.storedInfo = info;
        this.subject.next(info);
    };
    /**
     * @return {?}
     */
    OUserInfoService.prototype.getUserInfo = /**
     * @return {?}
     */
    function () {
        return this.storedInfo;
    };
    /**
     * @return {?}
     */
    OUserInfoService.prototype.getUserInfoObservable = /**
     * @return {?}
     */
    function () {
        return this.subject.asObservable();
    };
    OUserInfoService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OUserInfoService.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OUserInfoService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OModulesInfoService$$1 = /** @class */ (function () {
    function OModulesInfoService$$1(injector) {
        var _this = this;
        this.injector = injector;
        this.subject = new Subject();
        this.router = this.injector.get(router.Router);
        this.actRoute = this.injector.get(router.ActivatedRoute);
        this.translateService = this.injector.get(OTranslateService$$1);
        this.router.events.subscribe(function (ev) {
            if (ev instanceof router.NavigationEnd) {
                /** @type {?} */
                var translation = _this.translateService.get(ev.url);
                if (translation !== ev.url) {
                    _this.setModuleInfo({
                        name: translation
                    });
                }
            }
        });
    }
    /**
     * @param {?} info
     * @return {?}
     */
    OModulesInfoService$$1.prototype.setModuleInfo = /**
     * @param {?} info
     * @return {?}
     */
    function (info) {
        this.storedInfo = info;
        this.subject.next(info);
    };
    /**
     * @return {?}
     */
    OModulesInfoService$$1.prototype.getModuleInfo = /**
     * @return {?}
     */
    function () {
        return this.storedInfo;
    };
    /**
     * @return {?}
     */
    OModulesInfoService$$1.prototype.getModuleChangeObservable = /**
     * @return {?}
     */
    function () {
        return this.subject.asObservable();
    };
    OModulesInfoService$$1.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OModulesInfoService$$1.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OModulesInfoService$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTranslateHttpLoader = /** @class */ (function (_super) {
    __extends(OTranslateHttpLoader, _super);
    function OTranslateHttpLoader(httpClient, prefix, suffix, injector) {
        if (prefix === void 0) { prefix = OTranslateService$$1.ASSETS_PATH; }
        if (suffix === void 0) { suffix = OTranslateService$$1.ASSETS_EXTENSION; }
        var _this = _super.call(this, httpClient, prefix, suffix) || this;
        _this.injector = injector;
        _this.appConfig = _this.injector.get(AppConfig);
        _this.httpClient = httpClient;
        return _this;
    }
    /**
     * @return {?}
     */
    OTranslateHttpLoader.prototype.getAssetsPath = /**
     * @return {?}
     */
    function () {
        return this.prefix;
    };
    /**
     * @return {?}
     */
    OTranslateHttpLoader.prototype.getAssetsExtension = /**
     * @return {?}
     */
    function () {
        return this.suffix;
    };
    /**
     * @param {?} lang
     * @return {?}
     */
    OTranslateHttpLoader.prototype.getLocalTranslation = /**
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        /** @type {?} */
        var innerObserver;
        /** @type {?} */
        var dataObservable = new Observable(function (observer) { return innerObserver = observer; }).pipe(share());
        _super.prototype.getTranslation.call(this, lang)
            .subscribe(function (res) {
            innerObserver.next(res);
            innerObserver.complete();
        }, function (error) {
            innerObserver.next(undefined);
        }, function () { return innerObserver.complete(); });
        return dataObservable;
    };
    /**
     * @param {?} lang
     * @return {?}
     */
    OTranslateHttpLoader.prototype.getTranslation = /**
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        /** @type {?} */
        var translationOrigins = [];
        translationOrigins.push(this.getLocalTranslation(lang));
        if (this.appConfig.useRemoteBundle()) {
            translationOrigins.push(this.getRemoteBundle(lang));
        }
        /** @type {?} */
        var innerObserver;
        /** @type {?} */
        var dataObservable = new Observable(function (observer) { return innerObserver = observer; }).pipe(share());
        combineLatest.apply(void 0, translationOrigins).subscribe(function (res) {
            /** @type {?} */
            var staticBundle = res[0] || {};
            /** @type {?} */
            var remoteBundle = res[1] || {};
            /** @type {?} */
            var allBundles = Object.assign(staticBundle, remoteBundle);
            innerObserver.next(allBundles);
        });
        return dataObservable;
    };
    /**
     * @param {?} lang
     * @return {?}
     */
    OTranslateHttpLoader.prototype.getRemoteBundle = /**
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        var _this = this;
        /** @type {?} */
        var bundleEndpoint = this.appConfig.getBundleEndpoint();
        /** @type {?} */
        var innerObserver;
        /** @type {?} */
        var dataObservable = new Observable(function (observer) { return innerObserver = observer; }).pipe(share());
        if (!bundleEndpoint) {
            innerObserver.next([]);
        }
        /** @type {?} */
        var url = bundleEndpoint + '?lang=' + lang;
        this.httpClient.get(url).subscribe(function (resp) {
            /** @type {?} */
            var response = {};
            if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                response = _this.parseBundleResponse(resp.data);
            }
            innerObserver.next(response);
        }, function (error) {
            console.log('Remote Bundle service is not available');
            innerObserver.next(error);
        }, function () { return innerObserver.complete(); });
        return dataObservable;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OTranslateHttpLoader.prototype.parseBundleResponse = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var result = {};
        data.forEach(function (item) {
            result[item[OTranslateHttpLoader.BUNDLE_KEY]] = item[OTranslateHttpLoader.BUNDLE_VALUE];
        });
        return result;
    };
    OTranslateHttpLoader.BUNDLE_KEY = 'key';
    OTranslateHttpLoader.BUNDLE_VALUE = 'value';
    return OTranslateHttpLoader;
}(httpLoader.TranslateHttpLoader));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTranslateParser = /** @class */ (function (_super) {
    __extends(OTranslateParser, _super);
    function OTranslateParser() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.templateMatcher = /{\s?([0-9][^{}\s]*)\s?}/g;
        return _this;
    }
    /**
     * @param {?} expr
     * @param {?=} params
     * @return {?}
     */
    OTranslateParser.prototype.interpolate = /**
     * @param {?} expr
     * @param {?=} params
     * @return {?}
     */
    function (expr, params) {
        if (typeof expr !== 'string' || !params) {
            return expr;
        }
        return expr.replace(this.templateMatcher, function (substring, index) {
            /** @type {?} */
            var argValue = Util.isDefined(params[index]) ? params[index] : '';
            return !isNaN(parseInt(index)) ? argValue : substring;
        });
    };
    OTranslateParser.decorators = [
        { type: core.Injectable },
    ];
    return OTranslateParser;
}(core$1.TranslateDefaultParser));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var Error403Component = /** @class */ (function () {
    function Error403Component(injector) {
        this.injector = injector;
        this.router = this.injector.get(router.Router);
        this.navigationService = this.injector.get(NavigationService);
        this.lastPageData = this.navigationService.getLastItem();
    }
    /**
     * @return {?}
     */
    Error403Component.prototype.onNavigateBackClick = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var extras = {};
        /** @type {?} */
        var route = '';
        if (this.lastPageData) {
            extras[Codes.QUERY_PARAMS] = this.lastPageData.queryParams;
            route = this.lastPageData.url;
        }
        this.router.navigate([route], extras);
    };
    Error403Component.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-error-403',
                    template: "\n    <div fxFlex fxFlexFill fxLayout=\"column\" fxLayoutAlign=\"center center\">\n      {{ 'MESSAGES.ERROR_403_TEXT' | oTranslate }}\n      <button color=\"accent\" type=\"button\" mat-raised-button (click)=\"onNavigateBackClick()\">\n        {{ 'MESSAGES.ERROR_403_TEXT_BUTTON' | oTranslate }}\n      </button>\n    </div>\n  ",
                    styles: ["\n    .o-error-403{height:100%}.o-error-403 button{margin:16px}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-error-403]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    Error403Component.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return Error403Component;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ShareCanActivateChildService = /** @class */ (function () {
    function ShareCanActivateChildService(injector) {
        this.injector = injector;
        this.router = this.injector.get(router.Router);
        this.permissionsService = this.injector.get(PermissionsService);
    }
    /**
     * @param {?} guard
     * @return {?}
     */
    ShareCanActivateChildService.prototype.setPermissionsGuard = /**
     * @param {?} guard
     * @return {?}
     */
    function (guard) {
        this.permissionsGuard = guard;
    };
    /**
     * @param {?} childRoute
     * @param {?} state
     * @return {?}
     */
    ShareCanActivateChildService.prototype.canActivateChildUsingPermissions = /**
     * @param {?} childRoute
     * @param {?} state
     * @return {?}
     */
    function (childRoute, state$$1) {
        if (this.permissionsGuard) {
            return this.permissionsGuard.canActivateChild(childRoute, state$$1);
        }
        return true;
    };
    ShareCanActivateChildService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    ShareCanActivateChildService.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return ShareCanActivateChildService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var PermissionsGuardService = /** @class */ (function () {
    function PermissionsGuardService(injector) {
        this.injector = injector;
        this.router = this.injector.get(router.Router);
        this.permissionsService = this.injector.get(PermissionsService);
        this.snackBarService = this.injector.get(SnackBarService);
        this.shareCanActivateChildService = this.injector.get(ShareCanActivateChildService);
        this.shareCanActivateChildService.setPermissionsGuard(this);
    }
    /**
     * @param {?} childRoute
     * @param {?} state
     * @return {?}
     */
    PermissionsGuardService.prototype.canActivateChild = /**
     * @param {?} childRoute
     * @param {?} state
     * @return {?}
     */
    function (childRoute, state$$1) {
        /** @type {?} */
        var restricted = false;
        /** @type {?} */
        var oPermission = childRoute.data ? childRoute.data['oPermission'] : undefined;
        /** @type {?} */
        var permissionId = (oPermission || {})['permissionId'];
        if (Util.isDefined(permissionId)) {
            restricted = this.permissionsService.isPermissionIdRouteRestricted(permissionId);
            if (restricted) {
                /** @type {?} */
                var msg = 'MESSAGES.NAVIGATION_NOT_ALLOWED_PERMISSION';
                /** @type {?} */
                var route = oPermission['restrictedPermissionsRedirect'];
                if (Util.isDefined(route)) {
                    msg = 'MESSAGES.NAVIGATION_REDIRECTED_PERMISSION';
                    this.router.navigate([route]);
                }
                this.snackBarService.open(msg);
            }
        }
        return !restricted;
    };
    PermissionsGuardService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    PermissionsGuardService.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return PermissionsGuardService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var PermissionsServiceFactory = /** @class */ (function () {
    function PermissionsServiceFactory(injector) {
        this.injector = injector;
        this.config = this.injector.get(AppConfig).getConfiguration();
    }
    /**
     * @return {?}
     */
    PermissionsServiceFactory.prototype.factory = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var serviceType = this.config.permissionsServiceType;
        if (!Util.isDefined(serviceType) || 'OntimizePermissions' === serviceType) {
            return new OntimizePermissionsService$$1(this.injector);
        }
        else if ('OntimizeEEPermissions' === serviceType) {
            return new OntimizeEEPermissionsService$$1(this.injector);
        }
        else {
            /** @type {?} */
            var newInstance = Object.create((/** @type {?} */ (serviceType)).prototype);
            serviceType.apply(newInstance, new Array(this.injector));
            return newInstance;
        }
    };
    return PermissionsServiceFactory;
}());
/**
 * @param {?} injector
 * @return {?}
 */
function permissionsServiceFactory(injector) {
    return new PermissionsServiceFactory(injector).factory();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @param {?} injector
 * @return {?}
 */
function getPermissionsServiceProvider(injector) {
    return new PermissionsService(injector);
}
var 0$1$1 = permissionsServiceFactory;
var OPermissionsModule = /** @class */ (function () {
    function OPermissionsModule() {
    }
    OPermissionsModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [Error403Component],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [Error403Component],
                    entryComponents: [Error403Component],
                    providers: [{
                            provide: PermissionsGuardService,
                            useClass: PermissionsGuardService
                        }, {
                            provide: PermissionsService,
                            useFactory: getPermissionsServiceProvider,
                            deps: [core.Injector]
                        }, {
                            provide: OntimizePermissionsService$$1,
                            useFactory: 0$1$1,
                            deps: [core.Injector]
                        }]
                },] },
    ];
    return OPermissionsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ORemoteConfigurationService = /** @class */ (function () {
    function ORemoteConfigurationService(injector) {
        this.injector = injector;
        this._columns = {
            user: ORemoteConfigurationService.DEFAULT_COLUMN_USER,
            appId: ORemoteConfigurationService.DEFAULT_COLUMN_APPID,
            configuration: ORemoteConfigurationService.DEFAULT_COLUMN_CONFIG
        };
        this.httpClient = this.injector.get(http.HttpClient);
        this._appConfig = this.injector.get(AppConfig);
        this.loginService = this.injector.get(LoginService$$1);
        this.localStorageService = this.injector.get(LocalStorageService);
        this.httpClient = this.injector.get(http.HttpClient);
        this._uuid = this._appConfig.getConfiguration().uuid;
        if (this._appConfig.useRemoteConfiguration()) {
            this._url = this._appConfig.getRemoteConfigurationEndpoint();
            /** @type {?} */
            var remoteConfig = this._appConfig.getRemoteConfigurationConfig();
            this._columns = (remoteConfig && remoteConfig.columns) ? Object.assign(this._columns, remoteConfig.columns) : this._columns;
            this._timeout = (remoteConfig && remoteConfig.timeout) ? remoteConfig.timeout : ORemoteConfigurationService.DEFAULT_STORAGE_TIMEOUT;
            /** @type {?} */
            var self_1 = this;
            this.localStorageService.onSetLocalStorage.subscribe(function () {
                if (self_1.storeSubscription) {
                    self_1.storeSubscription.unsubscribe();
                }
            });
        }
    }
    /**
     * @return {?}
     */
    ORemoteConfigurationService.prototype.beforeunloadHandler = /**
     * @return {?}
     */
    function () {
        this.finalize().subscribe(function () {
            //
        });
    };
    /**
     * @return {?}
     */
    ORemoteConfigurationService.prototype.getUserConfiguration = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var observable$$1 = new Observable(function (observer) {
            /** @type {?} */
            var sessionInfo = self.loginService.getSessionInfo();
            if (!self.hasSession(sessionInfo)) {
                observer.error();
                return;
            }
            /** @type {?} */
            var url = self._url + '/search';
            /** @type {?} */
            var body = {};
            body[self._columns.user] = sessionInfo.user;
            body[self._columns.appId] = self._uuid;
            /** @type {?} */
            var options = {
                headers: self.buildHeaders()
            };
            self.httpClient.post(url, body, options).subscribe(function (resp) {
                if (resp && resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE && Util.isDefined(resp.data)) {
                    /** @type {?} */
                    var storedConf = void 0;
                    if (Util.isArray(resp.data)) {
                        storedConf = resp.data[0][self._columns.configuration];
                    }
                    else {
                        storedConf = resp.data;
                    }
                    if (Util.isDefined(storedConf)) {
                        /** @type {?} */
                        var componentsData = void 0;
                        try {
                            /** @type {?} */
                            var decoded = atob(storedConf);
                            componentsData = JSON.parse(decoded);
                        }
                        catch (e) {
                            componentsData = {};
                        }
                        self.localStorageService.storeSessionUserComponentsData(componentsData);
                    }
                    observer.next(resp);
                }
                else {
                    observer.error();
                }
            }, function (error) { return observer.error(error); }, function () { return observer.complete(); });
        });
        return observable$$1;
    };
    /**
     * @return {?}
     */
    ORemoteConfigurationService.prototype.storeUserConfiguration = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        if (self.storeSubscription) {
            self.storeSubscription.unsubscribe();
        }
        /** @type {?} */
        var observable$$1 = new Observable(function (observer) {
            /** @type {?} */
            var sessionInfo = self.loginService.getSessionInfo();
            if (!self._appConfig.useRemoteConfiguration() || !self.hasSession(sessionInfo)) {
                observer.next();
                observer.complete();
                return;
            }
            /** @type {?} */
            var url = self._url;
            /** @type {?} */
            var body = { filter: {}, data: {} };
            body.filter[self._columns.user] = sessionInfo.user;
            body.filter[self._columns.appId] = self._uuid;
            /** @type {?} */
            var userData = self.localStorageService.getSessionUserComponentsData() || {};
            try {
                userData = btoa(JSON.stringify(userData));
            }
            catch (e) {
                userData = '';
            }
            body.data[self._columns.configuration] = userData;
            /** @type {?} */
            var options = {
                headers: self.buildHeaders()
            };
            self.httpClient.put(url, body, options).subscribe(function (resp) {
                if (resp && resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                    observer.next(resp);
                }
                else {
                    observer.error();
                }
            }, function (error) { return observer.error(error); }, function () { return observer.complete(); });
        });
        return observable$$1;
    };
    /**
     * @return {?}
     */
    ORemoteConfigurationService.prototype.initialize = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        return new Observable(function (observer) {
            if (self._appConfig.useRemoteConfiguration()) {
                self.timerSubscription = timer(self._timeout, self._timeout).subscribe(function () {
                    self.storeSubscription = self.storeUserConfiguration().subscribe(function () {
                        //
                    });
                });
                self.getUserConfiguration().subscribe(function () {
                    observer.next();
                }, function () {
                    observer.next();
                });
            }
            else {
                observer.next();
            }
        });
    };
    /**
     * @return {?}
     */
    ORemoteConfigurationService.prototype.finalize = /**
     * @return {?}
     */
    function () {
        if (this.timerSubscription) {
            this.timerSubscription.unsubscribe();
        }
        return this.storeUserConfiguration();
    };
    /**
     * @param {?} sessionInfo
     * @return {?}
     */
    ORemoteConfigurationService.prototype.hasSession = /**
     * @param {?} sessionInfo
     * @return {?}
     */
    function (sessionInfo) {
        return Util.isDefined(sessionInfo) && Util.isDefined(sessionInfo.user) && Util.isDefined(sessionInfo.id);
    };
    /**
     * @return {?}
     */
    ORemoteConfigurationService.prototype.buildHeaders = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var sessionInfo = this.loginService.getSessionInfo();
        return new http.HttpHeaders({
            'Access-Control-Allow-Origin': '*',
            'Content-Type': 'application/json;charset=UTF-8',
            'Authorization': 'Bearer ' + sessionInfo.id
        });
    };
    ORemoteConfigurationService.DEFAULT_COLUMN_USER = 'USER_';
    ORemoteConfigurationService.DEFAULT_COLUMN_APPID = 'APP_UUID';
    ORemoteConfigurationService.DEFAULT_COLUMN_CONFIG = 'CONFIGURATION';
    ORemoteConfigurationService.DEFAULT_STORAGE_TIMEOUT = 60000;
    ORemoteConfigurationService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    ORemoteConfigurationService.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    ORemoteConfigurationService.propDecorators = {
        beforeunloadHandler: [{ type: core.HostListener, args: ['window:beforeunload', ['$event'],] }]
    };
    return ORemoteConfigurationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_BASE_MENU_ITEM = [
    'title',
    'tooltip',
    'icon',
    'attr'
];
var OBaseMenuItemClass = /** @class */ (function () {
    function OBaseMenuItemClass(menu, elRef, injector) {
        var _this = this;
        this.menu = menu;
        this.elRef = elRef;
        this.injector = injector;
        this._isHovered = false;
        this.onMouseover = function () { return _this.isHovered = true; };
        this.onMouseout = function () { return _this.isHovered = false; };
        this.translateService = this.injector.get(OTranslateService$$1);
    }
    /**
     * @return {?}
     */
    OBaseMenuItemClass.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.tooltip) {
            this.tooltip = this.title;
        }
        if (this.translateService) {
            this.onLanguageChangeSubscription = this.translateService.onLanguageChanged.subscribe(function () {
                _this.setDOMTitle();
            });
            this.setDOMTitle();
        }
        this.parsePermissions();
    };
    /**
     * @return {?}
     */
    OBaseMenuItemClass.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.onLanguageChangeSubscription) {
            this.onLanguageChangeSubscription.unsubscribe();
        }
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
        }
    };
    /**
     * @return {?}
     */
    OBaseMenuItemClass.prototype.setDOMTitle = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var tooltip = this.translateService.get(this.tooltip);
        this.elRef.nativeElement.setAttribute('title', tooltip);
    };
    /**
     * @return {?}
     */
    OBaseMenuItemClass.prototype.parsePermissions = /**
     * @return {?}
     */
    function () {
        // if oattr in form, it can have permissions
        this.permissions = this.menu.getPermissionsService().getMenuPermissions(this.attr);
        if (!Util.isDefined(this.permissions)) {
            return;
        }
        this.restricted = this.permissions.visible === false;
        this.disabled = this.permissions.enabled === false;
        if (this.disabled) {
            this.mutationObserver = PermissionsUtils.registerDisabledChangesInDom(this.elRef.nativeElement, {
                checkStringValue: true
            });
        }
    };
    Object.defineProperty(OBaseMenuItemClass.prototype, "isHovered", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isHovered;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (!this.disabled) {
                this._isHovered = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    OBaseMenuItemClass.DEFAULT_INPUTS_O_BASE_MENU_ITEM = DEFAULT_INPUTS_O_BASE_MENU_ITEM;
    OBaseMenuItemClass.propDecorators = {
        onMouseover: [{ type: core.HostListener, args: ['mouseover',] }],
        onMouseout: [{ type: core.HostListener, args: ['mouseout',] }]
    };
    return OBaseMenuItemClass;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_LOCALE_BAR_MENU_ITEM = OBaseMenuItemClass.DEFAULT_INPUTS_O_BASE_MENU_ITEM.concat([
    'locale'
]);
var OLocaleBarMenuItemComponent = /** @class */ (function (_super) {
    __extends(OLocaleBarMenuItemComponent, _super);
    function OLocaleBarMenuItemComponent(menu, elRef, injector) {
        var _this = _super.call(this, menu, elRef, injector) || this;
        _this.menu = menu;
        _this.elRef = elRef;
        _this.injector = injector;
        return _this;
    }
    /**
     * @return {?}
     */
    OLocaleBarMenuItemComponent.prototype.configureI18n = /**
     * @return {?}
     */
    function () {
        if (this.isConfiguredLang()) {
            return;
        }
        if (this.translateService) {
            this.translateService.use(this.locale);
        }
        if (this.menu) {
            this.menu.collapseAll();
        }
    };
    /**
     * @return {?}
     */
    OLocaleBarMenuItemComponent.prototype.isConfiguredLang = /**
     * @return {?}
     */
    function () {
        if (this.translateService) {
            return (this.translateService.getCurrentLang() === this.locale);
        }
        return false;
    };
    OLocaleBarMenuItemComponent.DEFAULT_INPUTS_O_LOCALE_BAR_MENU_ITEM = DEFAULT_INPUTS_O_LOCALE_BAR_MENU_ITEM;
    OLocaleBarMenuItemComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-locale-bar-menu-item',
                    template: "\n    <div class=\"fake-li mat-primary \" [class.fake-li-hover]=\"isHovered\" [class.is-selected]=\"isConfiguredLang()\">\n      <a fxLayout=\"row\" fxLayoutAlign=\"space-between center\" (click)=\"configureI18n()\" class=\"mat-list-item\">\n        <mat-icon *ngIf=\"icon !== undefined\" class=\"o-bar-menu-item-icon mat-24\">{{ icon }}</mat-icon>\n        <div fxFlex matLine class=\"o-bar-menu-item-title\">{{ title | oTranslate }}</div>\n        <mat-icon *ngIf=\"isConfiguredLang()\" class=\"o-bar-menu-item-icon configured-lang mat-24\" svgIcon=\"ontimize:check_circle\"></mat-icon>\n      </a>\n    </div>\n  ",
                    styles: ["\n    .o-bar-menu-item-icon.configured-lang{flex:0 1 auto;line-height:24px}\n  "],
                    inputs: DEFAULT_INPUTS_O_LOCALE_BAR_MENU_ITEM,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-locale-bar-menu-item]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OLocaleBarMenuItemComponent.ctorParameters = function () { return [
        { type: OBarMenuComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OBarMenuComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    return OLocaleBarMenuItemComponent;
}(OBaseMenuItemClass));
var OLocaleBarMenuItemModule = /** @class */ (function () {
    function OLocaleBarMenuItemModule() {
    }
    OLocaleBarMenuItemModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OLocaleBarMenuItemComponent],
                    imports: [OSharedModule, common.CommonModule, router.RouterModule],
                    exports: [OLocaleBarMenuItemComponent]
                },] },
    ];
    return OLocaleBarMenuItemModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_BAR_MENU_GROUP = OBaseMenuItemClass.DEFAULT_INPUTS_O_BASE_MENU_ITEM.slice();
var OBarMenuGroupComponent = /** @class */ (function (_super) {
    __extends(OBarMenuGroupComponent, _super);
    function OBarMenuGroupComponent(menu, elRef, injector) {
        var _this = _super.call(this, menu, elRef, injector) || this;
        _this.menu = menu;
        _this.elRef = elRef;
        _this.injector = injector;
        _this.id = 'm_' + String((new Date()).getTime() + Math.random());
        return _this;
    }
    OBarMenuGroupComponent.DEFAULT_INPUTS_O_BAR_MENU_GROUP = DEFAULT_INPUTS_O_BAR_MENU_GROUP;
    OBarMenuGroupComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-bar-menu-group',
                    template: "\n    <div class=\"fake-li\" [class.fake-li-hover]=\"isHovered\">\n      <label [attr.for]=\"id\" class=\"toggle mat-list-item\">\n        <mat-icon class=\"o-bar-menu-group-icon mat-24\">{{ icon }}</mat-icon>\n        {{ title | oTranslate }}\n        <mat-icon class=\"o-bar-menu-group-icon-arrow\" *ngIf=\"!checkbox.checked\">chevron_right</mat-icon>\n        <mat-icon class=\"o-bar-menu-group-icon-arrow\" *ngIf=\"checkbox.checked\">expand_more</mat-icon>\n      </label>\n      <a class=\"o-bar-menu-group-title\">\n        <mat-icon class=\"o-bar-menu-group-icon mat-24\">{{ icon }}</mat-icon> {{ title | oTranslate }}\n        <mat-icon class=\"o-bar-menu-group-icon-arrow\">chevron_right</mat-icon>\n      </a>\n      <input [attr.id]=\"id\" type=\"checkbox\" #checkbox />\n      <div *ngIf=\"!disabled\" class=\"fake-ul mat-primary mat-elevation-z4\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n  ",
                    styles: ["\n    .o-bar-menu-group[disabled=true] .fake-li{opacity:.5}.o-bar-menu-group[disabled=true] .fake-li a.o-bar-menu-group-title{cursor:default}.o-bar-menu-group .fake-li .o-bar-menu-group-icon,.o-bar-menu-group .fake-ul .o-bar-menu-group-icon{display:inline-block;margin:0 10px 0 0}.o-bar-menu-group .fake-li .o-bar-menu-group-icon ~ .o-bar-menu-group-title,.o-bar-menu-group .fake-ul .o-bar-menu-group-icon ~ .o-bar-menu-group-title{padding-left:0}.o-bar-menu-group .fake-li .o-bar-menu-group-icon-arrow,.o-bar-menu-group .fake-ul .o-bar-menu-group-icon-arrow{margin-left:auto}\n  "],
                    inputs: DEFAULT_INPUTS_O_BAR_MENU_GROUP,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-bar-menu-group]': 'true',
                        '[attr.disabled]': 'disabled'
                    }
                },] },
    ];
    /** @nocollapse */
    OBarMenuGroupComponent.ctorParameters = function () { return [
        { type: OBarMenuComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OBarMenuComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    return OBarMenuGroupComponent;
}(OBaseMenuItemClass));
var OBarMenuGroupModule = /** @class */ (function () {
    function OBarMenuGroupModule() {
    }
    OBarMenuGroupModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OBarMenuGroupComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OBarMenuGroupComponent]
                },] },
    ];
    return OBarMenuGroupModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_BAR_MENU_ITEM = OBaseMenuItemClass.DEFAULT_INPUTS_O_BASE_MENU_ITEM.concat([
    'route',
    'action'
]);
var OBarMenuItemComponent = /** @class */ (function (_super) {
    __extends(OBarMenuItemComponent, _super);
    function OBarMenuItemComponent(menu, elRef, injector) {
        var _this = _super.call(this, menu, elRef, injector) || this;
        _this.menu = menu;
        _this.elRef = elRef;
        _this.injector = injector;
        _this.router = _this.injector.get(router.Router);
        return _this;
    }
    /**
     * @return {?}
     */
    OBarMenuItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // if (typeof (this.route) === 'string') {
        //   // TODO, permisos por route?
        // } else {
        //   this.restricted = false;
        // }
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    OBarMenuItemComponent.prototype.collapseMenu = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        if (this.menu) {
            this.menu.collapseAll();
        }
    };
    /**
     * @return {?}
     */
    OBarMenuItemComponent.prototype.onClick = /**
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        if (Util.isDefined(this.route)) {
            this.router.navigate([this.route]);
        }
        else if (Util.isDefined(this.action)) {
            this.action();
        }
    };
    OBarMenuItemComponent.DEFAULT_INPUTS_O_BAR_MENU_ITEM = DEFAULT_INPUTS_O_BAR_MENU_ITEM;
    OBarMenuItemComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-bar-menu-item',
                    template: "\n    <div class=\"fake-li mat-primary\" *ngIf=\"!restricted\" (click)=\"collapseMenu($event)\" [class.fake-li-hover]=\"isHovered\">\n      <a *ngIf=\"action || route\" class=\"mat-list-item\" (click)=\"onClick()\">\n        <mat-icon class=\"o-bar-menu-item-icon mat-24\">{{ icon }}</mat-icon>\n        <div class=\"o-bar-menu-item-title\">{{ title | oTranslate }}</div>\n      </a>\n      <div *ngIf=\"!route && !action\" class=\"o-bar-menu-item-text mat-list-item\">\n        <mat-icon class=\"o-bar-menu-item-icon mat-24\">{{ icon }}</mat-icon>\n        <div class=\"o-bar-menu-item-title\">{{ title | oTranslate }}</div>\n      </div>\n    </div>\n  ",
                    styles: ["\n    .o-bar-menu-item[disabled=true] .fake-li{opacity:.5}.o-bar-menu-item[disabled=true] .fake-li a.mat-list-item{cursor:default}.o-bar-menu-item .o-bar-menu-item-text{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;box-sizing:border-box;font-size:16px;height:48px;padding:0 16px}.o-bar-menu-item .o-bar-menu-item-icon{display:inline-block;margin:6px 10px 0 0}.o-bar-menu-item .o-bar-menu-item-icon ~ .o-bar-menu-item-title{padding-left:0}.o-bar-menu-item .o-bar-menu-item-title{display:inline-block;position:relative;top:3px;padding-left:40px}\n  "],
                    inputs: DEFAULT_INPUTS_O_BAR_MENU_ITEM,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-bar-menu-item]': 'true',
                        '[attr.disabled]': 'disabled'
                    }
                },] },
    ];
    /** @nocollapse */
    OBarMenuItemComponent.ctorParameters = function () { return [
        { type: OBarMenuComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OBarMenuComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    return OBarMenuItemComponent;
}(OBaseMenuItemClass));
var OBarMenuItemModule = /** @class */ (function () {
    function OBarMenuItemModule() {
    }
    OBarMenuItemModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OBarMenuItemComponent],
                    imports: [OSharedModule, common.CommonModule, router.RouterModule],
                    exports: [OBarMenuItemComponent]
                },] },
    ];
    return OBarMenuItemModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_BAR_MENU_NESTED = [
    'items'
];
var OBarMenuNestedComponent = /** @class */ (function () {
    function OBarMenuNestedComponent(injector) {
        this.injector = injector;
        this.appMenuService = this.injector.get(AppMenuService);
    }
    /**
     * @param {?} menu
     * @param {?} attr
     * @return {?}
     */
    OBarMenuNestedComponent.prototype.getValueOfAttr = /**
     * @param {?} menu
     * @param {?} attr
     * @return {?}
     */
    function (menu, attr) {
        /** @type {?} */
        var valAttr = '';
        if (menu.hasOwnProperty(attr)) {
            valAttr = menu[attr];
        }
        return valAttr;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OBarMenuNestedComponent.prototype.isMenuGroup = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.appMenuService.getMenuItemType(item) === 'group';
    };
    OBarMenuNestedComponent.DEFAULT_INPUTS_O_BAR_MENU = DEFAULT_INPUTS_O_BAR_MENU_NESTED;
    OBarMenuNestedComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-bar-menu-nested',
                    template: "\n    <ng-container *ngFor=\"let item of items\">\n      <!--menu-group-->\n      <o-bar-menu-group *ngIf=\"isMenuGroup(item)\" [title]=\"getValueOfAttr(item, 'name')\" [attr]=\"getValueOfAttr(item,'id')\"\n        [tooltip]=\"getValueOfAttr(item, 'tooltip')\" [icon]=\"getValueOfAttr(item,'icon')\" [ngClass]=\"item.class\">\n        <o-bar-menu-nested [items]=\"item.items\"> </o-bar-menu-nested>\n      </o-bar-menu-group>\n      <!--menu-item-->\n      <o-bar-menu-item *ngIf=\"!isMenuGroup(item)\" [title]=\"getValueOfAttr(item,'name')\" [attr]=\"getValueOfAttr(item,'id')\"\n        [tooltip]=\"getValueOfAttr(item, 'tooltip') \" [icon]=\"getValueOfAttr(item, 'icon') \"\n        [route]=\"getValueOfAttr(item, 'route') \" [ngClass]=\"item.class\">\n      </o-bar-menu-item>\n    </ng-container>\n  ",
                    inputs: DEFAULT_INPUTS_O_BAR_MENU_NESTED,
                    encapsulation: core.ViewEncapsulation.None
                },] },
    ];
    /** @nocollapse */
    OBarMenuNestedComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OBarMenuNestedComponent;
}());
var OBarMenuNestedModule = /** @class */ (function () {
    function OBarMenuNestedModule() {
    }
    OBarMenuNestedModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OBarMenuNestedComponent],
                    imports: [common.CommonModule, OBarMenuGroupModule, OBarMenuItemModule],
                    exports: [OBarMenuNestedComponent]
                },] },
    ];
    return OBarMenuNestedModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OBarMenuSeparatorComponent = /** @class */ (function () {
    function OBarMenuSeparatorComponent() {
    }
    OBarMenuSeparatorComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-bar-menu-separator',
                    template: "\n    <div class=\"fake-li mat-primary separator\"></div>\n  ",
                    styles: ["\n    o-bar-menu-separator .fake-li.separator{border-bottom:2px solid #ccc}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-bar-menu-separator]': 'true'
                    }
                },] },
    ];
    return OBarMenuSeparatorComponent;
}());
var OBarMenuSeparatorModule = /** @class */ (function () {
    function OBarMenuSeparatorModule() {
    }
    OBarMenuSeparatorModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OBarMenuSeparatorComponent],
                    imports: [common.CommonModule],
                    exports: [OBarMenuSeparatorComponent]
                },] },
    ];
    return OBarMenuSeparatorModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_BAR_MENU = [
    'menuTitle: title',
    'tooltip',
];
var OBarMenuComponent = /** @class */ (function () {
    function OBarMenuComponent(elRef, injector) {
        this.elRef = elRef;
        this.injector = injector;
        this.id = 'm_' + String((new Date()).getTime() + Math.random());
        this.permissionsService = this.injector.get(PermissionsService);
        this.translateService = this.injector.get(OTranslateService$$1);
        this.appMenuService = this.injector.get(AppMenuService);
        this.menuRoots = this.appMenuService.getMenuRoots();
    }
    /**
     * @return {?}
     */
    OBarMenuComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.tooltip) {
            this.tooltip = this.menuTitle;
        }
        if (this.translateService) {
            this.translateService.onLanguageChanged.subscribe(function () {
                _this.setDOMTitle();
            });
            this.setDOMTitle();
        }
    };
    /**
     * @return {?}
     */
    OBarMenuComponent.prototype.setDOMTitle = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var tooltip = this.translateService.get(this.tooltip);
        this.elRef.nativeElement.setAttribute('title', tooltip);
    };
    /**
     * @return {?}
     */
    OBarMenuComponent.prototype.collapseAll = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var inputs = this.elRef.nativeElement.querySelectorAll('input');
        if (inputs) {
            inputs.forEach(function (element) {
                element.checked = false;
            });
        }
        /** @type {?} */
        var fakeLis = this.elRef.nativeElement.querySelectorAll('.fake-li-hover');
        if (fakeLis) {
            fakeLis.forEach(function (element) {
                element.classList.remove('fake-li-hover');
            });
        }
    };
    /**
     * @return {?}
     */
    OBarMenuComponent.prototype.getPermissionsService = /**
     * @return {?}
     */
    function () {
        return this.permissionsService;
    };
    Object.defineProperty(OBarMenuComponent.prototype, "menuTitle", {
        get: /**
         * @return {?}
         */
        function () {
            return this._menuTitle;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._menuTitle = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBarMenuComponent.prototype, "tooltip", {
        get: /**
         * @return {?}
         */
        function () {
            return this._tooltip;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._tooltip = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBarMenuComponent.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () {
            return this._id;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._id = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBarMenuComponent.prototype, "menuItems", {
        get: /**
         * @return {?}
         */
        function () {
            return this.menuRoots;
        },
        enumerable: true,
        configurable: true
    });
    OBarMenuComponent.DEFAULT_INPUTS_O_BAR_MENU = DEFAULT_INPUTS_O_BAR_MENU;
    OBarMenuComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-bar-menu',
                    template: "\n    <mat-toolbar color=\"primary\">\n      <nav>\n        <mat-icon class=\"mat-24 menu-icon toggle\" (click)=\"input.checked = !input.checked\" svgIcon=\"ontimize:menu\"></mat-icon>\n        <label [attr.for]=\"id\" class=\"toggle title-label\">{{ menuTitle | oTranslate }}</label>\n        <input #input [attr.id]=\"id\" type=\"checkbox\" />\n        <div class=\"fake-ul mat-primary menu\">\n          <ng-container>\n            <o-bar-menu-nested [items]=\"menuItems\"> </o-bar-menu-nested>\n          </ng-container>\n          <ng-content></ng-content>\n        </div>\n      </nav>\n    </mat-toolbar>\n  ",
                    styles: ["\n    .o-bar-menu .toggle,.o-bar-menu input{display:none}.o-bar-menu nav{margin:0;padding:0}.o-bar-menu nav:after{content:\"\";display:table;clear:both}.o-bar-menu nav .fake-li a{cursor:pointer}.o-bar-menu nav .fake-ul{float:right;padding:0;margin:0;list-style:none;position:relative}.o-bar-menu nav .fake-ul.menu>.o-bar-menu-item .o-bar-menu-item-title{top:0;padding-left:0}.o-bar-menu nav .fake-ul .fake-li{margin:0;display:inline-block}.o-bar-menu nav .fake-ul .fake-ul{display:none;position:absolute;top:60px}.o-bar-menu nav .fake-ul .fake-ul .fake-li{min-width:250px;width:250px;float:none;display:list-item;position:relative;white-space:nowrap}.o-bar-menu nav .fake-ul .fake-ul .fake-ul{top:0}.o-bar-menu nav .fake-ul .fake-ul .fake-ul .fake-li{position:relative;top:0;left:0}.o-bar-menu nav a{display:flex;align-items:center;padding:0 20px;font-size:20px;line-height:60px;text-decoration:none}.o-bar-menu .fake-li>a:only-child:after{content:''}@media all and (min-width: 768px){.o-bar-menu nav .fake-ul .fake-li-hover>.fake-ul{display:inline-block;z-index:1000}.o-bar-menu nav .fake-ul .fake-ul .fake-li-hover>.fake-ul{display:inline-block;z-index:1000;left:250px}}@media all and (max-width: 767px){.o-bar-menu .mat-toolbar{height:auto !important}.o-bar-menu nav{margin:10px 0;width:100%}.o-bar-menu nav .o-bar-menu-group,.o-bar-menu nav .o-bar-menu-item,.o-bar-menu nav .o-bar-menu-separator,.o-bar-menu nav .o-locale-bar-menu-item{display:flex}.o-bar-menu nav .o-bar-menu-group .mat-list-item,.o-bar-menu nav .o-bar-menu-item .mat-list-item,.o-bar-menu nav .o-bar-menu-separator .mat-list-item,.o-bar-menu nav .o-locale-bar-menu-item .mat-list-item{display:flex;justify-content:flex-start;align-items:center}.o-bar-menu nav .fake-ul{width:100%}.o-bar-menu nav .fake-ul .fake-li{width:100%}.o-bar-menu nav .fake-ul .fake-ul{float:none;position:static;width:100%}.o-bar-menu nav .fake-ul .fake-ul .fake-li{padding-left:20px;width:100%}.o-bar-menu nav .fake-ul .fake-ul .mat-elevation-z4{box-shadow:none}.o-bar-menu .toggle{display:inline-block;padding:0 20px;font-size:20px;line-height:60px;text-decoration:none;border:none;cursor:pointer}.o-bar-menu .toggle+a{display:none !important}.o-bar-menu .menu{display:none;float:left !important}.o-bar-menu label.title-label{display:inline-block}.o-bar-menu .mat-icon.menu-icon{vertical-align:middle;display:inline-block;line-height:1;padding:0 4px}.o-bar-menu input:checked+.fake-ul{display:block}}@media all and (max-width: 330px){.o-bar-menu nav .fake-ul .fake-li{width:94%}}\n  "],
                    inputs: DEFAULT_INPUTS_O_BAR_MENU,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-bar-menu]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OBarMenuComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    return OBarMenuComponent;
}());
var OBarMenuModule = /** @class */ (function () {
    function OBarMenuModule() {
    }
    OBarMenuModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OBarMenuComponent],
                    imports: [
                        common.CommonModule,
                        OSharedModule,
                        OBarMenuGroupModule,
                        OBarMenuItemModule,
                        OLocaleBarMenuItemModule,
                        OBarMenuSeparatorModule,
                        OBarMenuNestedModule
                    ],
                    exports: [OBarMenuComponent]
                },] },
    ];
    return OBarMenuModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_BREADCRUMB$$1 = [
    '_formRef: form',
    'labelColumns: label-columns',
    'separator'
];
var OBreadcrumbComponent$$1 = /** @class */ (function () {
    function OBreadcrumbComponent$$1(injector) {
        this.injector = injector;
        this.separator = ' ';
        this.labelColsArray = [];
        this._displayTextloaded = false;
        this.router = this.injector.get(router.Router);
        this.navigationService = this.injector.get(NavigationService);
    }
    /**
     * @return {?}
     */
    OBreadcrumbComponent$$1.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        this.labelColsArray = Util.parseArray(this.labelColumns);
        if (this.navigationService && this.navigationService.navigationEvents$) {
            this.navigationServiceSubscription = this.navigationService.navigationEvents$.subscribe(function (e) {
                // setting loaded to false if the breadcrumb is inside a form (and later it will find its displayText)
                self.displayTextloaded = !(self._formRef && self.labelColsArray.length);
                self.breadcrumbs = e;
            });
        }
    };
    /**
     * @return {?}
     */
    OBreadcrumbComponent$$1.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this._formRef && this.labelColsArray.length) {
            /** @type {?} */
            var self_1 = this;
            this.onDataLoadedSubscription = this._formRef.onDataLoaded.subscribe(function (value) {
                if (self_1.breadcrumbs.length) {
                    /** @type {?} */
                    var displayText = self_1.labelColsArray.map(function (element) { return value[element]; }).join(self_1.separator);
                    self_1.breadcrumbs[self_1.breadcrumbs.length - 1].displayText = displayText;
                    self_1.displayTextloaded = true;
                }
            });
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OBreadcrumbComponent$$1.prototype.showBreadcrumbItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.displayTextloaded && item.terminal;
    };
    /**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    OBreadcrumbComponent$$1.prototype.isNotInsideFormLayoutManager = /**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    function (item, index) {
        /** @type {?} */
        var previousItem = this.breadcrumbs[index - 1];
        return (previousItem && previousItem.isMainFormLayoutManagerComponent());
    };
    /**
     * @param {?} route
     * @return {?}
     */
    OBreadcrumbComponent$$1.prototype.isTerminal = /**
     * @param {?} route
     * @return {?}
     */
    function (route) {
        return route.firstChild === null || route.firstChild.routeConfig === null;
    };
    /**
     * @return {?}
     */
    OBreadcrumbComponent$$1.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.onDataLoadedSubscription) {
            this.onDataLoadedSubscription.unsubscribe();
        }
        if (this.navigationServiceSubscription) {
            this.navigationServiceSubscription.unsubscribe();
        }
    };
    /**
     * @param {?} route
     * @return {?}
     */
    OBreadcrumbComponent$$1.prototype.onRouteClick = /**
     * @param {?} route
     * @return {?}
     */
    function (route) {
        /** @type {?} */
        var extras = {};
        if (route.queryParams) {
            extras[Codes.QUERY_PARAMS] = route.queryParams;
        }
        this.router.navigate([route.url], extras);
    };
    Object.defineProperty(OBreadcrumbComponent$$1.prototype, "displayTextloaded", {
        get: /**
         * @return {?}
         */
        function () {
            return this._displayTextloaded;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._displayTextloaded = arg;
        },
        enumerable: true,
        configurable: true
    });
    OBreadcrumbComponent$$1.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-breadcrumb',
                    template: "\n    <mat-toolbar class=\"toolbar-breadcrumb\">\n      <ng-template ngFor let-route let-i=\"index\" [ngForOf]=\"breadcrumbs\">\n        <ng-container *ngIf=\"!isNotInsideFormLayoutManager(route, i)\">\n          <a *ngIf=\"!route.terminal\" class=\"breadcrumb-item\" (click)=\"onRouteClick(route)\" layout-padding>\n            {{ route.displayText ? route.displayText : route.text | uppercase | oTranslate }}\n          </a>\n          <span *ngIf=\"showBreadcrumbItem(route)\" class=\"breadcrumb-item active\" layout-padding>\n            {{ route.displayText ? route.displayText : route.text | uppercase | oTranslate }}\n          </span>\n          <mat-icon *ngIf=\"!route.terminal\" svgIcon=\"ontimize:keyboard_arrow_right\"></mat-icon>\n        </ng-container>\n      </ng-template>\n    </mat-toolbar>\n  ",
                    styles: ["\n    .o-breadcrumb{display:flex;height:50px;min-height:50px;padding-bottom:8px}.o-breadcrumb .mat-toolbar{box-shadow:2px 2px 6px rgba(0,0,0,0.24);background:#ffffff;border-radius:6px;min-height:50px;max-height:50px}.o-breadcrumb .mat-toolbar .mat-toolbar-row{height:50px}.o-breadcrumb .mat-toolbar a{text-decoration:none;cursor:pointer}.o-breadcrumb .mat-toolbar span{cursor:default}.o-breadcrumb .mat-toolbar a,.o-breadcrumb .mat-toolbar span{padding-top:0;padding-bottom:0}\n  "],
                    inputs: DEFAULT_INPUTS_O_BREADCRUMB$$1,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-breadcrumb]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OBreadcrumbComponent$$1.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OBreadcrumbComponent$$1;
}());
var OBreadcrumbModule$$1 = /** @class */ (function () {
    function OBreadcrumbModule$$1() {
    }
    OBreadcrumbModule$$1.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule, OSharedModule, router.RouterModule],
                    exports: [OBreadcrumbComponent$$1],
                    declarations: [OBreadcrumbComponent$$1]
                },] },
    ];
    return OBreadcrumbModule$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_BUTTON = [
    'oattr: attr',
    'olabel: label',
    'otype: type',
    'icon',
    'svgIcon : svg-icon',
    'iconPosition: icon-position',
    'image'
];
var OButtonComponent = /** @class */ (function () {
    function OButtonComponent() {
        this.otype = OButtonComponent.DEFAULT_TYPE;
    }
    /**
     * @return {?}
     */
    OButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.otype) {
            this.otype = this.otype.toUpperCase();
        }
    };
    Object.defineProperty(OButtonComponent.prototype, "needsIconButtonClass", {
        get: /**
         * @return {?}
         */
        function () {
            return this.icon !== undefined && (this.olabel === undefined || this.olabel === '');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OButtonComponent.prototype.isFab = /**
     * @return {?}
     */
    function () {
        return this.otype === 'FAB';
    };
    /**
     * @return {?}
     */
    OButtonComponent.prototype.isRaised = /**
     * @return {?}
     */
    function () {
        return this.otype === 'RAISED';
    };
    /**
     * @return {?}
     */
    OButtonComponent.prototype.isFlat = /**
     * @return {?}
     */
    function () {
        return this.otype === 'FLAT';
    };
    /**
     * @return {?}
     */
    OButtonComponent.prototype.isStroked = /**
     * @return {?}
     */
    function () {
        return (this.otype === 'STROKED' || !this.otype);
    };
    /**
     * @return {?}
     */
    OButtonComponent.prototype.isBasic = /**
     * @return {?}
     */
    function () {
        return this.otype === 'BASIC';
    };
    /**
     * @return {?}
     */
    OButtonComponent.prototype.isMiniFab = /**
     * @return {?}
     */
    function () {
        return this.otype === 'FAB-MINI';
    };
    /**
     * @return {?}
     */
    OButtonComponent.prototype.isIconButton = /**
     * @return {?}
     */
    function () {
        return this.otype === 'ICON';
    };
    OButtonComponent.DEFAULT_INPUTS_O_BUTTON = DEFAULT_INPUTS_O_BUTTON;
    OButtonComponent.DEFAULT_TYPE = 'STROKED';
    OButtonComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-button',
                    inputs: DEFAULT_INPUTS_O_BUTTON,
                    template: "\n    <button type=\"button\" *ngIf=\"isBasic()\" mat-button [class.mat-icon-button]=\"needsIconButtonClass\">\n      <img src=\"{{ image }}\" class=\"o-button-image\" *ngIf=\"image!=undefined\" />\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"icon!==undefined\" style=\"vertical-align:middle\">{{ icon }}\n      </mat-icon>\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"svgIcon!==undefined\" style=\"vertical-align:middle\"\n        [svgIcon]=\"svgIcon\"></mat-icon>\n      <br *ngIf=\"iconPosition==='top'\" />\n      {{ olabel | oTranslate }}\n    </button>\n\n    <button type=\"button\" *ngIf=\"isRaised()\" mat-raised-button class=\"mat-raised-button\"\n      [class.mat-icon-button]=\"needsIconButtonClass\">\n      <img src=\"{{ image }}\" class=\"o-button-image\" *ngIf=\"image!=undefined\" />\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"icon!==undefined\" style=\"vertical-align:middle\">{{ icon }}\n      </mat-icon>\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"svgIcon!==undefined\" style=\"vertical-align:middle\"\n      [svgIcon]=\"svgIcon\"></mat-icon>\n      <br *ngIf=\"iconPosition==='top'\" />\n      {{ olabel | oTranslate }}\n    </button>\n\n    <button type=\"button\" *ngIf=\"isStroked()\" mat-stroked-button [class.mat-icon-button]=\"needsIconButtonClass\">\n      <img src=\"{{ image }}\" class=\"o-button-image\" *ngIf=\"image!=undefined\" />\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"icon!==undefined\" style=\"vertical-align:middle\">{{ icon }}\n      </mat-icon>\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"svgIcon!==undefined\" style=\"vertical-align:middle\"\n      [svgIcon]=\"svgIcon\"></mat-icon>\n      <br *ngIf=\"iconPosition==='top'\" />\n      {{ olabel | oTranslate }}\n    </button>\n\n    <button type=\"button\" *ngIf=\"isFlat()\" mat-flat-button [class.mat-icon-button]=\"needsIconButtonClass\">\n      <img src=\"{{ image }}\" class=\"o-button-image\" *ngIf=\"image!=undefined\" />\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"icon!==undefined\" style=\"vertical-align:middle\">{{ icon }}\n      </mat-icon>\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"svgIcon!==undefined\" style=\"vertical-align:middle\"\n      [svgIcon]=\"svgIcon\"></mat-icon>\n      <br *ngIf=\"iconPosition==='top'\" />\n      {{ olabel | oTranslate }}\n    </button>\n\n    <button type=\"button\" *ngIf=\"isIconButton()\" mat-icon-button [class.mat-icon-button]=\"needsIconButtonClass\">\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"icon!==undefined\" style=\"vertical-align:middle\">{{ icon }}\n      </mat-icon>\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"svgIcon!==undefined\" style=\"vertical-align:middle\"\n      [svgIcon]=\"svgIcon\"></mat-icon>\n    </button>\n\n    <button type=\"button\" *ngIf=\"isFab()\" mat-fab>\n      <img src=\"{{ image }}\" class=\"o-button-image\" *ngIf=\"image!=undefined\" />\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"icon!==undefined\" style=\"vertical-align:middle\">{{ icon }}\n      </mat-icon>\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"svgIcon!==undefined\" style=\"vertical-align:middle\"\n      [svgIcon]=\"svgIcon\"></mat-icon>\n      <br *ngIf=\"iconPosition==='top'\" />\n      {{ olabel | oTranslate }}\n    </button>\n\n    <button type=\"button\" *ngIf=\"isMiniFab()\" mat-mini-fab>\n      <img src=\"{{ image }}\" class=\"o-button-image\" *ngIf=\"image!=undefined\" />\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"icon!==undefined\" style=\"vertical-align:middle\">{{ icon }}\n      </mat-icon>\n      <mat-icon class=\"material-icons o-button-icon\" *ngIf=\"svgIcon!==undefined\" style=\"vertical-align:middle\"\n      [svgIcon]=\"svgIcon\"></mat-icon>\n      <br *ngIf=\"iconPosition==='top'\" />\n      {{ olabel | oTranslate }}\n    </button>\n  ",
                    styles: ["\n    .o-button{display:inline-block}.o-button .mat-icon-button .mat-button-ripple.mat-ripple{border-radius:50%}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-button]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OButtonComponent.ctorParameters = function () { return []; };
    return OButtonComponent;
}());
var OButtonModule = /** @class */ (function () {
    function OButtonModule() {
    }
    OButtonModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OButtonComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OButtonComponent]
                },] },
    ];
    return OButtonModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_BUTTON_TOGGLE = [
    'oattr: attr',
    'label',
    'icon',
    'iconPosition: icon-position',
    'checked',
    'enabled',
    'value',
    'name'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_BUTTON_TOGGLE = [
    'onChange'
];
var OButtonToggleComponent = /** @class */ (function () {
    function OButtonToggleComponent(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
        this.DEFAULT_INPUTS_O_BUTTON_TOGGLE = DEFAULT_INPUTS_O_BUTTON_TOGGLE;
        this.DEFAULT_OUTPUTS_O_BUTTON_TOGGLE = DEFAULT_OUTPUTS_O_BUTTON_TOGGLE;
        this.iconPosition = 'before';
        this._checked = false;
        this._enabled = true;
        this.onChange = new core.EventEmitter();
    }
    Object.defineProperty(OButtonToggleComponent.prototype, "checked", {
        get: /**
         * @return {?}
         */
        function () {
            return this._innerButtonToggle.checked;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            val = Util.parseBoolean(String(val));
            this._innerButtonToggle.checked = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OButtonToggleComponent.prototype, "enabled", {
        get: /**
         * @return {?}
         */
        function () {
            return !this._innerButtonToggle.disabled;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            val = Util.parseBoolean(String(val));
            this._innerButtonToggle.disabled = !val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OButtonToggleComponent.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._innerButtonToggle.value;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._innerButtonToggle.value = val;
        },
        enumerable: true,
        configurable: true
    });
    OButtonToggleComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-button-toggle',
                    template: "\n    <mat-button-toggle #bt [id]=\"oattr\" [name]=\"name\" [checked]=\"checked\" [disabled]=\"!enabled\" [value]=\"value\" (change)=\"onChange.emit($event)\">\n      <mat-icon *ngIf=\"icon && iconPosition==='before'\">{{ icon }}</mat-icon>\n      {{ label }}\n      <mat-icon *ngIf=\"icon && iconPosition==='after'\">{{ icon }}</mat-icon>\n    </mat-button-toggle>\n  ",
                    styles: ["\n    .o-button-toggle{display:inline-block}.o-button-toggle .mat-button-toggle{display:flex}\n  "],
                    inputs: DEFAULT_INPUTS_O_BUTTON_TOGGLE,
                    outputs: DEFAULT_OUTPUTS_O_BUTTON_TOGGLE,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-button-toggle]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OButtonToggleComponent.ctorParameters = function () { return [
        { type: core.ViewContainerRef }
    ]; };
    OButtonToggleComponent.propDecorators = {
        _innerButtonToggle: [{ type: core.ViewChild, args: ['bt',] }]
    };
    return OButtonToggleComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function StringConverter(value) {
    if (value === null || value === undefined || typeof value === 'string') {
        return value;
    }
    return value.toString();
}
/**
 * @param {?} value
 * @return {?}
 */
function BooleanConverter(value) {
    if (value === null || value === undefined || typeof value === 'boolean') {
        return value;
    }
    return value.toString() === 'true' || value.toString() === 'yes';
}
/**
 * @param {?} value
 * @return {?}
 */
function NumberConverter(value) {
    if (value === null || value === undefined || typeof value === 'number') {
        return value;
    }
    return parseFloat(value.toString());
}
/**
 * @param {?=} converter
 * @return {?}
 */
function InputConverter(converter) {
    /**
     * @param {?} target
     * @param {?} key
     * @return {?}
     */
    function InputConverterInner(target, key) {
        if (converter === undefined) {
            /** @type {?} */
            var metadata = (/** @type {?} */ (Reflect)).getMetadata('design:type', target, key);
            if (metadata === undefined || metadata === null) {
                throw new Error('The reflection metadata could not be found.');
            }
            if (metadata.name === 'String') {
                converter = StringConverter;
            }
            else if (metadata.name === 'Boolean') {
                converter = BooleanConverter;
            }
            else if (metadata.name === 'Number') {
                converter = NumberConverter;
            }
            else {
                throw new Error('There is no converter for the given property type "' + metadata.name + '".');
            }
        }
        /** @type {?} */
        var definition = Object.getOwnPropertyDescriptor(target, key);
        if (definition) {
            Object.defineProperty(target, key, {
                get: definition.get,
                set: function (newValue) {
                    definition.set(converter(newValue));
                },
                enumerable: true,
                configurable: true
            });
        }
        else {
            Object.defineProperty(target, key, {
                get: function () {
                    return this['__' + key];
                },
                set: function (newValue) {
                    this['__' + key] = converter(newValue);
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    return InputConverterInner;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @param {?} newCompAnnotations
 * @return {?}
 */
function OComponent(newCompAnnotations) {
    /**
     * @param {?} target
     * @return {?}
     */
    function OComponentInner(target) {
        /** @type {?} */
        var parentTarget = Object.getPrototypeOf(target.prototype).constructor;
        /** @type {?} */
        var parentAnnotations = Reflect.getMetadata('annotations', parentTarget);
        if (parentAnnotations) {
            /** @type {?} */
            var parentAnnotation = parentAnnotations[0];
            copyDecorators(newCompAnnotations, parentAnnotation);
        }
        else if (parentTarget.hasOwnProperty('decorators')) {
            /** @type {?} */
            var parentDecorators = getDecorators(parentTarget);
            copyDecorators(newCompAnnotations, parentDecorators);
        }
        /** @type {?} */
        var metadata = new core.Component(newCompAnnotations);
        Reflect.defineMetadata('annotations', [metadata], target);
    }
    return OComponentInner;
}
/**
 * @param {?} obj
 * @return {?}
 */
function isPresent$1(obj) {
    return obj !== undefined && obj !== null;
}
/**
 * @param {?} target
 * @return {?}
 */
function getDecorators(target) {
    /** @type {?} */
    var decoratorsObj = undefined;
    /** @type {?} */
    var decorators = target.decorators[0];
    if (decorators && decorators.args && decorators.args[0]) {
        decoratorsObj = decorators.args[0];
    }
    return decoratorsObj;
}
/**
 * @param {?} newComp
 * @param {?} parent
 * @return {?}
 */
function copyDecorators(newComp, parent) {
    var _this = this;
    Object.keys(parent).forEach(function (key) {
        if (isPresent$1(parent[key])) {
            if (!isPresent$1(newComp[key])) {
                if (typeof newComp[key] === 'function') {
                    newComp[key] = newComp[key].call(_this, parent[key]);
                }
                else {
                    newComp[key] = parent[key];
                }
            }
        }
        if (!isPresent$1(newComp[key])) {
            newComp[key] = parent[key];
        }
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_BUTTON_TOGGLE_GROUP = [
    'oattr: attr',
    'name',
    'enabled',
    'layout',
    'multiple',
    'value'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_BUTTON_TOGGLE_GROUP = [
    'onChange'
];
var OButtonToggleGroupComponent = /** @class */ (function () {
    function OButtonToggleGroupComponent(resolver) {
        this.resolver = resolver;
        this.DEFAULT_INPUTS_O_BUTTON_TOGGLE_GROUP = DEFAULT_INPUTS_O_BUTTON_TOGGLE_GROUP;
        this.DEFAULT_OUTPUTS_O_BUTTON_TOGGLE_GROUP = DEFAULT_OUTPUTS_O_BUTTON_TOGGLE_GROUP;
        this._enabled = true;
        this.layout = 'row';
        this.multiple = false;
        this.onChange = new core.EventEmitter();
    }
    Object.defineProperty(OButtonToggleGroupComponent.prototype, "enabled", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._innerButtonToggleGroup instanceof material.MatButtonToggleGroup) {
                return !this._innerButtonToggleGroup.disabled;
            }
            return true;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (this._innerButtonToggleGroup instanceof material.MatButtonToggleGroup) {
                val = Util.parseBoolean(String(val));
                this._innerButtonToggleGroup.disabled = !val;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OButtonToggleGroupComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!Util.isDefined(this.name)) {
            this.name = this.oattr;
        }
    };
    /**
     * @return {?}
     */
    OButtonToggleGroupComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.buildChildren();
        this._children.changes.subscribe(function () { return _this.buildChildren(); });
    };
    /**
     * @return {?}
     */
    OButtonToggleGroupComponent.prototype.buildChildren = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var factory = this.resolver.resolveComponentFactory(OButtonToggleComponent);
        this._viewContainerRef.clear();
        /** @type {?} */
        var childList = this._children.map(function (child) {
            /** @type {?} */
            var componentRef = _this._viewContainerRef.createComponent(factory);
            componentRef.instance.oattr = child.oattr;
            componentRef.instance.label = child.label;
            componentRef.instance.icon = child.icon;
            componentRef.instance.iconPosition = child.iconPosition;
            componentRef.instance.checked = child.checked;
            componentRef.instance.enabled = child.enabled;
            componentRef.instance.value = child.value;
            componentRef.instance.name = _this.name;
            componentRef.instance.onChange = child.onChange;
            componentRef.changeDetectorRef.detectChanges();
            return componentRef.instance;
        });
        this._innerButtonToggleGroup._buttonToggles.reset(childList.map(function (c) { return c._innerButtonToggle; }));
        this._children.reset(childList);
    };
    /**
     * @return {?}
     */
    OButtonToggleGroupComponent.prototype.getValue = /**
     * @return {?}
     */
    function () {
        return this._innerButtonToggleGroup ? this._innerButtonToggleGroup.value : void 0;
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OButtonToggleGroupComponent.prototype.setValue = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        this._innerButtonToggleGroup.value = val;
    };
    OButtonToggleGroupComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-button-toggle-group',
                    template: "\n    <mat-button-toggle-group [disabled]=\"!enabled\" [name]=\"name\" [value]=\"value\" [vertical]=\"layout==='column'\" [multiple]=\"multiple\"\n      (change)=\"onChange.emit($event)\">\n      <ng-container #childContainer></ng-container>\n    </mat-button-toggle-group>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_BUTTON_TOGGLE_GROUP,
                    outputs: DEFAULT_OUTPUTS_O_BUTTON_TOGGLE_GROUP,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-button-toggle-group]': 'true'
                    },
                    entryComponents: [OButtonToggleComponent]
                },] },
    ];
    /** @nocollapse */
    OButtonToggleGroupComponent.ctorParameters = function () { return [
        { type: core.ComponentFactoryResolver }
    ]; };
    OButtonToggleGroupComponent.propDecorators = {
        _innerButtonToggleGroup: [{ type: core.ViewChild, args: [material.MatButtonToggleGroup,] }],
        _viewContainerRef: [{ type: core.ViewChild, args: ['childContainer', { read: core.ViewContainerRef },] }],
        _children: [{ type: core.ContentChildren, args: [core.forwardRef(function () { return OButtonToggleComponent; }),] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OButtonToggleGroupComponent.prototype, "multiple", void 0);
    return OButtonToggleGroupComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OButtonToggleModule = /** @class */ (function () {
    function OButtonToggleModule() {
    }
    OButtonToggleModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [
                        OButtonToggleComponent,
                        OButtonToggleGroupComponent
                    ],
                    imports: [
                        common.CommonModule,
                        OSharedModule
                    ],
                    exports: [
                        OButtonToggleComponent,
                        OButtonToggleGroupComponent
                    ]
                },] },
    ];
    return OButtonToggleModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OFormControl = /** @class */ (function (_super) {
    __extends(OFormControl, _super);
    function OFormControl(formState, validatorOrOpts, asyncValidator) {
        if (formState === void 0) { formState = null; }
        return _super.call(this, formState, validatorOrOpts, asyncValidator) || this;
    }
    /**
     * @param {?=} opts
     * @return {?}
     */
    OFormControl.prototype.markAsTouched = /**
     * @param {?=} opts
     * @return {?}
     */
    function (opts) {
        if (opts === void 0) { opts = {}; }
        _super.prototype.markAsTouched.call(this, opts);
        if (!this.fControlChildren) {
            return;
        }
        this.fControlChildren.forEach(function (x) {
            if (x instanceof forms.FormControl) {
                x.markAsTouched(opts);
            }
            else {
                if (x.getFormControl()) {
                    x.getFormControl().markAsTouched();
                }
            }
        });
    };
    /**
     * @param {?=} opts
     * @return {?}
     */
    OFormControl.prototype.markAsDirty = /**
     * @param {?=} opts
     * @return {?}
     */
    function (opts) {
        if (opts === void 0) { opts = {}; }
        _super.prototype.markAsDirty.call(this, opts);
        if (!this.fControlChildren) {
            return;
        }
        this.fControlChildren.forEach(function (x) {
            if (x instanceof forms.FormControl) {
                x.markAsDirty(opts);
            }
            else {
                if (x.getFormControl()) {
                    x.getFormControl().markAsDirty();
                }
            }
        });
    };
    /**
     * @param {?=} opts
     * @return {?}
     */
    OFormControl.prototype.markAsPristine = /**
     * @param {?=} opts
     * @return {?}
     */
    function (opts) {
        if (opts === void 0) { opts = {}; }
        _super.prototype.markAsPristine.call(this, opts);
        if (!this.fControlChildren) {
            return;
        }
        this.fControlChildren.forEach(function (x) {
            if (x instanceof forms.FormControl) {
                x.markAsPristine(opts);
            }
            else {
                if (x.getFormControl()) {
                    x.getFormControl().markAsPristine();
                }
            }
        });
    };
    /**
     * @return {?}
     */
    OFormControl.prototype.getValue = /**
     * @return {?}
     */
    function () {
        return this.value;
    };
    return OFormControl;
}(forms.FormControl));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OFormCacheClass = /** @class */ (function () {
    function OFormCacheClass(form) {
        this.form = form;
        this.initialDataCache = {};
        this.valueChangesStack = [];
        this._componentsSubscritpions = {};
        this.blockCaching = false;
        this.initializedCache = false;
        this.onCacheEmptyStateChanges = new core.EventEmitter();
        this.onCacheStateChanges = new core.EventEmitter();
        this.changedFormControls = [];
    }
    /**
     * @return {?}
     */
    OFormCacheClass.prototype.updateFormDataCache = /**
     * @return {?}
     */
    function () {
        this.formDataCache = this.form.getRegisteredFieldsValues();
    };
    /**
     * @param {?} comp
     * @return {?}
     */
    OFormCacheClass.prototype.addChangeToStack = /**
     * @param {?} comp
     * @return {?}
     */
    function (comp) {
        /** @type {?} */
        var currentValue = comp.getFormControl().value;
        /** @type {?} */
        var wasEmpty = this.valueChangesStack.length === 0;
        this.valueChangesStack.push({
            attr: comp.getAttribute(),
            value: currentValue
        });
        if (wasEmpty) {
            this.onCacheEmptyStateChanges.emit(false);
        }
        this.onCacheStateChanges.emit();
    };
    /**
     * @param {?} comp
     * @return {?}
     */
    OFormCacheClass.prototype.registerComponentCaching = /**
     * @param {?} comp
     * @return {?}
     */
    function (comp) {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var attr = comp.getAttribute();
        /** @type {?} */
        var listenTo = this.form.detectChangesOnBlur ? comp.onValueChange : comp.onChange;
        if (!Util.isDefined(listenTo)) {
            return;
        }
        this._componentsSubscritpions[attr] = listenTo.subscribe(function () {
            if (self.initializedCache && !self.blockCaching && self.hasComponentChanged(attr, comp)) {
                if (self.changedFormControls.indexOf(attr) === -1) {
                    self.changedFormControls.push(attr);
                }
                self.updateFormDataCache();
                self.addChangeToStack(comp);
            }
        });
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OFormCacheClass.prototype.getCachedValue = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        if (this.formDataCache && this.formDataCache.hasOwnProperty(attr)) {
            return this.formDataCache[attr];
        }
        return undefined;
    };
    /**
     * @return {?}
     */
    OFormCacheClass.prototype.destroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        Object.keys(this._componentsSubscritpions).forEach(function (attr) {
            /** @type {?} */
            var subs = _this._componentsSubscritpions[attr];
            subs.unsubscribe();
        });
        this._componentsSubscritpions = {};
        this.formDataCache = undefined;
        this.changedFormControls = [];
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    OFormCacheClass.prototype.removeUndefinedProperties = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        Object.keys(arg).forEach(function (key) {
            if (arg[key] === undefined) {
                delete arg[key];
            }
        });
        return arg;
    };
    /**
     * @return {?}
     */
    OFormCacheClass.prototype.registerCache = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var initialCache = this.form.getRegisteredFieldsValues();
        this.removeUndefinedProperties(initialCache);
        this.initializeCache(initialCache);
        this.formDataCache = initialCache;
        /** @type {?} */
        var components = this.form.getComponents();
        /** @type {?} */
        var self = this;
        Object.keys(components).forEach(function (attr) {
            /** @type {?} */
            var comp = components[attr];
            if (comp.isAutomaticRegistering()) {
                self.registerComponentCaching(comp);
            }
        });
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OFormCacheClass.prototype.initializeCache = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        this.initialDataCache = val;
        this.valueChangesStack = [];
        this.onCacheEmptyStateChanges.emit(true);
        this.initializedCache = true;
        this.changedFormControls = [];
    };
    /**
     * @return {?}
     */
    OFormCacheClass.prototype.getInitialDataCache = /**
     * @return {?}
     */
    function () {
        return this.initialDataCache;
    };
    /**
     * @return {?}
     */
    OFormCacheClass.prototype.getDataCache = /**
     * @return {?}
     */
    function () {
        return this.formDataCache;
    };
    /**
     * @return {?}
     */
    OFormCacheClass.prototype.restartCache = /**
     * @return {?}
     */
    function () {
        this.formDataCache = undefined;
        this.initializeCache({});
        this.initializedCache = false;
        this.onCacheStateChanges.emit();
    };
    /**
     * @return {?}
     */
    OFormCacheClass.prototype.setCacheSnapshot = /**
     * @return {?}
     */
    function () {
        this.initializeCache(this.getDataCache());
    };
    /**
     * @param {?=} options
     * @return {?}
     */
    OFormCacheClass.prototype.undoLastChange = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        options = (options || {});
        /** @type {?} */
        var lastElement = this.valueChangesStack[this.valueChangesStack.length - 1];
        if (lastElement) {
            /** @type {?} */
            var lastCacheValue = this.getCacheLastValue(lastElement.attr);
            /** @type {?} */
            var lastValue = (lastCacheValue !== null) ? lastCacheValue : this.initialDataCache[lastElement.attr];
            this.undoComponentValue(lastElement.attr, lastValue);
            this.updateFormDataCache();
            this.onCacheStateChanges.emit();
        }
    };
    /**
     * @param {?} attr
     * @param {?} val
     * @return {?}
     */
    OFormCacheClass.prototype.undoComponentValue = /**
     * @param {?} attr
     * @param {?} val
     * @return {?}
     */
    function (attr, val) {
        this.blockCaching = true;
        /** @type {?} */
        var comp = this.form.getFieldReference(attr);
        if (comp) {
            // (comp as any).oldValue = undefined;
            comp.setValue(val);
        }
        this.blockCaching = false;
    };
    /**
     * @param {?} attr
     * @param {?} comp
     * @return {?}
     */
    OFormCacheClass.prototype.hasComponentChanged = /**
     * @param {?} attr
     * @param {?} comp
     * @return {?}
     */
    function (attr, comp) {
        /** @type {?} */
        var currentValue = comp.getFormControl().value;
        /** @type {?} */
        var cache = this.formDataCache || this.initialDataCache;
        return (currentValue !== cache[attr]);
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OFormCacheClass.prototype.getCacheLastValue = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        this.updateChangesStack(attr);
        /** @type {?} */
        var result = null;
        for (var i = this.valueChangesStack.length - 1; i >= 0; i--) {
            /** @type {?} */
            var current = this.valueChangesStack[i];
            if (current.attr === attr) {
                result = current.value;
                break;
            }
        }
        return result;
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OFormCacheClass.prototype.updateChangesStack = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        /** @type {?} */
        var index = undefined;
        for (var i = this.valueChangesStack.length - 1; i >= 0; i--) {
            /** @type {?} */
            var current = this.valueChangesStack[i];
            if (current.attr === attr) {
                index = i;
                break;
            }
        }
        if (index !== undefined) {
            for (var i = index; i >= 0; i--) {
                /** @type {?} */
                var prev = this.valueChangesStack[i - 1];
                /** @type {?} */
                var current = this.valueChangesStack[i];
                if (current.attr === attr) {
                    this.valueChangesStack.splice(i, 1);
                    if (!prev || prev.attr === attr) {
                        continue;
                    }
                    else {
                        break;
                    }
                }
            }
        }
        if (this.valueChangesStack.length === 0) {
            this.onCacheEmptyStateChanges.emit(true);
        }
    };
    Object.defineProperty(OFormCacheClass.prototype, "isCacheStackEmpty", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.valueChangesStack.length === 0);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OFormCacheClass.prototype.isInitialStateChanged = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var currentCache;
        if (this.formDataCache) {
            currentCache = Object.assign({}, this.formDataCache);
            this.removeUndefinedProperties(currentCache);
        }
        /** @type {?} */
        var initialKeys = Object.keys(this.initialDataCache);
        /** @type {?} */
        var currentKeys = currentCache ? Object.keys(currentCache) : initialKeys;
        if (initialKeys.length !== currentKeys.length) {
            return true;
        }
        /** @type {?} */
        var res = false;
        for (var i = 0, len = initialKeys.length; i < len; i++) {
            /** @type {?} */
            var key = initialKeys[i];
            // TODO be careful with types comparisions
            res = (this.initialDataCache[key] !== currentCache[key]);
            if (res) {
                break;
            }
        }
        return res;
    };
    /**
     * @return {?}
     */
    OFormCacheClass.prototype.getChangedFormControlsAttr = /**
     * @return {?}
     */
    function () {
        return this.changedFormControls;
    };
    return OFormCacheClass;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CanDeactivateFormGuard = /** @class */ (function () {
    function CanDeactivateFormGuard() {
    }
    /**
     * @param {?} component
     * @param {?} curr
     * @param {?} state
     * @param {?} future
     * @return {?}
     */
    CanDeactivateFormGuard.prototype.canDeactivate = /**
     * @param {?} component
     * @param {?} curr
     * @param {?} state
     * @param {?} future
     * @return {?}
     */
    function (component, curr, state$$1, future) {
        /** @type {?} */
        var futureQueryParams = future.root.queryParams;
        if (futureQueryParams.hasOwnProperty(Codes.IGNORE_CAN_DEACTIVATE)) {
            return true;
        }
        if (this.oForm) {
            return this.oForm.canDeactivate();
        }
        return true;
    };
    /**
     * @param {?} form
     * @return {?}
     */
    CanDeactivateFormGuard.prototype.setForm = /**
     * @param {?} form
     * @return {?}
     */
    function (form) {
        this.oForm = form;
    };
    CanDeactivateFormGuard.decorators = [
        { type: core.Injectable },
    ];
    return CanDeactivateFormGuard;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OFormLayoutManagerContentDirective = /** @class */ (function () {
    function OFormLayoutManagerContentDirective(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
    OFormLayoutManagerContentDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[o-form-layout-manager-content]',
                },] },
    ];
    /** @nocollapse */
    OFormLayoutManagerContentDirective.ctorParameters = function () { return [
        { type: core.ViewContainerRef }
    ]; };
    OFormLayoutManagerContentDirective.propDecorators = {
        index: [{ type: core.Input }]
    };
    return OFormLayoutManagerContentDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OFormLayoutDialogComponent = /** @class */ (function () {
    function OFormLayoutDialogComponent(dialogRef, injector, componentFactoryResolver, data) {
        this.dialogRef = dialogRef;
        this.injector = injector;
        this.componentFactoryResolver = componentFactoryResolver;
        if (data.title) {
            this.title = data.title;
        }
        if (data.data) {
            this.data = data.data;
            /** @type {?} */
            var component = data.data.component;
            this.componentFactory = this.componentFactoryResolver.resolveComponentFactory(component);
            this.params = data.data.params;
            this.queryParams = data.data.queryParams;
            this.urlSegments = data.data.urlSegments;
        }
        if (data.layoutManagerComponent) {
            this.formLayoutManager = data.layoutManagerComponent;
        }
    }
    /**
     * @return {?}
     */
    OFormLayoutDialogComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.contentDirective && this.componentFactory) {
            /** @type {?} */
            var viewContainerRef = this.contentDirective.viewContainerRef;
            viewContainerRef.clear();
            viewContainerRef.createComponent(this.componentFactory);
        }
    };
    /**
     * @param {?} data
     * @param {?} id
     * @return {?}
     */
    OFormLayoutDialogComponent.prototype.updateNavigation = /**
     * @param {?} data
     * @param {?} id
     * @return {?}
     */
    function (data, id) {
        /** @type {?} */
        var label = this.formLayoutManager.getLabelFromData(data);
        label = label.length ? label : this.formLayoutManager.getLabelFromUrlParams(this.params);
        if (label && label.length) {
            label = ': ' + label;
        }
        this.label = label;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OFormLayoutDialogComponent.prototype.updateActiveData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.data = Object.assign(this.data, data);
    };
    /**
     * @return {?}
     */
    OFormLayoutDialogComponent.prototype.closeDialog = /**
     * @return {?}
     */
    function () {
        this.dialogRef.close();
    };
    /**
     * @return {?}
     */
    OFormLayoutDialogComponent.prototype.getRouteOfActiveItem = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var parentRoute = this.formLayoutManager.parentFormLayoutManager.getRouteOfActiveItem();
        /** @type {?} */
        var segments = (this.urlSegments || []);
        /** @type {?} */
        var route = [];
        segments.forEach(function (segment, index) {
            if (parentRoute[index] !== segment.path) {
                route.push(segment.path);
            }
        });
        return route;
    };
    /**
     * @return {?}
     */
    OFormLayoutDialogComponent.prototype.getParams = /**
     * @return {?}
     */
    function () {
        return this.params;
    };
    OFormLayoutDialogComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-form-layout-dialog',
                    template: "\n    <div fxLayout=\"row\" fxLayoutAlign=\"space-between center\" class=\"title-container\">\n      <span fxFlex fxLayoutAlign=\"center center\" mat-dialog-title> {{ (title || 'LAYOUT_MANANGER.DIALOG_TITLE') | oTranslate }}{{ label }} </span>\n      <mat-icon (click)=\"closeDialog()\" svgIcon=\"ontimize:close\"></mat-icon>\n    </div>\n\n    <div mat-dialog-content class=\"form-layout-dialog-container\">\n      <ng-template o-form-layout-manager-content></ng-template>\n    </div>\n  ",
                    styles: ["\n    .o-form-layout-dialog-overlay{width:65%;height:90%}.o-form-layout-dialog-overlay .title-container{cursor:default;height:64px;padding:0 16px}.o-form-layout-dialog-overlay .title-container .mat-dialog-title{width:100%;padding-left:24px;text-align:center;margin:0}.o-form-layout-dialog-overlay .title-container .mat-icon{cursor:pointer}.o-form-layout-dialog-overlay .mat-dialog-container{padding:0 !important;overflow:hidden}.o-form-layout-dialog-overlay .mat-dialog-container .mat-dialog-content.form-layout-dialog-container{display:block;padding-top:16px;margin:0;max-height:calc(100% - 78px);height:100%}.o-form-layout-dialog-overlay .mat-dialog-container .o-form-layout-dialog o-form-toolbar .mat-toolbar{padding:0}.o-form-layout-dialog-overlay .mat-dialog-container .o-form-layout-dialog .o-form form.inner-form{position:relative;margin-top:0}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-form-layout-dialog]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OFormLayoutDialogComponent.ctorParameters = function () { return [
        { type: material.MatDialogRef },
        { type: core.Injector },
        { type: core.ComponentFactoryResolver },
        { type: undefined, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] }] }
    ]; };
    OFormLayoutDialogComponent.propDecorators = {
        contentDirective: [{ type: core.ViewChild, args: [OFormLayoutManagerContentDirective,] }]
    };
    return OFormLayoutDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_SEARCH_INPUT = [
    'placeholder',
    'width',
    'floatLabel: float-label',
    'appearance',
    'columns',
    'filterCaseSensitive: filter-case-sensitive',
    'showCaseSensitiveCheckbox: show-case-sensitive-checkbox',
    'showMenu: show-menu'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_SEARCH_INPUT = [
    'onSearch'
];
var OSearchInputComponent = /** @class */ (function () {
    function OSearchInputComponent(injector, elRef) {
        this.injector = injector;
        this.elRef = elRef;
        this.onSearch = new core.EventEmitter();
        this.colArray = [];
        this.placeholder = 'SEARCH';
        this.showCaseSensitiveCheckbox = false;
        this.showMenu = true;
        this._filterCaseSensitive = false;
        this.translateService = this.injector.get(OTranslateService$$1);
        this.snackBarService = this.injector.get(SnackBarService);
        this.formGroup = new forms.FormGroup({});
    }
    /**
     * @return {?}
     */
    OSearchInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.term = new forms.FormControl();
        this.formGroup.addControl('term', this.term);
        this.term.valueChanges.pipe(debounceTime(400))
            .pipe(distinctUntilChanged()).subscribe(function (term) {
            if (_this.checkActiveColumns()) {
                _this.onSearch.emit(term);
            }
        });
        /** @type {?} */
        var colArray = Util.parseArray(this.columns, true);
        colArray.forEach(function (col) {
            _this.colArray.push({
                column: col,
                checked: true
            });
        });
    };
    /**
     * @return {?}
     */
    OSearchInputComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        try {
            this.oInputsOptions = this.injector.get(O_INPUTS_OPTIONS);
        }
        catch (e) {
            this.oInputsOptions = {};
        }
        Util.parseOInputsOptions(this.elRef, this.oInputsOptions);
    };
    Object.defineProperty(OSearchInputComponent.prototype, "floatLabel", {
        get: /**
         * @return {?}
         */
        function () {
            return this._floatLabel;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var values = ['always', 'never', 'auto'];
            if (values.indexOf(value) === -1) {
                value = 'auto';
            }
            this._floatLabel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OSearchInputComponent.prototype, "appearance", {
        get: /**
         * @return {?}
         */
        function () {
            return this._appearance;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var values = ['legacy', 'standard', 'fill', 'outline'];
            if (values.indexOf(value) === -1) {
                value = undefined;
            }
            this._appearance = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OSearchInputComponent.prototype, "filterCaseSensitive", {
        get: /**
         * @return {?}
         */
        function () {
            return this._filterCaseSensitive;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filterCaseSensitive = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OSearchInputComponent.prototype.getFormGroup = /**
     * @return {?}
     */
    function () {
        return this.formGroup;
    };
    /**
     * @return {?}
     */
    OSearchInputComponent.prototype.getValue = /**
     * @return {?}
     */
    function () {
        return this.term.value;
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OSearchInputComponent.prototype.setValue = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        this.term.setValue(val);
    };
    /**
     * @return {?}
     */
    OSearchInputComponent.prototype.getFormControl = /**
     * @return {?}
     */
    function () {
        return this.term;
    };
    Object.defineProperty(OSearchInputComponent.prototype, "hasCustomWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return this.width !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OSearchInputComponent.prototype, "showFilterMenu", {
        get: /**
         * @return {?}
         */
        function () {
            return this.showMenu && this.colArray.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} column
     * @return {?}
     */
    OSearchInputComponent.prototype.isChecked = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return column.checked;
    };
    /**
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    OSearchInputComponent.prototype.onCheckboxChange = /**
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    function (column, event) {
        column.checked = event.checked;
        // triggerOnSearch if we want to trigger search on each change
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OSearchInputComponent.prototype.onSelectAllChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.colArray.forEach(function (col) {
            col.checked = event.checked;
        });
        // triggerOnSearch if we want to trigger search on each change
    };
    /**
     * @return {?}
     */
    OSearchInputComponent.prototype.areAllColumnsChecked = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = true;
        this.colArray.forEach(function (col) {
            result = result && col.checked;
        });
        return result;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OSearchInputComponent.prototype.onFilterCaseSensitiveChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.filterCaseSensitive = event.checked;
        // triggerOnSearch if we want to trigger search on each change
    };
    /**
     * @return {?}
     */
    OSearchInputComponent.prototype.getActiveColumns = /**
     * @return {?}
     */
    function () {
        return this.colArray.filter(function (col) { return col.checked; }).map(function (col) { return col.column; });
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    OSearchInputComponent.prototype.setActiveColumns = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        this.colArray.forEach(function (c) {
            c.checked = arg.indexOf(c.column) !== -1;
        });
    };
    /**
     * @return {?}
     */
    OSearchInputComponent.prototype.checkActiveColumns = /**
     * @return {?}
     */
    function () {
        if (this.getActiveColumns().length === 0) {
            this.snackBarService.open('MESSAGES.AVOID_QUERY_WITHOUT_QUICKFILTER_COLUMNS');
            return false;
        }
        return true;
    };
    /**
     * @return {?}
     */
    OSearchInputComponent.prototype.triggerOnSearch = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var term = this.term.value;
        if (this.checkActiveColumns() && Util.isDefined(term) && term.length > 0) {
            this.onSearch.emit(term);
        }
    };
    /**
     * @return {?}
     */
    OSearchInputComponent.prototype.onMenuClosed = /**
     * @return {?}
     */
    function () {
        this.triggerOnSearch();
    };
    Object.defineProperty(OSearchInputComponent.prototype, "filterExpression", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var result;
            /** @type {?} */
            var termValue = this.getValue();
            if (Util.isDefined(termValue) && termValue.length > 0) {
                /** @type {?} */
                var filterCols = this.getActiveColumns();
                if (filterCols.length > 0) {
                    return FilterExpressionUtils.buildArrayExpressionLike(filterCols, termValue);
                }
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    OSearchInputComponent.DEFAULT_INPUTS_O_SEARCH_INPUT = DEFAULT_INPUTS_O_SEARCH_INPUT;
    OSearchInputComponent.DEFAULT_OUTPUTS_O_SEARCH_INPUT = DEFAULT_OUTPUTS_O_SEARCH_INPUT;
    OSearchInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-search-input',
                    template: "\n    <form [formGroup]=\"getFormGroup()\">\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [class.custom-width]=\"hasCustomWidth\"\n        class=\"icon-field\" fxFill>\n        <mat-icon *ngIf=\"!showFilterMenu\" svgIcon=\"ontimize:search\" matPrefix></mat-icon>\n        <mat-icon *ngIf=\"showFilterMenu\" svgIcon=\"ontimize:search\" matPrefix [matMenuTriggerFor]=\"menu\"\n          class=\"menu-trigger\" (menuClosed)=\"onMenuClosed()\"></mat-icon>\n        <input #term matInput id=\"term\" type=\"search\" placeholder=\"{{ placeholder | oTranslate }}\" formControlName=\"term\">\n      </mat-form-field>\n    </form>\n\n    <mat-menu #menu=\"matMenu\" class=\"o-search-input-menu\">\n      <div fxLayout=\"column\" class=\"checkbox-container\">\n\n        <ng-container *ngIf=\"colArray.length > 1\">\n          <mat-checkbox (click)=\"$event.stopPropagation()\" [checked]=\"areAllColumnsChecked()\"\n            (change)=\"onSelectAllChange($event)\">\n            {{ 'SELECT_ALL' | oTranslate }}</mat-checkbox>\n          <mat-divider></mat-divider>\n        </ng-container>\n\n        <ng-container *ngFor=\"let item of colArray\">\n          <mat-checkbox (click)=\"$event.stopPropagation()\" [checked]=\"isChecked(item)\"\n            (change)=\"onCheckboxChange(item, $event)\">\n            {{ item.column | oTranslate }}\n          </mat-checkbox>\n        </ng-container>\n\n        <ng-container *ngIf=\"showCaseSensitiveCheckbox\">\n          <mat-divider></mat-divider>\n          <mat-checkbox (click)=\"$event.stopPropagation()\" [checked]=\"filterCaseSensitive\"\n            (change)=\"onFilterCaseSensitiveChange($event)\">\n            {{ 'TABLE.FILTER.CASE_SENSITIVE' | oTranslate }}\n          </mat-checkbox>\n        </ng-container>\n      </div>\n    </mat-menu>\n  ",
                    styles: ["\n    .o-search-input .mat-icon{vertical-align:bottom;cursor:default}.o-search-input .mat-icon.menu-trigger{cursor:pointer}.o-search-input .mat-input-element{line-height:20px}.o-search-input-menu .mat-divider{margin:8px 0}.o-search-input-menu .checkbox-container{padding:6px 12px}\n  "],
                    inputs: DEFAULT_INPUTS_O_SEARCH_INPUT,
                    outputs: DEFAULT_OUTPUTS_O_SEARCH_INPUT,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-search-input]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OSearchInputComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: core.ElementRef }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OSearchInputComponent.prototype, "showCaseSensitiveCheckbox", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OSearchInputComponent.prototype, "showMenu", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OSearchInputComponent.prototype, "_filterCaseSensitive", void 0);
    return OSearchInputComponent;
}());
var OSearchInputModule = /** @class */ (function () {
    function OSearchInputModule() {
    }
    OSearchInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OSearchInputComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OSearchInputComponent]
                },] },
    ];
    return OSearchInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_SERVICE_BASE_COMPONENT = [
    'oattr: attr',
    'service',
    'serviceType : service-type',
    'entity',
    'queryOnInit: query-on-init',
    'queryOnBind: query-on-bind',
    'queryOnEvent: query-on-event',
    'pageable',
    'columns',
    'keys',
    'parentKeys: parent-keys',
    'staticData: static-data',
    'queryMethod: query-method',
    'paginatedQueryMethod : paginated-query-method',
    'oQueryRows: query-rows',
    'insertMethod: insert-method',
    'updateMethod: update-method',
    'deleteMethod: delete-method',
    'storeState: store-state',
    'queryWithNullParentKeys: query-with-null-parent-keys',
    'queryFallbackFunction: query-fallback-function'
];
var OServiceBaseComponent = /** @class */ (function () {
    function OServiceBaseComponent(injector) {
        this.injector = injector;
        this.queryOnInit = true;
        this.queryOnBind = true;
        this.pageable = false;
        this.queryMethod = Codes.QUERY_METHOD;
        this.paginatedQueryMethod = Codes.PAGINATED_QUERY_METHOD;
        this.originalQueryRows = Codes.DEFAULT_QUERY_ROWS;
        this._queryRows = this.originalQueryRows;
        this.insertMethod = Codes.INSERT_METHOD;
        this.updateMethod = Codes.UPDATE_METHOD;
        this.deleteMethod = Codes.DELETE_METHOD;
        this.storeState = true;
        this.queryWithNullParentKeys = false;
        // insertFallbackFunction: Function;
        // updateFallbackFunction: Function;
        // deleteFallbackFunction: Function;
        /* end of inputs variables */
        /* parsed inputs variables */
        this.colArray = [];
        this.keysArray = [];
        this._pKeysEquiv = {};
        this.dataArray = [];
        this.oattrFromEntity = false;
        this._state = {};
        this.loadingSubject = new BehaviorSubject(false);
        this.loading = this.loadingSubject.asObservable();
        this.alreadyStored = false;
        this.sqlTypes = undefined;
        this.dialogService = this.injector.get(DialogService);
        this.localStorageService = this.injector.get(LocalStorageService);
        this.router = this.injector.get(router.Router);
        this.actRoute = this.injector.get(router.ActivatedRoute);
        try {
            this.cd = this.injector.get(core.ChangeDetectorRef);
            this.form = this.injector.get(OFormComponent);
        }
        catch (e) {
            // no parent form
        }
    }
    Object.defineProperty(OServiceBaseComponent.prototype, "oQueryRows", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (Util.isDefined(value)) {
                this.originalQueryRows = value;
                this._queryRows = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OServiceBaseComponent.prototype, "queryRows", {
        get: /**
         * @return {?}
         */
        function () {
            return this._queryRows;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (Util.isDefined(value)) {
                this._queryRows = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!Util.isDefined(this.oattr) && Util.isDefined(this.entity)) {
            this.oattr = this.entity.replace('.', '_');
            this.oattrFromEntity = true;
        }
        this.keysArray = Util.parseArray(this.keys);
        this.colArray = Util.parseArray(this.columns, true);
        /** @type {?} */
        var pkArray = Util.parseArray(this.parentKeys);
        this._pKeysEquiv = Util.parseParentKeysEquivalences(pkArray, Codes.COLUMNS_ALIAS_SEPARATOR);
        if (this.storeState) {
            this.onRouteChangeStorageSubscription = this.localStorageService.onRouteChange.subscribe(function (res) {
                _this.updateStateStorage();
                // when the storage is updated because a route change
                // the alreadyStored control variable is changed to its initial value
                // when the storage is updated because a route change
                // the alreadyStored control variable is changed to its initial value
                _this.alreadyStored = false;
            });
            this.initializeState();
            // if query-rows in initial configuration is equals to original query-rows input
            // query_rows will be the value in local storage
            if (this.state.hasOwnProperty('query-rows')) {
                if (this.state.hasOwnProperty('initial-configuration') && this.state['initial-configuration'].hasOwnProperty['query-rows']
                    && this.state['initial-configuration']['query-rows'] === this.originalQueryRows) {
                    this.queryRows = this.state['query-rows'];
                }
            }
        }
        if (this.staticData) {
            this.queryOnBind = false;
            this.queryOnInit = false;
            this.setDataArray(this.staticData);
        }
        else {
            this.configureService();
        }
        if (this.form && Util.isDefined(this.dataService)) {
            this.setFormComponent(this.form);
        }
        if (Util.isDefined(this.queryOnEvent) && Util.isDefined(this.queryOnEvent.subscribe)) {
            /** @type {?} */
            var self_1 = this;
            this.queryOnEventSubscription = this.queryOnEvent.subscribe(function (value) {
                if (Util.isDefined(value) || _this.queryWithNullParentKeys) {
                    self_1.queryData();
                }
            });
        }
        if (typeof this.queryFallbackFunction !== 'function') {
            this.queryFallbackFunction = undefined;
        }
        // if (typeof this.insertFallbackFunction !== 'function') {
        //   this.insertFallbackFunction = undefined;
        // }
        // if (typeof this.updateFallbackFunction !== 'function') {
        //   this.updateFallbackFunction = undefined;
        // }
        // if (typeof this.deleteFallbackFunction !== 'function') {
        //   this.deleteFallbackFunction = undefined;
        // }
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.afterViewInit = /**
     * @return {?}
     */
    function () {
        //
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (this.onFormDataSubscribe) {
            this.onFormDataSubscribe.unsubscribe();
        }
        if (this.querySubscription) {
            this.querySubscription.unsubscribe();
        }
        if (this.loaderSubscription) {
            this.loaderSubscription.unsubscribe();
        }
        if (this.onRouteChangeStorageSubscription) {
            this.onRouteChangeStorageSubscription.unsubscribe();
        }
        if (this.queryOnEventSubscription) {
            this.queryOnEventSubscription.unsubscribe();
        }
        this.updateStateStorage();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    OServiceBaseComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (Util.isDefined(changes['staticData'])) {
            this.setDataArray(changes['staticData'].currentValue);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OServiceBaseComponent.prototype.beforeunloadHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.updateStateStorage();
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.getAttribute = /**
     * @return {?}
     */
    function () {
        return this.oattr;
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.getComponentKey = /**
     * @return {?}
     */
    function () {
        return this.getAttribute();
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.getDataToStore = /**
     * @return {?}
     */
    function () {
        return this.state;
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.getRouteKey = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var route = this.router.url;
        this.actRoute.params.subscribe(function (params) {
            Object.keys(params).forEach(function (key) {
                route = route.replace(params[key], key);
            });
        });
        return route;
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.getKeys = /**
     * @return {?}
     */
    function () {
        return this.keysArray;
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.configureService = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var loadingService = OntimizeService$$1;
        if (this.serviceType) {
            loadingService = this.serviceType;
        }
        try {
            this.dataService = this.injector.get(loadingService);
            if (Util.isDataService(this.dataService)) {
                /** @type {?} */
                var serviceCfg = this.dataService.getDefaultServiceConfiguration(this.service);
                if (this.entity) {
                    serviceCfg['entity'] = this.entity;
                }
                this.dataService.configureService(serviceCfg);
            }
        }
        catch (e) {
            console.error(e);
        }
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.getDataArray = /**
     * @return {?}
     */
    function () {
        return this.dataArray;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OServiceBaseComponent.prototype.setDataArray = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (Util.isArray(data)) {
            this.dataArray = data;
        }
        else if (Util.isObject(data)) {
            this.dataArray = [data];
        }
        else {
            console.warn('Component has received not supported service data. Supported data are Array or Object');
            this.dataArray = [];
        }
    };
    /**
     * @param {?} form
     * @return {?}
     */
    OServiceBaseComponent.prototype.setFormComponent = /**
     * @param {?} form
     * @return {?}
     */
    function (form) {
        var _this = this;
        if (!Util.isDefined(this.form)) {
            this.form = form;
        }
        if (this.queryOnBind) {
            this.onFormDataSubscribe = this.form.onDataLoaded.subscribe(function () { return _this.pageable ? _this.reloadPaginatedDataFromStart() : _this.reloadData(); });
        }
    };
    /**
     * @param {?=} filter
     * @param {?=} ovrrArgs
     * @return {?}
     */
    OServiceBaseComponent.prototype.queryData = /**
     * @param {?=} filter
     * @param {?=} ovrrArgs
     * @return {?}
     */
    function (filter$$1, ovrrArgs) {
        var _this = this;
        /** @type {?} */
        var queryMethodName = this.pageable ? this.paginatedQueryMethod : this.queryMethod;
        if (!this.dataService || !(queryMethodName in this.dataService) || !this.entity) {
            return;
        }
        /** @type {?} */
        var filterParentKeys = ServiceUtils$$1.getParentKeysFromForm(this._pKeysEquiv, this.form);
        if (!ServiceUtils$$1.filterContainsAllParentKeys(filterParentKeys, this._pKeysEquiv) && !this.queryWithNullParentKeys) {
            this.setData([], []);
        }
        else {
            filter$$1 = Object.assign(filter$$1 || {}, filterParentKeys);
            /** @type {?} */
            var queryArguments = this.getQueryArguments(filter$$1, ovrrArgs);
            if (this.querySubscription) {
                this.querySubscription.unsubscribe();
            }
            if (this.loaderSubscription) {
                this.loaderSubscription.unsubscribe();
            }
            this.loaderSubscription = this.load();
            /** @type {?} */
            var self_2 = this;
            this.queryArguments = queryArguments;
            this.querySubscription = this.dataService[queryMethodName].apply(this.dataService, queryArguments).subscribe(function (res) {
                /** @type {?} */
                var data = undefined;
                _this.sqlTypes = undefined;
                if (Util.isArray(res)) {
                    data = res;
                    _this.sqlTypes = {};
                }
                else if ((res.code === Codes.ONTIMIZE_SUCCESSFUL_CODE)) {
                    /** @type {?} */
                    var arrData = (res.data !== undefined) ? res.data : [];
                    data = Util.isArray(arrData) ? arrData : [];
                    _this.sqlTypes = res.sqlTypes;
                    if (_this.pageable) {
                        _this.updatePaginationInfo(res);
                    }
                }
                self_2.setData(data, _this.sqlTypes, (ovrrArgs && ovrrArgs.replace));
                self_2.loaderSubscription.unsubscribe();
            }, function (err) {
                self_2.setData([], []);
                self_2.loaderSubscription.unsubscribe();
                if (Util.isDefined(self_2.queryFallbackFunction)) {
                    self_2.queryFallbackFunction(err);
                }
                else if (err && typeof err !== 'object') {
                    self_2.dialogService.alert('ERROR', err);
                }
                else {
                    self_2.dialogService.alert('ERROR', 'MESSAGES.ERROR_QUERY');
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.reloadData = /**
     * @return {?}
     */
    function () {
        this.queryData();
    };
    /**
     * Reloads the component data and restarts the pagination.
     */
    /**
     * Reloads the component data and restarts the pagination.
     * @return {?}
     */
    OServiceBaseComponent.prototype.reloadPaginatedDataFromStart = /**
     * Reloads the component data and restarts the pagination.
     * @return {?}
     */
    function () {
        this.reloadData();
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.load = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var zone = this.injector.get(core.NgZone);
        /** @type {?} */
        var loadObservable = new Observable(function (observer) {
            /** @type {?} */
            var timer$$1 = window.setTimeout(function () {
                observer.next(true);
            }, 250);
            return function () {
                window.clearTimeout(timer$$1);
                zone.run(function () {
                    self.loadingSubject.next(false);
                });
            };
        });
        /** @type {?} */
        var subscription = loadObservable.subscribe(function (val) {
            zone.run(function () {
                self.loadingSubject.next(/** @type {?} */ (val));
            });
        });
        return subscription;
    };
    /**
     * Extracting the given record keys
     * @param item record object
     * @returns object containing item object properties contained in keysArray
     */
    /**
     * Extracting the given record keys
     * @param {?} item record object
     * @return {?} object containing item object properties contained in keysArray
     */
    OServiceBaseComponent.prototype.extractKeysFromRecord = /**
     * Extracting the given record keys
     * @param {?} item record object
     * @return {?} object containing item object properties contained in keysArray
     */
    function (item) {
        /** @type {?} */
        var result = {};
        if (Util.isObject(item)) {
            this.keysArray.forEach(function (key) {
                if (Util.isDefined(item[key])) {
                    result[key] = item[key];
                }
            });
        }
        return result;
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.getAttributesValuesToQuery = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = this.colArray;
        this.keysArray.forEach(function (key) {
            if (result.indexOf(key) === -1) {
                result.push(key);
            }
        });
        return result;
    };
    /**
     * @param {?} filter
     * @param {?=} ovrrArgs
     * @return {?}
     */
    OServiceBaseComponent.prototype.getQueryArguments = /**
     * @param {?} filter
     * @param {?=} ovrrArgs
     * @return {?}
     */
    function (filter$$1, ovrrArgs) {
        /** @type {?} */
        var compFilter = this.getComponentFilter(filter$$1);
        /** @type {?} */
        var queryCols = this.getAttributesValuesToQuery();
        /** @type {?} */
        var sqlTypes = (ovrrArgs && ovrrArgs.hasOwnProperty('sqltypes')) ? ovrrArgs.sqltypes : this.form ? this.form.getAttributesSQLTypes() : {};
        /** @type {?} */
        var queryArguments = [compFilter, queryCols, this.entity, sqlTypes];
        if (this.pageable) {
            /** @type {?} */
            var queryOffset = (ovrrArgs && ovrrArgs.hasOwnProperty('offset')) ? ovrrArgs.offset : this.state.queryRecordOffset;
            /** @type {?} */
            var queryRowsN = (ovrrArgs && ovrrArgs.hasOwnProperty('length')) ? ovrrArgs.length : this.queryRows;
            queryArguments = queryArguments.concat([queryOffset, queryRowsN, undefined]);
        }
        return queryArguments;
    };
    /**
     * @param {?} queryRes
     * @return {?}
     */
    OServiceBaseComponent.prototype.updatePaginationInfo = /**
     * @param {?} queryRes
     * @return {?}
     */
    function (queryRes) {
        /** @type {?} */
        var resultEndIndex = queryRes.startRecordIndex + (queryRes.data ? queryRes.data.length : 0);
        if (queryRes.startRecordIndex !== undefined) {
            this.state.queryRecordOffset = resultEndIndex;
        }
        if (queryRes.totalQueryRecordsNumber !== undefined) {
            this.state.totalQueryRecordsNumber = queryRes.totalQueryRecordsNumber;
        }
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.getTotalRecordsNumber = /**
     * @return {?}
     */
    function () {
        return (this.state && this.state.totalQueryRecordsNumber !== undefined) ? this.state.totalQueryRecordsNumber : undefined;
    };
    /**
     * @param {?=} existingFilter
     * @return {?}
     */
    OServiceBaseComponent.prototype.getComponentFilter = /**
     * @param {?=} existingFilter
     * @return {?}
     */
    function (existingFilter) {
        if (existingFilter === void 0) { existingFilter = {}; }
        return existingFilter;
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.getSqlTypes = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this.sqlTypes) ? this.sqlTypes : {};
    };
    Object.defineProperty(OServiceBaseComponent.prototype, "state", {
        get: /**
         * @return {?}
         */
        function () {
            return this._state;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._state = arg;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.getParentKeysValues = /**
     * @return {?}
     */
    function () {
        return ServiceUtils$$1.getParentKeysFromForm(this._pKeysEquiv, this.form);
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.updateStateStorage = /**
     * @return {?}
     */
    function () {
        if (this.localStorageService && this.storeState && !this.alreadyStored) {
            this.alreadyStored = true;
            this.localStorageService.updateComponentStorage(this, this.getRouteKey());
        }
    };
    /**
     * @param {?} data
     * @param {?=} sqlTypes
     * @param {?=} replace
     * @return {?}
     */
    OServiceBaseComponent.prototype.setData = /**
     * @param {?} data
     * @param {?=} sqlTypes
     * @param {?=} replace
     * @return {?}
     */
    function (data, sqlTypes, replace) {
        //
    };
    /**
     * @return {?}
     */
    OServiceBaseComponent.prototype.initializeState = /**
     * @return {?}
     */
    function () {
        // Get previous status
        this.state = this.localStorageService.getComponentStorage(this, this.getRouteKey());
    };
    OServiceBaseComponent.DEFAULT_INPUTS_O_SERVICE_BASE_COMPONENT = DEFAULT_INPUTS_O_SERVICE_BASE_COMPONENT;
    OServiceBaseComponent.propDecorators = {
        beforeunloadHandler: [{ type: core.HostListener, args: ['window:beforeunload', ['$event'],] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceBaseComponent.prototype, "queryOnInit", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceBaseComponent.prototype, "queryOnBind", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceBaseComponent.prototype, "pageable", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], OServiceBaseComponent.prototype, "oQueryRows", null);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceBaseComponent.prototype, "storeState", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceBaseComponent.prototype, "queryWithNullParentKeys", void 0);
    return OServiceBaseComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_SERVICE_COMPONENT$$1 = DEFAULT_INPUTS_O_SERVICE_BASE_COMPONENT.concat([
    '_title: title',
    'ovisible: visible',
    'enabled',
    'controls',
    'detailMode: detail-mode',
    'detailFormRoute: detail-form-route',
    'recursiveDetail: recursive-detail',
    'detailButtonInRow: detail-button-in-row',
    'detailButtonInRowIcon: detail-button-in-row-icon',
    'editFormRoute: edit-form-route',
    'recursiveEdit: recursive-edit',
    'editButtonInRow: edit-button-in-row',
    'editButtonInRowIcon: edit-button-in-row-icon',
    'insertButton: insert-button',
    'rowHeight : row-height',
    'insertFormRoute: insert-form-route',
    'recursiveInsert: recursive-insert',
    'filterCaseSensitive: filter-case-sensitive',
    'quickFilter: quick-filter',
]);
var OServiceComponent$$1 = /** @class */ (function (_super) {
    __extends(OServiceComponent$$1, _super);
    function OServiceComponent$$1(injector, elRef, form) {
        var _this = _super.call(this, injector) || this;
        _this.elRef = elRef;
        _this.form = form;
        _this.ovisible = true;
        _this.oenabled = true;
        _this.controls = true;
        _this.detailMode = Codes.DETAIL_MODE_CLICK;
        _this.recursiveDetail = false;
        _this.detailButtonInRow = false;
        _this.detailButtonInRowIcon = Codes.DETAIL_ICON;
        _this.recursiveEdit = false;
        _this.editButtonInRow = false;
        _this.editButtonInRowIcon = Codes.EDIT_ICON;
        _this._rowHeight = Codes.DEFAULT_ROW_HEIGHT;
        _this.rowHeightSubject = new BehaviorSubject(_this._rowHeight);
        _this.rowHeightObservable = _this.rowHeightSubject.asObservable();
        _this.recursiveInsert = false;
        _this.filterCaseSensitive = false;
        _this._quickFilter = true;
        _this.selection = new SelectionModel(true, []);
        _this.permissionsService = _this.injector.get(PermissionsService);
        _this.translateService = _this.injector.get(OTranslateService$$1);
        _this.navigationService = _this.injector.get(NavigationService);
        try {
            _this.formLayoutManager = _this.injector.get(OFormLayoutManagerComponent);
        }
        catch (e) {
            // no parent form layout manager
        }
        try {
            _this.oFormLayoutDialog = _this.injector.get(OFormLayoutDialogComponent);
            _this.formLayoutManager = _this.oFormLayoutDialog.formLayoutManager;
        }
        catch (e) {
            // no parent form layout manager
        }
        return _this;
    }
    Object.defineProperty(OServiceComponent$$1.prototype, "title", {
        get: /**
         * @return {?}
         */
        function () {
            if (Util.isDefined(this._title)) {
                return this.translateService.get(this._title);
            }
            return this._title;
        },
        /* inputs variables */
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._title = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OServiceComponent$$1.prototype, "rowHeight", {
        get: /**
         * @return {?}
         */
        function () {
            return this._rowHeight;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._rowHeight = value ? value.toLowerCase() : value;
            if (!Codes.isValidRowHeight(this._rowHeight)) {
                this._rowHeight = Codes.DEFAULT_ROW_HEIGHT;
            }
            this.rowHeightSubject.next(this._rowHeight);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OServiceComponent$$1.prototype, "quickFilter", {
        get: /**
         * @return {?}
         */
        function () {
            return this._quickFilter;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            val = Util.parseBoolean(String(val));
            this._quickFilter = val;
            if (val) {
                setTimeout(function () { return _this.registerQuickFilter(_this.searchInputComponent); }, 0);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.initialize = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.formLayoutManager && this.formLayoutManager.isTabMode() && this.formLayoutManager.oTabGroup) {
            this.formLayoutManagerTabIndex = this.formLayoutManager.oTabGroup.data.length;
            this.tabsSubscriptions = this.formLayoutManager.oTabGroup.onSelectedTabChange.subscribe(function () {
                if (_this.formLayoutManagerTabIndex !== _this.formLayoutManager.oTabGroup.selectedTabIndex) {
                    _this.updateStateStorage();
                    // when the storage is updated because a form layout manager tab change
                    // the alreadyStored control variable is changed to its initial value
                    // when the storage is updated because a form layout manager tab change
                    // the alreadyStored control variable is changed to its initial value
                    _this.alreadyStored = false;
                }
            });
            this.tabsSubscriptions.add(this.formLayoutManager.oTabGroup.onCloseTab.subscribe(function () {
                if (_this.formLayoutManagerTabIndex === _this.formLayoutManager.oTabGroup.selectedTabIndex) {
                    _this.updateStateStorage();
                }
            }));
        }
        _super.prototype.initialize.call(this);
        if (this.detailButtonInRow || this.editButtonInRow) {
            this.detailMode = Codes.DETAIL_MODE_NONE;
        }
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.afterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.afterViewInit.call(this);
        if (this.elRef) {
            this.elRef.nativeElement.removeAttribute('title');
        }
        if (this.formLayoutManager && this.formLayoutManager.isMainComponent(this)) {
            this.onTriggerUpdateSubscription = this.formLayoutManager.onTriggerUpdate.subscribe(function () {
                _this.reloadData();
            });
        }
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.destroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.destroy.call(this);
        if (this.onTriggerUpdateSubscription) {
            this.onTriggerUpdateSubscription.unsubscribe();
        }
        if (this.tabsSubscriptions) {
            this.tabsSubscriptions.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.isVisible = /**
     * @return {?}
     */
    function () {
        return this.ovisible;
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.hasControls = /**
     * @return {?}
     */
    function () {
        return this.controls;
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.hasTitle = /**
     * @return {?}
     */
    function () {
        return this.title !== undefined;
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.getSelectedItems = /**
     * @return {?}
     */
    function () {
        return this.selection.selected;
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.clearSelection = /**
     * @return {?}
     */
    function () {
        this.selection.clear();
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OServiceComponent$$1.prototype.setSelected = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this.selection.toggle(item);
    };
    /**
     * @param {?} route
     * @param {?} qParams
     * @param {?} relativeTo
     * @return {?}
     */
    OServiceComponent$$1.prototype.navigateToDetail = /**
     * @param {?} route
     * @param {?} qParams
     * @param {?} relativeTo
     * @return {?}
     */
    function (route, qParams, relativeTo) {
        /** @type {?} */
        var extras = {
            relativeTo: relativeTo
        };
        if (this.formLayoutManager && this.formLayoutManager.isMainComponent(this)) {
            qParams[Codes.IGNORE_CAN_DEACTIVATE] = true;
            this.formLayoutManager.setAsActiveFormLayoutManager();
        }
        extras[Codes.QUERY_PARAMS] = qParams;
        this.router.navigate(route, extras);
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.insertDetail = /**
     * @return {?}
     */
    function () {
        if (this.oFormLayoutDialog) {
            console.warn('Navigation is not available yet in a form layout manager with mode="dialog"');
            return;
        }
        /** @type {?} */
        var route = this.getInsertRoute();
        this.addFormLayoutManagerRoute(route);
        if (route.length > 0) {
            /** @type {?} */
            var relativeTo = this.recursiveInsert ? this.actRoute.parent : this.actRoute;
            /** @type {?} */
            var qParams = {};
            this.navigateToDetail(route, qParams, relativeTo);
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OServiceComponent$$1.prototype.viewDetail = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this.oFormLayoutDialog) {
            console.warn('Navigation is not available yet in a form layout manager with mode="dialog"');
            return;
        }
        /** @type {?} */
        var route = this.getItemModeRoute(item, 'detailFormRoute');
        this.addFormLayoutManagerRoute(route);
        if (route.length > 0) {
            /** @type {?} */
            var qParams = Codes.getIsDetailObject();
            /** @type {?} */
            var relativeTo = this.recursiveDetail ? this.actRoute.parent : this.actRoute;
            this.navigateToDetail(route, qParams, relativeTo);
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OServiceComponent$$1.prototype.editDetail = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this.oFormLayoutDialog) {
            console.warn('Navigation is not available yet in a form layout manager with mode="dialog"');
            return;
        }
        /** @type {?} */
        var route = this.getItemModeRoute(item, 'editFormRoute');
        this.addFormLayoutManagerRoute(route);
        if (route.length > 0) {
            /** @type {?} */
            var qParams = Codes.getIsDetailObject();
            /** @type {?} */
            var relativeTo = this.recursiveEdit ? this.actRoute.parent : this.actRoute;
            this.navigateToDetail(route, qParams, relativeTo);
        }
    };
    /**
     * @param {?} routeArr
     * @return {?}
     */
    OServiceComponent$$1.prototype.addFormLayoutManagerRoute = /**
     * @param {?} routeArr
     * @return {?}
     */
    function (routeArr) {
        if (this.formLayoutManager && routeArr.length > 0) {
            /** @type {?} */
            var compRoute = this.formLayoutManager.getRouteForComponent(this);
            if (compRoute && compRoute.length > 0) {
                routeArr.unshift.apply(routeArr, compRoute);
            }
        }
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.getEncodedParentKeys = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var encoded;
        if (Object.keys(this._pKeysEquiv).length > 0) {
            /** @type {?} */
            var pKeys = this.getParentKeysValues();
            if (Object.keys(pKeys).length > 0) {
                encoded = Util.encodeParentKeys(pKeys);
            }
        }
        return encoded;
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.getInsertRoute = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var route = [];
        if (Util.isDefined(this.detailFormRoute)) {
            route.push(this.detailFormRoute);
        }
        /** @type {?} */
        var insertRoute = Util.isDefined(this.insertFormRoute) ? this.insertFormRoute : Codes.DEFAULT_INSERT_ROUTE;
        route.push(insertRoute);
        /** @type {?} */
        var encodedParentKeys = this.getEncodedParentKeys();
        if (Util.isDefined(encodedParentKeys)) {
            /** @type {?} */
            var routeObj = {};
            routeObj[Codes.PARENT_KEYS_KEY] = encodedParentKeys;
            route.push(routeObj);
        }
        if (route.length > 0) {
            this.storeNavigationFormRoutes('insertFormRoute');
        }
        return route;
    };
    /**
     * @param {?} item
     * @param {?} modeRoute
     * @return {?}
     */
    OServiceComponent$$1.prototype.getItemModeRoute = /**
     * @param {?} item
     * @param {?} modeRoute
     * @return {?}
     */
    function (item, modeRoute) {
        /** @type {?} */
        var result = this.getRouteOfSelectedRow(item);
        if (result.length > 0) {
            if (Util.isDefined(this.detailFormRoute)) {
                result.unshift(this.detailFormRoute);
            }
            if (modeRoute === 'editFormRoute') {
                result.push(this.editFormRoute || Codes.DEFAULT_EDIT_ROUTE);
            }
        }
        if (result.length > 0 && !this.oFormLayoutDialog) {
            this.storeNavigationFormRoutes(modeRoute, this.getQueryConfiguration());
        }
        return result;
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.getQueryConfiguration = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = {
            keysValues: this.getKeysValues()
        };
        if (this.pageable) {
            result = Object.assign({
                serviceType: this.serviceType,
                queryArguments: this.queryArguments,
                entity: this.entity,
                service: this.service,
                queryMethod: this.pageable ? this.paginatedQueryMethod : this.queryMethod,
                totalRecordsNumber: this.getTotalRecordsNumber(),
                queryRows: this.queryRows,
                queryRecordOffset: Math.max(this.state.queryRecordOffset - this.queryRows, 0)
            }, result);
        }
        return result;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OServiceComponent$$1.prototype.getRouteOfSelectedRow = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var route = [];
        if (Util.isObject(item)) {
            this.keysArray.forEach(function (key) {
                if (Util.isDefined(item[key])) {
                    route.push(item[key]);
                }
            });
        }
        return route;
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.deleteLocalItems = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var selectedItems = this.getSelectedItems();
        for (var i = 0; i < selectedItems.length; ++i) {
            /** @type {?} */
            var selectedItem = selectedItems[i];
            /** @type {?} */
            var selectedItemKv = {};
            for (var k = 0; k < this.keysArray.length; ++k) {
                /** @type {?} */
                var key = this.keysArray[k];
                selectedItemKv[key] = selectedItem[key];
            }
            for (var j = this.dataArray.length - 1; j >= 0; --j) {
                /** @type {?} */
                var item = this.dataArray[j];
                /** @type {?} */
                var itemKv = {};
                for (var k = 0; k < this.keysArray.length; ++k) {
                    /** @type {?} */
                    var key = this.keysArray[k];
                    itemKv[key] = item[key];
                }
                /** @type {?} */
                var found = false;
                for (var k in selectedItemKv) {
                    if (selectedItemKv.hasOwnProperty(k)) {
                        found = itemKv.hasOwnProperty(k) && (selectedItemKv[k] === itemKv[k]);
                    }
                }
                if (found) {
                    this.dataArray.splice(j, 1);
                    break;
                }
            }
        }
        this.clearSelection();
    };
    /**
     * @param {?} options
     * @return {?}
     */
    OServiceComponent$$1.prototype.reinitialize = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        if (options && Object.keys(options).length) {
            /** @type {?} */
            var clonedOpts = Object.assign({}, options);
            if (clonedOpts.hasOwnProperty('entity')) {
                this.entity = clonedOpts.entity;
                if (this.oattrFromEntity) {
                    this.oattr = undefined;
                }
                delete clonedOpts.entity;
            }
            for (var prop in clonedOpts) {
                if (clonedOpts.hasOwnProperty(prop)) {
                    this[prop] = clonedOpts[prop];
                }
            }
            this.destroy();
            this.initialize();
        }
    };
    /**
     * Sets the `o-filter-builder` component that this component will use to filter its data.
     * @param {?} filterBuilder the `o-filter-builder` component.
     * @return {?}
     */
    OServiceComponent$$1.prototype.setFilterBuilder = /**
     * Sets the `o-filter-builder` component that this component will use to filter its data.
     * @param {?} filterBuilder the `o-filter-builder` component.
     * @return {?}
     */
    function (filterBuilder) {
        this.filterBuilder = filterBuilder;
    };
    /**
     * @param {?=} existingFilter
     * @return {?}
     */
    OServiceComponent$$1.prototype.getComponentFilter = /**
     * @param {?=} existingFilter
     * @return {?}
     */
    function (existingFilter) {
        if (existingFilter === void 0) { existingFilter = {}; }
        /** @type {?} */
        var filter$$1 = _super.prototype.getComponentFilter.call(this, existingFilter);
        /** @type {?} */
        var quickFilterExpr = this.getQuickFilterExpression();
        /** @type {?} */
        var filterBuilderExpr = this.getFilterBuilderExpression();
        /** @type {?} */
        var complexExpr = quickFilterExpr || filterBuilderExpr;
        if (quickFilterExpr && filterBuilderExpr) {
            complexExpr = FilterExpressionUtils.buildComplexExpression(quickFilterExpr, filterBuilderExpr, FilterExpressionUtils.OP_AND);
        }
        if (complexExpr && !Util.isDefined(filter$$1[FilterExpressionUtils.BASIC_EXPRESSION_KEY])) {
            filter$$1[FilterExpressionUtils.BASIC_EXPRESSION_KEY] = complexExpr;
        }
        else if (complexExpr) {
            filter$$1[FilterExpressionUtils.BASIC_EXPRESSION_KEY] =
                FilterExpressionUtils.buildComplexExpression(filter$$1[FilterExpressionUtils.BASIC_EXPRESSION_KEY], complexExpr, FilterExpressionUtils.OP_AND);
        }
        return filter$$1;
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.getQuickFilterExpression = /**
     * @return {?}
     */
    function () {
        if (this.pageable && Util.isDefined(this.quickFilterComponent)) {
            return this.quickFilterComponent.filterExpression;
        }
        return undefined;
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.getFilterBuilderExpression = /**
     * @return {?}
     */
    function () {
        // Add filter from o-filter-builder component
        if (Util.isDefined(this.filterBuilder)) {
            return this.filterBuilder.getExpression();
        }
        return undefined;
    };
    /**
     * @param {?} activeMode
     * @param {?=} queryConf
     * @return {?}
     */
    OServiceComponent$$1.prototype.storeNavigationFormRoutes = /**
     * @param {?} activeMode
     * @param {?=} queryConf
     * @return {?}
     */
    function (activeMode, queryConf) {
        /** @type {?} */
        var mainFormLayoutComp = this.formLayoutManager ? Util.isDefined(this.formLayoutManager.isMainComponent(this)) : undefined;
        this.navigationService.storeFormRoutes({
            mainFormLayoutManagerComponent: mainFormLayoutComp,
            detailFormRoute: this.detailFormRoute,
            editFormRoute: this.editFormRoute,
            insertFormRoute: Util.isDefined(this.insertFormRoute) ? this.insertFormRoute : Codes.DEFAULT_INSERT_ROUTE
        }, activeMode, queryConf);
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.saveDataNavigationInLocalStorage = /**
     * @return {?}
     */
    function () {
        // Save data of the list in navigation-data in the localstorage
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.getKeysValues = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var data = this.dataArray;
        /** @type {?} */
        var self = this;
        return data.map(function (row) {
            /** @type {?} */
            var obj = {};
            self.keysArray.forEach(function (key) {
                if (row[key] !== undefined) {
                    obj[key] = row[key];
                }
            });
            return obj;
        });
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.getRouteKey = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var route = '';
        if (this.formLayoutManager && !this.formLayoutManager.isMainComponent(this)) {
            route = this.router.url;
            /** @type {?} */
            var params = this.formLayoutManager.getParams();
            if (params) {
                route += '/' + (Object.keys(params).join('/'));
            }
        }
        else {
            route = _super.prototype.getRouteKey.call(this);
        }
        return route;
    };
    Object.defineProperty(OServiceComponent$$1.prototype, "elementRef", {
        get: /**
         * @return {?}
         */
        function () {
            return this.elRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.initializeState = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var routeKey = _super.prototype.getRouteKey.call(this);
        if (this.formLayoutManager && this.formLayoutManager.isTabMode() && !this.formLayoutManager.isMainComponent(this)) {
            try {
                /** @type {?} */
                var params = this.formLayoutManager.oTabGroup.state.tabsData[0].params;
                if (params) {
                    routeKey = this.router.url;
                    routeKey += '/' + (Object.keys(params).join('/'));
                }
            }
            catch (e) {
                //
            }
        }
        // Get previous status
        this.state = this.localStorageService.getComponentStorage(this, routeKey);
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.showCaseSensitiveCheckbox = /**
     * @return {?}
     */
    function () {
        return !this.pageable;
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    OServiceComponent$$1.prototype.registerQuickFilter = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        var _this = this;
        /** @type {?} */
        var quickFilter = (/** @type {?} */ (arg));
        if (Util.isDefined(this.quickFilterComponent)) {
            // avoiding to register a quickfiltercomponent if it already exists one
            return;
        }
        this.quickFilterComponent = quickFilter;
        if (Util.isDefined(this.quickFilterComponent)) {
            if (this.state.hasOwnProperty('filterValue')) {
                this.quickFilterComponent.setValue(this.state.filterValue);
            }
            if (this.state.hasOwnProperty('quickFilterActiveColumns')) {
                /** @type {?} */
                var parsedArr = Util.parseArray(this.state.quickFilterActiveColumns, true);
                this.quickFilterComponent.setActiveColumns(parsedArr);
            }
            this.quickFilterComponent.onSearch.subscribe(function (val) { return _this.filterData(val); });
        }
    };
    /**
     * @param {?=} value
     * @param {?=} loadMore
     * @return {?}
     */
    OServiceComponent$$1.prototype.filterData = /**
     * @param {?=} value
     * @param {?=} loadMore
     * @return {?}
     */
    function (value, loadMore) {
        //
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.isFilterCaseSensitive = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var useQuickFilterValue = Util.isDefined(this.quickFilterComponent) && this.showCaseSensitiveCheckbox();
        if (useQuickFilterValue) {
            return this.quickFilterComponent.filterCaseSensitive;
        }
        return this.filterCaseSensitive;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OServiceComponent$$1.prototype.configureFilterValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var returnVal = value;
        if (value && value.length > 0) {
            if (!value.startsWith('*')) {
                returnVal = '*' + returnVal;
            }
            if (!value.endsWith('*')) {
                returnVal = returnVal + '*';
            }
        }
        return returnVal;
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.getQuickFilterValue = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = '';
        if (Util.isDefined(this.quickFilterComponent)) {
            return this.quickFilterComponent.getValue() || '';
        }
        return result;
    };
    /**
     * @return {?}
     */
    OServiceComponent$$1.prototype.getQuickFilterColumns = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = this.quickFilterColArray;
        if (Util.isDefined(this.quickFilterComponent)) {
            result = this.quickFilterComponent.getActiveColumns();
        }
        return result;
    };
    OServiceComponent$$1.DEFAULT_INPUTS_O_SERVICE_COMPONENT = DEFAULT_INPUTS_O_SERVICE_COMPONENT$$1;
    OServiceComponent$$1.propDecorators = {
        searchInputComponent: [{ type: core.ViewChild, args: [(core.forwardRef(function () { return OSearchInputComponent; })),] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceComponent$$1.prototype, "ovisible", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceComponent$$1.prototype, "oenabled", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceComponent$$1.prototype, "controls", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceComponent$$1.prototype, "recursiveDetail", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceComponent$$1.prototype, "detailButtonInRow", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceComponent$$1.prototype, "recursiveEdit", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceComponent$$1.prototype, "editButtonInRow", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceComponent$$1.prototype, "insertButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceComponent$$1.prototype, "recursiveInsert", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OServiceComponent$$1.prototype, "filterCaseSensitive", void 0);
    return OServiceComponent$$1;
}(OServiceBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OListItemComponent = /** @class */ (function () {
    function OListItemComponent(elRef, _renderer, _injector, _list) {
        this.elRef = elRef;
        this._renderer = _renderer;
        this._injector = _injector;
        this._list = _list;
        this._isSelected = false;
    }
    Object.defineProperty(OListItemComponent.prototype, "_hasAvatar", {
        set: /**
         * @param {?} avatar
         * @return {?}
         */
        function (avatar) {
            /** @type {?} */
            var listItemNativeEl = this.elRef.nativeElement.getElementsByTagName('mat-list-item');
            if (listItemNativeEl && listItemNativeEl.length === 1) {
                if ((avatar !== null && avatar !== undefined)) {
                    this._renderer.addClass(listItemNativeEl[0], 'mat-list-avatar');
                }
                else {
                    this._renderer.removeClass(listItemNativeEl[0], 'mat-list-avatar');
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OListItemComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var matLinesRef = this._lines;
        /** @type {?} */
        var ngAfterContentInitOriginal = this._innerListItem.ngAfterContentInit;
        this._innerListItem.ngAfterContentInit = function () {
            /** @type {?} */
            var emptyDiv = this._element.nativeElement.querySelector('.mat-list-text:empty');
            if (emptyDiv) {
                emptyDiv.remove();
            }
            this._lines = matLinesRef;
            ngAfterContentInitOriginal.apply(this);
        };
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OListItemComponent.prototype.onClick = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (!this._list.detailButtonInRow) {
            this._list.onItemDetailClick(this);
        }
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OListItemComponent.prototype.onDoubleClick = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (!this._list.detailButtonInRow) {
            this._list.onItemDetailDoubleClick(this);
        }
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OListItemComponent.prototype.onDetailIconClicked = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (Util.isDefined(e)) {
            e.stopPropagation();
        }
        this._list.viewDetail(this.modelData);
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OListItemComponent.prototype.onEditIconClicked = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (Util.isDefined(e)) {
            e.stopPropagation();
        }
        this._list.editDetail(this.modelData);
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OListItemComponent.prototype.setItemData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (!this.modelData) {
            this.modelData = data;
        }
    };
    /**
     * @return {?}
     */
    OListItemComponent.prototype.getItemData = /**
     * @return {?}
     */
    function () {
        return this.modelData;
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OListItemComponent.prototype.onCheckboxChange = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (this._list.selectable) {
            this._list.setSelected(this.modelData);
        }
    };
    Object.defineProperty(OListItemComponent.prototype, "isSelected", {
        get: /**
         * @return {?}
         */
        function () {
            return this._list.selection.isSelected(this.modelData);
        },
        enumerable: true,
        configurable: true
    });
    OListItemComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-list-item',
                    template: "\n    <mat-list-item #innerListItem>\n      <div class=\"o-list-row-action o-list-item-selection-check\" *ngIf=\"_list && _list.selectable\">\n        <mat-checkbox [checked]=\"isSelected\" (change)=\"onCheckboxChange($event)\"></mat-checkbox>\n      </div>\n      <ng-content select=\"[o-list-item-avatar], [matListAvatar], [matListIcon]\"> </ng-content>\n      <div class=\"mat-list-text\">\n        <ng-content select=\"[matLine]\"></ng-content>\n      </div>\n      <ng-content></ng-content>\n      <div fxLayout=\"row\" class=\"row-buttons-container\">\n        <div class=\"o-list-row-action o-list-item-icon\" *ngIf=\"_list && _list.editButtonInRow\" (click)=\"onEditIconClicked($event)\">\n          <mat-icon class=\"material-icons\">{{ _list.editButtonInRowIcon }}</mat-icon>\n        </div>\n        <div class=\"o-list-row-action o-list-item-icon\" *ngIf=\"_list && _list.detailButtonInRow\" (click)=\"onDetailIconClicked($event)\">\n          <mat-icon class=\"material-icons\">{{ _list.detailButtonInRowIcon }}</mat-icon>\n        </div>\n      </div>\n    </mat-list-item>\n  ",
                    styles: ["\n    .o-list-item{display:flex}.o-list-item .mat-list-item{width:100%}.o-list-item .mat-list-item .o-list-item-selection-check{padding-right:16px}.o-list-item .mat-list-item .row-buttons-container .o-list-row-action{height:24px;text-align:center;cursor:pointer}.mat-list[dense] .o-list-item .o-list-row-action .mat-checkbox-inner-container{height:16px;width:16px}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-list-item]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OListItemComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: core.Injector },
        { type: OListComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OListComponent; }),] }] }
    ]; };
    OListItemComponent.propDecorators = {
        _lines: [{ type: core.ContentChildren, args: [material.MatLine,] }],
        _innerListItem: [{ type: core.ViewChild, args: ['innerListItem',] }],
        _hasAvatar: [{ type: core.ContentChild, args: [material.MatListAvatarCssMatStyler,] }]
    };
    return OListItemComponent;
}());
var OListItemModule = /** @class */ (function () {
    function OListItemModule() {
    }
    OListItemModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OListItemComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OListItemComponent]
                },] },
    ];
    return OListItemModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_LIST = OServiceComponent$$1.DEFAULT_INPUTS_O_SERVICE_COMPONENT.concat([
    'quickFilterColumns: quick-filter-columns',
    'refreshButton: refresh-button',
    'route',
    'selectable',
    'odense : dense',
    'deleteButton: delete-button',
    'sortColumns: sort-columns',
    'insertButtonPosition:insert-button-position',
    'insertButtonFloatable:insert-button-floatable'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_LIST = [
    'onClick',
    'onDoubleClick',
    'onInsertButtonClick',
    'onItemDeleted',
    'onDataLoaded',
    'onPaginatedDataLoaded'
];
var 0$2$1 = dataServiceFactory;
var OListComponent = /** @class */ (function (_super) {
    __extends(OListComponent, _super);
    function OListComponent(injector, elRef, form) {
        var _this = _super.call(this, injector, elRef, form) || this;
        /* Inputs */
        _this.refreshButton = true;
        _this.selectable = false;
        _this.odense = false;
        _this.deleteButton = true;
        _this.insertButtonFloatable = true;
        _this.sortColArray = [];
        _this.onClick = new core.EventEmitter();
        _this.onDoubleClick = new core.EventEmitter();
        _this.onInsertButtonClick = new core.EventEmitter();
        _this.onItemDeleted = new core.EventEmitter();
        _this.onDataLoaded = new core.EventEmitter();
        _this.onPaginatedDataLoaded = new core.EventEmitter();
        _this.selection = new SelectionModel(true, []);
        _this.enabledDeleteButton = false;
        _this.insertButtonPosition = 'bottom';
        _this.dataResponseArray = [];
        _this.storePaginationState = false;
        _this.subscription = new Subscription();
        return _this;
    }
    /**
     * @return {?}
     */
    OListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.initialize();
        this.subscription.add(this.selection.changed.subscribe(function () { return _this.enabledDeleteButton = !_this.selection.isEmpty(); }));
    };
    /**
     * @return {?}
     */
    OListComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.afterViewInit.call(this);
        this.parseSortColumns();
        this.filterCaseSensitive = this.state.hasOwnProperty('filter-case-sensitive') ?
            this.state['filter-case-sensitive'] : this.filterCaseSensitive;
        if (Util.isDefined(this.searchInputComponent)) {
            this.registerQuickFilter(this.searchInputComponent);
        }
    };
    /**
     * @return {?}
     */
    OListComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.setListItemsData();
        this.listItemComponents.changes.subscribe(function () { return _this.setListItemsData(); });
        this.setListItemDirectivesData();
        this.listItemDirectives.changes.subscribe(function () { return _this.setListItemDirectivesData(); });
    };
    /**
     * @return {?}
     */
    OListComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy();
        this.subscription.unsubscribe();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    OListComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (typeof (changes['staticData']) !== 'undefined') {
            this.dataResponseArray = changes['staticData'].currentValue;
            /** @type {?} */
            var filter$$1 = (this.state && this.state.filterValue) ? this.state.filterValue : undefined;
            this.filterData(filter$$1);
        }
    };
    /**
     * @return {?}
     */
    OListComponent.prototype.getComponentKey = /**
     * @return {?}
     */
    function () {
        return 'OListComponent_' + this.oattr;
    };
    /**
     * @return {?}
     */
    OListComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        _super.prototype.initialize.call(this);
        if (this.staticData && this.staticData.length) {
            this.dataResponseArray = this.staticData;
        }
        if (!Util.isDefined(this.quickFilterColumns)) {
            this.quickFilterColumns = this.columns;
        }
        this.quickFilterColArray = Util.parseArray(this.quickFilterColumns, true);
        /** @type {?} */
        var initialQueryLength;
        if (this.state.hasOwnProperty('queryRecordOffset')) {
            initialQueryLength = this.state.queryRecordOffset;
        }
        this.state.queryRecordOffset = 0;
        if (!this.state.hasOwnProperty('totalQueryRecordsNumber')) {
            this.state.totalQueryRecordsNumber = 0;
        }
        if (this.queryOnInit) {
            /** @type {?} */
            var queryArgs = {
                offset: 0,
                length: initialQueryLength || this.queryRows
            };
            this.queryData(void 0, queryArgs);
        }
    };
    /**
     * @param {?} options
     * @return {?}
     */
    OListComponent.prototype.reinitialize = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        _super.prototype.reinitialize.call(this, options);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OListComponent.prototype.registerListItemDirective = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var _this = this;
        if (item) {
            item.onClick(function (directiveItem) { return _this.onItemDetailClick(directiveItem); });
            item.onDoubleClick(function (directiveItem) { return _this.onItemDetailDoubleClick(directiveItem); });
        }
    };
    /**
     * @return {?}
     */
    OListComponent.prototype.getDense = /**
     * @return {?}
     */
    function () {
        return this.odense;
    };
    /**
     * @param {?} onNext
     * @return {?}
     */
    OListComponent.prototype.onListItemClicked = /**
     * @param {?} onNext
     * @return {?}
     */
    function (onNext) {
        return ObservableWrapper.subscribe(this.onClick, onNext);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OListComponent.prototype.onItemDetailClick = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var data = item.getItemData();
        if (this.oenabled && this.detailMode === Codes.DETAIL_MODE_CLICK) {
            this.saveDataNavigationInLocalStorage();
            this.viewDetail(data);
        }
        ObservableWrapper.callEmit(this.onClick, data);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OListComponent.prototype.onItemDetailDoubleClick = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var data = item.getItemData();
        if (this.oenabled && Codes.isDoubleClickMode(this.detailMode)) {
            this.saveDataNavigationInLocalStorage();
            this.viewDetail(data);
        }
        ObservableWrapper.callEmit(this.onDoubleClick, data);
    };
    /**
     * @return {?}
     */
    OListComponent.prototype.getDataToStore = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var dataToStore = _super.prototype.getDataToStore.call(this);
        if (!this.storePaginationState) {
            delete dataToStore['queryRecordOffset'];
        }
        if (this.quickFilter && Util.isDefined(this.quickFilterComponent)) {
            dataToStore['quickFilterActiveColumns'] = this.quickFilterComponent.getActiveColumns().join(Codes.ARRAY_INPUT_SEPARATOR);
        }
        dataToStore['filter-case-sensitive'] = this.isFilterCaseSensitive();
        return dataToStore;
    };
    /**
     * @return {?}
     */
    OListComponent.prototype.reloadData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var queryArgs = {};
        if (this.pageable) {
            this.state.queryRecordOffset = 0;
            queryArgs = {
                length: Math.max(this.queryRows, this.dataResponseArray.length),
                replace: true
            };
        }
        if (this.selectable) {
            // this.selectedItems = [];
            this.clearSelection();
            this.state.selectedIndexes = [];
        }
        this.queryData(void 0, queryArgs);
    };
    /**
     * @return {?}
     */
    OListComponent.prototype.reloadPaginatedDataFromStart = /**
     * @return {?}
     */
    function () {
        this.dataResponseArray = [];
        this.reloadData();
    };
    /**
     * Filters data locally
     * @param {?} value the filtering value
     * @param {?=} loadMore
     * @return {?}
     */
    OListComponent.prototype.filterData = /**
     * Filters data locally
     * @param {?} value the filtering value
     * @param {?=} loadMore
     * @return {?}
     */
    function (value, loadMore) {
        if (this.state) {
            this.state.filterValue = value;
        }
        if (this.pageable) {
            /** @type {?} */
            var queryArgs = {
                offset: 0,
                length: this.queryRows,
                replace: true
            };
            this.queryData(void 0, queryArgs);
        }
        else if (value && value.length > 0 && this.dataResponseArray && this.dataResponseArray.length > 0) {
            /** @type {?} */
            var self_1 = this;
            /** @type {?} */
            var caseSensitive_1 = this.isFilterCaseSensitive();
            /** @type {?} */
            var filteredData = this.dataResponseArray.filter(function (item) {
                return self_1.getQuickFilterColumns().some(function (col) {
                    /** @type {?} */
                    var regExpStr = Util.escapeSpecialCharacter(Util.normalizeString(value, !caseSensitive_1));
                    return new RegExp(regExpStr).test(Util.normalizeString(item[col] + '', !caseSensitive_1));
                });
            });
            this.setDataArray(filteredData);
        }
        else {
            this.setDataArray(this.dataResponseArray);
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OListComponent.prototype.isItemSelected = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.selection.isSelected(item);
    };
    /**
     * @param {?} item
     * @param {?} isSelected
     * @return {?}
     */
    OListComponent.prototype.updateSelectedState = /**
     * @param {?} item
     * @param {?} isSelected
     * @return {?}
     */
    function (item, isSelected) {
        /** @type {?} */
        var selectedIndexes = this.state.selectedIndexes || [];
        /** @type {?} */
        var itemIndex = this.dataResponseArray.indexOf(item);
        if (isSelected && selectedIndexes.indexOf(itemIndex) === -1) {
            selectedIndexes.push(itemIndex);
        }
        else if (!isSelected) {
            selectedIndexes.splice(selectedIndexes.indexOf(itemIndex), 1);
        }
        this.state.selectedIndexes = selectedIndexes;
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OListComponent.prototype.onScroll = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (this.pageable) {
            /** @type {?} */
            var pendingRegistries = this.dataResponseArray.length < this.state.totalQueryRecordsNumber;
            if (!this.loadingSubject.value && pendingRegistries) {
                /** @type {?} */
                var element = /** @type {?} */ (e.target);
                if (element.offsetHeight + element.scrollTop + 5 >= element.scrollHeight) {
                    /** @type {?} */
                    var queryArgs = {
                        offset: this.state.queryRecordOffset,
                        length: this.queryRows
                    };
                    this.queryData(void 0, queryArgs);
                }
            }
        }
    };
    /**
     * @param {?=} clearSelectedItems
     * @return {?}
     */
    OListComponent.prototype.remove = /**
     * @param {?=} clearSelectedItems
     * @return {?}
     */
    function (clearSelectedItems) {
        var _this = this;
        if (clearSelectedItems === void 0) { clearSelectedItems = false; }
        /** @type {?} */
        var selectedItems = this.getSelectedItems();
        if (selectedItems.length > 0) {
            this.dialogService.confirm('CONFIRM', 'MESSAGES.CONFIRM_DELETE').then(function (res) {
                if (res === true) {
                    if (_this.dataService && (_this.deleteMethod in _this.dataService) && _this.entity && (_this.keysArray.length > 0)) {
                        /** @type {?} */
                        var filters = ServiceUtils$$1.getArrayProperties(selectedItems, _this.keysArray);
                        merge(filters.map((function (kv) { return _this.dataService[_this.deleteMethod](kv, _this.entity); }))).subscribe(function (obs) { return obs.subscribe(function () {
                            ObservableWrapper.callEmit(_this.onItemDeleted, selectedItems);
                        }, function (error) {
                            _this.dialogService.alert('ERROR', 'MESSAGES.ERROR_DELETE');
                        }, function () {
                            _this.reloadData();
                        }); });
                    }
                    else {
                        _this.deleteLocalItems();
                    }
                }
                else if (clearSelectedItems) {
                    _this.clearSelection();
                }
            });
        }
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OListComponent.prototype.add = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        this.onInsertButtonClick.emit(e);
        _super.prototype.insertDetail.call(this);
    };
    /**
     * @return {?}
     */
    OListComponent.prototype.parseSortColumns = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var sortColumnsParam = this.state['sort-columns'] || this.sortColumns;
        this.sortColArray = ServiceUtils$$1.parseSortColumns(sortColumnsParam);
    };
    /**
     * @param {?} filter
     * @param {?=} ovrrArgs
     * @return {?}
     */
    OListComponent.prototype.getQueryArguments = /**
     * @param {?} filter
     * @param {?=} ovrrArgs
     * @return {?}
     */
    function (filter$$1, ovrrArgs) {
        /** @type {?} */
        var queryArguments = _super.prototype.getQueryArguments.call(this, filter$$1, ovrrArgs);
        if (this.pageable) {
            queryArguments[6] = this.sortColArray;
        }
        return queryArguments;
    };
    /**
     * @return {?}
     */
    OListComponent.prototype.setListItemsData = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.listItemComponents.forEach(function (element, index) { return element.setItemData(_this.dataResponseArray[index]); });
    };
    /**
     * @return {?}
     */
    OListComponent.prototype.setListItemDirectivesData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        this.listItemDirectives.forEach(function (element, index) {
            element.setItemData(self.dataResponseArray[index]);
            element.setListComponent(self);
            self.registerListItemDirective(element);
        });
    };
    /**
     * @return {?}
     */
    OListComponent.prototype.saveDataNavigationInLocalStorage = /**
     * @return {?}
     */
    function () {
        _super.prototype.saveDataNavigationInLocalStorage.call(this);
        this.storePaginationState = true;
    };
    /**
     * @param {?} data
     * @param {?=} sqlTypes
     * @param {?=} replace
     * @return {?}
     */
    OListComponent.prototype.setData = /**
     * @param {?} data
     * @param {?=} sqlTypes
     * @param {?=} replace
     * @return {?}
     */
    function (data, sqlTypes, replace) {
        if (Util.isArray(data)) {
            /** @type {?} */
            var respDataArray = data;
            if (this.pageable && !replace) {
                respDataArray = (this.dataResponseArray || []).concat(data);
            }
            /** @type {?} */
            var selectedIndexes = this.state.selectedIndexes || [];
            for (var _i = 0, selectedIndexes_1 = selectedIndexes; _i < selectedIndexes_1.length; _i++) {
                var selIndex = selectedIndexes_1[_i];
                // for (let i = 0; i < selectedIndexes.length; i++) {
                if (selIndex < this.dataResponseArray.length) {
                    // this.selectedItems.push(this.dataResponseArray[selIndex]);
                    this.selection.select(this.dataResponseArray[selIndex]);
                }
            }
            this.dataResponseArray = respDataArray;
            if (!this.pageable) {
                this.filterData(this.state.filterValue);
            }
            else {
                this.setDataArray(this.dataResponseArray);
            }
        }
        else {
            this.setDataArray([]);
        }
        if (this.loaderSubscription) {
            this.loaderSubscription.unsubscribe();
        }
        if (this.pageable) {
            ObservableWrapper.callEmit(this.onPaginatedDataLoaded, data);
        }
        ObservableWrapper.callEmit(this.onDataLoaded, this.dataResponseArray);
    };
    OListComponent.DEFAULT_INPUTS_O_LIST = DEFAULT_INPUTS_O_LIST;
    OListComponent.DEFAULT_OUTPUTS_O_LIST = DEFAULT_OUTPUTS_O_LIST;
    OListComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-list',
                    providers: [
                        { provide: OntimizeService$$1, useFactory: 0$2$1, deps: [core.Injector] }
                    ],
                    inputs: DEFAULT_INPUTS_O_LIST,
                    outputs: DEFAULT_OUTPUTS_O_LIST,
                    template: "\n    <div class=\"o-list-container\" [style.display]=\"isVisible()? '' : 'none'\" fxFill>\n      <div *ngIf=\"loading | async\" fxLayoutAlign=\"center center\"\n        [class.pageable-loading]=\"pageable && state.queryRecordOffset > 0\" class=\"spinner-container\">\n        <mat-progress-spinner strokeWidth=\"3\" mode=\"indeterminate\"></mat-progress-spinner>\n      </div>\n\n      <mat-toolbar *ngIf=\"hasControls()\" [class.dense]=\"odense\">\n        <div class=\"mat-toolbar-tools\" fxLayout=\"row\" fxFill fxLayoutAlign=\"start center\">\n          <button *ngIf=\"insertButton && !insertButtonFloatable\" type=\"button\" mat-icon-button aria-label=\"Insert\"\n            (click)=\"add($event)\">\n            <mat-icon svgIcon=\"ontimize:add\"></mat-icon>\n          </button>\n          <button type=\"button\" mat-icon-button aria-label=\"Refresh\" (click)=\"reloadData()\" *ngIf=\"refreshButton\">\n            <mat-icon svgIcon=\"ontimize:autorenew\"></mat-icon>\n          </button>\n\n          <button *ngIf=\"deleteButton\" type=\"button\" mat-icon-button aria-label=\"Delete\" [disabled]=\"!enabledDeleteButton\"\n            [class.disabled]=\"!enabledDeleteButton\" (click)=\"remove()\">\n            <mat-icon svgIcon=\"ontimize:delete\"></mat-icon>\n          </button>\n          <div fxLayoutAlign=\"center center\" fxFlex>\n            <span *ngIf=\"hasTitle()\" fxLayoutAlign=\"center center\">{{ title | oTranslate }}</span>\n          </div>\n          <o-search-input *ngIf=\"quickFilter\" [filter-case-sensitive]=\"filterCaseSensitive\"\n            [show-case-sensitive-checkbox]=\"showCaseSensitiveCheckbox()\" [columns]=\"quickFilterColumns\" placeholder=\"\">\n          </o-search-input>\n        </div>\n      </mat-toolbar>\n\n      <div fxLayout=\"column\" class=\"o-list-content\" [class.o-list-content-toolbar]=\"hasControls() && !odense\"\n        [class.o-list-content-toolbar-dense]=\"hasControls() && odense\">\n\n        <!--MAT-LIST-->\n        <mat-list [attr.dense]=\"odense || undefined\" (scroll)=\"onScroll($event)\" [class.selectable]=\"selectable\"\n          [class.o-list-item-has-buttons]=\"insertButton && (editButtonInRow || detailButtonInRow)\">\n\n          <mat-list-item *ngIf=\"!getDataArray().length\" fxLayout=\"row\" fxLayoutAlign=\"center center\"\n            style=\"cursor: default;\">\n            <h3 matLine>\n              {{ 'TABLE.EMPTY' | oTranslate }}\n              <ng-container *ngIf=\"getQuickFilterValue().length > 0\">\n                {{ 'TABLE.EMPTY_USING_FILTER' | oTranslate : {values: [getQuickFilterValue()]} }}\n              </ng-container>\n            </h3>\n          </mat-list-item>\n          <ng-content></ng-content>\n        </mat-list>\n\n        <!--INSERT BUTTONcd -->\n        <button type=\"button\" *ngIf=\"insertButton && insertButtonFloatable && odense\" mat-mini-fab (click)=\"add($event)\"\n          class=\"add-button\" [class.add-button-bottom]=\"insertButtonPosition ==='bottom'\"\n          [class.add-button-top]=\"insertButtonPosition ==='top'\">\n          <mat-icon svgIcon=\"ontimize:add\"></mat-icon>\n        </button>\n        <button type=\"button\" *ngIf=\"insertButton && insertButtonFloatable && !odense\" mat-fab (click)=\"add($event)\"\n          class=\"add-button add-button-bottom\" [class.add-button-bottom]=\"insertButtonPosition ==='bottom'\"\n          [class.add-button-top]=\"insertButtonPosition ==='top'\">\n          <mat-icon svgIcon=\"ontimize:add\"></mat-icon>\n        </button>\n      </div>\n    </div>\n  ",
                    styles: ["\n    ::-webkit-input-placeholder{color:#8E0C39}:-moz-placeholder{color:#8E0C39;opacity:1}::-moz-placeholder{color:#8E0C39;opacity:1}:-ms-input-placeholder{color:#8E0C39}:placeholder-shown{color:#8E0C39}.o-list-container{position:relative;flex-direction:column}.o-list-container .mat-toolbar.dense{height:48px}.o-list-container .o-list-content{height:100%}.o-list-container .o-list-content.o-list-content-toolbar{height:calc(100% - 64px)}.o-list-container .o-list-content.o-list-content-toolbar-dense{height:calc(100% - 48px)}.o-list-container .o-list-content.o-list-content-toolbar-dense .add-button.add-button-top{top:60px}.o-list-container .o-list-title{font-size:1.5em}.o-list-container .spinner-container{position:absolute;top:0;bottom:0;left:0;right:0;z-index:500}.o-list-container .spinner-container:not(.pageable-loading){top:0;background:#fff}.o-list-container .spinner-container.pageable-loading{background:rgba(255,255,255,0.5)}.o-list-container .spinner-container path{stroke-width:5px !important}.o-list-container .mat-list{overflow:auto}.o-list-container .mat-list .mat-3-line .o-custom-list-item{position:relative}.o-list-container .mat-list .o-custom-list-item{max-width:100%;width:100%}.o-list-container .mat-list .o-custom-list-item .o-list-item-icon{cursor:pointer;padding-right:6px}.o-list-container .mat-list.o-list-item-has-buttons .o-list-item .mat-list-item-content{padding-right:72px}.o-list-container .mat-list.o-list-item-has-buttons[dense] .o-list-item .mat-list-item-content{padding-right:56px}.o-list-container .mat-list .o-list-item.mat-card,.o-list-container .mat-list .o-list-item.mat-list-item{margin:6px 0}.o-list-container .add-button{right:12px;position:absolute}.o-list-container .add-button.add-button-bottom{bottom:12px}.o-list-container .add-button.add-button-top{top:88px}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-list]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OListComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: core.ElementRef },
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] }
    ]; };
    OListComponent.propDecorators = {
        listItemComponents: [{ type: core.ContentChildren, args: [OListItemComponent,] }],
        listItemDirectives: [{ type: core.ContentChildren, args: [OListItemDirective,] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OListComponent.prototype, "refreshButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OListComponent.prototype, "selectable", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OListComponent.prototype, "odense", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OListComponent.prototype, "deleteButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OListComponent.prototype, "insertButtonFloatable", void 0);
    return OListComponent;
}(OServiceComponent$$1));
var OListModule = /** @class */ (function () {
    function OListModule() {
    }
    OListModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OListComponent],
                    imports: [common.CommonModule, OListItemModule, OSearchInputModule, OSharedModule, router.RouterModule],
                    exports: [OListComponent],
                    entryComponents: [material.MatCheckbox]
                },] },
    ];
    return OListModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_CONTEXT_MENU_ITEMS = [
    'attr',
    'ovisible: visible'
];
var OComponentMenuItems = /** @class */ (function () {
    function OComponentMenuItems() {
        this.ovisible = true;
        this.type = OComponentMenuItems.TYPE_GROUP_MENU;
    }
    Object.defineProperty(OComponentMenuItems.prototype, "isVisible", {
        get: /**
         * @return {?}
         */
        function () {
            return this.parseInput(this.ovisible);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @param {?=} defaultValue
     * @return {?}
     */
    OComponentMenuItems.prototype.parseInput = /**
     * @param {?} value
     * @param {?=} defaultValue
     * @return {?}
     */
    function (value, defaultValue) {
        if (value instanceof Function || typeof value === 'boolean') {
            return value;
        }
        return Util.parseBoolean(value, defaultValue);
    };
    OComponentMenuItems.TYPE_ITEM_MENU = 'item_menu';
    OComponentMenuItems.TYPE_GROUP_MENU = 'item_group';
    OComponentMenuItems.TYPE_SEPARATOR_MENU = 'item_separator';
    return OComponentMenuItems;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_CONTEXT_MENU_CONTENT_ITEM_INPUTS = [
    'items',
    'class'
];
var OWrapperContentMenuComponent = /** @class */ (function () {
    function OWrapperContentMenuComponent(injector, menuService) {
        this.injector = injector;
        this.menuService = menuService;
    }
    /**
     * @param {?} item
     * @param {?=} event
     * @return {?}
     */
    OWrapperContentMenuComponent.prototype.onClick = /**
     * @param {?} item
     * @param {?=} event
     * @return {?}
     */
    function (item, event) {
        item.triggerExecute(item.data, event);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OWrapperContentMenuComponent.prototype.isGroup = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var isGroup = false;
        if (item && item.children && item.children.length > 0) {
            isGroup = true;
        }
        return isGroup;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OWrapperContentMenuComponent.prototype.isSepararor = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var isSepararor = false;
        if (item && item.type && item.type === OComponentMenuItems.TYPE_SEPARATOR_MENU) {
            isSepararor = true;
        }
        return isSepararor;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OWrapperContentMenuComponent.prototype.isItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var isItem = false;
        if (item && item.type && item.type === OComponentMenuItems.TYPE_ITEM_MENU) {
            isItem = true;
        }
        return isItem;
    };
    OWrapperContentMenuComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-wrapper-content-menu',
                    template: "\n    <mat-menu #childMenu=\"matMenu\" [class]=\"class\" [overlapTrigger]=\"false\" [hasBackdrop]=\"false\">\n      <ng-container *ngFor=\"let child of items\">\n        <!-- Handle branch node menu items -->\n        <span *ngIf=\"isGroup(child) && child.isVisible\">\n          <button mat-menu-item color=\"primary\" [matMenuTriggerFor]=\"menu.childMenu\" [disabled]=\"child.disabled\">\n            <mat-icon *ngIf=\"child.svgIcon !== undefined\" [svgIcon]=\"child.svgIcon\"></mat-icon>\n            <mat-icon *ngIf=\"child.svgIcon === undefined\">{{ child.icon }}</mat-icon>\n            <span>{{ child.label | oTranslate}}</span>\n          </button>\n          <o-wrapper-content-menu #menu [items]=\"child.children\" [class]=\"class\"></o-wrapper-content-menu>\n        </span>\n        <!-- Handle leaf node menu items -->\n        <button mat-menu-item (click)=\"onClick(child, $event)\" [disabled]=\"child.disabled\" *ngIf=\"isItem(child) && child.isVisible\">\n          <mat-icon *ngIf=\"child.svgIcon !== undefined\" [svgIcon]=\"child.svgIcon\"></mat-icon>\n          <mat-icon *ngIf=\"child.svgIcon === undefined\">{{ child.icon }}</mat-icon>\n          <span>{{ child.label | oTranslate}} </span>\n        </button>\n        <!-- separator leaf node menu items -->\n        <mat-divider *ngIf=\"isSepararor(child) && child.isVisible\"></mat-divider>\n      </ng-container>\n    </mat-menu>\n  ",
                    styles: ["\n    mat-divider.mat-divider:first-child,mat-divider.mat-divider:last-child{display:none}.mat-icon{display:inline-flex}\n  "],
                    inputs: DEFAULT_CONTEXT_MENU_CONTENT_ITEM_INPUTS
                },] },
    ];
    /** @nocollapse */
    OWrapperContentMenuComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: OContextMenuService }
    ]; };
    OWrapperContentMenuComponent.propDecorators = {
        items: [{ type: core.Input }],
        childMenu: [{ type: core.ViewChild, args: ['childMenu',] }],
        menu: [{ type: core.ViewChild, args: [OWrapperContentMenuComponent,] }]
    };
    return OWrapperContentMenuComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_CONTEXT_MENU_CONTENT_INPUTS = [
    'menuItems',
    'overlay',
    'data',
    'menuClass'
];
/** @type {?} */
var DEFAULT_CONTEXT_MENU_CONTENT_OUTPUTS = [
    'execute',
    'close'
];
var OContextMenuContentComponent = /** @class */ (function () {
    function OContextMenuContentComponent(injector, menuService) {
        this.injector = injector;
        this.menuService = menuService;
        this.menuItems = [];
        this.execute = new core.EventEmitter();
    }
    /**
     * @return {?}
     */
    OContextMenuContentComponent.prototype.click = /**
     * @return {?}
     */
    function () {
        this.close();
    };
    /**
     * @return {?}
     */
    OContextMenuContentComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.initialize();
    };
    /**
     * @return {?}
     */
    OContextMenuContentComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.trigger.openMenu();
    };
    /**
     * @return {?}
     */
    OContextMenuContentComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        this.setData(this.menuItems);
    };
    /**
     * @param {?} items
     * @return {?}
     */
    OContextMenuContentComponent.prototype.setData = /**
     * @param {?} items
     * @return {?}
     */
    function (items) {
        var _this = this;
        items.forEach(function (menuItem) {
            if (_this.data) {
                menuItem.data = _this.data;
                if (menuItem.children && menuItem.children.length > 0) {
                    _this.setData(menuItem.children);
                }
            }
        });
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OContextMenuContentComponent.prototype.onMenuClosed = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.close();
    };
    /**
     * @return {?}
     */
    OContextMenuContentComponent.prototype.close = /**
     * @return {?}
     */
    function () {
        this.trigger.closeMenu();
        this.menuService.closeContextMenu.next();
    };
    OContextMenuContentComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-context-menu-content',
                    template: "\n    <button mat-button [matMenuTriggerFor]=\"menu.childMenu\" (menuClosed)=\"onMenuClosed($event)\"></button>\n    <o-wrapper-content-menu #menu [items]=\"menuItems\" [class]=\"menuClass\"> </o-wrapper-content-menu>\n  ",
                    inputs: DEFAULT_CONTEXT_MENU_CONTENT_INPUTS,
                    outputs: DEFAULT_CONTEXT_MENU_CONTENT_OUTPUTS,
                    host: {
                        '[class.o-context-menu-content]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OContextMenuContentComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: OContextMenuService }
    ]; };
    OContextMenuContentComponent.propDecorators = {
        oContextMenuItems: [{ type: core.ContentChildren, args: [OComponentMenuItems,] }],
        trigger: [{ type: core.ViewChild, args: [material.MatMenuTrigger,] }],
        menu: [{ type: core.ViewChild, args: [OWrapperContentMenuComponent,] }],
        click: [{ type: core.HostListener, args: ['document:click',] }]
    };
    return OContextMenuContentComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OContextMenuService = /** @class */ (function () {
    function OContextMenuService(overlay, scrollStrategy) {
        var _this = this;
        this.overlay = overlay;
        this.scrollStrategy = scrollStrategy;
        this.showContextMenu = new Subject();
        this.closeContextMenu = new Subject();
        this.overlays = [];
        this.fakeElement = {
            getBoundingClientRect: function () { return ({
                bottom: 0,
                height: 0,
                left: 0,
                right: 0,
                top: 0,
                width: 0,
            }); }
        };
        this.subscription = new Subscription();
        this.subscription.add(this.closeContextMenu.subscribe(function () { return _this.destroyOverlays(); }));
    }
    /**
     * @return {?}
     */
    OContextMenuService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    /**
     * @param {?} context
     * @return {?}
     */
    OContextMenuService.prototype.openContextMenu = /**
     * @param {?} context
     * @return {?}
     */
    function (context) {
        this.destroyOverlays();
        this.createOverlay(context);
    };
    /**
     * @return {?}
     */
    OContextMenuService.prototype.destroyOverlays = /**
     * @return {?}
     */
    function () {
        if (this.overlays) {
            this.overlays.forEach(function (overlay, index) {
                overlay.detach();
                overlay.dispose();
            });
        }
        this.overlays = [];
        if (this.activeMenu) {
            this.activeMenu.close();
        }
    };
    // Create overlay and attach `o-context-menu-content` to it in order to trigger the menu click, the menu opens in a new overlay
    // TODO: try to use only one overlay
    /**
     * @param {?} context
     * @return {?}
     */
    OContextMenuService.prototype.createOverlay = /**
     * @param {?} context
     * @return {?}
     */
    function (context) {
        context.event.preventDefault();
        context.event.stopPropagation();
        this.fakeElement.getBoundingClientRect = function () { return ({
            bottom: context.event.clientY,
            height: 0,
            left: context.event.clientX,
            right: context.event.clientX,
            top: context.event.clientY,
            width: 0,
        }); };
        /** @type {?} */
        var positionStrategy = this.overlay.position()
            .flexibleConnectedTo(context.anchorElement || this.fakeElement)
            .withPositions([{
                overlayX: 'start',
                overlayY: 'top',
                originX: 'start',
                originY: 'bottom'
            }]);
        /** @type {?} */
        var overlayRef = this.overlay.create({
            positionStrategy: positionStrategy,
            hasBackdrop: false,
            panelClass: ['o-context-menu'],
            scrollStrategy: this.scrollStrategy.close()
        });
        this.overlays = [overlayRef];
        this.attachContextMenu(this.overlays[0], context);
    };
    /**
     * @param {?} overlay
     * @param {?} context
     * @return {?}
     */
    OContextMenuService.prototype.attachContextMenu = /**
     * @param {?} overlay
     * @param {?} context
     * @return {?}
     */
    function (overlay, context) {
        /** @type {?} */
        var contextMenuContent = overlay.attach(new ComponentPortal(OContextMenuContentComponent));
        contextMenuContent.instance.overlay = overlay;
        contextMenuContent.instance.menuItems = context.menuItems;
        contextMenuContent.instance.data = context.data;
        contextMenuContent.instance.menuClass = context.class;
    };
    OContextMenuService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OContextMenuService.ctorParameters = function () { return [
        { type: Overlay },
        { type: ScrollStrategyOptions }
    ]; };
    return OContextMenuService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_CONTEXT_MENU_DIRECTIVE_INPUTS = [
    'oContextMenu',
    'oContextMenuData'
];
var OContextMenuDirective = /** @class */ (function () {
    function OContextMenuDirective(injector) {
        this.injector = injector;
        this.oContextMenuService = this.injector.get(OContextMenuService);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    OContextMenuDirective.prototype.onRightClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.oContextMenuService.showContextMenu.next({
            contextMenu: this.oContextMenu,
            event: event,
            data: this.oContextMenuData
        });
    };
    OContextMenuDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[oContextMenu]',
                    inputs: DEFAULT_CONTEXT_MENU_DIRECTIVE_INPUTS
                },] },
    ];
    /** @nocollapse */
    OContextMenuDirective.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OContextMenuDirective.propDecorators = {
        onRightClick: [{ type: core.HostListener, args: ['contextmenu', ['$event'],] }]
    };
    return OContextMenuDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_OUTPUTS_O_CONTEXT_MENU = [
    'onShow',
    'onClose'
];
var OContextMenuComponent = /** @class */ (function () {
    function OContextMenuComponent(injector) {
        this.injector = injector;
        this.onShow = new core.EventEmitter();
        this.onClose = new core.EventEmitter();
        this.subscription = new Subscription();
        this.oContextMenuService = this.injector.get(OContextMenuService);
    }
    /**
     * @return {?}
     */
    OContextMenuComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subscription.add(this.oContextMenuService.showContextMenu.subscribe(function (param) { return _this.showContextMenu(param); }));
        this.subscription.add(this.oContextMenuService.closeContextMenu.subscribe(function (param) { return _this.onClose.emit(); }));
    };
    /**
     * @return {?}
     */
    OContextMenuComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    /**
     * @param {?} params
     * @return {?}
     */
    OContextMenuComponent.prototype.showContextMenu = /**
     * @param {?} params
     * @return {?}
     */
    function (params) {
        this.origin = /** @type {?} */ (params.event.target);
        this.onShow.emit(params);
        if (params.contextMenu !== this) {
            return;
        }
        params.menuItems = this.oContextMenuItems;
        if (params.menuItems.length > 0) {
            this.oContextMenuService.openContextMenu(params);
        }
    };
    OContextMenuComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-context-menu',
                    template: ' ',
                    outputs: DEFAULT_OUTPUTS_O_CONTEXT_MENU
                },] },
    ];
    /** @nocollapse */
    OContextMenuComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OContextMenuComponent.propDecorators = {
        oContextMenuItems: [{ type: core.ContentChildren, args: [OComponentMenuItems,] }]
    };
    return OContextMenuComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_CONTEXT_MENU_ITEM_OUTPUTS = [
    'execute'
];
/** @type {?} */
var DEFAULT_INPUTS_O_CONTEXT_MENU_ITEM = DEFAULT_INPUTS_O_CONTEXT_MENU_ITEMS.concat([
    'icon',
    'data',
    'label',
    'oenabled: enabled',
    'svgIcon: svg-icon'
]);
var OContextMenuItemComponent = /** @class */ (function (_super) {
    __extends(OContextMenuItemComponent, _super);
    function OContextMenuItemComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.execute = new core.EventEmitter();
        _this.type = OComponentMenuItems.TYPE_ITEM_MENU;
        _this.enabled = true;
        return _this;
    }
    /**
     * @return {?}
     */
    OContextMenuItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.enabled = this.parseInput(this.oenabled, true);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OContextMenuItemComponent.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.triggerExecute(this.data, event);
    };
    /**
     * @param {?} data
     * @param {?=} $event
     * @return {?}
     */
    OContextMenuItemComponent.prototype.triggerExecute = /**
     * @param {?} data
     * @param {?=} $event
     * @return {?}
     */
    function (data, $event) {
        if (!this.enabled) {
            return;
        }
        this.execute.emit({ event: $event, data: data });
    };
    Object.defineProperty(OContextMenuItemComponent.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.enabled instanceof Function) {
                return !this.enabled(this.data);
            }
            return !this.enabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OContextMenuItemComponent.prototype, "isVisible", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.ovisible instanceof Function) {
                return this.ovisible(this.data);
            }
            return this.ovisible;
        },
        enumerable: true,
        configurable: true
    });
    OContextMenuItemComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-context-menu-item',
                    template: ' ',
                    inputs: DEFAULT_INPUTS_O_CONTEXT_MENU_ITEM,
                    outputs: DEFAULT_CONTEXT_MENU_ITEM_OUTPUTS,
                    providers: [{ provide: OComponentMenuItems, useExisting: core.forwardRef(function () { return OContextMenuItemComponent; }) }]
                },] },
    ];
    return OContextMenuItemComponent;
}(OComponentMenuItems));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_CONTEXT_MENU_ITEM_INPUTS$$1 = DEFAULT_INPUTS_O_CONTEXT_MENU_ITEMS.slice();
var OContextMenuSeparatorComponent$$1 = /** @class */ (function (_super) {
    __extends(OContextMenuSeparatorComponent$$1, _super);
    function OContextMenuSeparatorComponent$$1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = OComponentMenuItems.TYPE_SEPARATOR_MENU;
        return _this;
    }
    /**
     * @return {?}
     */
    OContextMenuSeparatorComponent$$1.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    OContextMenuSeparatorComponent$$1.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-context-menu-separator',
                    template: ' ',
                    inputs: DEFAULT_CONTEXT_MENU_ITEM_INPUTS$$1,
                    providers: [{ provide: OComponentMenuItems, useExisting: core.forwardRef(function () { return OContextMenuSeparatorComponent$$1; }) }]
                },] },
    ];
    return OContextMenuSeparatorComponent$$1;
}(OContextMenuItemComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_CONTEXT_MENU_GROUP_INPUTS$$1 = DEFAULT_INPUTS_O_CONTEXT_MENU_ITEM.concat([
    'children'
]);
var OContextMenuGroupComponent$$1 = /** @class */ (function (_super) {
    __extends(OContextMenuGroupComponent$$1, _super);
    function OContextMenuGroupComponent$$1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = OComponentMenuItems.TYPE_GROUP_MENU;
        _this.children = [];
        return _this;
    }
    /**
     * @return {?}
     */
    OContextMenuGroupComponent$$1.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.children = this.oContextMenuItems.toArray().slice(1, this.oContextMenuItems.toArray().length);
    };
    OContextMenuGroupComponent$$1.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-context-menu-group',
                    template: ' ',
                    inputs: DEFAULT_CONTEXT_MENU_GROUP_INPUTS$$1,
                    providers: [{ provide: OComponentMenuItems, useExisting: core.forwardRef(function () { return OContextMenuGroupComponent$$1; }) }]
                },] },
    ];
    OContextMenuGroupComponent$$1.propDecorators = {
        oContextMenuItems: [{ type: core.ContentChildren, args: [OComponentMenuItems,] }]
    };
    return OContextMenuGroupComponent$$1;
}(OContextMenuItemComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OContextMenuModule = /** @class */ (function () {
    function OContextMenuModule() {
    }
    OContextMenuModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule, OSharedModule],
                    entryComponents: [OContextMenuContentComponent, OContextMenuComponent],
                    exports: [common.CommonModule, OContextMenuDirective, OContextMenuComponent, OContextMenuItemComponent, OContextMenuGroupComponent$$1, OContextMenuSeparatorComponent$$1],
                    declarations: [
                        OContextMenuDirective,
                        OContextMenuContentComponent,
                        OContextMenuComponent,
                        OContextMenuItemComponent,
                        OContextMenuGroupComponent$$1,
                        OWrapperContentMenuComponent,
                        OContextMenuSeparatorComponent$$1
                    ]
                },] },
    ];
    return OContextMenuModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OBaseTableCellEditor = /** @class */ (function () {
    function OBaseTableCellEditor(injector) {
        this.injector = injector;
        this.orequired = false;
        this.showPlaceHolder = false;
        this.updateRecordOnEdit = true;
        this.showNotificationOnEdit = true;
        this._enabled = true;
        this.formGroup = new forms.FormGroup({});
        this.editionStarted = new core.EventEmitter();
        this.editionCancelled = new core.EventEmitter();
        this.editionCommitted = new core.EventEmitter();
        this.onPostUpdateRecord = new core.EventEmitter();
        this.editorCreated = new core.EventEmitter();
        this.registerInColumn = true;
        this.snackBarService = this.injector.get(SnackBarService);
        this.tableColumn = this.injector.get(OTableColumnComponent);
        this.translateService = this.injector.get(OTranslateService$$1);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    OBaseTableCellEditor.prototype.onDocumentKeyup = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.handleKeyup(event);
    };
    /**
     * @return {?}
     */
    OBaseTableCellEditor.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.createFormControl();
        this.registerEditor();
        this.editorCreated.emit(this);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OBaseTableCellEditor.prototype.handleKeyup = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var oColumn = this.table.getOColumn(this.tableColumnAttr);
        if (!oColumn || !oColumn.editing) {
            return;
        }
        if (event.keyCode === 27) {
            // escape
            this.onEscClicked();
        }
        else if (event.keyCode === 13 || event.keyCode === 9) {
            // intro or tab
            this.commitEdition();
        }
    };
    /**
     * @return {?}
     */
    OBaseTableCellEditor.prototype.createFormControl = /**
     * @return {?}
     */
    function () {
        if (!this.formControl) {
            /** @type {?} */
            var validators = this.resolveValidators();
            /** @type {?} */
            var cfg = {
                value: undefined,
                disabled: !this.enabled
            };
            this.formControl = new forms.FormControl(cfg, validators);
            this.formGroup.addControl(Math.random().toString(36), this.formControl);
        }
    };
    /**
     * @return {?}
     */
    OBaseTableCellEditor.prototype.registerEditor = /**
     * @return {?}
     */
    function () {
        if (this.registerInColumn && !Util.isDefined(this.tableColumn.editor)) {
            this.tableColumn.registerEditor(this);
            if (!Util.isDefined(this.type) && Util.isDefined(this.tableColumn.type)) {
                this.type = this.tableColumn.type;
            }
        }
    };
    /**
     * @return {?}
     */
    OBaseTableCellEditor.prototype.getCellData = /**
     * @return {?}
     */
    function () {
        return this._rowData[this.tableColumnAttr];
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OBaseTableCellEditor.prototype.startEdition = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.formGroup.reset();
        this.rowData = data;
        if (!this.isSilentControl()) {
            this.editionStarted.emit(this._rowData);
        }
    };
    /**
     * @param {?} saveChanges
     * @return {?}
     */
    OBaseTableCellEditor.prototype.endEdition = /**
     * @param {?} saveChanges
     * @return {?}
     */
    function (saveChanges) {
        /** @type {?} */
        var oColumn = this.table.getOColumn(this.tableColumnAttr);
        if (oColumn) {
            /** @type {?} */
            var self_1 = this;
            /** @type {?} */
            var updateObserver = this.table.updateCellData(oColumn, this._rowData, saveChanges);
            if (updateObserver) {
                updateObserver.subscribe(function (res) {
                    self_1.onUpdateSuccess(res);
                    self_1.table.cd.detectChanges();
                }, function (error) {
                    self_1._rowData[self_1.tableColumnAttr] = self_1.oldValue;
                    self_1.table.dataSource.updateRenderedRowData(self_1._rowData);
                    self_1.table.showDialogError(error, 'MESSAGES.ERROR_UPDATE');
                    self_1.table.cd.detectChanges();
                });
            }
            else {
                self_1.table.cd.detectChanges();
            }
        }
    };
    /**
     * @return {?}
     */
    OBaseTableCellEditor.prototype.commitEdition = /**
     * @return {?}
     */
    function () {
        if (!this.formControl.invalid) {
            this.oldValue = this._rowData[this.tableColumnAttr];
            this._rowData[this.tableColumnAttr] = this.formControl.value;
            if (!this.isSilentControl()) {
                this.endEdition(true);
                this.editionCommitted.emit(this._rowData);
            }
        }
    };
    Object.defineProperty(OBaseTableCellEditor.prototype, "tableColumn", {
        get: /**
         * @return {?}
         */
        function () {
            return this._tableColumn;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._tableColumn = arg;
            if (arg) {
                this._table = arg.table;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseTableCellEditor.prototype, "tableColumnAttr", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._tableColumn) {
                return this._tableColumn.attr;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseTableCellEditor.prototype, "table", {
        get: /**
         * @return {?}
         */
        function () {
            return this._table;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._table = arg;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseTableCellEditor.prototype, "rowData", {
        get: /**
         * @return {?}
         */
        function () {
            return this._rowData;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._rowData = arg;
            /** @type {?} */
            var cellData = this.getCellData();
            this.formControl.setValue(cellData);
            this.formControl.markAsTouched();
            if (this.inputRef && this.inputRef.nativeElement.type === 'text') {
                this.inputRef.nativeElement.setSelectionRange(0, String(cellData).length);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OBaseTableCellEditor.prototype.resolveValidators = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validators = [];
        if (this.orequired) {
            validators.push(forms.Validators.required);
        }
        return validators;
    };
    /**
     * @param {?} error
     * @return {?}
     */
    OBaseTableCellEditor.prototype.hasError = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        return this.formControl && this.formControl.touched && this.hasErrorExclusive(error);
    };
    /**
     * @param {?} error
     * @return {?}
     */
    OBaseTableCellEditor.prototype.hasErrorExclusive = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        /** @type {?} */
        var hasError = false;
        /** @type {?} */
        var errorsOrder = ['matDatepickerMax', 'matDatepickerMin', 'matDatepickerFilter', 'matDatepickerParse', 'required'];
        /** @type {?} */
        var errors = this.formControl.errors;
        if (Util.isDefined(errors)) {
            if (Object.keys(errors).length === 1) {
                return errors.hasOwnProperty(error);
            }
            else {
                for (var i = 0, len = errorsOrder.length; i < len; i++) {
                    hasError = errors.hasOwnProperty(errorsOrder[i]);
                    if (hasError) {
                        hasError = (errorsOrder[i] === error);
                        break;
                    }
                }
            }
        }
        return hasError;
    };
    /**
     * @param {?} error
     * @param {?} prop
     * @return {?}
     */
    OBaseTableCellEditor.prototype.getErrorValue = /**
     * @param {?} error
     * @param {?} prop
     * @return {?}
     */
    function (error, prop) {
        return this.formControl.hasError(error) ? this.formControl.getError(error)[prop] || '' : '';
    };
    /**
     * @return {?}
     */
    OBaseTableCellEditor.prototype.onEscClicked = /**
     * @return {?}
     */
    function () {
        if (!this.isSilentControl()) {
            this.endEdition(false);
            this.editionCancelled.emit(this._rowData);
        }
    };
    /**
     * @return {?}
     */
    OBaseTableCellEditor.prototype.isSilentControl = /**
     * @return {?}
     */
    function () {
        return this.controlArgs !== undefined && this.controlArgs.silent;
    };
    /**
     * @return {?}
     */
    OBaseTableCellEditor.prototype.getPlaceholder = /**
     * @return {?}
     */
    function () {
        return this.showPlaceHolder ?
            this.translateService.get(this.olabel || this.tableColumn ? (this.tableColumn.title || this.tableColumnAttr) : this.tableColumnAttr) :
            undefined;
    };
    /**
     * @param {?} res
     * @return {?}
     */
    OBaseTableCellEditor.prototype.onUpdateSuccess = /**
     * @param {?} res
     * @return {?}
     */
    function (res) {
        ObservableWrapper.callEmit(this.onPostUpdateRecord, this._rowData);
        if (this.showNotificationOnEdit) {
            this.snackBarService.open('MESSAGES.UPDATED', { icon: 'check_circle' });
        }
    };
    Object.defineProperty(OBaseTableCellEditor.prototype, "enabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._enabled;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._enabled = arg;
            if (this.formControl) {
                this._enabled ? this.formControl.enable() : this.formControl.disable();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OBaseTableCellEditor.prototype.getFormControl = /**
     * @return {?}
     */
    function () {
        return this.formControl;
    };
    OBaseTableCellEditor.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR = [
        'orequired: required',
        'showPlaceHolder: show-placeholder',
        'olabel: label',
        'updateRecordOnEdit: update-record-on-edit',
        'showNotificationOnEdit: show-notification-on-edit',
        'enabled'
    ];
    OBaseTableCellEditor.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR = [
        'editionStarted',
        'editionCancelled',
        'editionCommitted',
        'onPostUpdateRecord'
    ];
    OBaseTableCellEditor.propDecorators = {
        onDocumentKeyup: [{ type: core.HostListener, args: ['document:keyup', ['$event'],] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OBaseTableCellEditor.prototype, "orequired", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OBaseTableCellEditor.prototype, "showPlaceHolder", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OBaseTableCellEditor.prototype, "updateRecordOnEdit", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OBaseTableCellEditor.prototype, "showNotificationOnEdit", void 0);
    return OBaseTableCellEditor;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_BOOLEAN = OBaseTableCellEditor.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR.concat([
    'indeterminateOnNull: indeterminate-on-null',
    'trueValue: true-value',
    'falseValue: false-value',
    'booleanType: boolean-type',
    'autoCommit: auto-commit'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_BOOLEAN = OBaseTableCellEditor.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR.slice();
var OTableCellEditorBooleanComponent = /** @class */ (function (_super) {
    __extends(OTableCellEditorBooleanComponent, _super);
    function OTableCellEditorBooleanComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.indeterminate = false;
        _this.indeterminateOnNull = false;
        _this.booleanType = 'boolean';
        _this.autoCommit = true;
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellEditorBooleanComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        this.parseInputs();
    };
    /**
     * @return {?}
     */
    OTableCellEditorBooleanComponent.prototype.parseInputs = /**
     * @return {?}
     */
    function () {
        switch (this.booleanType) {
            case 'string':
                this.parseStringInputs();
                break;
            case 'number':
                this.parseNumberInputs();
                break;
            default:
                this.trueValue = true;
                this.falseValue = false;
                break;
        }
    };
    /**
     * @return {?}
     */
    OTableCellEditorBooleanComponent.prototype.parseStringInputs = /**
     * @return {?}
     */
    function () {
        if ((this.trueValue || '').length === 0) {
            this.trueValue = undefined;
        }
        if ((this.falseValue || '').length === 0) {
            this.falseValue = undefined;
        }
    };
    /**
     * @return {?}
     */
    OTableCellEditorBooleanComponent.prototype.parseNumberInputs = /**
     * @return {?}
     */
    function () {
        this.trueValue = parseInt(this.trueValue);
        if (isNaN(this.trueValue)) {
            this.trueValue = 1;
        }
        this.falseValue = parseInt(this.falseValue);
        if (isNaN(this.falseValue)) {
            this.falseValue = 0;
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OTableCellEditorBooleanComponent.prototype.startEdition = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        _super.prototype.startEdition.call(this, data);
        /** @type {?} */
        var self = this;
        setTimeout(function () {
            // using setTimeout to forcing this code execution after super.activateColumnEdition column.editing = true line
            if (self.autoCommit) {
                /** @type {?} */
                var isTrue = (self.formControl.value === self.trueValue);
                self.formControl.setValue(isTrue ? self.falseValue : self.trueValue, { emitEvent: false });
                self.commitEdition();
            }
            else {
                /** @type {?} */
                var isTrue = (self.formControl.value === self.trueValue);
                self.formControl.setValue(isTrue ? self.trueValue : self.falseValue, { emitEvent: false });
            }
        }, 0);
    };
    /**
     * @return {?}
     */
    OTableCellEditorBooleanComponent.prototype.getCellData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var cellData = _super.prototype.getCellData.call(this);
        this.indeterminate = this.indeterminateOnNull && !Util.isDefined(cellData);
        if (!this.indeterminate) {
            cellData = this.parseValueByType(cellData);
        }
        return cellData;
    };
    /**
     * @param {?} cellData
     * @return {?}
     */
    OTableCellEditorBooleanComponent.prototype.hasCellDataTrueValue = /**
     * @param {?} cellData
     * @return {?}
     */
    function (cellData) {
        /** @type {?} */
        var result = undefined;
        if (Util.isDefined(cellData)) {
            result = (cellData === this.trueValue);
            if (this.booleanType === 'string' && !Util.isDefined(this.trueValue)) {
                result = Util.parseBoolean(cellData, false);
            }
        }
        return result;
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OTableCellEditorBooleanComponent.prototype.parseValueByType = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        /** @type {?} */
        var result = val;
        /** @type {?} */
        var cellIsTrue = this.hasCellDataTrueValue(val);
        /** @type {?} */
        var value = cellIsTrue ? this.trueValue : this.falseValue;
        switch (this.booleanType) {
            case 'string':
                result = this.translateService.get(value);
                break;
            case 'number':
                result = parseInt(value);
                break;
            default:
                break;
        }
        return result;
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    OTableCellEditorBooleanComponent.prototype.onChange = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        this.formControl.setValue(arg.checked ? this.trueValue : this.falseValue, { emitEvent: false });
        this.commitEdition();
    };
    OTableCellEditorBooleanComponent.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_BOOLEAN = DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_BOOLEAN;
    OTableCellEditorBooleanComponent.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_BOOLEAN = DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_BOOLEAN;
    OTableCellEditorBooleanComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-editor-boolean',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\" let-rowvalue=\"rowvalue\">\n      <div class=\"o-table-cell-editor-boolean\" [formGroup]=\"formGroup\">\n        <mat-checkbox (click)=\"$event.stopPropagation()\" (change)=\"onChange($event)\" [indeterminate]=\"indeterminate\"\n          [formControl]=\"formControl\">\n        </mat-checkbox>\n      </div>\n    </ng-template>\n  ",
                    styles: ["\n    .o-table-cell-editor-boolean .mat-checkbox-ripple{display:none}\n  "],
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_BOOLEAN,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_BOOLEAN,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-table-cell-editor-boolean]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OTableCellEditorBooleanComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellEditorBooleanComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableCellEditorBooleanComponent.prototype, "indeterminateOnNull", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableCellEditorBooleanComponent.prototype, "autoCommit", void 0);
    return OTableCellEditorBooleanComponent;
}(OBaseTableCellEditor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_VALIDATOR = [
    'validatorFn: validator-function',
    'errorName: error-name',
    'errorText: error-text'
];
var OValidatorComponent = /** @class */ (function () {
    function OValidatorComponent(injector) {
        this.injector = injector;
        this.validatorFn = null;
        this.errorsData = [];
    }
    /**
     * @param {?} oError
     * @return {?}
     */
    OValidatorComponent.prototype.registerError = /**
     * @param {?} oError
     * @return {?}
     */
    function (oError) {
        this.errorsData.push({
            name: oError.getName(),
            text: oError.getText()
        });
    };
    /**
     * @return {?}
     */
    OValidatorComponent.prototype.getValidatorFn = /**
     * @return {?}
     */
    function () {
        return this.validatorFn;
    };
    /**
     * @return {?}
     */
    OValidatorComponent.prototype.getErrorsData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = [];
        if (this.errorsData.length > 0) {
            result = this.errorsData;
        }
        else if (Util.isDefined(this.errorName) && Util.isDefined(this.errorText)) {
            result = [{
                    name: this.errorName,
                    text: this.errorText
                }];
        }
        return result;
    };
    OValidatorComponent.DEFAULT_INPUTS_O_VALIDATOR = DEFAULT_INPUTS_O_VALIDATOR;
    OValidatorComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-validator',
                    template: ' ',
                    inputs: DEFAULT_INPUTS_O_VALIDATOR
                },] },
    ];
    /** @nocollapse */
    OValidatorComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OValidatorComponent;
}());
var OValidatorModule = /** @class */ (function () {
    function OValidatorModule() {
    }
    OValidatorModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OValidatorComponent],
                    imports: [OSharedModule, common.CommonModule],
                    exports: [OValidatorComponent]
                },] },
    ];
    return OValidatorModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OBaseComponent = /** @class */ (function () {
    function OBaseComponent(injector) {
        this._enabled = true;
        this._orequired = false;
        this._tooltipPosition = 'below';
        this._tooltipShowDelay = 500;
        this._tooltipHideDelay = 0;
        this.injector = injector;
        if (this.injector) {
            this.translateService = this.injector.get(OTranslateService$$1);
        }
    }
    /**
     * @return {?}
     */
    OBaseComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        if (!Util.isDefined(this._olabel)) {
            this._olabel = this.oattr;
        }
        if (Util.isDefined(this.oplaceholder) && this.oplaceholder.length > 0) {
            this.oplaceholder = this.translateService.get(this.oplaceholder);
        }
    };
    /**
     * @return {?}
     */
    OBaseComponent.prototype.getAttribute = /**
     * @return {?}
     */
    function () {
        if (this.oattr) {
            return this.oattr;
        }
        return undefined;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OBaseComponent.prototype.setEnabled = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!PermissionsUtils.checkEnabledPermission(this.permissions)) {
            return;
        }
        /** @type {?} */
        var parsedValue = BooleanConverter(value);
        this._enabled = parsedValue;
    };
    Object.defineProperty(OBaseComponent.prototype, "placeHolder", {
        get: /**
         * @return {?}
         */
        function () {
            return this.oplaceholder;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.oplaceholder = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseComponent.prototype, "tooltipClass", {
        get: /**
         * @return {?}
         */
        function () {
            return this.getTooltipClass();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OBaseComponent.prototype.getTooltipClass = /**
     * @return {?}
     */
    function () {
        return "o-tooltip " + this.tooltipPosition;
    };
    /**
     * @return {?}
     */
    OBaseComponent.prototype.getTooltipText = /**
     * @return {?}
     */
    function () {
        if (Util.isDefined(this._tooltip) && this.translateService) {
            return this.translateService.get(this._tooltip);
        }
        return this._tooltip;
    };
    Object.defineProperty(OBaseComponent.prototype, "tooltip", {
        get: /**
         * @return {?}
         */
        function () {
            return this.getTooltipText();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._tooltip = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseComponent.prototype, "tooltipPosition", {
        get: /**
         * @return {?}
         */
        function () {
            return this._tooltipPosition;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._tooltipPosition = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseComponent.prototype, "tooltipShowDelay", {
        get: /**
         * @return {?}
         */
        function () {
            return this._tooltipShowDelay;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._tooltipShowDelay = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseComponent.prototype, "tooltipHideDelay", {
        get: /**
         * @return {?}
         */
        function () {
            return this._tooltipHideDelay;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._tooltipHideDelay = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseComponent.prototype, "isReadOnly", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isReadOnly;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setIsReadOnly(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    OBaseComponent.prototype.setIsReadOnly = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // only modifiyng read only state if the component has not its own read-only input
        if (Util.isDefined(this.readOnly)) {
            return;
        }
        if (!this.enabled) {
            this._isReadOnly = false;
            return;
        }
        if (!PermissionsUtils.checkEnabledPermission(this.permissions)) {
            return;
        }
        this._isReadOnly = value;
    };
    Object.defineProperty(OBaseComponent.prototype, "readOnly", {
        get: /**
         * @return {?}
         */
        function () {
            return this._readOnly;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!PermissionsUtils.checkEnabledPermission(this.permissions)) {
                return;
            }
            /** @type {?} */
            var parsedValue = BooleanConverter(value);
            this._readOnly = parsedValue;
            this._isReadOnly = parsedValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseComponent.prototype, "orequired", {
        get: /**
         * @return {?}
         */
        function () {
            return this._orequired;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._orequired = BooleanConverter(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseComponent.prototype, "isRequired", {
        get: /**
         * @return {?}
         */
        function () {
            return this.orequired;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseComponent.prototype, "required", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.orequired = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseComponent.prototype, "enabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._enabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var parsedValue = BooleanConverter(value);
            this.setEnabled(parsedValue);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseComponent.prototype, "olabel", {
        get: /**
         * @return {?}
         */
        function () {
            return this._olabel;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._olabel = value;
        },
        enumerable: true,
        configurable: true
    });
    return OBaseComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OValueChangeEvent = /** @class */ (function () {
    function OValueChangeEvent(type, newValue, oldValue, target) {
        this.type = type;
        this.newValue = newValue;
        this.oldValue = oldValue;
        this.target = target;
    }
    /**
     * @return {?}
     */
    OValueChangeEvent.prototype.isUserChange = /**
     * @return {?}
     */
    function () {
        return this.type === OValueChangeEvent.USER_CHANGE;
    };
    /**
     * @return {?}
     */
    OValueChangeEvent.prototype.isProgrammaticChange = /**
     * @return {?}
     */
    function () {
        return this.type === OValueChangeEvent.PROGRAMMATIC_CHANGE;
    };
    OValueChangeEvent.USER_CHANGE = 0;
    OValueChangeEvent.PROGRAMMATIC_CHANGE = 1;
    return OValueChangeEvent;
}());
/** @type {?} */
var DEFAULT_INPUTS_O_FORM_DATA_COMPONENT = [
    'oattr: attr',
    'olabel: label',
    'floatLabel: float-label',
    'oplaceholder: placeholder',
    'tooltip',
    'tooltipPosition: tooltip-position',
    'tooltipShowDelay: tooltip-show-delay',
    'tooltipHideDelay: tooltip-hide-delay',
    'data',
    'autoBinding: automatic-binding',
    'autoRegistering: automatic-registering',
    'enabled',
    'orequired: required',
    'sqlType: sql-type',
    'width',
    'readOnly: read-only',
    'clearButton: clear-button',
    'angularValidatorsFn: validators',
    'appearance',
    'hideRequiredMarker:hide-required-marker',
    'labelVisible:label-visible'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_FORM_DATA_COMPONENT = [
    'onChange',
    'onValueChange',
    'onFocus',
    'onBlur'
];
var OFormDataComponent = /** @class */ (function (_super) {
    __extends(OFormDataComponent, _super);
    function OFormDataComponent(form, elRef, injector) {
        var _this = _super.call(this, injector) || this;
        _this.autoBinding = true;
        _this.autoRegistering = true;
        _this.clearButton = false;
        _this.angularValidatorsFn = [];
        _this.hideRequiredMarker = false;
        _this.labelVisible = true;
        _this.onChange = new core.EventEmitter();
        _this.onValueChange = new core.EventEmitter();
        _this.onFocus = new core.EventEmitter();
        _this.onBlur = new core.EventEmitter();
        _this.defaultValue = void 0;
        _this._SQLType = SQLTypes.OTHER;
        _this._defaultSQLTypeKey = 'OTHER';
        _this.errorsData = [];
        _this.form = form;
        _this.elRef = elRef;
        _this.permissionsService = _this.injector.get(PermissionsService);
        try {
            _this.errorOptions = _this.injector.get(O_MAT_ERROR_OPTIONS) || {};
        }
        catch (e) {
            _this.errorOptions = {};
        }
        return _this;
    }
    Object.defineProperty(OFormDataComponent.prototype, "hostWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return this.width;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.initialize();
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        if (this._matSuffixList) {
            this.setSuffixClass(this._matSuffixList.length);
            this.matSuffixSubscription = this._matSuffixList.changes.subscribe(function () {
                self.setSuffixClass(self._matSuffixList.length);
            });
        }
        if (this.validatorChildren) {
            this.validatorsSubscription = this.validatorChildren.changes.subscribe(function () {
                self.updateValidators();
            });
            if (this.validatorChildren.length > 0) {
                this.updateValidators();
            }
        }
        if (!this.enabled) {
            this.mutationObserver = PermissionsUtils.registerDisabledChangesInDom(this.getMutationObserverTarget(), {
                callback: this.disableFormControl.bind(this)
            });
        }
        this.addOntimizeCustomAppearanceClass();
        try {
            this.oInputsOptions = this.injector.get(O_INPUTS_OPTIONS);
        }
        catch (e) {
            this.oInputsOptions = {};
        }
        Util.parseOInputsOptions(this.elRef, this.oInputsOptions);
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    OFormDataComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (Util.isDefined(changes['angularValidatorsFn'])) {
            this.updateValidators();
        }
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.hasEnabledPermission = /**
     * @return {?}
     */
    function () {
        return this.permissions ? this.permissions.enabled : true;
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.hasVisiblePermission = /**
     * @return {?}
     */
    function () {
        return this.permissions ? this.permissions.visible : true;
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.getFormGroup = /**
     * @return {?}
     */
    function () {
        if (this._fGroup) {
            return this._fGroup;
        }
        /** @type {?} */
        var formGroup = this.form ? this.form.formGroup : undefined;
        if ((!this.hasEnabledPermission() || !this.hasVisiblePermission()) && !this._fGroup) {
            /** @type {?} */
            var group = {};
            group[this.oattr] = this._fControl;
            this._fGroup = new forms.FormGroup(group);
            formGroup = this._fGroup;
        }
        return formGroup;
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.getFormControl = /**
     * @return {?}
     */
    function () {
        return this._fControl;
    };
    /**
     * @param {?} error
     * @return {?}
     */
    OFormDataComponent.prototype.hasError = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        return !this.isReadOnly && this._fControl && this._fControl.touched && this._fControl.hasError(error);
    };
    /**
     * @param {?} error
     * @param {?} prop
     * @return {?}
     */
    OFormDataComponent.prototype.getErrorValue = /**
     * @param {?} error
     * @param {?} prop
     * @return {?}
     */
    function (error, prop) {
        return this._fControl && this._fControl.hasError(error) ? this._fControl.getError(error)[prop] || '' : '';
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.getActiveOErrors = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return this.errorsData.filter(function (item) { return _this.hasError(item.name); });
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        _super.prototype.initialize.call(this);
        // ensuring formControl creation
        this.getControl();
        this.parsePermissions();
        if (!Util.isDefined(this.permissions)) {
            if (this.form) {
                this.registerFormListeners();
                this.isReadOnly = !(this.form.isInUpdateMode() || this.form.isInInsertMode() || this.form.isEditableDetail());
            }
            else {
                this.isReadOnly = !this.enabled;
            }
        }
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.unregisterFormListeners();
        if (this.matSuffixSubscription) {
            this.matSuffixSubscription.unsubscribe();
        }
        if (this.validatorsSubscription) {
            this.validatorsSubscription.unsubscribe();
        }
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
        }
        if (this._fControlSubscription) {
            this._fControlSubscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.registerFormListeners = /**
     * @return {?}
     */
    function () {
        if (this.form) {
            this.form.registerFormComponent(this);
            this.form.registerFormControlComponent(this);
            this.form.registerSQLTypeFormComponent(this);
        }
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.unregisterFormListeners = /**
     * @return {?}
     */
    function () {
        if (this.form) {
            this.form.unregisterFormComponent(this);
            this.form.unregisterFormControlComponent(this);
            this.form.unregisterSQLTypeFormComponent(this);
        }
    };
    Object.defineProperty(OFormDataComponent.prototype, "data", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setData(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} newValue
     * @return {?}
     */
    OFormDataComponent.prototype.setData = /**
     * @param {?} newValue
     * @return {?}
     */
    function (newValue) {
        /** @type {?} */
        var previousValue = this.oldValue;
        this.setFormValue(newValue);
        this.emitOnValueChange(OValueChangeEvent.PROGRAMMATIC_CHANGE, newValue, previousValue);
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.isAutomaticBinding = /**
     * @return {?}
     */
    function () {
        return this.autoBinding;
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.isAutomaticRegistering = /**
     * @return {?}
     */
    function () {
        return this.autoRegistering;
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.getValue = /**
     * @return {?}
     */
    function () {
        if (this.value instanceof OFormValue) {
            if (this.value.value !== undefined) {
                return this.value.value;
            }
        }
        return this.defaultValue;
    };
    /**
     * @param {?} val
     * @param {?=} options
     * @param {?=} setDirty
     * @return {?}
     */
    OFormDataComponent.prototype.setValue = /**
     * @param {?} val
     * @param {?=} options
     * @param {?=} setDirty
     * @return {?}
     */
    function (val, options, setDirty) {
        if (options === void 0) { options = {}; }
        if (setDirty === void 0) { setDirty = false; }
        if (!PermissionsUtils.checkEnabledPermission(this.permissions)) {
            return;
        }
        if (this.oldValue !== val) {
            /** @type {?} */
            var newValue = val;
            /** @type {?} */
            var previousValue = this.oldValue;
            this.setFormValue(val, options, setDirty);
            if (options && options.emitModelToViewValueChange !== false) {
                /** @type {?} */
                var changeType = (options && options.hasOwnProperty('changeType')) ? options.changeType : OValueChangeEvent.PROGRAMMATIC_CHANGE;
                this.emitOnValueChange(changeType, newValue, previousValue);
            }
        }
    };
    /**
     * Clears the component value.
     * @param {?=} options
     * @param {?=} setDirty
     * @return {?}
     */
    OFormDataComponent.prototype.clearValue = /**
     * Clears the component value.
     * @param {?=} options
     * @param {?=} setDirty
     * @return {?}
     */
    function (options, setDirty) {
        if (setDirty === void 0) { setDirty = false; }
        if (!PermissionsUtils.checkEnabledPermission(this.permissions)) {
            return;
        }
        this.setValue(void 0, options, setDirty);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OFormDataComponent.prototype.onClickClearValue = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        event.preventDefault();
        this.clearValue({ changeType: OValueChangeEvent.USER_CHANGE }, true);
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    OFormDataComponent.prototype.onChangeEvent = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        /** @type {?} */
        var value = this.getValue();
        if (this.oldValue !== value) {
            /** @type {?} */
            var previousValue = this.oldValue;
            this.oldValue = value;
            this.emitOnValueChange(OValueChangeEvent.USER_CHANGE, value, previousValue);
        }
    };
    Object.defineProperty(OFormDataComponent.prototype, "showClearButton", {
        get: /**
         * @return {?}
         */
        function () {
            return this.clearButton && !this.isReadOnly && this.enabled && this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    OFormDataComponent.prototype.onFormControlChange = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // equivalente al innerOnChange
        if (!this.value) {
            this.value = new OFormValue();
        }
        this.ensureOFormValue(value);
        this.onChange.emit(value);
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    OFormDataComponent.prototype.ensureOFormValue = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        if (arg instanceof OFormValue) {
            this.value = arg;
        }
        else if (Util.isDefined(arg) && !(arg instanceof OFormValue)) {
            /** @type {?} */
            var val = this.value || new OFormValue();
            val.value = arg;
            this.value = val;
        }
        else {
            this.value = new OFormValue(this.defaultValue);
        }
    };
    /**
     * This method should overwritten in the child component when it have addicional form control or other oFormDataComponent
     * @param {?=} cfg
     * @param {?=} validators
     * @return {?}
     */
    OFormDataComponent.prototype.createFormControl = /**
     * This method should overwritten in the child component when it have addicional form control or other oFormDataComponent
     * @param {?=} cfg
     * @param {?=} validators
     * @return {?}
     */
    function (cfg, validators) {
        return new OFormControl(cfg, {
            validators: validators
        }, null);
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.getControl = /**
     * @return {?}
     */
    function () {
        if (!this._fControl) {
            /** @type {?} */
            var validators = this.resolveValidators();
            /** @type {?} */
            var cfg = {
                value: this.value ? this.value.value : undefined,
                disabled: !this.enabled
            };
            this._fControl = this.createFormControl(cfg, validators);
            this.registerOnFormControlChange();
        }
        return this._fControl;
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.resolveValidators = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validators = [];
        this.angularValidatorsFn.forEach(function (fn) {
            validators.push(fn);
        });
        if (this.orequired) {
            validators.push(forms.Validators.required);
        }
        return validators;
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.getSQLType = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var sqlt = this.sqlType && this.sqlType.length > 0 ? this.sqlType : this._defaultSQLTypeKey;
        this._SQLType = SQLTypes.getSQLTypeValue(sqlt);
        return this._SQLType;
    };
    Object.defineProperty(OFormDataComponent.prototype, "isValid", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._fControl) {
                return this._fControl.valid;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.isEmpty = /**
     * @return {?}
     */
    function () {
        if (this.value instanceof OFormValue) {
            if (this.value.value !== undefined) {
                return false;
            }
        }
        return true;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OFormDataComponent.prototype.setEnabled = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        _super.prototype.setEnabled.call(this, value);
        if (this.hasVisiblePermission()) {
            if (this._fControl && value) {
                this._fControl.enable();
            }
            else if (this._fControl) {
                this._fControl.disable();
            }
        }
    };
    Object.defineProperty(OFormDataComponent.prototype, "elementRef", {
        get: /**
         * @return {?}
         */
        function () {
            return this.elRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormDataComponent.prototype, "hasCustomWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return this.width !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormDataComponent.prototype, "orequired", {
        get: /**
         * @return {?}
         */
        function () {
            return this._orequired;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var old = this._orequired;
            this._orequired = BooleanConverter(val);
            if (val !== old) {
                this.updateValidators();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    OFormDataComponent.prototype.innerOnFocus = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.isReadOnly && this.enabled) {
            this.onFocus.emit(event);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OFormDataComponent.prototype.innerOnBlur = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.isReadOnly && this.enabled) {
            this.onBlur.emit(event);
        }
    };
    Object.defineProperty(OFormDataComponent.prototype, "appearance", {
        get: /**
         * @return {?}
         */
        function () {
            return this._appearance;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var values = ['legacy', 'standard', 'fill', 'outline'];
            if (values.indexOf(value) === -1) {
                value = undefined;
            }
            this._appearance = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormDataComponent.prototype, "floatLabel", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.labelVisible) {
                this.floatLabel = 'never';
            }
            return this._floatLabel;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var values = ['always', 'never', 'auto'];
            if (values.indexOf(value) === -1) {
                value = 'auto';
            }
            this._floatLabel = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.registerOnFormControlChange = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        if (this._fControl) {
            this._fControlSubscription = this._fControl.valueChanges.subscribe(function (value) {
                self.onFormControlChange(value);
            });
        }
    };
    /**
     * @param {?} type
     * @param {?} newValue
     * @param {?} oldValue
     * @return {?}
     */
    OFormDataComponent.prototype.emitOnValueChange = /**
     * @param {?} type
     * @param {?} newValue
     * @param {?} oldValue
     * @return {?}
     */
    function (type, newValue, oldValue) {
        /** @type {?} */
        var event = new OValueChangeEvent(type, newValue, oldValue, this);
        this.onValueChange.emit(event);
    };
    /**
     * @param {?} val
     * @param {?=} options
     * @param {?=} setDirty
     * @return {?}
     */
    OFormDataComponent.prototype.setFormValue = /**
     * @param {?} val
     * @param {?=} options
     * @param {?=} setDirty
     * @return {?}
     */
    function (val, options, setDirty) {
        if (setDirty === void 0) { setDirty = false; }
        this.ensureOFormValue(val);
        if (this._fControl) {
            this._fControl.setValue(this.value.value, options);
            if (setDirty) {
                this._fControl.markAsDirty();
            }
            if (this._fControl.invalid && !this.form.isInInsertMode()) {
                this._fControl.markAsTouched();
            }
        }
        this.oldValue = this.value.value;
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.updateValidators = /**
     * @return {?}
     */
    function () {
        if (!this._fControl) {
            return;
        }
        /** @type {?} */
        var self = this;
        this._fControl.clearValidators();
        this.errorsData = [];
        /** @type {?} */
        var validators = this.resolveValidators();
        if (this.validatorChildren) {
            this.validatorChildren.forEach(function (oValidator) {
                var _a;
                /** @type {?} */
                var validatorFunction = oValidator.getValidatorFn();
                if (validatorFunction) {
                    validators.push(validatorFunction);
                }
                /** @type {?} */
                var errorsData = oValidator.getErrorsData();
                (_a = self.errorsData).push.apply(_a, errorsData);
            });
        }
        this._fControl.setValidators(validators);
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.addOntimizeCustomAppearanceClass = /**
     * @return {?}
     */
    function () {
        try {
            if (this.elRef) {
                /** @type {?} */
                var matFormFieldEl = this.elRef.nativeElement.getElementsByTagName('mat-form-field');
                if (matFormFieldEl && matFormFieldEl.length === 1) {
                    matFormFieldEl.item(0).classList.add('mat-form-field-appearance-ontimize');
                }
            }
        }
        catch (e) {
            //
        }
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.getTooltipClass = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var liteError = this.errorOptions.type === Codes.O_MAT_ERROR_LITE;
        if (!liteError) {
            return _super.prototype.getTooltipClass.call(this);
        }
        /** @type {?} */
        var errorClass = Util.isDefined(this._fControl.errors) ? 'o-mat-error' : '';
        return _super.prototype.getTooltipClass.call(this) + " " + errorClass;
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.getTooltipText = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var liteError = this.errorOptions.type === Codes.O_MAT_ERROR_LITE;
        if (liteError && Util.isDefined(this._fControl.errors) && this.oMatErrorChildren && this.oMatErrorChildren.length > 0) {
            /** @type {?} */
            var result_1 = '';
            this.oMatErrorChildren.forEach(function (oMatError) {
                result_1 += oMatError.text + "\n";
            });
            return result_1;
        }
        return _super.prototype.getTooltipText.call(this);
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.parsePermissions = /**
     * @return {?}
     */
    function () {
        // if oattr in form, it can have permissions
        if (!this.form || !Util.isDefined(this.form.oattr)) {
            return;
        }
        /** @type {?} */
        var permissions = this.form.getFormComponentPermissions(this.oattr);
        if (!Util.isDefined(permissions)) {
            return;
        }
        if (permissions.visible === false) {
            /* hide input per permissions */
            this.elRef.nativeElement.remove();
            this.destroy();
        }
        else if (permissions.enabled === false) {
            /* disable input per permissions */
            this.enabled = false;
            if (this.form) {
                this.form.registerFormComponent(this);
            }
        }
        this.permissions = permissions;
    };
    /**
     * @return {?}
     */
    OFormDataComponent.prototype.getMutationObserverTarget = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result;
        try {
            result = this.elementRef.nativeElement.getElementsByTagName('input').item(0);
        }
        catch (error) {
            //
        }
        return result;
    };
    /**
     * @param {?} count
     * @return {?}
     */
    OFormDataComponent.prototype.setSuffixClass = /**
     * @param {?} count
     * @return {?}
     */
    function (count$$1) {
        /** @type {?} */
        var iconFieldEl = this.elRef.nativeElement.getElementsByClassName('icon-field');
        if (iconFieldEl.length === 1) {
            /** @type {?} */
            var classList = [].slice.call(iconFieldEl[0].classList);
            classList.forEach(function (className) {
                if (className.startsWith('icon-field-')) {
                    iconFieldEl[0].classList.remove(className);
                }
            });
            if (count$$1 > 0) {
                /** @type {?} */
                var matSuffixClass = "icon-field-" + count$$1 + "-suffix";
                iconFieldEl[0].classList.add(matSuffixClass);
            }
        }
    };
    /**
     * Do not allow the disabled attribute to change by code or by inspector
     * @return {?}
     */
    OFormDataComponent.prototype.disableFormControl = /**
     * Do not allow the disabled attribute to change by code or by inspector
     * @return {?}
     */
    function () {
        /** @type {?} */
        var control = this.getFormControl();
        control.disable({
            onlySelf: true,
            emitEvent: false
        });
    };
    OFormDataComponent.propDecorators = {
        hostWidth: [{ type: core.HostBinding, args: ['style.width',] }],
        _matSuffixList: [{ type: core.ViewChildren, args: [material.MatSuffix,] }],
        validatorChildren: [{ type: core.ContentChildren, args: [OValidatorComponent,] }],
        oMatErrorChildren: [{ type: core.ViewChildren, args: [OMatErrorComponent,] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormDataComponent.prototype, "autoBinding", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormDataComponent.prototype, "autoRegistering", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormDataComponent.prototype, "clearButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormDataComponent.prototype, "hideRequiredMarker", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormDataComponent.prototype, "labelVisible", void 0);
    return OFormDataComponent;
}(OBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TEXT_INPUT = DEFAULT_INPUTS_O_FORM_DATA_COMPONENT.concat([
    'minLength: min-length',
    'maxLength: max-length'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_TEXT_INPUT = DEFAULT_OUTPUTS_O_FORM_DATA_COMPONENT.slice();
var OTextInputComponent = /** @class */ (function (_super) {
    __extends(OTextInputComponent, _super);
    function OTextInputComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this._minLength = -1;
        _this._maxLength = -1;
        return _this;
    }
    /**
     * @return {?}
     */
    OTextInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @return {?}
     */
    OTextInputComponent.prototype.resolveValidators = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validators = _super.prototype.resolveValidators.call(this);
        if (this.minLength >= 0) {
            validators.push(forms.Validators.minLength(this.minLength));
        }
        if (this.maxLength >= 0) {
            validators.push(forms.Validators.maxLength(this.maxLength));
        }
        return validators;
    };
    Object.defineProperty(OTextInputComponent.prototype, "minLength", {
        get: /**
         * @return {?}
         */
        function () {
            return this._minLength;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var old = this._minLength;
            this._minLength = NumberConverter(val);
            if (val !== old) {
                this.updateValidators();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTextInputComponent.prototype, "maxLength", {
        get: /**
         * @return {?}
         */
        function () {
            return this._maxLength;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var old = this._maxLength;
            this._maxLength = NumberConverter(val);
            if (val !== old) {
                this.updateValidators();
            }
        },
        enumerable: true,
        configurable: true
    });
    OTextInputComponent.DEFAULT_INPUTS_O_TEXT_INPUT = DEFAULT_INPUTS_O_TEXT_INPUT;
    OTextInputComponent.DEFAULT_OUTPUTS_O_TEXT_INPUT = DEFAULT_OUTPUTS_O_TEXT_INPUT;
    OTextInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-text-input',
                    template: "\n    <div [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\" [matTooltipClass]=\"tooltipClass\"\n      [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\">\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [hideRequiredMarker]=\"hideRequiredMarker\"\n        [class.custom-width]=\"hasCustomWidth\" [class.icon-field]=\"showClearButton\" fxFlexFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input matInput type=\"text\" [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\" [placeholder]=\"placeHolder\"\n          (focus)=\"innerOnFocus($event)\" (blur)=\"innerOnBlur($event)\" [readonly]=\"isReadOnly\"\n          (change)=\"onChangeEvent($event)\" [required]=\"isRequired\" />\n        <button type=\"button\" *ngIf=\"showClearButton\" matSuffix mat-icon-button (click)=\"onClickClearValue($event)\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('minlength')\"\n          text=\"{{ 'FORM_VALIDATION.MIN_LENGTH' | oTranslate }}: {{ getErrorValue('minlength', 'requiredLength') }}\">\n        </mat-error>\n        <mat-error *ngIf=\"hasError('maxlength')\"\n          text=\"{{ 'FORM_VALIDATION.MAX_LENGTH' | oTranslate }}: {{ getErrorValue('maxlength', 'requiredLength') }}\">\n        </mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_TEXT_INPUT,
                    outputs: DEFAULT_OUTPUTS_O_TEXT_INPUT,
                    encapsulation: core.ViewEncapsulation.None
                },] },
    ];
    /** @nocollapse */
    OTextInputComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    OTextInputComponent.propDecorators = {
        matInputRef: [{ type: core.ViewChild, args: ['matInputRef',] }]
    };
    return OTextInputComponent;
}(OFormDataComponent));
var OTextInputModule = /** @class */ (function () {
    function OTextInputModule() {
    }
    OTextInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OTextInputComponent],
                    imports: [OSharedModule, common.CommonModule],
                    exports: [OTextInputComponent]
                },] },
    ];
    return OTextInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_OUTPUTS_O_DATE_INPUT = DEFAULT_OUTPUTS_O_TEXT_INPUT.slice();
/** @type {?} */
var DEFAULT_INPUTS_O_DATE_INPUT = [
    'oformat: format',
    'olocale: locale',
    'oStartView: start-view',
    'oMinDate: min',
    'oMaxDate: max',
    'oTouchUi: touch-ui',
    'oStartAt: start-at',
    'filterDate: filter-date',
    'textInputEnabled: text-input-enabled',
    'valueType: value-type'
].concat(DEFAULT_INPUTS_O_TEXT_INPUT);
var ODateInputComponent = /** @class */ (function (_super) {
    __extends(ODateInputComponent, _super);
    function ODateInputComponent(form, dateAdapter, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.textInputEnabled = true;
        _this._oformat = 'L';
        _this.updateLocaleOnChange = false;
        _this.oStartView = 'month';
        _this._valueType = 'timestamp';
        _this.momentDateAdapter = dateAdapter;
        _this._defaultSQLTypeKey = 'DATE';
        _this.momentSrv = _this.injector.get(MomentService);
        _this.media = _this.injector.get(flexLayout.ObservableMedia);
        return _this;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    ODateInputComponent.convertToODateValueType = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        /** @type {?} */
        var result = 'timestamp';
        /** @type {?} */
        var lowerVal = (val || '').toLowerCase();
        if (lowerVal === 'string' || lowerVal === 'date' || lowerVal === 'timestamp' || lowerVal === 'iso-8601') {
            result = lowerVal;
        }
        return result;
    };
    /**
     * @return {?}
     */
    ODateInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.initialize();
        if (!this.olocale) {
            this.updateLocaleOnChange = true;
            this.olocale = this.momentSrv.getLocale();
        }
        if (this.oformat) {
            (/** @type {?} */ (this.momentDateAdapter)).oFormat = this.oformat;
        }
        this.momentDateAdapter.setLocale(this.olocale);
        if (this.oStartView) {
            this.datepicker.startView = this.oStartView;
        }
        if (this.oStartAt) {
            this.datepicker.startAt = new Date(this.oStartAt);
        }
        if (this.oMinDate) {
            /** @type {?} */
            var date = new Date(this.oMinDate);
            /** @type {?} */
            var momentD = moment__default__default(date);
            if (momentD.isValid()) {
                this.datepickerInput.min = date;
                this.minDateString = momentD.format(this.oformat);
            }
        }
        if (this.oMaxDate) {
            /** @type {?} */
            var date = new Date(this.oMaxDate);
            /** @type {?} */
            var momentD = moment__default__default(date);
            if (momentD.isValid()) {
                this.datepickerInput.max = date;
                this.maxDateString = momentD.format(this.oformat);
            }
        }
        if (this.updateLocaleOnChange) {
            this.onLanguageChangeSubscription = this.translateService.onLanguageChanged.subscribe(function () {
                _this.momentDateAdapter.setLocale(_this.translateService.getCurrentLang());
                _this.setValue(_this.getValue());
            });
        }
    };
    /**
     * @return {?}
     */
    ODateInputComponent.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.mediaSubscription = this.media.subscribe(function (change) {
            if (['xs', 'sm'].indexOf(change.mqAlias) !== -1) {
                _this.touchUi = Util.isDefined(_this.oTouchUi) ? _this.oTouchUi : true;
            }
            if (['md', 'lg', 'xl'].indexOf(change.mqAlias) !== -1) {
                _this.touchUi = Util.isDefined(_this.oTouchUi) ? _this.oTouchUi : false;
            }
        });
    };
    /**
     * @return {?}
     */
    ODateInputComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
        if (this.mediaSubscription) {
            this.mediaSubscription.unsubscribe();
        }
        if (this.onLanguageChangeSubscription) {
            this.onLanguageChangeSubscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    ODateInputComponent.prototype.getValueAsDate = /**
     * @return {?}
     */
    function () {
        return this.dateValue;
    };
    /**
     * @return {?}
     */
    ODateInputComponent.prototype.getValue = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var timestampValue = _super.prototype.getValue.call(this);
        if (timestampValue && timestampValue instanceof Date) {
            timestampValue = timestampValue.getTime();
        }
        return timestampValue;
    };
    Object.defineProperty(ODateInputComponent.prototype, "showClearButton", {
        get: /**
         * @return {?}
         */
        function () {
            return this.clearButton && !this.isReadOnly && this.enabled && this.matInputRef.nativeElement.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ODateInputComponent.prototype.open = /**
     * @return {?}
     */
    function () {
        if (!this.isReadOnly && this.enabled) {
            this.datepicker.open();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ODateInputComponent.prototype.onChangeEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var isValid = event.value && event.value.isValid && event.value.isValid();
        /** @type {?} */
        var val = isValid ? event.value.valueOf() : event.value;
        /** @type {?} */
        var m = moment__default__default(val);
        switch (this.valueType) {
            case 'string':
                if (val) {
                    val = m.format(this.oformat);
                }
                break;
            case 'date':
                val = new Date(val);
                break;
            case 'iso-8601':
                val = m.toISOString();
                break;
            case 'timestamp':
            default:
                break;
        }
        this.setValue(val, {
            changeType: OValueChangeEvent.USER_CHANGE,
            emitEvent: false,
            emitModelToViewChange: false
        });
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ODateInputComponent.prototype.onClickInput = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!this.textInputEnabled) {
            this.open();
        }
    };
    Object.defineProperty(ODateInputComponent.prototype, "filterDate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._filterDate;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._filterDate = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODateInputComponent.prototype, "oformat", {
        get: /**
         * @return {?}
         */
        function () {
            return this._oformat;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._oformat = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODateInputComponent.prototype, "minDateString", {
        get: /**
         * @return {?}
         */
        function () {
            return this._minDateString;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._minDateString = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODateInputComponent.prototype, "maxDateString", {
        get: /**
         * @return {?}
         */
        function () {
            return this._maxDateString;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._maxDateString = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODateInputComponent.prototype, "touchUi", {
        get: /**
         * @return {?}
         */
        function () {
            return this.oTouchUi || false;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.oTouchUi = val;
            this.datepicker.touchUi = this.touchUi;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} val
     * @return {?}
     */
    ODateInputComponent.prototype.ensureODateValueType = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        if (!Util.isDefined(val)) {
            return val;
        }
        /** @type {?} */
        var result = val;
        switch (this.valueType) {
            case 'string':
                if (typeof val === 'string') {
                    /** @type {?} */
                    var m = moment__default__default(val, this.oformat);
                    if (m.isValid()) {
                        this.dateValue = new Date(m.valueOf());
                    }
                }
                else {
                    result = undefined;
                }
                break;
            case 'date':
                if ((val instanceof Date)) {
                    this.dateValue = val;
                }
                else {
                    result = undefined;
                }
                break;
            case 'timestamp':
                if (typeof val === 'number') {
                    this.dateValue = new Date(val);
                }
                else {
                    result = undefined;
                }
                break;
            case 'iso-8601':
                if (typeof val !== 'string') {
                    /** @type {?} */
                    var acceptTimestamp = typeof val === 'number' && this.getSQLType() === SQLTypes.TIMESTAMP;
                    if (acceptTimestamp) {
                        this.dateValue = new Date(val);
                    }
                    else {
                        result = undefined;
                    }
                }
                else {
                    /** @type {?} */
                    var m = moment__default__default(val);
                    if (m.isValid()) {
                        this.dateValue = new Date(m.valueOf());
                    }
                    else {
                        result = undefined;
                    }
                }
                break;
            default:
                break;
        }
        if (!Util.isDefined(result)) {
            console.warn("ODateInputComponent value (" + val + ") is not consistent with value-type (" + this.valueType + ")");
        }
        return result;
    };
    /**
     * @param {?} val
     * @param {?=} options
     * @param {?=} setDirty
     * @return {?}
     */
    ODateInputComponent.prototype.setFormValue = /**
     * @param {?} val
     * @param {?=} options
     * @param {?=} setDirty
     * @return {?}
     */
    function (val, options, setDirty) {
        if (setDirty === void 0) { setDirty = false; }
        /** @type {?} */
        var value = val;
        if (val instanceof OFormValue) {
            value = val.value;
        }
        value = this.ensureODateValueType(value);
        _super.prototype.setFormValue.call(this, value, options, setDirty);
    };
    Object.defineProperty(ODateInputComponent.prototype, "valueType", {
        get: /**
         * @return {?}
         */
        function () {
            return this._valueType;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._valueType = ODateInputComponent.convertToODateValueType(val);
        },
        enumerable: true,
        configurable: true
    });
    ODateInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-date-input',
                    template: "\n    <div fxLayout=\"row\" fxLayoutAlign=\"space-between center\" [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\"\n      [matTooltipClass]=\"tooltipClass\" [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\" (click)=\"onClickInput($event)\">\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [hideRequiredMarker]=\"hideRequiredMarker\"\n        [class.custom-width]=\"hasCustomWidth\" class=\"icon-field\" fxFlexFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input matInput #matInputRef [matDatepicker]=\"d\" [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\"\n          [placeholder]=\"placeHolder\" [readonly]=\"isReadOnly || !textInputEnabled\" (focus)=\"innerOnFocus($event)\"\n          (blur)=\"innerOnBlur($event)\" [matDatepickerFilter]=\"filterDate\" (dateChange)=\"onChangeEvent($event)\"\n          [required]=\"isRequired\" [value]=\"getValueAsDate()\">\n\n        <button type=\"button\" *ngIf=\"showClearButton\" matSuffix mat-icon-button (click)=\"onClickClearValue($event)\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n        <mat-datepicker-toggle matSuffix [disabled]=\"isReadOnly || !enabled\" [class.read-only]=\"isReadOnly\" [for]=\"d\">\n          <mat-icon matDatepickerToggleIcon>today</mat-icon>\n        </mat-datepicker-toggle>\n        <mat-datepicker #d [disabled]=\"isReadOnly || !enabled\"></mat-datepicker>\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('matDatepickerParse')\"\n          text=\"{{ 'FORM_VALIDATION.DATE_PARSE' | oTranslate }} {{ oformat }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('matDatepickerFilter')\" text=\"{{ 'FORM_VALIDATION.DATE_FILTER' | oTranslate }}\">\n        </mat-error>\n        <mat-error *ngIf=\"hasError('matDatepickerMin')\"\n          text=\"{{ 'FORM_VALIDATION.DATE_MIN' | oTranslate }} {{ minDateString }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('matDatepickerMax')\"\n          text=\"{{ 'FORM_VALIDATION.DATE_MAX' | oTranslate }} {{ maxDateString }}\"></mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ['./o-date-input.component.scss'],
                    outputs: DEFAULT_OUTPUTS_O_DATE_INPUT,
                    inputs: DEFAULT_INPUTS_O_DATE_INPUT,
                    providers: [
                        { provide: material.DateAdapter, useClass: OntimizeMomentDateAdapter, deps: [material.MAT_DATE_LOCALE] }
                    ]
                },] },
    ];
    /** @nocollapse */
    ODateInputComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: material.DateAdapter },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    ODateInputComponent.propDecorators = {
        datepicker: [{ type: core.ViewChild, args: [material.MatDatepicker,] }],
        datepickerInput: [{ type: core.ViewChild, args: [material.MatDatepickerInput,] }],
        matInputRef: [{ type: core.ViewChild, args: ['matInputRef',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], ODateInputComponent.prototype, "textInputEnabled", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], ODateInputComponent.prototype, "oTouchUi", void 0);
    return ODateInputComponent;
}(OFormDataComponent));
var ODateInputModule = /** @class */ (function () {
    function ODateInputModule() {
    }
    ODateInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [ODateInputComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [ODateInputComponent]
                },] },
    ];
    return ODateInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_DATE = OBaseTableCellEditor.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR.concat([
    'format',
    'locale',
    'oStartView: start-view',
    'min',
    'max',
    'oTouchUi: touch-ui',
    'startAt: start-at',
    'filterDate: filter-date',
    'dateValueType: date-value-type'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_DATE = OBaseTableCellEditor.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR.slice();
var OTableCellEditorDateComponent = /** @class */ (function (_super) {
    __extends(OTableCellEditorDateComponent, _super);
    function OTableCellEditorDateComponent(injector, momentDateAdapter) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.momentDateAdapter = momentDateAdapter;
        _this.format = 'L';
        _this.oStartView = 'month';
        _this.oTouchUi = false;
        _this._dateValueType = 'timestamp';
        _this.momentSrv = _this.injector.get(MomentService);
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellEditorDateComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        if (!this.locale) {
            this.locale = this.momentSrv.getLocale();
        }
        if (this.format) {
            (/** @type {?} */ (this.momentDateAdapter)).oFormat = this.format;
        }
        this.momentDateAdapter.setLocale(this.locale);
        if (this.startAt) {
            this.oStartAt = new Date(this.startAt);
        }
        if (this.min) {
            /** @type {?} */
            var date = new Date(this.min);
            /** @type {?} */
            var momentD = moment__default__default(date);
            if (momentD.isValid()) {
                this.oMinDate = date;
                this.minDateString = momentD.format(this.format);
            }
        }
        if (this.max) {
            /** @type {?} */
            var date = new Date(this.max);
            /** @type {?} */
            var momentD = moment__default__default(date);
            if (momentD.isValid()) {
                this.oMaxDate = date;
                this.maxDateString = momentD.format(this.format);
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableCellEditorDateComponent.prototype.handleKeyup = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var oColumn = this.table.getOColumn(this.tableColumn.attr);
        if (!oColumn) {
            return;
        }
        if (!oColumn.editing && this.datepicker && this.datepicker.opened) {
            this.datepicker.close();
        }
        else {
            _super.prototype.handleKeyup.call(this, event);
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OTableCellEditorDateComponent.prototype.startEdition = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        _super.prototype.startEdition.call(this, data);
        if (!this.startAt) {
            this.oStartAt = this.getCellData();
        }
    };
    /**
     * @return {?}
     */
    OTableCellEditorDateComponent.prototype.getCellData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var value = _super.prototype.getCellData.call(this);
        if (Util.isDefined(value)) {
            /** @type {?} */
            var result = value;
            /** @type {?} */
            var m = void 0;
            switch (this.dateValueType) {
                case 'string':
                    m = moment__default__default(value, this.format);
                    break;
                case 'date':
                    break;
                case 'iso-8601':
                case 'timestamp':
                default:
                    m = moment__default__default(value);
                    break;
            }
            if (Util.isDefined(m)) {
                result = m.toDate();
            }
            return result;
        }
        return value;
    };
    /**
     * @return {?}
     */
    OTableCellEditorDateComponent.prototype.commitEdition = /**
     * @return {?}
     */
    function () {
        // !this.datepicker.opened &&
        if (!this.formControl.invalid) {
            this.oldValue = this._rowData[this.tableColumnAttr];
            this._rowData[this.tableColumnAttr] = this.getValueByValyType();
            if (!this.isSilentControl()) {
                this.endEdition(true);
                this.editionCommitted.emit(this._rowData);
            }
        }
    };
    /**
     * @return {?}
     */
    OTableCellEditorDateComponent.prototype.getValueByValyType = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = this.formControl.value;
        /** @type {?} */
        var m = moment__default__default(this.formControl.value);
        switch (this.dateValueType) {
            case 'string':
                result = m.format(this.format);
                break;
            case 'date':
                result = new Date(result);
                break;
            case 'iso-8601':
                result = m.toISOString();
                break;
            case 'timestamp':
            default:
                result = m.valueOf();
                break;
        }
        return result;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableCellEditorDateComponent.prototype.onDateChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var isValid = event.value && event.value.isValid && event.value.isValid();
        /** @type {?} */
        var val = isValid ? event.value.valueOf() : event.value;
        /** @type {?} */
        var m = moment__default__default(val);
        switch (this.dateValueType) {
            case 'string':
                if (val) {
                    val = m.format(this.format);
                }
                break;
            case 'date':
                val = new Date(val);
                break;
            case 'iso-8601':
                val = m.toISOString();
                break;
            case 'timestamp':
            default:
                break;
        }
        this.formControl.setValue(val, {
            emitModelToViewChange: false,
            emitEvent: false
        });
    };
    /**
     * @param {?} d
     * @return {?}
     */
    OTableCellEditorDateComponent.prototype.openDatepicker = /**
     * @param {?} d
     * @return {?}
     */
    function (d) {
        this.datepicker = d;
        d.open();
    };
    Object.defineProperty(OTableCellEditorDateComponent.prototype, "dateValueType", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dateValueType;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._dateValueType = ODateInputComponent.convertToODateValueType(val);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableCellEditorDateComponent.prototype.onClosed = /**
     * @return {?}
     */
    function () {
        this.inputRef.nativeElement.focus();
    };
    OTableCellEditorDateComponent.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_DATE = DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_DATE;
    OTableCellEditorDateComponent.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_DATE = DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_DATE;
    OTableCellEditorDateComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-editor-date',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\" let-rowvalue=\"rowvalue\">\n      <div [formGroup]=\"formGroup\" class=\"o-table-cell-editor-date\">\n        <mat-form-field floatLabel=\"never\">\n          <input #input matInput [placeholder]=\"getPlaceholder()\" [formControl]=\"formControl\"\n            [required]=\"orequired\" [matDatepicker]=\"d\" [matDatepickerFilter]=\"filterDate\"\n            (dateChange)=\"onDateChange($event)\" [min]=\"oMinDate\" [max]=\"oMaxDate\">\n\n          <mat-datepicker #d [startView]=\"oStartView\" [startAt]=\"oStartAt\" [touchUi]=\"oTouchUi\" (closed)=\"onClosed()\">\n          </mat-datepicker>\n\n          <span class=\"icon-btn\" (click)=\"openDatepicker(d)\" matSuffix>\n            <mat-icon svgIcon=\"ontimize:today\"></mat-icon>\n          </span>\n\n          <mat-error *ngIf=\"hasError('required')\">{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}</mat-error>\n          <mat-error *ngIf=\"hasError('matDatepickerParse')\">{{ 'FORM_VALIDATION.DATE_PARSE' | oTranslate }} {{ format }}\n          </mat-error>\n          <mat-error *ngIf=\"hasError('matDatepickerFilter')\">{{ 'FORM_VALIDATION.DATE_FILTER' | oTranslate }}</mat-error>\n          <mat-error *ngIf=\"hasError('matDatepickerMin')\">{{ 'FORM_VALIDATION.DATE_MIN' | oTranslate }} {{ minDateString }}\n          </mat-error>\n          <mat-error *ngIf=\"hasError('matDatepickerMax')\">{{ 'FORM_VALIDATION.DATE_MAX' | oTranslate }} {{ maxDateString }}\n          </mat-error>\n        </mat-form-field>\n      </div>\n    </ng-template>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_DATE,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_DATE,
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    providers: [
                        { provide: material.DateAdapter, useClass: OntimizeMomentDateAdapter, deps: [material.MAT_DATE_LOCALE] }
                    ]
                },] },
    ];
    /** @nocollapse */
    OTableCellEditorDateComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: material.DateAdapter }
    ]; };
    OTableCellEditorDateComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }],
        inputRef: [{ type: core.ViewChild, args: ['input',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableCellEditorDateComponent.prototype, "oTouchUi", void 0);
    return OTableCellEditorDateComponent;
}(OBaseTableCellEditor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_INTEGER = OBaseTableCellEditor.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR.concat([
    'min',
    'max',
    'step'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_INTEGER = OBaseTableCellEditor.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR.slice();
var OTableCellEditorIntegerComponent = /** @class */ (function (_super) {
    __extends(OTableCellEditorIntegerComponent, _super);
    function OTableCellEditorIntegerComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.step = 1;
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellEditorIntegerComponent.prototype.getCellData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var cellData = _super.prototype.getCellData.call(this);
        /** @type {?} */
        var intValue = parseInt(cellData);
        return isNaN(intValue) ? undefined : intValue;
    };
    /**
     * @return {?}
     */
    OTableCellEditorIntegerComponent.prototype.resolveValidators = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validators = _super.prototype.resolveValidators.call(this);
        if (typeof (this.min) !== 'undefined') {
            validators.push(this.minValidator.bind(this));
        }
        if (typeof (this.max) !== 'undefined') {
            validators.push(this.maxValidator.bind(this));
        }
        return validators;
    };
    /**
     * @param {?} control
     * @return {?}
     */
    OTableCellEditorIntegerComponent.prototype.minValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if ((typeof (control.value) === 'number') && (control.value < this.min)) {
            return {
                'min': {
                    'requiredMin': this.min
                }
            };
        }
        return {};
    };
    /**
     * @param {?} control
     * @return {?}
     */
    OTableCellEditorIntegerComponent.prototype.maxValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if ((typeof (control.value) === 'number') && (this.max < control.value)) {
            return {
                'max': {
                    'requiredMax': this.max
                }
            };
        }
        return {};
    };
    OTableCellEditorIntegerComponent.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_INTEGER = DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_INTEGER;
    OTableCellEditorIntegerComponent.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_INTEGER = DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_INTEGER;
    OTableCellEditorIntegerComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-editor-integer',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\" let-rowvalue=\"rowvalue\">\n      <div [formGroup]=\"formGroup\">\n        <mat-form-field floatLabel=\"never\">\n          <input #input matInput type=\"number\" [placeholder]=\"getPlaceholder()\" [formControl]=\"formControl\"\n            [required]=\"orequired\" [min]=\"min\" [max]=\"max\" [step]=\"step\">\n          <mat-error *ngIf=\"hasError('required')\">{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}</mat-error>\n          <mat-error *ngIf=\"hasError('min')\">{{ 'FORM_VALIDATION.MIN_VALUE' | oTranslate }}:\n            {{ getErrorValue('min', 'requiredMin') }}</mat-error>\n          <mat-error *ngIf=\"hasError('max')\">{{ 'FORM_VALIDATION.MAX_VALUE' | oTranslate }}:\n            {{ getErrorValue('max', 'requiredMax') }}</mat-error>\n        </mat-form-field>\n      </div>\n    </ng-template>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_INTEGER,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_INTEGER
                },] },
    ];
    /** @nocollapse */
    OTableCellEditorIntegerComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellEditorIntegerComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableCellEditorIntegerComponent.prototype, "min", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableCellEditorIntegerComponent.prototype, "max", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableCellEditorIntegerComponent.prototype, "step", void 0);
    return OTableCellEditorIntegerComponent;
}(OBaseTableCellEditor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_REAL = OTableCellEditorIntegerComponent.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_INTEGER.slice();
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_REAL = OTableCellEditorIntegerComponent.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_INTEGER.slice();
var OTableCellEditorRealComponent = /** @class */ (function (_super) {
    __extends(OTableCellEditorRealComponent, _super);
    function OTableCellEditorRealComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.step = 0.01;
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellEditorRealComponent.prototype.getCellData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var cellData = _super.prototype.getCellData.call(this);
        /** @type {?} */
        var floatValue = parseFloat(cellData);
        return isNaN(floatValue) ? undefined : floatValue;
    };
    /**
     * @return {?}
     */
    OTableCellEditorRealComponent.prototype.resolveValidators = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validators = _super.prototype.resolveValidators.call(this);
        if (typeof (this.min) !== 'undefined') {
            validators.push(this.minValidator.bind(this));
        }
        if (typeof (this.max) !== 'undefined') {
            validators.push(this.maxValidator.bind(this));
        }
        return validators;
    };
    /**
     * @param {?} control
     * @return {?}
     */
    OTableCellEditorRealComponent.prototype.minValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if ((typeof (control.value) === 'number') && (control.value < this.min)) {
            return {
                'min': {
                    'requiredMin': this.min
                }
            };
        }
        return {};
    };
    /**
     * @param {?} control
     * @return {?}
     */
    OTableCellEditorRealComponent.prototype.maxValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if ((typeof (control.value) === 'number') && (this.max < control.value)) {
            return {
                'max': {
                    'requiredMax': this.max
                }
            };
        }
        return {};
    };
    OTableCellEditorRealComponent.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_REAL = DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_REAL;
    OTableCellEditorRealComponent.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_REAL = DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_REAL;
    OTableCellEditorRealComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-editor-real',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\" let-rowvalue=\"rowvalue\">\n      <div [formGroup]=\"formGroup\">\n        <mat-form-field floatLabel=\"never\">\n\n          <input #input matInput type=\"number\" [placeholder]=\"getPlaceholder()\" [formControl]=\"formControl\"\n            [required]=\"orequired\" [min]=\"min\" [max]=\"max\" [step]=\"step\">\n\n          <mat-error *ngIf=\"hasError('required')\">{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}</mat-error>\n          <mat-error *ngIf=\"hasError('min')\">{{ 'FORM_VALIDATION.MIN_VALUE' | oTranslate }}:\n            {{ getErrorValue('min', 'requiredMin') }}</mat-error>\n          <mat-error *ngIf=\"hasError('max')\">{{ 'FORM_VALIDATION.MAX_VALUE' | oTranslate }}:\n            {{ getErrorValue('max', 'requiredMax') }}</mat-error>\n\n        </mat-form-field>\n      </div>\n    </ng-template>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_REAL,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_REAL
                },] },
    ];
    /** @nocollapse */
    OTableCellEditorRealComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellEditorRealComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableCellEditorRealComponent.prototype, "min", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableCellEditorRealComponent.prototype, "max", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableCellEditorRealComponent.prototype, "step", void 0);
    return OTableCellEditorRealComponent;
}(OBaseTableCellEditor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TEXT = OBaseTableCellEditor.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR.slice();
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TEXT = OBaseTableCellEditor.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR.slice();
var OTableCellEditorTextComponent = /** @class */ (function (_super) {
    __extends(OTableCellEditorTextComponent, _super);
    function OTableCellEditorTextComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        return _this;
    }
    OTableCellEditorTextComponent.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TEXT = DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TEXT;
    OTableCellEditorTextComponent.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TEXT = DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TEXT;
    OTableCellEditorTextComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-editor-text',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\" let-rowvalue=\"rowvalue\">\n      <div [formGroup]=\"formGroup\">\n        <mat-form-field floatLabel=\"never\">\n          <input #input matInput type=\"text\" [placeholder]=\"getPlaceholder()\" [formControl]=\"formControl\"\n            [required]=\"orequired\">\n          <mat-error *ngIf=\"hasError('required')\">{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}</mat-error>\n        </mat-form-field>\n      </div>\n    </ng-template>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TEXT,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TEXT
                },] },
    ];
    /** @nocollapse */
    OTableCellEditorTextComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellEditorTextComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }],
        inputRef: [{ type: core.ViewChild, args: ['input',] }]
    };
    return OTableCellEditorTextComponent;
}(OBaseTableCellEditor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TIME = OBaseTableCellEditor.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR.concat([
    'oDateFormat: date-format',
    'oDateLocale: date-locale',
    'oDateStartView: date-start-view',
    'oMinDate: date-min',
    'oMaxDate: date-max',
    'oDateTouchUi: date-touch-ui',
    'oDateStartAt: date-start-at',
    'oHourFormat: hour-format',
    'oHourMin: hour-min',
    'oHourMax: hour-max',
    'oHourPlaceholder: hour-placeholder',
    'oDatePlaceholder: date-placeholder'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TIME = OBaseTableCellEditor.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR.slice();
var 0$3$1 = materialMomentAdapter.MAT_MOMENT_DATE_FORMATS;
var OTableCellEditorTimeComponent = /** @class */ (function (_super) {
    __extends(OTableCellEditorTimeComponent, _super);
    function OTableCellEditorTimeComponent(injector, adapter) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.adapter = adapter;
        _this.oStartView = 'month';
        _this.oDateFormat = 'L';
        _this.oHourFormat = Codes.TWENTY_FOUR_HOUR_FORMAT;
        _this.onKeyboardInputDone = false;
        _this.enabledCommitOnTabPress = false;
        _this.activeKeys = {};
        _this.momentSrv = _this.injector.get(MomentService);
        return _this;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.onDocumentKeydown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.handleKeydown(event);
    };
    /**
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        this.createInternalFormControl();
        if (!this._oDateLocale) {
            this.oDateLocale = this.momentSrv.getLocale();
        }
        if (this.oMinDate) {
            /** @type {?} */
            var date = new Date(this.oMinDate);
            /** @type {?} */
            var momentD = moment__default__default(date);
            if (momentD.isValid()) {
                this.minDateString = momentD.format(this.oDateFormat);
            }
        }
        if (this.oMaxDate) {
            /** @type {?} */
            var date = new Date(this.oMaxDate);
            /** @type {?} */
            var momentD = moment__default__default(date);
            if (momentD.isValid()) {
                this.maxDateString = momentD.format(this.oDateFormat);
            }
        }
    };
    /**
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.createInternalFormControl = /**
     * @return {?}
     */
    function () {
        if (!this.formControlDate) {
            /** @type {?} */
            var validators = this.resolveValidators();
            /** @type {?} */
            var cfg = {
                value: undefined,
                disabled: !this.enabled
            };
            this.formControlDate = new forms.FormControl(cfg, validators);
            this.formGroup.addControl('dateInput', this.formControlDate);
        }
        if (!this.formControlHour) {
            /** @type {?} */
            var validators = this.resolveValidators();
            /** @type {?} */
            var cfg = {
                value: undefined,
                disabled: !this.enabled
            };
            this.formControlHour = new forms.FormControl(cfg, validators);
            this.formGroup.addControl('hourInput', this.formControlHour);
        }
    };
    /**
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        this.modifyPickerMethods();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.setTime = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.picker.setTime();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.onDateChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var isValid = event.value && event.value.isValid && event.value.isValid();
        /** @type {?} */
        var val = isValid ? event.value.valueOf() : moment__default__default().startOf('day');
        this.formControlDate.setValue(val, {
            emitModelToViewChange: false,
            emitEvent: false
        });
        this.updateComponentValue();
    };
    /**
     * @param {?} blurEvent
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.updateValeOnInputChange = /**
     * @param {?} blurEvent
     * @return {?}
     */
    function (blurEvent) {
        if (this.onKeyboardInputDone) {
            /** @type {?} */
            var value = blurEvent.currentTarget.value;
            // ngx-material-timepicker does not allow writing characters on input, so we add 'AM/PM' in order to make validation work properly
            value = this.parseHour(value);
            this.formControlHour.setValue(value);
        }
        this.onKeyboardInputDone = false;
    };
    /**
     * Receives an hour input introduced by the user and returns the hour formated acording current format
     * @param value
     */
    /**
     * Receives an hour input introduced by the user and returns the hour formated acording current format
     * @param {?} value
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.parseHour = /**
     * Receives an hour input introduced by the user and returns the hour formated acording current format
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var strArray = value.split(':');
        /** @type {?} */
        var hour = strArray[0];
        if (Codes.TWELVE_FOUR_HOUR_FORMAT === this.oHourFormat) {
            if (hour) {
                hour = parseInt(hour);
                /** @type {?} */
                var period = hour <= 12 ? ' AM' : ' PM';
                if (hour > 12) {
                    hour = hour - 12;
                }
                strArray[0] = hour;
                value = strArray.join(':') + period;
            }
        }
        return value;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.onHourChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var value;
        if (event instanceof Event) {
            this.updateValeOnInputChange(event);
        }
        else {
            value = this.convertToFormatString(event);
            /** emitModelToViewChange: false  because onChange event is trigger in ngModelChange */
            this.formControlHour.setValue(value, {
                emitEvent: false,
                emitModelToViewChange: false
            });
        }
        this.updateComponentValue();
    };
    /**
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.setTimestampValue = /**
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    function (value, options) {
        /** @type {?} */
        var parsedValue;
        /** @type {?} */
        var momentV = Util.isDefined(value) ? moment__default__default(value) : value;
        if (momentV && momentV.isValid()) {
            parsedValue = momentV.utcOffset(0).format(this.formatString);
        }
        this.formControlHour.setValue(parsedValue, options);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.convertToFormatString = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value === '00:00' || !Util.isDefined(value)) {
            return value;
        }
        /** @type {?} */
        var formatStr = this.oHourFormat === Codes.TWENTY_FOUR_HOUR_FORMAT ? 'HH:mm' : 'hh:mm a';
        /** @type {?} */
        var result = value;
        if (typeof value === 'number') {
            result = moment__default__default(value).format(formatStr);
        }
        else {
            result = value ? moment__default__default(value, 'h:mm A').format(formatStr) : value;
        }
        return result;
    };
    /**
     * @param {?} d
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.openDatepicker = /**
     * @param {?} d
     * @return {?}
     */
    function (d) {
        this.datepicker = d;
        d.open();
    };
    /**
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.getPlaceholderHour = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var placeholder = '';
        if (this.oHourPlaceholder) {
            placeholder = this.translateService.get(this.oHourPlaceholder);
        }
        else {
            placeholder = _super.prototype.getPlaceholder.call(this);
        }
        return placeholder;
    };
    /**
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.getPlaceholderDate = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var placeholder = '';
        if (this.oDatePlaceholder) {
            placeholder = this.translateService.get(this.oDatePlaceholder);
        }
        else {
            placeholder = _super.prototype.getPlaceholder.call(this);
        }
        return placeholder;
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.open = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (Util.isDefined(e)) {
            e.stopPropagation();
        }
        if (this.picker) {
            this.picker.open();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.handleKeydown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.activeKeys[e.keyCode] = true;
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.handleKeyup = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.activeKeys[e.keyCode] = false;
        /** @type {?} */
        var oColumn = this.table.getOColumn(this.tableColumn.attr);
        if (!oColumn) {
            return;
        }
        if (e.keyCode === 9 && (this.activeKeys[16] || !this.enabledCommitOnTabPress)) {
            // tab + shift or tab pressed with focus in the date component
            return;
        }
        if (!oColumn.editing && this.datepicker && this.datepicker.opened) {
            this.datepicker.close();
        }
        else {
            _super.prototype.handleKeyup.call(this, e);
        }
    };
    /**
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.updateComponentValue = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var timeValue;
        /** @type {?} */
        var values = this.formGroup.getRawValue();
        /** @type {?} */
        var mDate = (values['dateInput'] ? moment__default__default(values['dateInput']) : moment__default__default()).startOf('day');
        /** @type {?} */
        var mHour = moment__default__default(values['hourInput'], this.formatString);
        timeValue = mDate.clone()
            .set('hour', mHour.get('hour'))
            .set('minute', mHour.get('minutes'))
            .valueOf();
        if (this.formControl) {
            this.formControl.setValue(timeValue);
            this.formControl.markAsDirty();
        }
    };
    /**
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.modifyPickerMethods = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.picker) {
            /** @type {?} */
            var ngxTimepicker = this.picker.timepickerInput;
            if (ngxTimepicker && ngxTimepicker.onInput) {
                ngxTimepicker.onInput = function (value) { return _this.onKeyboardInputDone = true; };
            }
        }
    };
    /**
     * @param {?} error
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.hasErrorDate = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        return this.formControlDate && this.formControlDate.touched && this.hasErrorExclusive(error);
    };
    /**
     * @param {?} error
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.hasErrorExclusive = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        /** @type {?} */
        var hasError = false;
        /** @type {?} */
        var errorsOrder = ['matDatepickerMax', 'matDatepickerMin', 'matDatepickerFilter', 'matDatepickerParse', 'required'];
        /** @type {?} */
        var errors = this.formControlDate.errors;
        if (Util.isDefined(errors)) {
            if (Object.keys(errors).length === 1) {
                return errors.hasOwnProperty(error);
            }
            else {
                for (var i = 0, len = errorsOrder.length; i < len; i++) {
                    hasError = errors.hasOwnProperty(errorsOrder[i]);
                    if (hasError) {
                        hasError = (errorsOrder[i] === error);
                        break;
                    }
                }
            }
        }
        return hasError;
    };
    /**
     * @param {?} error
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.hasErrorHour = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        return this.formControlHour && this.formControlHour.touched;
    };
    /**
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.getCellDataDate = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var value = _super.prototype.getCellData.call(this);
        if (Util.isDefined(value)) {
            /** @type {?} */
            var m = moment__default__default(value);
            /** @type {?} */
            var result = value;
            if (Util.isDefined(m)) {
                result = m.toDate();
            }
            return result;
        }
        return value;
    };
    /**
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.getCellDataHour = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var value = _super.prototype.getCellData.call(this);
        if (Util.isDefined(value)) {
            /** @type {?} */
            var m = moment__default__default(value);
            /** @type {?} */
            var result = value;
            if (Util.isDefined(m)) {
                result = m.format(Codes.formatString(this.oHourFormat));
            }
            return result;
        }
        return value;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.startEdition = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        _super.prototype.startEdition.call(this, data);
        /** @type {?} */
        var cellDataDate = this.getCellDataDate();
        this.formControlDate.setValue(cellDataDate);
        /** @type {?} */
        var cellDataHour = this.getCellDataHour();
        this.formControlHour.setValue(cellDataHour);
        this.formGroup.markAsTouched();
    };
    Object.defineProperty(OTableCellEditorTimeComponent.prototype, "formatString", {
        get: /**
         * @return {?}
         */
        function () {
            return Codes.formatString(this.oHourFormat);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableCellEditorTimeComponent.prototype, "minDateString", {
        get: /**
         * @return {?}
         */
        function () {
            return this._minDateString;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._minDateString = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableCellEditorTimeComponent.prototype, "maxDateString", {
        get: /**
         * @return {?}
         */
        function () {
            return this._maxDateString;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._maxDateString = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableCellEditorTimeComponent.prototype, "oDateLocale", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._oDateLocale = value;
            if (Util.isDefined(this._oDateLocale)) {
                this.adapter.setLocale(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableCellEditorTimeComponent.prototype, "minDate", {
        get: /**
         * @return {?}
         */
        function () {
            return new Date(this.oMinDate);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableCellEditorTimeComponent.prototype, "maxDate", {
        get: /**
         * @return {?}
         */
        function () {
            return new Date(this.oMaxDate);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.onDatepickerClosed = /**
     * @return {?}
     */
    function () {
        this.dateInput.nativeElement.focus();
    };
    /**
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.onTimepickerClosed = /**
     * @return {?}
     */
    function () {
        this.hourInput.nativeElement.focus();
    };
    /**
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.commitEdition = /**
     * @return {?}
     */
    function () {
        if (!this.formGroup.invalid) {
            _super.prototype.commitEdition.call(this);
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OTableCellEditorTimeComponent.prototype.onKeyDown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!Codes.isHourInputAllowed(e)) {
            e.preventDefault();
        }
    };
    OTableCellEditorTimeComponent.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TIME = DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TIME;
    OTableCellEditorTimeComponent.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TIME = DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TIME;
    OTableCellEditorTimeComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-editor-time',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\" let-rowvalue=\"rowvalue\">\n      <div [formGroup]=\"formGroup\" class=\"o-table-cell-editor-time\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\"\n        fxLayoutGap=\"8px\">\n        <mat-form-field floatLabel=\"never\">\n\n          <input #dateInput matInput [placeholder]=\"getPlaceholderDate()\" [formControl]=\"formControlDate\"\n            [required]=\"orequired\" [matDatepicker]=\"d\" (dateChange)=\"onDateChange($event)\" [min]=\"minDate\" [max]=\"maxDate\"\n            (focus)=\"enabledCommitOnTabPress = false\">\n\n          <mat-datepicker #d [startView]=\"oStartView\" [startAt]=\"oStartAt\" [touchUi]=\"oTouchUi\" (closed)=\"onDatepickerClosed()\">\n          </mat-datepicker>\n\n          <span class=\"icon-btn\" (click)=\"openDatepicker(d)\" matSuffix>\n            <mat-icon svgIcon=\"ontimize:today\"></mat-icon>\n          </span>\n\n          <mat-error *ngIf=\"hasErrorDate('required') || hasErrorHour('required')\"\n            text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n          <mat-error *ngIf=\"hasErrorDate('matDatepickerParse')\"\n            text=\"{{ 'FORM_VALIDATION.DATE_PARSE' | oTranslate }} {{ format }}\"></mat-error>\n\n          <mat-error *ngIf=\"hasErrorDate('matDatepickerFilter')\" text=\"{{ 'FORM_VALIDATION.DATE_FILTER' | oTranslate }}\">\n          </mat-error>\n          <mat-error *ngIf=\"hasErrorDate('matDatepickerMin')\"\n            text=\"{{ 'FORM_VALIDATION.DATE_MIN' | oTranslate }} {{ minDateString }}\"></mat-error>\n\n          <mat-error *ngIf=\"hasErrorDate('matDatepickerMax')\"\n            text=\"{{ 'FORM_VALIDATION.DATE_MAX' | oTranslate }} {{ maxDateString }}\"></mat-error>\n\n        </mat-form-field>\n\n        <span class=\"separator\">&ndash;</span>\n\n        <mat-form-field floatLabel=\"never\">\n\n          <input #hourInput matInput [ngxTimepicker]=\"picker\" [placeholder]=\"getPlaceholderHour()\"\n            [formControl]=\"formControlHour\" [required]=\"orequired\" (change)=\"onHourChange($event)\" [min]=\"oHourMin\"\n            [max]=\"oHourMax\" (keydown)=\"onKeyDown($event)\" [disableClick]=\"true\" [format]=\"oHourFormat\"\n            (blur)=\"enabledCommitOnTabPress = true\">\n\n          <button type=\"button\" matSuffix mat-icon-button (click)=\"open($event)\">\n            <mat-icon ngxMaterialTimepickerToggleIcon svgIcon=\"ontimize:clock\"></mat-icon>\n          </button>\n\n          <mat-error *ngIf=\"hasErrorHour('invalidFormatHour')\"\n            text=\"{{ 'FORM_VALIDATION.HOUR_FORMAT' | oTranslate }} {{ formatString }}\"></mat-error>\n\n        </mat-form-field>\n\n        <ngx-material-timepicker #picker (timeSet)=\"onHourChange($event)\" [confirmBtnTmpl]=\"confirmBtn\"\n          [cancelBtnTmpl]=\"cancelBtn\" (closed)=\"onTimepickerClosed($event)\"></ngx-material-timepicker>\n        <ng-template #confirmBtn>\n          <button mat-stroked-button type=\"button\" (click)=\"setTime($event)\"><span>{{'OK' | oTranslate}}</span></button>\n        </ng-template>\n        <ng-template #cancelBtn>\n          <button mat-stroked-button type=\"button\" (click)=\"picker.close()\"><span>{{'CANCEL' | oTranslate}}</span></button>\n        </ng-template>\n      </div>\n\n    </ng-template>\n  ",
                    styles: ["\n    .separator{cursor:default}.mat-form-field:not(.custom-width) .mat-form-field-infix{width:84px}button.mat-stroked-button{margin:0 6px}\n  "],
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TIME,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TIME,
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    providers: [
                        { provide: material.DateAdapter, useClass: materialMomentAdapter.MomentDateAdapter, deps: [material.MAT_DATE_LOCALE] },
                        { provide: material.MAT_DATE_FORMATS, useValue: 0$3$1 },
                    ],
                },] },
    ];
    /** @nocollapse */
    OTableCellEditorTimeComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: material.DateAdapter }
    ]; };
    OTableCellEditorTimeComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }],
        dateInput: [{ type: core.ViewChild, args: ['dateInput',] }],
        hourInput: [{ type: core.ViewChild, args: ['hourInput',] }],
        picker: [{ type: core.ViewChild, args: ['picker',] }],
        datepickerInput: [{ type: core.ViewChild, args: [material.MatDatepickerInput,] }],
        onDocumentKeydown: [{ type: core.HostListener, args: ['document:keydown', ['$event'],] }]
    };
    return OTableCellEditorTimeComponent;
}(OBaseTableCellEditor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var O_TABLE_CELL_EDITORS = [
    OTableCellEditorBooleanComponent,
    OTableCellEditorDateComponent,
    OTableCellEditorIntegerComponent,
    OTableCellEditorRealComponent,
    OTableCellEditorTextComponent,
    OTableCellEditorTimeComponent
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OBaseTableCellRenderer = /** @class */ (function () {
    function OBaseTableCellRenderer(injector) {
        this.injector = injector;
        this.tableColumn = this.injector.get(OTableColumnComponent);
    }
    /**
     * @return {?}
     */
    OBaseTableCellRenderer.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.registerRenderer();
    };
    Object.defineProperty(OBaseTableCellRenderer.prototype, "table", {
        get: /**
         * @return {?}
         */
        function () {
            return this.tableColumn.table;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OBaseTableCellRenderer.prototype, "column", {
        get: /**
         * @return {?}
         */
        function () {
            return this.tableColumn.attr;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OBaseTableCellRenderer.prototype.registerRenderer = /**
     * @return {?}
     */
    function () {
        this.tableColumn.registerRenderer(this);
        if (!Util.isDefined(this.type) && Util.isDefined(this.tableColumn.type)) {
            this.type = this.tableColumn.type;
        }
    };
    /**
     * Returns the displayed table cell value
     * @param {?} cellvalue the internal table cell value
     * @param {?=} rowvalue the table row value
     * @return {?}
     */
    OBaseTableCellRenderer.prototype.getCellData = /**
     * Returns the displayed table cell value
     * @param {?} cellvalue the internal table cell value
     * @param {?=} rowvalue the table row value
     * @return {?}
     */
    function (cellvalue, rowvalue) {
        /** @type {?} */
        var parsedValue;
        if (this.componentPipe && typeof this.pipeArguments !== 'undefined' && cellvalue !== undefined) {
            parsedValue = this.componentPipe.transform(cellvalue, this.pipeArguments);
        }
        else {
            parsedValue = cellvalue;
        }
        return parsedValue;
    };
    /**
     * @param {?} cellValue
     * @param {?} rowValue
     * @return {?}
     */
    OBaseTableCellRenderer.prototype.getTooltip = /**
     * @param {?} cellValue
     * @param {?} rowValue
     * @return {?}
     */
    function (cellValue, rowValue) {
        return this.getCellData(cellValue, rowValue);
    };
    return OBaseTableCellRenderer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_ACTION = [
    'icon',
    'svgIcon:svg-icon',
    'action',
    'text',
    'iconPosition: icon-position'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_CELL_RENDERER_ACTION = [
    'onClick'
];
var OTableCellRendererActionComponent = /** @class */ (function (_super) {
    __extends(OTableCellRendererActionComponent, _super);
    function OTableCellRendererActionComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.onClick = new core.EventEmitter();
        _this.tableColumn.type = 'action';
        _this.tableColumn.orderable = false;
        _this.tableColumn.searchable = false;
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellRendererActionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.table) {
            /** @type {?} */
            var oCol = this.table.getOColumn(this.tableColumn.attr);
            oCol.title = undefined;
        }
        this.iconPosition = Util.parseIconPosition(this.iconPosition);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OTableCellRendererActionComponent.prototype.getCellData = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value;
    };
    /**
     * @param {?} event
     * @param {?} rowData
     * @return {?}
     */
    OTableCellRendererActionComponent.prototype.innerOnClick = /**
     * @param {?} event
     * @param {?} rowData
     * @return {?}
     */
    function (event, rowData) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        if (Util.isDefined(this.action)) {
            switch (this.action.toLowerCase()) {
                case 'detail':
                    this.table.viewDetail(rowData);
                    break;
                case 'edit':
                    this.table.editDetail(rowData);
                    break;
                default:
                    break;
            }
        }
        else {
            this.onClick.emit(rowData);
        }
    };
    Object.defineProperty(OTableCellRendererActionComponent.prototype, "icon", {
        get: /**
         * @return {?}
         */
        function () {
            return this._icon;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._icon = arg;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableCellRendererActionComponent.prototype.isIconPositionLeft = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this.icon) && this.iconPosition === Codes.ICON_POSITION_LEFT;
    };
    /**
     * @return {?}
     */
    OTableCellRendererActionComponent.prototype.isIconPositionRight = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this.icon) && this.iconPosition === Codes.ICON_POSITION_RIGHT;
    };
    /**
     * @return {?}
     */
    OTableCellRendererActionComponent.prototype.isSvgIconPositionRight = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this.svgIcon) && this.iconPosition === Codes.ICON_POSITION_RIGHT;
    };
    /**
     * @return {?}
     */
    OTableCellRendererActionComponent.prototype.isSvgIconPositionLeft = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this.svgIcon) && this.iconPosition === Codes.ICON_POSITION_LEFT;
    };
    OTableCellRendererActionComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_ACTION = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_ACTION;
    OTableCellRendererActionComponent.DEFAULT_OUTPUTS_O_TABLE_CELL_RENDERER_ACTION = DEFAULT_OUTPUTS_O_TABLE_CELL_RENDERER_ACTION;
    OTableCellRendererActionComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-renderer-action',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\" let-rowvalue=\"rowvalue\">\n      <span class=\"o-action-cell-renderer\" (click)=\"innerOnClick($event, rowvalue)\">\n        <mat-icon *ngIf=\"isIconPositionLeft()\">{{ icon }}</mat-icon>\n        <mat-icon *ngIf=\"isSvgIconPositionLeft()\" [svgIcon]=\"svgIcon\"></mat-icon>\n        <span *ngIf=\"text !== undefined\">{{ text | oTranslate }}</span>\n        <mat-icon *ngIf=\"isIconPositionRight()\">{{ icon }}</mat-icon>\n        <mat-icon *ngIf=\"isSvgIconPositionRight()\" [svgIcon]=\"svgIcon\"></mat-icon>\n      </span>\n    </ng-template>\n  ",
                    styles: ["\n    :host .mat-icon{margin:0 4px}\n  "],
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_ACTION,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_CELL_RENDERER_ACTION
                },] },
    ];
    /** @nocollapse */
    OTableCellRendererActionComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellRendererActionComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    return OTableCellRendererActionComponent;
}(OBaseTableCellRenderer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_BOOLEAN = [
    'trueValue: true-value',
    'falseValue: false-value',
    'booleanType: boolean-type',
    'renderTrueValue: render-true-value',
    'renderFalseValue: render-false-value',
    'renderType: render-type'
];
var OTableCellRendererBooleanComponent = /** @class */ (function (_super) {
    __extends(OTableCellRendererBooleanComponent, _super);
    function OTableCellRendererBooleanComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this._renderType = 'string';
        _this._booleanType = 'boolean';
        _this.tableColumn.type = 'boolean';
        _this.translateService = _this.injector.get(OTranslateService$$1);
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellRendererBooleanComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.parseInputs();
    };
    /**
     * @return {?}
     */
    OTableCellRendererBooleanComponent.prototype.parseInputs = /**
     * @return {?}
     */
    function () {
        switch (this.booleanType) {
            case 'string':
                this.parseStringInputs();
                break;
            case 'number':
                this.parseNumberInputs();
                break;
            default:
                this.trueValue = true;
                this.falseValue = false;
                break;
        }
    };
    /**
     * @return {?}
     */
    OTableCellRendererBooleanComponent.prototype.parseStringInputs = /**
     * @return {?}
     */
    function () {
        if ((this.trueValue || '').length === 0) {
            this.trueValue = undefined;
        }
        if ((this.falseValue || '').length === 0) {
            this.falseValue = undefined;
        }
    };
    /**
     * @return {?}
     */
    OTableCellRendererBooleanComponent.prototype.parseNumberInputs = /**
     * @return {?}
     */
    function () {
        this.trueValue = parseInt(this.trueValue);
        if (isNaN(this.trueValue)) {
            this.trueValue = 1;
        }
        this.falseValue = parseInt(this.falseValue);
        if (isNaN(this.falseValue)) {
            this.falseValue = 0;
        }
    };
    /**
     * @param {?} cellData
     * @return {?}
     */
    OTableCellRendererBooleanComponent.prototype.hasCellDataTrueValue = /**
     * @param {?} cellData
     * @return {?}
     */
    function (cellData) {
        /** @type {?} */
        var result = undefined;
        if (Util.isDefined(cellData)) {
            result = (cellData === this.trueValue);
            if (this.booleanType === 'string' && !Util.isDefined(this.trueValue)) {
                result = Util.parseBoolean(cellData, false);
            }
        }
        return result;
    };
    /**
     * @param {?} cellvalue
     * @param {?=} rowvalue
     * @return {?}
     */
    OTableCellRendererBooleanComponent.prototype.getCellData = /**
     * @param {?} cellvalue
     * @param {?=} rowvalue
     * @return {?}
     */
    function (cellvalue, rowvalue) {
        /** @type {?} */
        var result = cellvalue;
        /** @type {?} */
        var cellIsTrue = this.hasCellDataTrueValue(cellvalue);
        /** @type {?} */
        var value = cellIsTrue ? this.trueValue : this.falseValue;
        switch (this.renderType) {
            case 'string':
                result = this.translateService.get(value);
                break;
            case 'number':
                result = value;
                break;
            default:
                break;
        }
        return result;
    };
    Object.defineProperty(OTableCellRendererBooleanComponent.prototype, "booleanType", {
        get: /**
         * @return {?}
         */
        function () {
            return this._booleanType;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            arg = (arg || '').toLowerCase();
            if (['number', 'boolean', 'string'].indexOf(arg) === -1) {
                arg = 'boolean';
            }
            this._booleanType = arg;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableCellRendererBooleanComponent.prototype, "renderType", {
        get: /**
         * @return {?}
         */
        function () {
            return this._renderType;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            arg = (arg || '').toLowerCase();
            if (['string', 'number', 'icon', 'image'].indexOf(arg) === -1) {
                arg = 'string';
            }
            this._renderType = arg;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableCellRendererBooleanComponent.prototype, "renderTrueValue", {
        get: /**
         * @return {?}
         */
        function () {
            return this._renderTrueValue || this.trueValue;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._renderTrueValue = arg;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableCellRendererBooleanComponent.prototype, "renderFalseValue", {
        get: /**
         * @return {?}
         */
        function () {
            return this._renderFalseValue || this.falseValue;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._renderFalseValue = arg;
        },
        enumerable: true,
        configurable: true
    });
    OTableCellRendererBooleanComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_BOOLEAN = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_BOOLEAN;
    OTableCellRendererBooleanComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-renderer-boolean',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\">\n      <ng-container *ngIf=\"hasCellDataTrueValue(cellvalue)\">\n        <ng-container [ngSwitch]=\"renderType\">\n          <ng-container *ngSwitchCase=\"'number'\">{{ renderTrueValue }}</ng-container>\n          <ng-container *ngSwitchCase=\"'icon'\">\n            <mat-icon class=\"material-icons\"> {{ renderTrueValue }}</mat-icon>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'image'\">\n            <img [src]=\"renderTrueValue\" />\n          </ng-container>\n          <span *ngSwitchDefault>{{ renderTrueValue | oTranslate }}</span>\n        </ng-container>\n      </ng-container>\n      <ng-container *ngIf=\"!hasCellDataTrueValue(cellvalue)\">\n        <ng-container [ngSwitch]=\"renderType\">\n          <ng-container *ngSwitchCase=\"'number'\">{{ renderFalseValue }}</ng-container>\n          <ng-container *ngSwitchCase=\"'icon'\">\n            <mat-icon class=\"material-icons\"> {{ renderFalseValue }}</mat-icon>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'image'\">\n            <img [src]=\"renderFalseValue\" />\n          </ng-container>\n          <ng-container *ngSwitchDefault>{{ renderFalseValue | oTranslate}}</ng-container>\n        </ng-container>\n      </ng-container>\n    </ng-template>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_BOOLEAN
                },] },
    ];
    /** @nocollapse */
    OTableCellRendererBooleanComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellRendererBooleanComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    return OTableCellRendererBooleanComponent;
}(OBaseTableCellRenderer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_INTEGER = [
    'grouping',
    'thousandSeparator: thousand-separator'
];
var OTableCellRendererIntegerComponent = /** @class */ (function (_super) {
    __extends(OTableCellRendererIntegerComponent, _super);
    function OTableCellRendererIntegerComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.grouping = true;
        _this.thousandSeparator = ',';
        _this.tableColumn.type = 'integer';
        _this.setComponentPipe();
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellRendererIntegerComponent.prototype.setComponentPipe = /**
     * @return {?}
     */
    function () {
        this.componentPipe = new OIntegerPipe(this.injector);
    };
    /**
     * @return {?}
     */
    OTableCellRendererIntegerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.pipeArguments = {
            grouping: this.grouping,
            thousandSeparator: this.thousandSeparator
        };
    };
    /**
     * @return {?}
     */
    OTableCellRendererIntegerComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngAfterContentInit.call(this);
    };
    OTableCellRendererIntegerComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_INTEGER = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_INTEGER;
    OTableCellRendererIntegerComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-renderer-integer',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\">\n        {{ getCellData(cellvalue)}}\n    </ng-template>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_INTEGER
                },] },
    ];
    /** @nocollapse */
    OTableCellRendererIntegerComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellRendererIntegerComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableCellRendererIntegerComponent.prototype, "grouping", void 0);
    return OTableCellRendererIntegerComponent;
}(OBaseTableCellRenderer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_REAL = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_INTEGER.concat([
    'decimalSeparator: decimal-separator',
    'minDecimalDigits: min-decimal-digits',
    'maxDecimalDigits: max-decimal-digits'
]);
var OTableCellRendererRealComponent = /** @class */ (function (_super) {
    __extends(OTableCellRendererRealComponent, _super);
    function OTableCellRendererRealComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.minDecimalDigits = 2;
        _this.maxDecimalDigits = 2;
        _this.decimalSeparator = '.';
        _this.tableColumn.type = 'real';
        _this.numberService = _this.injector.get(NumberService);
        _this.setComponentPipe();
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellRendererRealComponent.prototype.setComponentPipe = /**
     * @return {?}
     */
    function () {
        this.componentPipe = new ORealPipe(this.injector);
    };
    /**
     * @return {?}
     */
    OTableCellRendererRealComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        this.pipeArguments = {
            minDecimalDigits: this.minDecimalDigits,
            maxDecimalDigits: this.maxDecimalDigits,
            decimalSeparator: this.decimalSeparator,
            grouping: this.grouping,
            thousandSeparator: this.thousandSeparator
        };
    };
    OTableCellRendererRealComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_REAL = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_REAL;
    OTableCellRendererRealComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-renderer-real',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\">\n            {{ getCellData(cellvalue)}}\n    </ng-template>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_REAL
                },] },
    ];
    /** @nocollapse */
    OTableCellRendererRealComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellRendererRealComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableCellRendererRealComponent.prototype, "minDecimalDigits", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableCellRendererRealComponent.prototype, "maxDecimalDigits", void 0);
    return OTableCellRendererRealComponent;
}(OTableCellRendererIntegerComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_CURRENCY = OTableCellRendererRealComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_REAL.concat([
    'currencySymbol: currency-symbol',
    'currencySymbolPosition: currency-symbol-position'
]);
var OTableCellRendererCurrencyComponent = /** @class */ (function (_super) {
    __extends(OTableCellRendererCurrencyComponent, _super);
    function OTableCellRendererCurrencyComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.minDecimalDigits = 2;
        _this.maxDecimalDigits = 2;
        _this.decimalSeparator = '.';
        _this.grouping = true;
        _this.thousandSeparator = ',';
        _this.tableColumn.type = 'currency';
        _this.currencyService = _this.injector.get(CurrencyService);
        _this.setComponentPipe();
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellRendererCurrencyComponent.prototype.setComponentPipe = /**
     * @return {?}
     */
    function () {
        this.componentPipe = new OCurrencyPipe(this.injector);
    };
    /**
     * @return {?}
     */
    OTableCellRendererCurrencyComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (typeof this.currencySymbol === 'undefined') {
            this.currencySymbol = this.currencyService.symbol;
        }
        if (typeof this.currencySymbolPosition === 'undefined') {
            this.currencySymbolPosition = this.currencyService.symbolPosition;
        }
        this.pipeArguments = {
            currencySimbol: this.currencySymbol,
            currencySymbolPosition: this.currencySymbolPosition,
            minDecimalDigits: this.minDecimalDigits,
            maxDecimalDigits: this.maxDecimalDigits,
            decimalSeparator: this.decimalSeparator,
            grouping: this.grouping,
            thousandSeparator: this.thousandSeparator
        };
    };
    OTableCellRendererCurrencyComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_CURRENCY = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_CURRENCY;
    OTableCellRendererCurrencyComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-renderer-currency',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\">\n      {{getCellData(cellvalue)}}\n    </ng-template>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_CURRENCY
                },] },
    ];
    /** @nocollapse */
    OTableCellRendererCurrencyComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellRendererCurrencyComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableCellRendererCurrencyComponent.prototype, "minDecimalDigits", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableCellRendererCurrencyComponent.prototype, "maxDecimalDigits", void 0);
    return OTableCellRendererCurrencyComponent;
}(OBaseTableCellRenderer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_DATE = [
    'format'
];
var OTableCellRendererDateComponent = /** @class */ (function (_super) {
    __extends(OTableCellRendererDateComponent, _super);
    function OTableCellRendererDateComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.tableColumn.type = 'date';
        _this.setComponentPipe();
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellRendererDateComponent.prototype.setComponentPipe = /**
     * @return {?}
     */
    function () {
        this.componentPipe = new OMomentPipe(this.injector);
    };
    /**
     * @return {?}
     */
    OTableCellRendererDateComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        //Called after the constructor, initializing input properties, and the first call to ngOnChanges.
        //Add 'implements OnInit' to the class.
        this.pipeArguments = {
            format: this.format
        };
    };
    OTableCellRendererDateComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_DATE = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_DATE;
    OTableCellRendererDateComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-renderer-date',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\">\n       {{getCellData(cellvalue)}}\n    </ng-template>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_DATE
                },] },
    ];
    /** @nocollapse */
    OTableCellRendererDateComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellRendererDateComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    return OTableCellRendererDateComponent;
}(OBaseTableCellRenderer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_IMAGE = [
    'imageType: image-type',
    'emptyImage: empty-image',
    'avatar'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_CELL_RENDERER_IMAGE = [
    'onClick'
];
var OTableCellRendererImageComponent = /** @class */ (function (_super) {
    __extends(OTableCellRendererImageComponent, _super);
    function OTableCellRendererImageComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.tableColumn.type = 'image';
        _this.tableColumn.orderable = false;
        _this.tableColumn.searchable = false;
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellRendererImageComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.table) {
            /** @type {?} */
            var oCol = this.table.getOColumn(this.tableColumn.attr);
            oCol.title = Util.isDefined(this.tableColumn.title) ? this.tableColumn.title : undefined;
            oCol.definition.contentAlign = oCol.definition.contentAlign ? oCol.definition.contentAlign : 'center';
        }
    };
    /**
     * @param {?} cellData
     * @return {?}
     */
    OTableCellRendererImageComponent.prototype.getSource = /**
     * @param {?} cellData
     * @return {?}
     */
    function (cellData) {
        this._source = '';
        switch (this.imageType) {
            case 'base64':
                this._source = cellData ? ('data:image/png;base64,' + ((typeof (cellData.bytes) !== 'undefined') ? cellData.bytes : cellData)) : this.emptyImage;
                break;
            case 'url':
                this._source = cellData ? cellData : this.emptyImage;
                break;
            default:
                this._source = this.emptyImage;
                break;
        }
        return this._source;
    };
    OTableCellRendererImageComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_IMAGE = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_IMAGE;
    OTableCellRendererImageComponent.DEFAULT_OUTPUTS_O_TABLE_CELL_RENDERER_IMAGE = DEFAULT_OUTPUTS_O_TABLE_CELL_RENDERER_IMAGE;
    OTableCellRendererImageComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-renderer-image',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\">\n      <div [ngClass]=\"{'image-avatar':avatar,'image-plain':!avatar} \">\n        <img [src]=\"getSource(cellvalue)\">\n      </div>\n    </ng-template>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_IMAGE
                },] },
    ];
    /** @nocollapse */
    OTableCellRendererImageComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellRendererImageComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    return OTableCellRendererImageComponent;
}(OBaseTableCellRenderer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_PERCENTAGE = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_REAL.concat([
    'valueBase: value-base'
]);
var OTableCellRendererPercentageComponent = /** @class */ (function (_super) {
    __extends(OTableCellRendererPercentageComponent, _super);
    function OTableCellRendererPercentageComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.decimalSeparator = '.';
        _this.minDecimalDigits = 0;
        _this.maxDecimalDigits = 0;
        _this.valueBase = 1;
        _this.tableColumn.type = 'real';
        _this.numberService = _this.injector.get(NumberService);
        _this.setComponentPipe();
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellRendererPercentageComponent.prototype.setComponentPipe = /**
     * @return {?}
     */
    function () {
        this.componentPipe = new OPercentPipe(this.injector);
    };
    /**
     * @return {?}
     */
    OTableCellRendererPercentageComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.pipeArguments = {
            minDecimalDigits: this.minDecimalDigits,
            maxDecimalDigits: this.maxDecimalDigits,
            decimalSeparator: this.decimalSeparator,
            grouping: this.grouping,
            thousandSeparator: this.thousandSeparator,
            valueBase: this.valueBase
        };
    };
    OTableCellRendererPercentageComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_PERCENTAGE = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_PERCENTAGE;
    OTableCellRendererPercentageComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-renderer-percentage',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\">\n            {{ getCellData(cellvalue)}}\n    </ng-template>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_PERCENTAGE
                },] },
    ];
    /** @nocollapse */
    OTableCellRendererPercentageComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellRendererPercentageComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    return OTableCellRendererPercentageComponent;
}(OTableCellRendererRealComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_SERVICE = [
    'entity',
    'service',
    'columns',
    'valueColumn: value-column',
    'parentKeys: parent-keys',
    'queryMethod: query-method',
    'serviceType : service-type'
];
var 0$4 = dataServiceFactory;
var OTableCellRendererServiceComponent = /** @class */ (function (_super) {
    __extends(OTableCellRendererServiceComponent, _super);
    function OTableCellRendererServiceComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.cellValues = [];
        _this.responseMap = {};
        _this.queryMethod = Codes.QUERY_METHOD;
        /* Internal variables */
        _this.colArray = [];
        _this._pKeysEquiv = {};
        _this.tableColumn.type = 'service';
        _this.dialogService = injector.get(DialogService);
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellRendererServiceComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.table) {
            /** @type {?} */
            var oCol = this.table.getOColumn(this.column);
            oCol.definition.contentAlign = oCol.definition.contentAlign ? oCol.definition.contentAlign : 'center';
        }
        this.colArray = Util.parseArray(this.columns, true);
        /** @type {?} */
        var pkArray = Util.parseArray(this.parentKeys);
        this._pKeysEquiv = Util.parseParentKeysEquivalences(pkArray);
        this.configureService();
    };
    /**
     * @return {?}
     */
    OTableCellRendererServiceComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var oCol = this.table.getOColumn(this.column);
        if (Util.isDefined(oCol.editor)) {
            /** @type {?} */
            var self_1 = this;
            this.editorSuscription = oCol.editor.onPostUpdateRecord.subscribe(function (data) {
                self_1.queryData(data[self_1.tableColumn.attr], data);
            });
        }
    };
    /**
     * @return {?}
     */
    OTableCellRendererServiceComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.editorSuscription) {
            this.editorSuscription.unsubscribe();
        }
    };
    /**
     * @param {?} cellvalue
     * @param {?} rowValue
     * @return {?}
     */
    OTableCellRendererServiceComponent.prototype.getDescriptionValue = /**
     * @param {?} cellvalue
     * @param {?} rowValue
     * @return {?}
     */
    function (cellvalue, rowValue) {
        if (cellvalue !== undefined && this.cellValues.indexOf(cellvalue) === -1) {
            this.queryData(cellvalue, rowValue);
            this.cellValues.push(cellvalue);
        }
        return '';
    };
    /**
     * @param {?} cellvalue
     * @param {?=} parentItem
     * @return {?}
     */
    OTableCellRendererServiceComponent.prototype.queryData = /**
     * @param {?} cellvalue
     * @param {?=} parentItem
     * @return {?}
     */
    function (cellvalue, parentItem) {
        var _this = this;
        /** @type {?} */
        var self = this;
        if (!this.dataService || !(this.queryMethod in this.dataService) || !this.entity) {
            console.warn('Service not properly configured! aborting query');
            return;
        }
        /** @type {?} */
        var filter$$1 = ServiceUtils$$1.getFilterUsingParentKeys(parentItem, this._pKeysEquiv);
        /** @type {?} */
        var tableColAlias = Object.keys(this._pKeysEquiv).find(function (key) { return _this._pKeysEquiv[key] === _this.column; });
        if (Util.isDefined(tableColAlias)) {
            if (!filter$$1[tableColAlias]) {
                filter$$1[tableColAlias] = cellvalue;
            }
        }
        else {
            filter$$1[this.column] = cellvalue;
        }
        this.querySubscription = this.dataService[this.queryMethod](filter$$1, this.colArray, this.entity).subscribe(function (resp) {
            if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                self.responseMap[cellvalue] = resp.data[0][self.valueColumn];
            }
        }, function (err) {
            console.error(err);
            if (err && typeof err !== 'object') {
                _this.dialogService.alert('ERROR', err);
            }
            else {
                _this.dialogService.alert('ERROR', 'MESSAGES.ERROR_QUERY');
            }
        });
    };
    /**
     * @return {?}
     */
    OTableCellRendererServiceComponent.prototype.configureService = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var loadingService = OntimizeService$$1;
        if (this.serviceType) {
            loadingService = this.serviceType;
        }
        try {
            this.dataService = this.injector.get(loadingService);
            if (Util.isDataService(this.dataService)) {
                /** @type {?} */
                var serviceCfg = this.dataService.getDefaultServiceConfiguration(this.service);
                if (this.entity) {
                    serviceCfg['entity'] = this.entity;
                }
                this.dataService.configureService(serviceCfg);
            }
        }
        catch (e) {
            console.error(e);
        }
    };
    /**
     * @param {?} cellvalue
     * @param {?=} rowvalue
     * @return {?}
     */
    OTableCellRendererServiceComponent.prototype.getCellData = /**
     * @param {?} cellvalue
     * @param {?=} rowvalue
     * @return {?}
     */
    function (cellvalue, rowvalue) {
        return this.responseMap[cellvalue];
    };
    OTableCellRendererServiceComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_SERVICE = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_SERVICE;
    OTableCellRendererServiceComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-renderer-service',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\" let-rowvalue=\"rowvalue\">\n      {{ getDescriptionValue(cellvalue, rowvalue) }}{{ responseMap[cellvalue] }}\n    </ng-template>\n  ",
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_SERVICE,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    providers: [
                        // Service renderer must have its own service instance in order to avoid overriding table service configuration
                        { provide: OntimizeService$$1, useFactory: 0$4, deps: [core.Injector] }
                    ]
                },] },
    ];
    /** @nocollapse */
    OTableCellRendererServiceComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellRendererServiceComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    return OTableCellRendererServiceComponent;
}(OBaseTableCellRenderer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_TIME = [
    'format'
];
var OTableCellRendererTimeComponent = /** @class */ (function (_super) {
    __extends(OTableCellRendererTimeComponent, _super);
    function OTableCellRendererTimeComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this._format = 'L HH:mm a';
        _this.tableColumn.type = 'time';
        _this.setComponentPipe();
        return _this;
    }
    Object.defineProperty(OTableCellRendererTimeComponent.prototype, "format", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (Util.isDefined(value)) {
                this._format = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableCellRendererTimeComponent.prototype.setComponentPipe = /**
     * @return {?}
     */
    function () {
        this.componentPipe = new OMomentPipe(this.injector);
    };
    /**
     * @return {?}
     */
    OTableCellRendererTimeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        //Called after the constructor, initializing input properties, and the first call to ngOnChanges.
        //Add 'implements OnInit' to the class.
        this.pipeArguments = {
            format: this._format
        };
    };
    OTableCellRendererTimeComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_TIME = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_TIME;
    OTableCellRendererTimeComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-renderer-time',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\">\n       {{getCellData(cellvalue)}}\n    </ng-template>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_TIME
                },] },
    ];
    /** @nocollapse */
    OTableCellRendererTimeComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellRendererTimeComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    return OTableCellRendererTimeComponent;
}(OBaseTableCellRenderer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_TRANSLATE = [
    'translateArgsFn: translate-params'
];
var OTableCellRendererTranslateComponent = /** @class */ (function (_super) {
    __extends(OTableCellRendererTranslateComponent, _super);
    function OTableCellRendererTranslateComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.pipeArguments = {};
        _this.tableColumn.type = 'translate';
        _this.setComponentPipe();
        return _this;
    }
    /**
     * @return {?}
     */
    OTableCellRendererTranslateComponent.prototype.setComponentPipe = /**
     * @return {?}
     */
    function () {
        this.componentPipe = new OTranslatePipe(this.injector);
    };
    /**
     * @param {?} cellvalue
     * @param {?=} rowvalue
     * @return {?}
     */
    OTableCellRendererTranslateComponent.prototype.getCellData = /**
     * @param {?} cellvalue
     * @param {?=} rowvalue
     * @return {?}
     */
    function (cellvalue, rowvalue) {
        this.pipeArguments = this.translateArgsFn ? { values: this.translateArgsFn(rowvalue) } : {};
        return _super.prototype.getCellData.call(this, cellvalue, rowvalue);
    };
    OTableCellRendererTranslateComponent.DEFAULT_IPUTS_O_TABLE_CELL_RENDERER_TRANSLATE = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_TRANSLATE;
    OTableCellRendererTranslateComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-renderer-translate',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\" let-rowvalue=\"rowvalue\">\n      {{ getCellData(cellvalue, rowvalue) }}\n    </ng-template>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_TRANSLATE
                },] },
    ];
    /** @nocollapse */
    OTableCellRendererTranslateComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    OTableCellRendererTranslateComponent.propDecorators = {
        templateref: [{ type: core.ViewChild, args: ['templateref', { read: core.TemplateRef },] }]
    };
    return OTableCellRendererTranslateComponent;
}(OBaseTableCellRenderer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var O_TABLE_CELL_RENDERERS = [
    OTableCellRendererActionComponent,
    OTableCellRendererDateComponent,
    OTableCellRendererBooleanComponent,
    OTableCellRendererImageComponent,
    OTableCellRendererIntegerComponent,
    OTableCellRendererRealComponent,
    OTableCellRendererCurrencyComponent,
    OTableCellRendererPercentageComponent,
    OTableCellRendererServiceComponent,
    OTableCellRendererTranslateComponent,
    OTableCellRendererTimeComponent
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_COLUMN = [
    'attr',
    'title',
    'titleAlign: title-align',
    'contentAlign: content-align',
    'orderable',
    'searchable',
    'type',
    'editable',
    'width',
    'minWidth: min-width',
    'maxWidth: max-width',
    'asyncLoad : async-load',
    'sqlType: sql-type',
    'tooltip',
    'tooltipValue: tooltip-value',
    'tooltipFunction: tooltip-function',
    'multiline',
    'resizable'
].concat(OTableCellRendererBooleanComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_BOOLEAN, OTableCellRendererCurrencyComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_CURRENCY, OTableCellRendererDateComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_DATE, OTableCellRendererImageComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_IMAGE, OTableCellRendererActionComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_ACTION, OTableCellRendererServiceComponent.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_SERVICE, OTableCellRendererTranslateComponent.DEFAULT_IPUTS_O_TABLE_CELL_RENDERER_TRANSLATE, OTableCellEditorBooleanComponent.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_BOOLEAN, OTableCellEditorDateComponent.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_DATE, OTableCellEditorRealComponent.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_REAL, OTableCellEditorTextComponent.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TEXT, OTableCellEditorTimeComponent.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TIME);
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_COLUMN = OTableCellRendererActionComponent.DEFAULT_OUTPUTS_O_TABLE_CELL_RENDERER_ACTION.concat(OTableCellEditorTextComponent.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TEXT);
var OTableColumnComponent = /** @class */ (function () {
    function OTableColumnComponent(table, resolver, injector) {
        this.table = table;
        this.resolver = resolver;
        this.injector = injector;
        this._defaultSQLTypeKey = 'OTHER';
        this._searchable = true;
        this.editable = false;
        this.tooltip = false;
        this._multiline = false;
        /* input renderer integer */
        this.grouping = true;
        this.thousandSeparator = ',';
        /* input renderer real */
        this.decimalSeparator = '.';
        this.renderType = 'string';
        this.booleanType = 'boolean';
        this.queryMethod = Codes.QUERY_METHOD;
        /**
         * input time
         */
        this.oDateFormat = 'L';
        this.oHourFormat = 24;
        /* input editor */
        this.orequired = false;
        this.showPlaceHolder = false;
        this.updateRecordOnEdit = true;
        this.showToastOnEdit = false;
        this.oStartView = 'month';
        this.oTouchUi = false;
        this.dateValueType = 'timestamp';
        this.minDecimalDigits = 2;
        this.maxDecimalDigits = 2;
        /* input editor boolean */
        this.indeterminateOnNull = false;
        /* output cell renderer action */
        this.onClick = new core.EventEmitter();
        /* output cell editor */
        this.editionStarted = new core.EventEmitter();
        this.editionCancelled = new core.EventEmitter();
        this.editionCommitted = new core.EventEmitter();
        this.onPostUpdateRecord = new core.EventEmitter();
        this.asyncLoad = false;
        this.subscriptions = new Subscription();
        this.table = table;
    }
    Object.defineProperty(OTableColumnComponent.prototype, "multiline", {
        get: /**
         * @return {?}
         */
        function () {
            return this._multiline;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            val = Util.parseBoolean(String(val));
            this._multiline = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableColumnComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.grouping = Util.parseBoolean(this.grouping, true);
        this.titleAlign = this.parseTitleAlign();
        this.table.registerColumn(this);
        this.subscriptions.add(this.table.onReinitialize.subscribe(function () { return _this.table.registerColumn(_this); }));
    };
    /**
     * @return {?}
     */
    OTableColumnComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.createRenderer();
        this.createEditor();
    };
    /**
     * @return {?}
     */
    OTableColumnComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.unsubscribe();
    };
    /**
     * @return {?}
     */
    OTableColumnComponent.prototype.parseTitleAlign = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var align = (this.titleAlign || '').toLowerCase();
        return Codes.AVAILABLE_COLUMN_TITLE_ALIGNS.indexOf(align) !== -1 ? align : undefined;
    };
    Object.defineProperty(OTableColumnComponent.prototype, "originalWidth", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var originalWidth = this.width;
            /** @type {?} */
            var pxVal = Util.extractPixelsValue(this.width);
            if (Util.isDefined(pxVal)) {
                originalWidth = pxVal + '';
            }
            return originalWidth;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableColumnComponent.prototype.createRenderer = /**
     * @return {?}
     */
    function () {
        if (!Util.isDefined(this.renderer) && Util.isDefined(this.type)) {
            /** @type {?} */
            var componentRef = OTableColumnComponent.renderersMapping[this.type];
            if (componentRef !== undefined) {
                /** @type {?} */
                var factory = this.resolver.resolveComponentFactory(componentRef);
                if (factory) {
                    /** @type {?} */
                    var ref = this.container.createComponent(factory);
                    /** @type {?} */
                    var newRenderer = ref.instance;
                    switch (this.type) {
                        case 'currency':
                            newRenderer.currencySymbol = this.currencySymbol;
                            newRenderer.currencySymbolPosition = this.currencySymbolPosition;
                            newRenderer.decimalSeparator = this.decimalSeparator;
                            newRenderer.minDecimalDigits = this.minDecimalDigits;
                            newRenderer.maxDecimalDigits = this.maxDecimalDigits;
                            newRenderer.grouping = this.grouping;
                            newRenderer.thousandSeparator = this.thousandSeparator;
                            break;
                        case 'date':
                            newRenderer.format = this.format;
                            break;
                        case 'time':
                            newRenderer.format = this.format;
                            break;
                        case 'integer':
                            newRenderer.grouping = this.grouping;
                            newRenderer.thousandSeparator = this.thousandSeparator;
                            break;
                        case 'boolean':
                            newRenderer.trueValue = this.trueValue;
                            newRenderer.falseValue = this.falseValue;
                            newRenderer.renderTrueValue = this.renderTrueValue;
                            newRenderer.renderFalseValue = this.renderFalseValue;
                            newRenderer.renderType = this.renderType;
                            newRenderer.booleanType = this.booleanType;
                            break;
                        case 'real':
                        case 'percentage':
                            newRenderer.decimalSeparator = this.decimalSeparator;
                            newRenderer.minDecimalDigits = this.minDecimalDigits;
                            newRenderer.maxDecimalDigits = this.maxDecimalDigits;
                            newRenderer.grouping = this.grouping;
                            newRenderer.thousandSeparator = this.thousandSeparator;
                            break;
                        case 'image':
                            newRenderer.imageType = this.imageType;
                            newRenderer.avatar = this.avatar;
                            newRenderer.emptyImage = this.emptyImage;
                            break;
                        case 'action':
                            newRenderer.icon = this.icon;
                            newRenderer.action = this.action;
                            newRenderer.text = this.text;
                            newRenderer.iconPosition = this.iconPosition;
                            newRenderer.onClick = this.onClick;
                            break;
                        case 'service':
                            newRenderer.entity = this.entity;
                            newRenderer.service = this.service;
                            newRenderer.columns = this.columns;
                            newRenderer.valueColumn = this.valueColumn;
                            newRenderer.parentKeys = this.parentKeys;
                            newRenderer.queryMethod = this.queryMethod;
                            newRenderer.serviceType = this.serviceType;
                            break;
                        case 'translate':
                            newRenderer.translateArgsFn = this.translateArgsFn;
                            break;
                    }
                    this.registerRenderer(newRenderer);
                }
            }
        }
    };
    /**
     * @param {?} type
     * @param {?} resolver
     * @param {?} container
     * @param {?} propsOrigin
     * @return {?}
     */
    OTableColumnComponent.prototype.buildCellEditor = /**
     * @param {?} type
     * @param {?} resolver
     * @param {?} container
     * @param {?} propsOrigin
     * @return {?}
     */
    function (type, resolver, container, propsOrigin) {
        /** @type {?} */
        var editor = undefined;
        /** @type {?} */
        var componentRef = OTableColumnComponent.editorsMapping[type] || OTableColumnComponent.editorsMapping['text'];
        if (componentRef === undefined) {
            return editor;
        }
        /** @type {?} */
        var factory = resolver.resolveComponentFactory(componentRef);
        if (factory) {
            /** @type {?} */
            var ref = container.createComponent(factory);
            editor = ref.instance;
            if (propsOrigin !== undefined) {
                switch (type) {
                    case 'date':
                        editor.format = propsOrigin.format;
                        editor.locale = propsOrigin.locale;
                        editor.oStartView = propsOrigin.oStartView;
                        editor.oMinDate = propsOrigin.oMinDate;
                        editor.oMaxDate = propsOrigin.oMaxDate;
                        editor.oTouchUi = propsOrigin.oTouchUi;
                        editor.oStartAt = propsOrigin.oStartAt;
                        editor.filterDate = propsOrigin.filterDate;
                        editor.dateValueType = propsOrigin.dateValueType;
                        break;
                    case 'time':
                        editor.oDateFormat = propsOrigin.oDateFormat;
                        editor.oHourFormat = propsOrigin.oHourFormat;
                        editor.oDateLocale = propsOrigin.oDateLocale;
                        editor.oMinDate = propsOrigin.oMinDate;
                        editor.oMaxDate = propsOrigin.oMaxDate;
                        editor.oTouchUi = propsOrigin.oTouchUi;
                        editor.oDateStartAt = propsOrigin.oDateStartAt;
                        editor.oDateTextInputEnabled = propsOrigin.oDateTextInputEnabled;
                        editor.oHourMin = propsOrigin.oHourMin;
                        editor.oHourMax = propsOrigin.oHourMax;
                        editor.oHourTextInputEnabled = propsOrigin.oHourTextInputEnabled;
                        editor.oHourPlaceholder = propsOrigin.oHourPlaceholder;
                        editor.oDatePlaceholder = propsOrigin.oDatePlaceholder;
                        break;
                    case 'boolean':
                        editor.booleanType = propsOrigin.booleanType;
                        editor.indeterminateOnNull = propsOrigin.indeterminateOnNull;
                        editor.autoCommit = propsOrigin.autoCommit;
                        editor.trueValue = propsOrigin.trueValue;
                        editor.falseValue = propsOrigin.falseValue;
                        break;
                    case 'integer':
                    case 'percentage':
                    case 'currency':
                    case 'real':
                        editor.min = propsOrigin.min;
                        editor.max = propsOrigin.max;
                        editor.step = Util.isDefined(propsOrigin.step) ? propsOrigin.step : editor.step;
                        break;
                    case 'image':
                        break;
                    default:
                        break;
                }
                editor.olabel = propsOrigin.olabel;
                editor.type = propsOrigin.type;
            }
        }
        return editor;
    };
    /**
     * @return {?}
     */
    OTableColumnComponent.prototype.createEditor = /**
     * @return {?}
     */
    function () {
        if (!Util.isDefined(this.editor) && this.editable) {
            /** @type {?} */
            var newEditor = this.buildCellEditor(this.type, this.resolver, this.container, this);
            if (newEditor) {
                newEditor.orequired = this.orequired;
                newEditor.showPlaceHolder = this.showPlaceHolder;
                newEditor.updateRecordOnEdit = this.updateRecordOnEdit;
                newEditor.showToastOnEdit = this.showToastOnEdit;
                newEditor.editionStarted = this.editionStarted;
                newEditor.editionCancelled = this.editionCancelled;
                newEditor.editionCommitted = this.editionCommitted;
                newEditor.onPostUpdateRecord = this.onPostUpdateRecord;
                this.registerEditor(newEditor);
            }
        }
    };
    /**
     * @param {?} renderer
     * @return {?}
     */
    OTableColumnComponent.prototype.registerRenderer = /**
     * @param {?} renderer
     * @return {?}
     */
    function (renderer) {
        this.renderer = renderer;
        /** @type {?} */
        var oCol = this.table.getOColumn(this.attr);
        if (oCol !== undefined) {
            oCol.renderer = this.renderer;
        }
        if (this.renderer.ngOnInit) {
            this.renderer.ngOnInit();
        }
    };
    /**
     * @param {?} editor
     * @return {?}
     */
    OTableColumnComponent.prototype.registerEditor = /**
     * @param {?} editor
     * @return {?}
     */
    function (editor) {
        this.editor = editor;
        /** @type {?} */
        var oCol = this.table.getOColumn(this.attr);
        if (oCol !== undefined) {
            oCol.editor = this.editor;
        }
        if (this.editor.ngOnInit) {
            this.editor.ngOnInit();
        }
    };
    /**
     * @param {?} type
     * @param {?} editorClassReference
     * @return {?}
     */
    OTableColumnComponent.addEditor = /**
     * @param {?} type
     * @param {?} editorClassReference
     * @return {?}
     */
    function (type, editorClassReference) {
        if (!OTableColumnComponent.editorsMapping.hasOwnProperty(type) && Util.isDefined(editorClassReference)) {
            OTableColumnComponent.editorsMapping[type] = editorClassReference;
        }
    };
    Object.defineProperty(OTableColumnComponent.prototype, "orderable", {
        get: /**
         * @return {?}
         */
        function () {
            return this._orderable;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._orderable = typeof val === 'boolean' ? val : Util.parseBoolean(val, true);
            /** @type {?} */
            var oCol = this.table.getOColumn(this.attr);
            if (oCol) {
                oCol.orderable = this._orderable;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableColumnComponent.prototype, "resizable", {
        get: /**
         * @return {?}
         */
        function () {
            return this._resizable;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._resizable = typeof val === 'boolean' ? val : Util.parseBoolean(val, true);
            /** @type {?} */
            var oCol = this.table.getOColumn(this.attr);
            if (oCol) {
                oCol.resizable = this._resizable;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableColumnComponent.prototype, "searchable", {
        get: /**
         * @return {?}
         */
        function () {
            return this._searchable;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._searchable = typeof val === 'boolean' ? val : Util.parseBoolean(val, true);
            /** @type {?} */
            var oCol = this.table.getOColumn(this.attr);
            if (oCol) {
                oCol.searchable = this._searchable;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableColumnComponent.prototype.getSQLType = /**
     * @return {?}
     */
    function () {
        if (!(this.sqlType && this.sqlType.length > 0)) {
            switch (this.type) {
                case 'date':
                    this.sqlType = 'TIMESTAMP';
                    break;
                case 'integer':
                    this.sqlType = 'INTEGER';
                    break;
                case 'boolean':
                    this.sqlType = 'BOOLEAN';
                    break;
                case 'real':
                case 'percentage':
                case 'currency':
                    this.sqlType = 'DOUBLE';
                    break;
            }
        }
        /** @type {?} */
        var sqlt = this.sqlType && this.sqlType.length > 0 ? this.sqlType : this._defaultSQLTypeKey;
        this._SQLType = SQLTypes.getSQLTypeValue(sqlt);
        return this._SQLType;
    };
    OTableColumnComponent.DEFAULT_INPUTS_O_TABLE_COLUMN = DEFAULT_INPUTS_O_TABLE_COLUMN;
    OTableColumnComponent.DEFAULT_OUTPUTS_O_TABLE_COLUMN = DEFAULT_OUTPUTS_O_TABLE_COLUMN;
    OTableColumnComponent.renderersMapping = {
        action: OTableCellRendererActionComponent,
        boolean: OTableCellRendererBooleanComponent,
        currency: OTableCellRendererCurrencyComponent,
        date: OTableCellRendererDateComponent,
        image: OTableCellRendererImageComponent,
        integer: OTableCellRendererIntegerComponent,
        percentage: OTableCellRendererPercentageComponent,
        real: OTableCellRendererRealComponent,
        service: OTableCellRendererServiceComponent,
        translate: OTableCellRendererTranslateComponent,
        time: OTableCellRendererTimeComponent
    };
    OTableColumnComponent.editorsMapping = {
        boolean: OTableCellEditorBooleanComponent,
        date: OTableCellEditorDateComponent,
        integer: OTableCellEditorIntegerComponent,
        real: OTableCellEditorRealComponent,
        percentage: OTableCellEditorRealComponent,
        currency: OTableCellEditorRealComponent,
        text: OTableCellEditorTextComponent,
        time: OTableCellEditorTimeComponent
    };
    OTableColumnComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-column',
                    template: "\n    <span #container>\n    </span>\n  ",
                    styles: ["\n\n  "],
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_COLUMN,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_COLUMN
                },] },
    ];
    /** @nocollapse */
    OTableColumnComponent.ctorParameters = function () { return [
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] },
        { type: core.ComponentFactoryResolver },
        { type: core.Injector }
    ]; };
    OTableColumnComponent.propDecorators = {
        container: [{ type: core.ViewChild, args: ['container', { read: core.ViewContainerRef },] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableColumnComponent.prototype, "editable", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableColumnComponent.prototype, "tooltip", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableColumnComponent.prototype, "orequired", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableColumnComponent.prototype, "showPlaceHolder", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableColumnComponent.prototype, "updateRecordOnEdit", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableColumnComponent.prototype, "showToastOnEdit", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableColumnComponent.prototype, "oTouchUi", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableColumnComponent.prototype, "min", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableColumnComponent.prototype, "max", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableColumnComponent.prototype, "step", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableColumnComponent.prototype, "minDecimalDigits", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTableColumnComponent.prototype, "maxDecimalDigits", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableColumnComponent.prototype, "indeterminateOnNull", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableColumnComponent.prototype, "autoCommit", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableColumnComponent.prototype, "asyncLoad", void 0);
    return OTableColumnComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_COLUMN_CALCULATED = DEFAULT_INPUTS_O_TABLE_COLUMN.concat([
    'operation',
    'functionOperation: operation-function'
]);
var OTableColumnCalculatedComponent = /** @class */ (function (_super) {
    __extends(OTableColumnCalculatedComponent, _super);
    function OTableColumnCalculatedComponent(table, resolver, injector) {
        var _this = _super.call(this, table, resolver, injector) || this;
        _this.table = table;
        _this.resolver = resolver;
        _this.injector = injector;
        return _this;
    }
    OTableColumnCalculatedComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-column-calculated',
                    template: "\n    <span #container>\n    </span>\n  ",
                    inputs: DEFAULT_INPUTS_O_TABLE_COLUMN_CALCULATED,
                    providers: [
                        {
                            provide: OTableColumnComponent,
                            useExisting: core.forwardRef(function () { return OTableColumnCalculatedComponent; })
                        }
                    ],
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                },] },
    ];
    /** @nocollapse */
    OTableColumnCalculatedComponent.ctorParameters = function () { return [
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] },
        { type: core.ComponentFactoryResolver },
        { type: core.Injector }
    ]; };
    return OTableColumnCalculatedComponent;
}(OTableColumnComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTableDao = /** @class */ (function () {
    function OTableDao(dataService, entity, methods) {
        this.dataService = dataService;
        this.entity = entity;
        this.methods = methods;
        this.usingStaticData = false;
        this._isLoadingResults = false;
        /**
         * Stream that emits whenever the data has been modified.
         */
        this.dataChange = new BehaviorSubject([]);
        this.sqlTypesChange = new BehaviorSubject({});
    }
    Object.defineProperty(OTableDao.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () { return this.dataChange.value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableDao.prototype, "sqlTypes", {
        get: /**
         * @return {?}
         */
        function () { return this.sqlTypesChange.value; },
        enumerable: true,
        configurable: true
    });
    /**
     * Call the service query and emit data has ben modified
     */
    /**
     * Call the service query and emit data has ben modified
     * @param {?} queryArgs
     * @return {?}
     */
    OTableDao.prototype.getQuery = /**
     * Call the service query and emit data has ben modified
     * @param {?} queryArgs
     * @return {?}
     */
    function (queryArgs) {
        this.isLoadingResults = true;
        return this.dataService[this.methods.query].apply(this.dataService, queryArgs);
    };
    /**
     * @param {?} filters
     * @return {?}
     */
    OTableDao.prototype.removeQuery = /**
     * @param {?} filters
     * @return {?}
     */
    function (filters) {
        var _this = this;
        return merge.apply(void 0, filters.map((function (kv) { return _this.dataService[_this.methods.delete](kv, _this.entity); })));
    };
    /**
     * @param {?} av
     * @param {?=} sqlTypes
     * @return {?}
     */
    OTableDao.prototype.insertQuery = /**
     * @param {?} av
     * @param {?=} sqlTypes
     * @return {?}
     */
    function (av, sqlTypes) {
        if (this.usingStaticData) {
            this.data.push(av);
            return of(this.data);
        }
        else {
            return this.dataService[this.methods.insert](av, this.entity, sqlTypes);
        }
    };
    /**
     * @param {?} kv
     * @param {?} av
     * @param {?=} sqlTypes
     * @return {?}
     */
    OTableDao.prototype.updateQuery = /**
     * @param {?} kv
     * @param {?} av
     * @param {?=} sqlTypes
     * @return {?}
     */
    function (kv, av, sqlTypes) {
        if (this.usingStaticData) {
            return of(this.data);
        }
        else {
            return this.dataService[this.methods.update](kv, av, this.entity, sqlTypes);
        }
    };
    /**
     * Set data array and emit data has ben modified
     * @param data
     */
    /**
     * Set data array and emit data has ben modified
     * @param {?} data
     * @return {?}
     */
    OTableDao.prototype.setDataArray = /**
     * Set data array and emit data has ben modified
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.dataChange.next(data);
        this.isLoadingResults = false;
        return of(data);
    };
    /**
     * @param {?} value
     * @param {?} rowData
     * @return {?}
     */
    OTableDao.prototype.setAsynchronousColumn = /**
     * @param {?} value
     * @param {?} rowData
     * @return {?}
     */
    function (value, rowData) {
        /** @type {?} */
        var index = null;
        for (var i = 0; i < this.data.length; i++) {
            if (this.data[i] === rowData) {
                index = i;
                break;
            }
        }
        if (index !== null) {
            Object.assign(this.data[index], value);
        }
    };
    Object.defineProperty(OTableDao.prototype, "isLoadingResults", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isLoadingResults;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            if (val) {
                this.cleanTimer();
                this.loadingTimer = setTimeout(function () {
                    _this._isLoadingResults = val;
                }, 500);
            }
            else {
                this.cleanTimer();
                this._isLoadingResults = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableDao.prototype.cleanTimer = /**
     * @return {?}
     */
    function () {
        if (this.loadingTimer) {
            clearTimeout(this.loadingTimer);
        }
    };
    return OTableDao;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_BUTTON = [
    'oattr: attr',
    'enabled',
    'icon',
    'svgIcon: svg-icon',
    'iconPosition: icon-position',
    'olabel: label'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_BUTTON = [
    'onClick'
];
var OTableButtonComponent = /** @class */ (function () {
    function OTableButtonComponent(injector, elRef, _table) {
        this.injector = injector;
        this.elRef = elRef;
        this._table = _table;
        this.onClick = new core.EventEmitter();
        this.enabled = true;
    }
    /**
     * @return {?}
     */
    OTableButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!Util.isDefined(this.icon) && !Util.isDefined(this.svgIcon)) {
            this.icon = 'priority_high';
        }
        this.iconPosition = Util.parseIconPosition(this.iconPosition);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableButtonComponent.prototype.innerOnClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        this.onClick.emit();
    };
    /**
     * @return {?}
     */
    OTableButtonComponent.prototype.isIconPositionLeft = /**
     * @return {?}
     */
    function () {
        return this.iconPosition === Codes.ICON_POSITION_LEFT;
    };
    Object.defineProperty(OTableButtonComponent.prototype, "table", {
        get: /**
         * @return {?}
         */
        function () {
            return this._table;
        },
        enumerable: true,
        configurable: true
    });
    OTableButtonComponent.DEFAULT_INPUTS_O_TABLE_BUTTON = DEFAULT_INPUTS_O_TABLE_BUTTON;
    OTableButtonComponent.DEFAULT_OUTPUTS_O_TABLE_BUTTON = DEFAULT_OUTPUTS_O_TABLE_BUTTON;
    OTableButtonComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-button',
                    template: "\n    <ng-container *ngIf=\"table.showButtonsText\">\n      <button type=\"button\" [disabled]=\"!enabled\" [class.disabled]=\"!enabled\" mat-stroked-button (click)=\"innerOnClick($event)\">\n        <mat-icon *ngIf=\"isIconPositionLeft() && svgIcon !== undefined\" [svgIcon]=\"svgIcon\"></mat-icon>\n        <mat-icon *ngIf=\"isIconPositionLeft() && svgIcon === undefined\">{{ icon }}</mat-icon>\n        <span>{{ olabel | oTranslate }}</span>\n        <mat-icon *ngIf=\"!isIconPositionLeft() && svgIcon !== undefined\" [svgIcon]=\"svgIcon\"></mat-icon>\n        <mat-icon *ngIf=\"!isIconPositionLeft() && svgIcon === undefined\">{{ icon }}</mat-icon>\n      </button>\n    </ng-container>\n\n    <ng-container *ngIf=\"!table.showButtonsText\">\n      <button type=\"button\" [disabled]=\"!enabled\" [class.disabled]=\"!enabled\" mat-icon-button (click)=\"innerOnClick($event)\">\n        <mat-icon *ngIf=\"isIconPositionLeft() && svgIcon !== undefined\" [svgIcon]=\"svgIcon\"></mat-icon>\n        <mat-icon *ngIf=\"isIconPositionLeft() && svgIcon === undefined\">{{ icon }}</mat-icon>\n        <mat-icon *ngIf=\"!isIconPositionLeft() && svgIcon !== undefined\" [svgIcon]=\"svgIcon\"></mat-icon>\n        <mat-icon *ngIf=\"!isIconPositionLeft() && svgIcon === undefined\">{{ icon }}</mat-icon>\n      </button>\n    </ng-container>\n  ",
                    styles: ["\n    .o-table-button{margin:0 8px}.o-table-button .mat-stroked-button{padding:0 6px;line-height:30px}.o-table-button .mat-stroked-button .mat-button-wrapper{display:flex;align-items:center}.o-table-button .mat-stroked-button .mat-button-wrapper .mat-icon{margin-right:4px}.o-table-button .mat-stroked-button .mat-button-wrapper span{flex:1}\n  "],
                    inputs: DEFAULT_INPUTS_O_TABLE_BUTTON,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_BUTTON,
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.o-table-button]': 'true',
                    }
                },] },
    ];
    /** @nocollapse */
    OTableButtonComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: core.ElementRef },
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableButtonComponent.prototype, "enabled", void 0);
    return OTableButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_BUTTONS = [
    'insertButton: insert-button',
    'refreshButton: refresh-button',
    'deleteButton: delete-button'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_BUTTONS = [];
var OTableButtonsComponent = /** @class */ (function () {
    function OTableButtonsComponent(injector, table) {
        this.injector = injector;
        this.table = table;
        /* Inputs */
        this.insertButton = true;
        this.refreshButton = true;
        this.deleteButton = true;
        this.enabledInsertButton = new BehaviorSubject(true);
        this.enabledRefreshButton = new BehaviorSubject(true);
        this.enabledDeleteButton = new BehaviorSubject(false);
        this.mutationObservers = [];
        this.permissions = this.table.getActionsPermissions();
    }
    /**
     * @return {?}
     */
    OTableButtonsComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var insertPerm = this.getPermissionByAttr('insert');
        /** @type {?} */
        var refreshPerm = this.getPermissionByAttr('refresh');
        /** @type {?} */
        var deletePerm = this.getPermissionByAttr('delete');
        if (this.insertButton && (insertPerm && insertPerm.enabled === false)) {
            this.enabledInsertButton.next(false);
        }
        if (this.refreshButton && (refreshPerm && refreshPerm.enabled === false)) {
            this.enabledRefreshButton.next(false);
        }
        this.subscription = this.table.selection.changed.subscribe(function () {
            return deletePerm ? _this.enabledDeleteButton.next(deletePerm.enabled && !_this.table.selection.isEmpty()) : _this.enabledDeleteButton.next(!_this.table.selection.isEmpty());
        });
    };
    /**
     * @return {?}
     */
    OTableButtonsComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.mutationObservers) {
            this.mutationObservers.forEach(function (m) {
                m.disconnect();
            });
        }
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OTableButtonsComponent.prototype.add = /**
     * @return {?}
     */
    function () {
        this.table.add();
    };
    /**
     * @return {?}
     */
    OTableButtonsComponent.prototype.reloadData = /**
     * @return {?}
     */
    function () {
        this.table.reloadData();
    };
    /**
     * @return {?}
     */
    OTableButtonsComponent.prototype.remove = /**
     * @return {?}
     */
    function () {
        this.table.remove();
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OTableButtonsComponent.prototype.getPermissionByAttr = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        return this.permissions.find(function (perm) { return perm.attr === attr; });
    };
    /**
     * @param {?} oTableButtons
     * @return {?}
     */
    OTableButtonsComponent.prototype.registerButtons = /**
     * @param {?} oTableButtons
     * @return {?}
     */
    function (oTableButtons) {
        /** @type {?} */
        var fixedButtons = ['insert', 'refresh', 'delete'];
        /** @type {?} */
        var userItems = this.permissions.filter(function (perm) { return fixedButtons.indexOf(perm.attr) === -1; });
        /** @type {?} */
        var self = this;
        userItems.forEach(function (perm) {
            /** @type {?} */
            var button = oTableButtons.find(function (oTableButton) { return oTableButton.oattr === perm.attr; });
            self.setPermissionsToOTableButton(perm, button);
        });
    };
    Object.defineProperty(OTableButtonsComponent.prototype, "showInsertOButton", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.insertButton) {
                return false;
            }
            /** @type {?} */
            var perm = this.getPermissionByAttr('insert');
            return !(perm && perm.visible === false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableButtonsComponent.prototype, "showRefreshOButton", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.refreshButton) {
                return false;
            }
            /** @type {?} */
            var perm = this.getPermissionByAttr('refresh');
            return !(perm && perm.visible === false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableButtonsComponent.prototype, "showDeleteOButton", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.deleteButton) {
                return false;
            }
            /** @type {?} */
            var perm = this.getPermissionByAttr('delete');
            return !(perm && perm.visible === false);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} perm
     * @param {?} button
     * @return {?}
     */
    OTableButtonsComponent.prototype.setPermissionsToOTableButton = /**
     * @param {?} perm
     * @param {?} button
     * @return {?}
     */
    function (perm, button) {
        if (perm.visible === false && button) {
            button.elRef.nativeElement.remove();
        }
        else if (perm.enabled === false && button) {
            button.enabled = false;
            /** @type {?} */
            var buttonEL = button.elRef.nativeElement.querySelector('button');
            /** @type {?} */
            var obs = PermissionsUtils.registerDisabledChangesInDom(buttonEL);
            this.mutationObservers.push(obs);
        }
    };
    OTableButtonsComponent.DEFAULT_INPUTS_O_TABLE_BUTTONS = DEFAULT_INPUTS_O_TABLE_BUTTONS;
    OTableButtonsComponent.DEFAULT_OUTPUTS_O_TABLE_BUTTONS = DEFAULT_OUTPUTS_O_TABLE_BUTTONS;
    OTableButtonsComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-buttons',
                    template: "\n    <div class=\"buttons\" fxLayout>\n      <o-table-button *ngIf=\"showInsertOButton\" [enabled]=\"enabledInsertButton | async\" label=\"TABLE.BUTTONS.ADD\"\n        svg-icon=\"ontimize:add\" (onClick)=\"add()\" class=\"o-table-button-add\"></o-table-button>\n      <o-table-button *ngIf=\"showRefreshOButton\" [enabled]=\"enabledRefreshButton | async\" label=\"TABLE.BUTTONS.REFRESH\"\n        svg-icon=\"ontimize:autorenew\" (onClick)=\"reloadData()\" class=\"o-table-button-refresh\">\n      </o-table-button>\n      <o-table-button *ngIf=\"showDeleteOButton\" [enabled]=\"enabledDeleteButton | async\" label=\"TABLE.BUTTONS.DELETE\"\n        svg-icon=\"ontimize:delete\" (onClick)=\"remove()\" class=\"o-table-button-delete\"></o-table-button>\n      <ng-content></ng-content>\n    </div>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_TABLE_BUTTONS,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_BUTTONS,
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.o-table-buttons]': 'true',
                    }
                },] },
    ];
    /** @nocollapse */
    OTableButtonsComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableButtonsComponent.prototype, "insertButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableButtonsComponent.prototype, "refreshButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableButtonsComponent.prototype, "deleteButton", void 0);
    return OTableButtonsComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_COLUMN_RESIZER = [
    'column'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_COLUMN_RESIZER = [];
var OTableColumnResizerComponent = /** @class */ (function () {
    function OTableColumnResizerComponent(table, elRef, ngZone, renderer) {
        this.table = table;
        this.elRef = elRef;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.disabled = false;
        this.dragListeners = [];
        this.isResizing = false;
        this.blockedMinCols = [];
        this.blockedMaxCols = [];
        this.columnsStartWidth = {};
    }
    /**
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.isDisabled) {
            this.headerEl = this.getHeaderEL();
            if (this.headerEl) {
                this.nextOColumns = this.getFollowingOColumns();
            }
        }
    };
    /**
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.stopDragging();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        event.preventDefault();
    };
    Object.defineProperty(OTableColumnResizerComponent.prototype, "isDisabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column && !this.column.resizable;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} e
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.onMousedown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!this.isDisabled) {
            this.startResize(e);
        }
    };
    /**
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.onMouseup = /**
     * @return {?}
     */
    function () {
        this.isResizing = false;
        this.stopDragging();
        // this.resize.emit(this.element.clientWidth);
    };
    /**
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.stopDragging = /**
     * @return {?}
     */
    function () {
        this.isResizing = false;
        this.columnsStartWidth = {};
        while (this.dragListeners.length > 0) {
            /** @type {?} */
            var fct = this.dragListeners.pop();
            if (fct) {
                fct();
            }
        }
    };
    /**
     * @param {?} startEvent
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.startResize = /**
     * @param {?} startEvent
     * @return {?}
     */
    function (startEvent) {
        var _this = this;
        startEvent.preventDefault();
        startEvent.stopPropagation();
        if (!Util.isDefined(this.headerEl)) {
            return;
        }
        this.startX = startEvent.screenX;
        this.startWidth = this.column.DOMWidth;
        this.minWidth = this.column.getMinWidthValue();
        this.initializeWidthData();
        this.ngZone.runOutsideAngular(function () {
            _this.dragListeners.push(_this.renderer.listen('document', 'mouseup', function (e) { return _this.stopDragging(); }));
        });
        if (!(startEvent instanceof MouseEvent)) {
            return;
        }
        this.ngZone.runOutsideAngular(function () {
            _this.dragListeners.push(_this.renderer.listen('document', 'mousemove', function (e) { return _this.resizeEvent(e); }));
        });
        this.isResizing = true;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.resizeEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.isResizing || !(event instanceof MouseEvent)) {
            return;
        }
        /** @type {?} */
        var movementX = (event.screenX - this.startX);
        if (movementX === 0) {
            return;
        }
        /** @type {?} */
        var newColumnWidth = this.startWidth + movementX;
        /** @type {?} */
        var lessThanMin = newColumnWidth < this.minWidth;
        /** @type {?} */
        var moreThanMax = newColumnWidth > this.maxWidth;
        if (lessThanMin || moreThanMax) {
            return;
        }
        if (!this.table.horizontalScroll) {
            this.calculateNewColumnsWidth(movementX, newColumnWidth);
            this.updateBlockedCols();
        }
        else {
            this.column.setWidth(newColumnWidth);
        }
        this.table.cd.detectChanges();
    };
    /**
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.getHeaderEL = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var element;
        /** @type {?} */
        var currentEl = this.elRef.nativeElement.parentElement;
        while (!element && currentEl) {
            if (currentEl.nodeName === 'TH') {
                element = currentEl;
            }
            else {
                currentEl = currentEl.parentElement;
            }
        }
        return currentEl;
    };
    /**
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.getFollowingOColumns = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = [];
        /** @type {?} */
        var nextTh = this.headerEl.nextSibling;
        /** @type {?} */
        var self = this;
        while (nextTh) {
            /** @type {?} */
            var oCol = self.table.getOColumnFromTh(nextTh);
            if (Util.isDefined(oCol)) {
                result.push(oCol);
            }
            nextTh = nextTh.nextSibling;
        }
        return result;
    };
    /**
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.updateBlockedCols = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        this.blockedMinCols = [];
        this.blockedMaxCols = [];
        /** @type {?} */
        var columns = [this.column].concat(this.nextOColumns);
        columns.forEach(function (oCol) {
            if (oCol.DOMWidth <= oCol.getMinWidthValue()) {
                self.blockedMinCols.push(oCol.attr);
            }
            /** @type {?} */
            var maxW = oCol.getMaxWidthValue();
            if (Util.isDefined(maxW) && oCol.DOMWidth >= maxW) {
                self.blockedMaxCols.push(oCol.attr);
            }
        });
    };
    /**
     * @param {?} movementX
     * @param {?} newColumnWidth
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.calculateNewColumnsWidth = /**
     * @param {?} movementX
     * @param {?} newColumnWidth
     * @return {?}
     */
    function (movementX, newColumnWidth) {
        /** @type {?} */
        var positive = (movementX > 0);
        if (positive) {
            this.calculateUsingNextColumnsRestrictions(movementX, newColumnWidth);
        }
        else {
            this.calculateUsingOwnColumnRestriction(movementX, newColumnWidth);
        }
    };
    /**
     * @param {?} movementX
     * @param {?} newColumnWidth
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.calculateUsingNextColumnsRestrictions = /**
     * @param {?} movementX
     * @param {?} newColumnWidth
     * @return {?}
     */
    function (movementX, newColumnWidth) {
        var _this = this;
        /** @type {?} */
        var availableCols = this.nextOColumns.length - this.blockedMinCols.length;
        if (availableCols <= 0) {
            return;
        }
        /** @type {?} */
        var widthRatio = movementX / availableCols;
        /** @type {?} */
        var cols = this.nextOColumns.filter(function (oCol) { return _this.blockedMinCols.indexOf(oCol.attr) === -1; });
        cols.forEach(function (oCol) {
            /** @type {?} */
            var newWidth = (_this.columnsStartWidth[oCol.attr] - widthRatio);
            /** @type {?} */
            var minWidth = oCol.getMinWidthValue();
            if (newWidth <= minWidth) {
                newWidth = minWidth;
                _this.blockedMinCols.push(oCol.attr);
            }
            oCol.setWidth(newWidth);
        });
        this.column.setWidth(newColumnWidth);
    };
    /**
     * @param {?} movementX
     * @param {?} newColumnWidth
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.calculateUsingOwnColumnRestriction = /**
     * @param {?} movementX
     * @param {?} newColumnWidth
     * @return {?}
     */
    function (movementX, newColumnWidth) {
        var _this = this;
        /** @type {?} */
        var widthRatio = Math.abs(movementX) / this.nextOColumns.length;
        /** @type {?} */
        var widthDifference = 0;
        if (widthRatio > 0 && this.blockedMaxCols.length < this.nextOColumns.length) {
            /** @type {?} */
            var cols = this.nextOColumns.filter(function (oCol) { return _this.blockedMaxCols.indexOf(oCol.attr) === -1; });
            cols.forEach(function (oCol) {
                /** @type {?} */
                var newWidth = (_this.columnsStartWidth[oCol.attr] + widthRatio);
                /** @type {?} */
                var maxWidth = oCol.getMaxWidthValue();
                if (maxWidth && newWidth > maxWidth) {
                    /** @type {?} */
                    var diff = newWidth - maxWidth;
                    newWidth = maxWidth;
                    _this.blockedMaxCols.push(oCol.attr);
                    /** @type {?} */
                    var notBlocked = _this.nextOColumns.length - _this.blockedMaxCols.length;
                    widthRatio += notBlocked > 0 ? Math.floor(diff / notBlocked) : 0;
                }
                widthDifference += newWidth - oCol.DOMWidth;
                oCol.setWidth(newWidth);
            });
        }
        /** @type {?} */
        var newWidth = Math.min(this.startWidth - widthDifference, newColumnWidth);
        this.column.setWidth(newWidth);
    };
    /**
     * @return {?}
     */
    OTableColumnResizerComponent.prototype.initializeWidthData = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var maxWidth = this.column.getMaxWidthValue();
        /** @type {?} */
        var nextColMinWidthAcum = 0;
        /** @type {?} */
        var nextColWidthAcum = 0;
        this.nextOColumns.forEach(function (col) {
            nextColMinWidthAcum += col.getMinWidthValue();
            nextColWidthAcum += col.DOMWidth;
            _this.columnsStartWidth[col.attr] = col.DOMWidth;
        });
        /** @type {?} */
        var calcMaxWidth = this.headerEl.clientWidth + (nextColWidthAcum - nextColMinWidthAcum);
        if (Util.isDefined(maxWidth)) {
            maxWidth = Math.min(maxWidth, calcMaxWidth);
        }
        else {
            maxWidth = calcMaxWidth;
        }
        this.maxWidth = maxWidth;
    };
    OTableColumnResizerComponent.DEFAULT_INPUTS_O_TABLE_COLUMN_RESIZER = DEFAULT_INPUTS_O_TABLE_COLUMN_RESIZER;
    OTableColumnResizerComponent.DEFAULT_OUTPUTS_O_TABLE_COLUMN_RESIZER = DEFAULT_OUTPUTS_O_TABLE_COLUMN_RESIZER;
    OTableColumnResizerComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'o-table-column-resizer',
                    inputs: DEFAULT_INPUTS_O_TABLE_COLUMN_RESIZER,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_COLUMN_RESIZER,
                    template: "\n    <span class=\"resizer\" (click)=\"onClick($event)\"></span>\n  ",
                    styles: ["\n    .o-table-column-resizer{display:inline-block;width:13px;position:absolute;right:0;top:6px;bottom:6px}.o-table-column-resizer:not(.disabled){cursor:col-resize}.o-table-column-resizer span{height:100%;width:1px;display:block;margin-left:auto;margin-right:auto}.o-table-column-resizer.disabled{cursor:default}\n  "],
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-table-column-resizer]': 'true',
                        '[class.disabled]': 'isDisabled',
                    }
                },] },
    ];
    /** @nocollapse */
    OTableColumnResizerComponent.ctorParameters = function () { return [
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.NgZone },
        { type: core.Renderer2 }
    ]; };
    OTableColumnResizerComponent.propDecorators = {
        onMousedown: [{ type: core.HostListener, args: ['mousedown', ['$event'],] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableColumnResizerComponent.prototype, "disabled", void 0);
    return OTableColumnResizerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_COLUMN_FILTER = [
    'columns',
    'preloadValues: preload-values',
    'mode'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_COLUMN_FILTER = [];
/** @enum {number} */
var ColumnValueFilterOperator = {
    IN: 0, LESS_EQUAL: 1, MORE_EQUAL: 2, BETWEEN: 3, EQUAL: 4,
};
ColumnValueFilterOperator[ColumnValueFilterOperator.IN] = 'IN';
ColumnValueFilterOperator[ColumnValueFilterOperator.LESS_EQUAL] = 'LESS_EQUAL';
ColumnValueFilterOperator[ColumnValueFilterOperator.MORE_EQUAL] = 'MORE_EQUAL';
ColumnValueFilterOperator[ColumnValueFilterOperator.BETWEEN] = 'BETWEEN';
ColumnValueFilterOperator[ColumnValueFilterOperator.EQUAL] = 'EQUAL';
var OTableColumnsFilterComponent = /** @class */ (function () {
    function OTableColumnsFilterComponent(injector, table) {
        this.injector = injector;
        this.table = table;
        this._mode = 'default';
        this.preloadValues = true;
        this._columnsArray = [];
        this.columnsComparisonProperty = {};
    }
    Object.defineProperty(OTableColumnsFilterComponent.prototype, "mode", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mode;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var m = OTableColumnsFilterComponent.OTableColumnsFilterModes.find(function (e) { return e === val; });
            if (Util.isDefined(m)) {
                this._mode = m;
            }
            else {
                console.error('Invalid `o-table-columns-filter` mode (' + val + ')');
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableColumnsFilterComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.columnsArray.length === 0) {
            this.columnsArray = this.table.oTableOptions.visibleColumns;
        }
        /** @type {?} */
        var self = this;
        this.columnsArray.forEach(function (colData, i, arr) {
            /** @type {?} */
            var colDef = colData.split(Codes.TYPE_SEPARATOR);
            /** @type {?} */
            var colName = colDef[0];
            /** @type {?} */
            var compType = (colDef[1] || '').toUpperCase();
            if ([OTableColumnsFilterComponent.DEFAULT_COMPARISON_TYPE, OTableColumnsFilterComponent.MODEL_COMPARISON_TYPE].indexOf(compType) === -1) {
                compType = OTableColumnsFilterComponent.DEFAULT_COMPARISON_TYPE;
            }
            arr[i] = colName;
            self.columnsComparisonProperty[colName] = compType;
        });
        this.table.setOTableColumnsFilter(this);
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OTableColumnsFilterComponent.prototype.isColumnFilterable = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        return (this.columnsArray.indexOf(attr) !== -1);
    };
    /**
     * @param {?} column
     * @param {?} val
     * @return {?}
     */
    OTableColumnsFilterComponent.prototype.getColumnComparisonValue = /**
     * @param {?} column
     * @param {?} val
     * @return {?}
     */
    function (column, val) {
        if (!column || this.columnsComparisonProperty[column.attr] === OTableColumnsFilterComponent.MODEL_COMPARISON_TYPE) {
            return val;
        }
        else {
            return column.renderer ? column.renderer.getCellData(val) : val;
        }
    };
    Object.defineProperty(OTableColumnsFilterComponent.prototype, "columns", {
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._columns = arg;
            this._columnsArray = Util.parseArray(this._columns, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableColumnsFilterComponent.prototype, "columnsArray", {
        get: /**
         * @return {?}
         */
        function () {
            return this._columnsArray;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._columnsArray = arg;
        },
        enumerable: true,
        configurable: true
    });
    OTableColumnsFilterComponent.DEFAULT_INPUTS_O_TABLE_COLUMN_FILTER = DEFAULT_INPUTS_O_TABLE_COLUMN_FILTER;
    OTableColumnsFilterComponent.DEFAULT_OUTPUTS_O_TABLE_COLUMN_FILTER = DEFAULT_OUTPUTS_O_TABLE_COLUMN_FILTER;
    OTableColumnsFilterComponent.DEFAULT_COMPARISON_TYPE = 'VIEW';
    OTableColumnsFilterComponent.MODEL_COMPARISON_TYPE = 'MODEL';
    OTableColumnsFilterComponent.OTableColumnsFilterModes = ['default', 'selection', 'custom'];
    OTableColumnsFilterComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-columns-filter',
                    template: ' ',
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_COLUMN_FILTER,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_COLUMN_FILTER
                },] },
    ];
    /** @nocollapse */
    OTableColumnsFilterComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableColumnsFilterComponent.prototype, "preloadValues", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], OTableColumnsFilterComponent.prototype, "mode", null);
    return OTableColumnsFilterComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTableApplyConfigurationDialogComponent = /** @class */ (function () {
    function OTableApplyConfigurationDialogComponent(dialogRef, data, injector) {
        this.dialogRef = dialogRef;
        this.injector = injector;
        this.default_configuration = 'OTableApplyConfigurationDialogComponent-default';
        this.configurations = [];
        this.onDelete = new core.EventEmitter();
        this.loadConfigurations(data);
        this.dialogService = this.injector.get(DialogService);
    }
    /**
     * @return {?}
     */
    OTableApplyConfigurationDialogComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.configurationList.selectedOptions = new SelectionModel(false);
    };
    /**
     * @param {?} configurations
     * @return {?}
     */
    OTableApplyConfigurationDialogComponent.prototype.loadConfigurations = /**
     * @param {?} configurations
     * @return {?}
     */
    function (configurations) {
        this.configurations = configurations;
    };
    /**
     * @param {?} configurationName
     * @return {?}
     */
    OTableApplyConfigurationDialogComponent.prototype.removeConfiguration = /**
     * @param {?} configurationName
     * @return {?}
     */
    function (configurationName) {
        var _this = this;
        this.dialogService.confirm('CONFIRM', 'TABLE.DIALOG.CONFIRM_REMOVE_CONFIGURATION').then(function (result) {
            if (result) {
                _this.onDelete.emit(configurationName);
            }
        });
    };
    /**
     * @return {?}
     */
    OTableApplyConfigurationDialogComponent.prototype.isDefaultConfigurationSelected = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var selected = this.configurationList.selectedOptions.selected;
        /** @type {?} */
        var selectedValue = selected.length ? selected[0].value : void 0;
        return selectedValue === this.default_configuration;
    };
    /**
     * @return {?}
     */
    OTableApplyConfigurationDialogComponent.prototype.getSelectedConfigurationName = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var selected = this.configurationList.selectedOptions.selected;
        return selected.length ? selected[0].value : void 0;
    };
    OTableApplyConfigurationDialogComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-apply-configuration-dialog',
                    template: "\n    <span mat-dialog-title>{{ 'TABLE.BUTTONS.APPLY_CONFIGURATION' | oTranslate }}</span>\n\n    <mat-dialog-content fxLayout=\"column\">\n      <div mat-subheader>{{ 'TABLE.DIALOG.APPLY_CONFIGURATION' | oTranslate }}</div>\n      <mat-selection-list #configurationList dense class=\"o-table-apply-configuration-dialog-list\">\n        <mat-list-option checkboxPosition=\"before\" [value]=\"default_configuration\">\n          <span matLine class=\"o-table-apply-configuration-dialog-list-title\">{{ 'TABLE.DIALOG.APPLY_CONFIGURATION_DEFAULT' | oTranslate }}</span>\n          <span matLine>{{ 'TABLE.DIALOG.APPLY_CONFIGURATION_DEFAULT_DESCRIPTION' | oTranslate }}</span>\n        </mat-list-option>\n        <mat-list-option checkboxPosition=\"before\" *ngFor=\"let configuration of configurations; let i = index\" [value]=\"configuration.name\">\n          <span matLine>{{ configuration.name }}</span>\n          <span matLine>{{ configuration.description }}</span>\n        </mat-list-option>\n      </mat-selection-list>\n    </mat-dialog-content>\n\n    <mat-dialog-actions align=\"end\">\n      <button type=\"button\" mat-stroked-button [disabled]=\"configurationList.selectedOptions.selected.length!==1 || isDefaultConfigurationSelected()\"\n        (click)=\"removeConfiguration(configurationList.selectedOptions.selected[0].value)\">\n        {{ 'DELETE' | oTranslate | uppercase }}\n      </button>\n      <span fxFlex></span>\n      <button type=\"button\" mat-stroked-button class=\"mat-primary\" [mat-dialog-close]=\"false\">{{ 'CANCEL' | oTranslate | uppercase }}</button>\n      <button type=\"button\" mat-stroked-button class=\"mat-primary\" [mat-dialog-close]=\"true\"\n        [disabled]=\"configurationList.selectedOptions.selected.length!==1\">{{ 'OK' | oTranslate | uppercase }}</button>\n    </mat-dialog-actions>\n  ",
                    styles: ["\n\n  "]
                },] },
    ];
    /** @nocollapse */
    OTableApplyConfigurationDialogComponent.ctorParameters = function () { return [
        { type: material.MatDialogRef },
        { type: Array, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] }] },
        { type: core.Injector }
    ]; };
    OTableApplyConfigurationDialogComponent.propDecorators = {
        configurationList: [{ type: core.ViewChild, args: [material.MatSelectionList,] }]
    };
    return OTableApplyConfigurationDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTableExportConfiguration = /** @class */ (function () {
    function OTableExportConfiguration() {
    }
    return OTableExportConfiguration;
}());
var OTableExportDialogComponent = /** @class */ (function () {
    function OTableExportDialogComponent(dialogRef, injector, config$$1) {
        this.dialogRef = dialogRef;
        this.injector = injector;
        this.config = config$$1;
        this.dialogService = injector.get(DialogService);
        this.translateService = this.injector.get(OTranslateService$$1);
    }
    /**
     * @return {?}
     */
    OTableExportDialogComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.initialize();
    };
    /**
     * @return {?}
     */
    OTableExportDialogComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        this.configureService();
    };
    /**
     * @return {?}
     */
    OTableExportDialogComponent.prototype.configureService = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var loadingService = OntimizeExportService$$1;
        // TODO: allow service type selection (extension)
        // if (this.serviceType) {
        //   loadingService = this.serviceType;
        // }
        try {
            this.exportService = this.injector.get(loadingService);
            /** @type {?} */
            var serviceCfg = this.exportService.getDefaultServiceConfiguration(this.config.service);
            this.exportService.configureService(serviceCfg);
        }
        catch (e) {
            console.error(e);
        }
    };
    /**
     * @param {?} excelButton
     * @return {?}
     */
    OTableExportDialogComponent.prototype.exportExcel = /**
     * @param {?} excelButton
     * @return {?}
     */
    function (excelButton) {
        excelButton.disabled = true;
        /** @type {?} */
        var exportData = {
            data: this.config.data,
            columns: this.config.columns,
            columnNames: this.config.columnNames,
            sqlTypes: this.config.sqlTypes
        };
        /** @type {?} */
        var self = this;
        this.proccessExportData(exportData.data, exportData.sqlTypes);
        this.exportService.exportData(exportData, OExportExtension$$1.Excel).subscribe(function (resp) {
            if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                self.exportService.downloadFile(resp.data[0]['xslxId'], OExportExtension$$1.Excel).subscribe(function () { return self.dialogRef.close(true); }, function (downloadError) {
                    console.error(downloadError);
                    self.dialogRef.close(false);
                });
            }
            else {
                self.dialogService.alert('ERROR', resp.message).then(function () { return self.dialogRef.close(false); });
            }
        }, function (err) { return self.handleError(err); });
    };
    /**
     * @param {?} htmlButton
     * @return {?}
     */
    OTableExportDialogComponent.prototype.exportHTML = /**
     * @param {?} htmlButton
     * @return {?}
     */
    function (htmlButton) {
        htmlButton.disabled = true;
        /** @type {?} */
        var exportData = {
            data: this.config.data,
            columns: this.config.columns,
            columnNames: this.config.columnNames,
            sqlTypes: this.config.sqlTypes
        };
        /** @type {?} */
        var self = this;
        this.proccessExportData(exportData.data, exportData.sqlTypes);
        this.exportService.exportData(exportData, OExportExtension$$1.HTML).subscribe(function (resp) {
            if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                self.exportService.downloadFile(resp.data[0]['htmlId'], OExportExtension$$1.HTML).subscribe(function () { return self.dialogRef.close(true); }, function (downloadError) {
                    console.error(downloadError);
                    self.dialogRef.close(false);
                });
            }
            else {
                self.dialogService.alert('ERROR', resp.message).then(function () { return self.dialogRef.close(false); });
            }
        }, function (err) { return self.handleError(err); });
    };
    /**
     * @param {?} pdfButton
     * @return {?}
     */
    OTableExportDialogComponent.prototype.exportPDF = /**
     * @param {?} pdfButton
     * @return {?}
     */
    function (pdfButton) {
        pdfButton.disabled = true;
        /** @type {?} */
        var exportData = {
            data: this.config.data,
            columns: this.config.columns,
            columnNames: this.config.columnNames,
            sqlTypes: this.config.sqlTypes
        };
        /** @type {?} */
        var self = this;
        this.proccessExportData(exportData.data, exportData.sqlTypes);
        this.exportService.exportData(exportData, OExportExtension$$1.PDF).subscribe(function (resp) {
            if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                self.exportService.downloadFile(resp.data[0]['pdfId'], OExportExtension$$1.PDF).subscribe(function () { return self.dialogRef.close(true); }, function (downloadError) {
                    console.error(downloadError);
                    self.dialogRef.close(false);
                });
            }
            else {
                self.dialogService.alert('ERROR', resp.message).then(function () { return self.dialogRef.close(false); });
            }
        }, function (err) { return self.handleError(err); });
    };
    /**
     * @param {?} data
     * @param {?} sqlTypes
     * @return {?}
     */
    OTableExportDialogComponent.prototype.proccessExportData = /**
     * @param {?} data
     * @param {?} sqlTypes
     * @return {?}
     */
    function (data, sqlTypes) {
        var _this = this;
        // Parse boolean
        Object.keys(sqlTypes).forEach(function (key) {
            if (SQLTypes.BOOLEAN === sqlTypes[key]) {
                /** @type {?} */
                var yes_1 = _this.translateService.get('YES');
                /** @type {?} */
                var no_1 = _this.translateService.get('NO');
                data.forEach(function (row) {
                    if (row[key]) {
                        row[key] = Util.parseBoolean(row[key]) ? yes_1 : no_1;
                    }
                });
            }
        });
    };
    /**
     * @param {?} err
     * @return {?}
     */
    OTableExportDialogComponent.prototype.handleError = /**
     * @param {?} err
     * @return {?}
     */
    function (err) {
        console.error(err);
        /** @type {?} */
        var self = this;
        if (err instanceof http.HttpErrorResponse) {
            this.dialogService.alert('ERROR', err.message).then(function () { return self.dialogRef.close(false); });
        }
        else {
            this.dialogService.alert('ERROR', 'MESSAGES.ERROR_EXPORT_TABLE_DATA').then(function () { return self.dialogRef.close(false); });
        }
    };
    OTableExportDialogComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-export-dialog',
                    template: "\n    <span mat-dialog-title>{{ 'TABLE.BUTTONS.EXPORT' | oTranslate }}</span>\n    <mat-dialog-content>\n      <div mat-subheader>{{ 'TABLE.DIALOG.EXPORT.DESCRIPTION' | oTranslate }}</div>\n      <div fxLayout=\"row\" fxLayoutAlign=\"space-around center\">\n        <button type=\"button\" #excelButton mat-raised-button (click)=\"exportExcel(excelButton)\" class=\"excel-button\">\n          <div fxLayout=\"column\" fxLayoutAlign=\"center center\">\n            <mat-icon svgIcon=\"ontimize:EXCEL\"></mat-icon>\n            <span>{{ 'TABLE.BUTTONS.EXCEL' | oTranslate }}</span>\n          </div>\n        </button>\n        <button type=\"button\" #htmlButton mat-raised-button (click)=\"exportHTML(htmlButton)\" class=\"html-button\">\n          <div fxLayout=\"column\" fxLayoutAlign=\"center center\">\n            <mat-icon svgIcon=\"ontimize:HTML\"></mat-icon>\n            <span>{{ 'TABLE.BUTTONS.HTML' | oTranslate }}</span>\n          </div>\n        </button>\n        <button type=\"button\" #pdfButton mat-raised-button (click)=\"exportPDF(pdfButton)\" class=\"pdf-button\">\n          <div fxLayout=\"column\" fxLayoutAlign=\"center center\">\n            <mat-icon svgIcon=\"ontimize:PDF\"></mat-icon>\n            <span>{{ 'TABLE.BUTTONS.PDF' | oTranslate }}</span>\n          </div>\n        </button>\n      </div>\n    </mat-dialog-content>\n\n    <mat-dialog-actions fxLayoutAlign=\"end center\">\n      <button type=\"button\" mat-stroked-button [mat-dialog-close]=\"false\">{{ 'CANCEL' | oTranslate | uppercase }}</button>\n    </mat-dialog-actions>\n  ",
                    styles: ["\n    .o-table-export-dialog .mat-icon{padding:6px 6px 0;width:48px;height:48px;font-size:48px}\n  "],
                    providers: [OntimizeExportService$$1],
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    host: {
                        'class': 'o-table-export-dialog'
                    },
                    encapsulation: core.ViewEncapsulation.None
                },] },
    ];
    /** @nocollapse */
    OTableExportDialogComponent.ctorParameters = function () { return [
        { type: material.MatDialogRef },
        { type: core.Injector },
        { type: OTableExportConfiguration, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] }] }
    ]; };
    return OTableExportDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTableBaseDialogClass = /** @class */ (function () {
    function OTableBaseDialogClass(injector) {
        this.injector = injector;
        try {
            this.errorOptions = this.injector.get(O_MAT_ERROR_OPTIONS) || {};
        }
        catch (e) {
            this.errorOptions = {};
        }
    }
    /**
     * @param {?} formControl
     * @return {?}
     */
    OTableBaseDialogClass.prototype.setFormControl = /**
     * @param {?} formControl
     * @return {?}
     */
    function (formControl) {
        this.formControl = formControl;
    };
    Object.defineProperty(OTableBaseDialogClass.prototype, "tooltipClass", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var result;
            /** @type {?} */
            var liteError = this.errorOptions.type === Codes.O_MAT_ERROR_LITE;
            if (liteError && Util.isDefined(this.formControl) && this.formControlHasErrors()) {
                result = "o-tooltip o-mat-error";
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableBaseDialogClass.prototype, "tooltipText", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var result;
            /** @type {?} */
            var liteError = this.errorOptions.type === Codes.O_MAT_ERROR_LITE;
            if (liteError && this.formControlHasErrors() && this.oMatErrorChildren && this.oMatErrorChildren.length > 0) {
                result = '';
                this.oMatErrorChildren.forEach(function (oMatError) {
                    result += oMatError.text + "\n";
                });
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableBaseDialogClass.prototype.formControlHasErrors = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this.formControl) && this.formControl.touched && Util.isDefined(this.formControl.errors);
    };
    OTableBaseDialogClass.propDecorators = {
        oMatErrorChildren: [{ type: core.ViewChildren, args: [OMatErrorComponent,] }]
    };
    return OTableBaseDialogClass;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTableStoreConfigurationDialogComponent = /** @class */ (function (_super) {
    __extends(OTableStoreConfigurationDialogComponent, _super);
    function OTableStoreConfigurationDialogComponent(dialogRef, injector) {
        var _this = _super.call(this, injector) || this;
        _this.dialogRef = dialogRef;
        _this.injector = injector;
        _this.properties = [{
                property: 'sort',
                name: 'TABLE.DIALOG.PROPERTIES.SORT',
                info: 'TABLE.DIALOG.PROPERTIES.SORT.INFO'
            }, {
                property: 'columns-display',
                name: 'TABLE.DIALOG.PROPERTIES.COLUMNS_DISPLAY',
                info: 'TABLE.DIALOG.PROPERTIES.COLUMNS_DISPLAY.INFO'
            }, {
                property: 'quick-filter',
                name: 'TABLE.DIALOG.PROPERTIES.QUICK_FILTER',
                info: 'TABLE.DIALOG.PROPERTIES.QUICK_FILTER.INFO'
            }, {
                property: 'columns-filter',
                name: 'TABLE.DIALOG.PROPERTIES.COLUMNS_FILTER',
                info: 'TABLE.DIALOG.PROPERTIES.COLUMNS_FILTER.INFO'
            }, {
                property: 'page',
                name: 'TABLE.DIALOG.PROPERTIES.PAGE',
                info: 'TABLE.DIALOG.PROPERTIES.PAGE.INFO'
            }];
        _this.formGroup = new forms.FormGroup({
            name: new forms.FormControl('', [
                forms.Validators.required
            ]),
            description: new forms.FormControl('')
        });
        _this.setFormControl(_this.formGroup.get('name'));
        return _this;
    }
    /**
     * @return {?}
     */
    OTableStoreConfigurationDialogComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.propertiesList.selectAll();
    };
    /**
     * @return {?}
     */
    OTableStoreConfigurationDialogComponent.prototype.areAllSelected = /**
     * @return {?}
     */
    function () {
        return this.propertiesList && this.propertiesList.options && this.propertiesList.options.length === this.propertiesList.selectedOptions.selected.length;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableStoreConfigurationDialogComponent.prototype.onSelectAllChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.checked ? this.propertiesList.selectAll() : this.propertiesList.deselectAll();
    };
    /**
     * @return {?}
     */
    OTableStoreConfigurationDialogComponent.prototype.getConfigurationAttributes = /**
     * @return {?}
     */
    function () {
        return this.formGroup.value;
    };
    /**
     * @return {?}
     */
    OTableStoreConfigurationDialogComponent.prototype.getSelectedTableProperties = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var selected = this.propertiesList.selectedOptions.selected;
        return selected.length ? selected.map(function (item) { return item.value; }) : [];
    };
    /**
     * @return {?}
     */
    OTableStoreConfigurationDialogComponent.prototype.isIndeterminate = /**
     * @return {?}
     */
    function () {
        return !this.areAllSelected();
    };
    OTableStoreConfigurationDialogComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-store-configuration-dialog',
                    template: "\n    <span mat-dialog-title>{{ 'TABLE.BUTTONS.SAVE_CONFIGURATION' | oTranslate }}</span>\n\n    <mat-dialog-content>\n      <div mat-subheader>{{ 'TABLE.DIALOG.SAVE_CONFIGURATION' | oTranslate }}</div>\n      <form #form [formGroup]=\"formGroup\" fxLayout=\"column\">\n        <mat-form-field>\n          <input matInput [matTooltip]=\"tooltipText\" [matTooltipClass]=\"tooltipClass\" placeholder=\"{{ 'TABLE.DIALOG.CONFIGURATION_NAME' | oTranslate }}\"\n            formControlName=\"name\" required>\n          <mat-error *ngIf=\"formGroup.controls['name'].hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        </mat-form-field>\n        <mat-form-field class=\"example-full-width\">\n          <textarea matInput placeholder=\"{{ 'TABLE.DIALOG.CONFIGURATION_DESCRIPTION' | oTranslate }}\" formControlName=\"description\" rows=\"4\"\n            cols=\"50\"></textarea>\n        </mat-form-field>\n        <div class=\"inner-subheader\" mat-subheader>{{ 'TABLE.DIALOG.CONFIGURATION_PROPERTIES' | oTranslate }}</div>\n        <div fxLayout=\"column\">\n          <mat-checkbox (change)=\"onSelectAllChange($event)\" [checked]=\"areAllSelected()\" [indeterminate]=\"isIndeterminate()\" class=\"select-all-checkbox\">\n            {{ 'SELECT_ALL' | oTranslate }}\n          </mat-checkbox>\n\n          <mat-selection-list #propertiesList dense class=\"o-table-save-configuration-dialog-list o-scroll\">\n            <mat-list-option checkboxPosition=\"before\" *ngFor=\"let property of properties\" [value]=\"property.property\">\n              <div fxLayout=\"row\" fxLayoutAlign=\"center center\">\n                <span matLine fxFlex>{{ property.name | oTranslate }}</span>\n                <mat-icon *ngIf=\"property.info\" matTooltip=\"{{ property.info | oTranslate }}\" class=\"o-tscd-list-tooltip\">info</mat-icon>\n              </div>\n            </mat-list-option>\n          </mat-selection-list>\n        </div>\n      </form>\n    </mat-dialog-content>\n\n    <mat-dialog-actions align=\"end\">\n      <button type=\"button\" mat-stroked-button class=\"mat-primary\" [mat-dialog-close]=\"false\">{{ 'CANCEL' | oTranslate | uppercase }}</button>\n      <button type=\"button\" mat-stroked-button class=\"mat-primary\" [mat-dialog-close]=\"true\"\n        [disabled]=\"!formGroup.valid || propertiesList.selectedOptions.selected.length===0\">{{ 'SAVE' | oTranslate | uppercase }}</button>\n    </mat-dialog-actions>\n  ",
                    styles: ["\n    .select-all-checkbox{padding:6px 0}.o-table-save-configuration-dialog-list{max-height:120px;overflow-y:scroll}.o-table-save-configuration-dialog-list .mat-list-item{height:30px}.o-table-save-configuration-dialog-list .mat-list-item .o-tscd-list-tooltip.mat-icon{opacity:.25}\n  "],
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    OTableStoreConfigurationDialogComponent.ctorParameters = function () { return [
        { type: material.MatDialogRef },
        { type: core.Injector }
    ]; };
    OTableStoreConfigurationDialogComponent.propDecorators = {
        propertiesList: [{ type: core.ViewChild, args: ['propertiesList',] }]
    };
    return OTableStoreConfigurationDialogComponent;
}(OTableBaseDialogClass));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTableLoadFilterDialogComponent = /** @class */ (function () {
    function OTableLoadFilterDialogComponent(dialogRef, data, injector) {
        this.dialogRef = dialogRef;
        this.injector = injector;
        this.filters = [];
        this.onDelete = new core.EventEmitter();
        this.loadFilters(data);
        this.dialogService = this.injector.get(DialogService);
        try {
            this.cd = this.injector.get(core.ChangeDetectorRef);
        }
        catch (e) {
            // no parent form
        }
    }
    /**
     * @return {?}
     */
    OTableLoadFilterDialogComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.filterList.selectedOptions = new SelectionModel(false);
    };
    /**
     * @param {?} filters
     * @return {?}
     */
    OTableLoadFilterDialogComponent.prototype.loadFilters = /**
     * @param {?} filters
     * @return {?}
     */
    function (filters) {
        this.filters = filters;
    };
    /**
     * @return {?}
     */
    OTableLoadFilterDialogComponent.prototype.getSelectedFilterName = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var selected = this.filterList.selectedOptions.selected;
        return selected.length ? selected[0].value : void 0;
    };
    /**
     * @param {?} filterName
     * @return {?}
     */
    OTableLoadFilterDialogComponent.prototype.removeFilter = /**
     * @param {?} filterName
     * @return {?}
     */
    function (filterName) {
        var _this = this;
        this.dialogService.confirm('CONFIRM', 'TABLE.DIALOG.CONFIRM_REMOVE_FILTER').then(function (result) {
            if (result) {
                _this.onDelete.emit(filterName);
                _this.cd.detectChanges();
            }
        });
    };
    OTableLoadFilterDialogComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-load-filter-dialog',
                    template: "\n    <span mat-dialog-title>{{ 'TABLE.BUTTONS.FILTER_LOAD' | oTranslate }}</span>\n    <mat-dialog-content fxLayout=\"column\">\n      <div mat-subheader>{{ 'TABLE.DIALOG.LOAD_FILTER' | oTranslate }}</div>\n      <mat-selection-list #filterList dense class=\"o-table-load-filter-dialog-list\">\n        <mat-list-option *ngFor=\"let filter of filters \" [value]=\"filter.name\" checkboxPosition=\"before\">\n          <span matLine class=\"o-table-load-filter-dialog-list-title\">{{ filter.name }}</span>\n          <span matLine>{{ filter.description }}</span>\n        </mat-list-option>\n        <mat-list-item *ngIf=\"filters.length === 0\">\n          <span class=\"empty-filter-list\">{{ 'TABLE.DIALOG.EMPTY_FILTER_LIST' | oTranslate }}</span>\n        </mat-list-item>\n      </mat-selection-list>\n    </mat-dialog-content>\n\n    <mat-dialog-actions align=\"end\">\n      <button type=\"button\" mat-stroked-button [disabled]=\"filterList.selectedOptions.selected.length!==1\"\n        (click)=\"removeFilter(filterList.selectedOptions.selected[0].value)\">{{ 'DELETE' | oTranslate | uppercase }}</button>\n      <span fxFlex></span>\n      <button type=\"button\" mat-stroked-button class=\"mat-primary\" [mat-dialog-close]=\"false\">{{ 'CANCEL' | oTranslate | uppercase }}</button>\n      <button type=\"button\" mat-stroked-button class=\"mat-primary\" [mat-dialog-close]=\"true\"\n        [disabled]=\"filterList.selectedOptions.selected.length!==1\">{{ 'TABLE.BUTTONS.APPLY' | oTranslate | uppercase }}</button>\n    </mat-dialog-actions>\n  ",
                    styles: ["\n\n  "],
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    OTableLoadFilterDialogComponent.ctorParameters = function () { return [
        { type: material.MatDialogRef },
        { type: Array, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] }] },
        { type: core.Injector }
    ]; };
    OTableLoadFilterDialogComponent.propDecorators = {
        filterList: [{ type: core.ViewChild, args: [material.MatSelectionList,] }]
    };
    return OTableLoadFilterDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTableStoreFilterDialogComponent = /** @class */ (function (_super) {
    __extends(OTableStoreFilterDialogComponent, _super);
    function OTableStoreFilterDialogComponent(dialogRef, injector, data) {
        var _this = _super.call(this, injector) || this;
        _this.dialogRef = dialogRef;
        _this.injector = injector;
        _this.filterNames = [];
        _this.formGroup = new forms.FormGroup({
            name: new forms.FormControl('', [
                forms.Validators.required,
                _this.filterNameValidator.bind(_this)
            ]),
            description: new forms.FormControl('')
        });
        _this.setFormControl(_this.formGroup.get('name'));
        _this.loadFilterNames(data);
        return _this;
    }
    /**
     * @param {?} filterNames
     * @return {?}
     */
    OTableStoreFilterDialogComponent.prototype.loadFilterNames = /**
     * @param {?} filterNames
     * @return {?}
     */
    function (filterNames) {
        this.filterNames = filterNames;
    };
    /**
     * @return {?}
     */
    OTableStoreFilterDialogComponent.prototype.getFilterAttributes = /**
     * @return {?}
     */
    function () {
        return this.formGroup.value;
    };
    /**
     * @param {?} control
     * @return {?}
     */
    OTableStoreFilterDialogComponent.prototype.filterNameValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        /** @type {?} */
        var ctrlValue = control.value;
        if (this.filterNames.indexOf(ctrlValue) !== -1) {
            return { 'filterNameAlreadyExists': true };
        }
        return {};
    };
    OTableStoreFilterDialogComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-store-filter-dialog',
                    template: "\n    <span mat-dialog-title>{{ 'TABLE.BUTTONS.SAVE_FILTER' | oTranslate }}</span>\n\n    <mat-dialog-content>\n      <div mat-subheader>{{ 'TABLE.DIALOG.SAVE_FILTER' | oTranslate }}</div>\n      <form #form [formGroup]=\"formGroup\" fxLayout=\"column\">\n        <mat-form-field>\n          <input matInput [matTooltip]=\"tooltipText\" [matTooltipClass]=\"tooltipClass\" placeholder=\"{{ 'TABLE.DIALOG.FILTER_NAME' | oTranslate }}\"\n            formControlName=\"name\" required>\n          <mat-error *ngIf=\"formGroup.controls['name'].hasError('filterNameAlreadyExists')\" text=\"{{ 'TABLE.DIALOG.FILTER_NAME_ALREADY_EXISTS' | oTranslate }}\"></mat-error>\n          <mat-error *ngIf=\"formGroup.controls['name'].hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        </mat-form-field>\n        <mat-form-field class=\"example-full-width\">\n          <textarea matInput placeholder=\"{{ 'TABLE.DIALOG.FILTER_DESCRIPTION' | oTranslate }}\" formControlName=\"description\" rows=\"4\" cols=\"50\"></textarea>\n        </mat-form-field>\n      </form>\n    </mat-dialog-content>\n\n    <mat-dialog-actions align=\"end\">\n      <button type=\"button\" mat-stroked-button class=\"mat-primary\" [mat-dialog-close]=\"false\">{{ 'CANCEL' | oTranslate | uppercase }}</button>\n      <button type=\"button\" mat-stroked-button class=\"mat-primary\" [mat-dialog-close]=\"true\" [disabled]=\"!formGroup.valid\">{{'SAVE' | oTranslate | uppercase }}</button>\n    </mat-dialog-actions>\n  ",
                    styles: ["\n\n  "],
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    OTableStoreFilterDialogComponent.ctorParameters = function () { return [
        { type: material.MatDialogRef },
        { type: core.Injector },
        { type: Array, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] }] }
    ]; };
    return OTableStoreFilterDialogComponent;
}(OTableBaseDialogClass));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTableVisibleColumnsDialogComponent = /** @class */ (function () {
    function OTableVisibleColumnsDialogComponent(injector, dialogRef, data) {
        var _this = this;
        this.injector = injector;
        this.dialogRef = dialogRef;
        this.columns = [];
        this.rowHeight = Codes.DEFAULT_ROW_HEIGHT;
        try {
            this.cd = this.injector.get(core.ChangeDetectorRef);
        }
        catch (e) {
            // no parent form
        }
        if (Util.isArray(data.columnsData) && Util.isArray(data.originalVisibleColumns)) {
            /** @type {?} */
            var originalCols_1 = data.originalVisibleColumns;
            data.columnsData.forEach(function (oCol) {
                _this.columns.push({
                    attr: oCol.attr,
                    title: oCol.title,
                    visible: oCol.visible,
                    showInList: (oCol.definition !== undefined || oCol.visible || originalCols_1.indexOf(oCol.attr) !== -1)
                });
            });
        }
        if (Util.isDefined(data.rowHeight)) {
            this.rowHeight = data.rowHeight;
        }
    }
    /**
     * @return {?}
     */
    OTableVisibleColumnsDialogComponent.prototype.getVisibleColumns = /**
     * @return {?}
     */
    function () {
        return this.columns.filter(function (col) { return col.visible; }).map(function (col) { return col.attr; });
    };
    /**
     * @return {?}
     */
    OTableVisibleColumnsDialogComponent.prototype.getColumnsOrder = /**
     * @return {?}
     */
    function () {
        return this.columns.map(function (col) { return col.attr; });
    };
    /**
     * @param {?} col
     * @return {?}
     */
    OTableVisibleColumnsDialogComponent.prototype.onClickColumn = /**
     * @param {?} col
     * @return {?}
     */
    function (col) {
        col.visible = !col.visible;
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    OTableVisibleColumnsDialogComponent.prototype.onDragSuccess = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        this.cd.detectChanges();
    };
    OTableVisibleColumnsDialogComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-visible-columns-dialog',
                    template: "\n    <span mat-dialog-title>{{ 'TABLE.BUTTONS.COLVIS' | oTranslate }}</span>\n\n    <mat-dialog-content>\n      <mat-list dnd-sortable-container [sortableData]=\"columns\" [ngClass]=\"rowHeight\">\n        <ng-container *ngFor=\"let column of columns; let x = index\">\n          <mat-list-item *ngIf=\"column.showInList\" (click)=\"onClickColumn(column)\" dnd-sortable [sortableIndex]=\"x\"\n            [dragData]=\"column\" [dragEnabled]=\"true\" (onDragSuccess)=\"onDragSuccess($event)\">\n            <mat-icon mat-list-icon svgIcon=\"ontimize:drag_handle\"></mat-icon>\n            <span mat-line>{{ (column.title || column.attr) | oTranslate }}</span>\n            <mat-icon *ngIf=\"column.visible\" svgIcon=\"ontimize:visibility\"></mat-icon>\n            <mat-icon *ngIf=\"!column.visible\" svgIcon=\"ontimize:visibility_off\"></mat-icon>\n          </mat-list-item>\n        </ng-container>\n      </mat-list>\n    </mat-dialog-content>\n\n    <mat-dialog-actions fxLayoutAlign=\"end center\">\n      <button type=\"button\" mat-stroked-button [mat-dialog-close]=\"false\">{{ 'CANCEL' | oTranslate | uppercase }}</button>\n      <button type=\"button\" mat-stroked-button [mat-dialog-close]=\"true\">{{ 'ACCEPT' | oTranslate | uppercase }}</button>\n    </mat-dialog-actions>\n  ",
                    styles: ["\n    .o-table-visible-columns-dialog .mat-dialog-content.mat-dialog-content{overflow:auto;padding-top:0;margin-top:24px}.o-table-visible-columns-dialog .mat-dialog-content.mat-dialog-content .mat-list{padding-top:24px}.o-table-visible-columns-dialog .mat-dialog-content.mat-dialog-content .mat-list .mat-list-item{cursor:pointer}.o-table-visible-columns-dialog .mat-dialog-content.mat-dialog-content .mat-list .mat-list-item .mat-list-item-content{padding:0}.o-table-visible-columns-dialog .mat-dialog-content.mat-dialog-content .mat-list .mat-list-item .mat-list-item-content div.mat-list-text{padding:0 8px}.o-table-visible-columns-dialog .mat-dialog-content.mat-dialog-content .mat-icon[svgicon=\"ontimize:drag_handle\"]{cursor:move}.o-table-visible-columns-dialog .mat-dialog-content.mat-dialog-content .mat-icon[svgicon=\"ontimize:visibility\"],.o-table-visible-columns-dialog .mat-dialog-content.mat-dialog-content .mat-icon[svgicon=\"ontimize:visibility_off\"]{width:32px}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    providers: [DragDropService],
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.o-table-visible-columns-dialog]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OTableVisibleColumnsDialogComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: material.MatDialogRef },
        { type: undefined, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] }] }
    ]; };
    return OTableVisibleColumnsDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTableFilterByColumnDataDialogComponent = /** @class */ (function () {
    function OTableFilterByColumnDataDialogComponent(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.preloadValues = true;
        this.isCustomFilterSubject = new BehaviorSubject(false);
        this.isCustomFilter = this.isCustomFilterSubject.asObservable();
        this.isDefaultFilterSubject = new BehaviorSubject(false);
        this.isDefaultFilter = this.isDefaultFilterSubject.asObservable();
        this.fcText = new forms.FormControl();
        this.fcFrom = new forms.FormControl();
        this.fcTo = new forms.FormControl();
        this.columnData = [];
        this.tableData = [];
        if (data.column) {
            this.column = data.column;
        }
        /** @type {?} */
        var previousFilter = {
            attr: undefined,
            operator: undefined,
            values: undefined
        };
        if (data.mode) {
            this.isDefaultFilterSubject.next(data.mode === 'default');
            this.isCustomFilterSubject.next(data.mode === 'custom');
            this.mode = data.mode;
        }
        if (data.previousFilter) {
            previousFilter = data.previousFilter;
            this.isCustomFilterSubject.next([ColumnValueFilterOperator.LESS_EQUAL, ColumnValueFilterOperator.MORE_EQUAL, ColumnValueFilterOperator.BETWEEN, ColumnValueFilterOperator.EQUAL].indexOf(previousFilter.operator) !== -1);
        }
        if (data.hasOwnProperty('preloadValues')) {
            this.preloadValues = data.preloadValues;
        }
        if (data.tableData && Array.isArray(data.tableData)) {
            this.getDistinctValues(data.tableData, previousFilter);
            this.initializeCustomFilterValues(previousFilter);
            this.initializeDataList(previousFilter);
        }
        if (data.mode) {
            this.mode = data.mode;
        }
    }
    /**
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.initializeFilterEvent();
    };
    Object.defineProperty(OTableFilterByColumnDataDialogComponent.prototype, "listData", {
        get: /**
         * @return {?}
         */
        function () {
            return this._listData;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._listData = arg;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?=} filter
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.initializeDataList = /**
     * @param {?=} filter
     * @return {?}
     */
    function (filter$$1) {
        if (this.preloadValues || (filter$$1 && filter$$1.operator === ColumnValueFilterOperator.IN)) {
            this.listData = this.columnData.slice();
        }
    };
    /**
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.initializeFilterEvent = /**
     * @return {?}
     */
    function () {
        if (this.filter) {
            /** @type {?} */
            var self_1 = this;
            fromEvent(this.filter.nativeElement, 'keyup')
                .pipe(debounceTime(150))
                .pipe(distinctUntilChanged())
                .subscribe(function () {
                /** @type {?} */
                var filterValue = self_1.filter.nativeElement.value;
                filterValue = Util.normalizeString(filterValue);
                if (filterValue.indexOf('*') !== -1) {
                    self_1.listData = self_1.columnData.filter(function (item) { return new RegExp('^' + Util.normalizeString(filterValue).split('*').join('.*') + '$').test(Util.normalizeString(item.value)); });
                }
                else {
                    self_1.listData = self_1.columnData.filter(function (item) { return (Util.normalizeString(item.value).indexOf(filterValue) !== -1); });
                }
            });
        }
    };
    /**
     * @param {?} filter
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.initializeCustomFilterValues = /**
     * @param {?} filter
     * @return {?}
     */
    function (filter$$1) {
        if (filter$$1.operator !== ColumnValueFilterOperator.IN) {
            if (ColumnValueFilterOperator.EQUAL === filter$$1.operator) {
                if (this.isTextType()) {
                    this.fcText.setValue(filter$$1.values);
                }
            }
            if (filter$$1.operator === ColumnValueFilterOperator.BETWEEN) {
                if (this.isDateType()) {
                    this.fcFrom.setValue(new Date(filter$$1.values[0]));
                    this.fcTo.setValue(new Date(filter$$1.values[1]));
                }
                else {
                    this.fcFrom.setValue(filter$$1.values[0]);
                    this.fcTo.setValue(filter$$1.values[1]);
                }
            }
            else {
                if (filter$$1.operator === ColumnValueFilterOperator.MORE_EQUAL) {
                    if (this.isDateType()) {
                        this.fcFrom.setValue(new Date(filter$$1.values));
                    }
                    else {
                        this.fcFrom.setValue(filter$$1.values);
                    }
                }
                if (filter$$1.operator === ColumnValueFilterOperator.LESS_EQUAL) {
                    if (this.isDateType()) {
                        this.fcTo.setValue(new Date(filter$$1.values));
                    }
                    else {
                        this.fcTo.setValue(filter$$1.values);
                    }
                }
            }
        }
    };
    Object.defineProperty(OTableFilterByColumnDataDialogComponent.prototype, "selectedValues", {
        get: /**
         * @return {?}
         */
        function () {
            return this.filterValueList ? this.filterValueList.selectedOptions.selected : [];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.areAllSelected = /**
     * @return {?}
     */
    function () {
        return this.selectedValues.length === this.columnData.length;
    };
    /**
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.isIndeterminate = /**
     * @return {?}
     */
    function () {
        return this.selectedValues.length > 0 && this.selectedValues.length !== this.columnData.length;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.onSelectAllChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.checked) {
            this.filterValueList.selectAll();
        }
        else {
            this.filterValueList.deselectAll();
        }
    };
    /**
     * @param {?} data
     * @param {?} filter
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.getDistinctValues = /**
     * @param {?} data
     * @param {?} filter
     * @return {?}
     */
    function (data, filter$$1) {
        var _this = this;
        /** @type {?} */
        var colValues = data.map(function (elem) { return elem[_this.column.attr]; });
        colValues.forEach(function (value, i) {
            if (_this.columnData.find(function (item) { return item.value === value; }) === undefined) {
                _this.columnData.push({
                    value: value,
                    selected: filter$$1.operator === ColumnValueFilterOperator.IN && (filter$$1.values || []).indexOf(value) !== -1
                });
                _this.tableData.push(data[i]);
            }
        });
    };
    /**
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.getColumnValuesFilter = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var filter$$1 = {
            attr: this.column.attr,
            operator: undefined,
            values: undefined
        };
        if (!this.isCustomFilterSubject.getValue()) {
            if (this.selectedValues.length) {
                filter$$1.operator = ColumnValueFilterOperator.IN;
                filter$$1.values = this.selectedValues.map(function (item) { return item.value; });
            }
        }
        else {
            if (this.fcText.value) {
                filter$$1.operator = ColumnValueFilterOperator.EQUAL;
                filter$$1.values = this.getTypedValue(this.fcText);
            }
            if (this.fcFrom.value && this.fcTo.value) {
                filter$$1.operator = ColumnValueFilterOperator.BETWEEN;
                /** @type {?} */
                var fromValue = this.getTypedValue(this.fcFrom);
                /** @type {?} */
                var toValue = this.getTypedValue(this.fcTo);
                filter$$1.values = fromValue <= toValue ? [fromValue, toValue] : [toValue, fromValue];
            }
            else {
                if (this.fcFrom.value) {
                    filter$$1.operator = ColumnValueFilterOperator.MORE_EQUAL;
                    filter$$1.values = this.getTypedValue(this.fcFrom);
                }
                if (this.fcTo.value) {
                    filter$$1.operator = ColumnValueFilterOperator.LESS_EQUAL;
                    filter$$1.values = this.getTypedValue(this.fcTo);
                }
            }
        }
        return filter$$1;
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.onSlideChange = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.isCustomFilterSubject.next(e.checked);
        if (!e.checked) {
            //Selection mode
            this.initializeDataList();
            /** @type {?} */
            var self_2 = this;
            setTimeout(function () {
                self_2.initializeFilterEvent();
            }, 0);
        }
    };
    /**
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.isTextType = /**
     * @return {?}
     */
    function () {
        return !this.isNumericType() && !this.isDateType();
    };
    /**
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.isNumericType = /**
     * @return {?}
     */
    function () {
        return ['integer', 'real', 'currency'].indexOf(this.column.type) !== -1;
    };
    /**
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.isDateType = /**
     * @return {?}
     */
    function () {
        return 'date' === this.column.type;
    };
    /**
     * @param {?} i
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.getRowValue = /**
     * @param {?} i
     * @return {?}
     */
    function (i) {
        return this.tableData[i];
    };
    /**
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.getFixedDimensionClass = /**
     * @return {?}
     */
    function () {
        return this.mode === 'selection' || this.mode === 'default';
    };
    /**
     * @param {?} control
     * @return {?}
     */
    OTableFilterByColumnDataDialogComponent.prototype.getTypedValue = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        /** @type {?} */
        var value = control.value;
        if (this.isNumericType()) {
            value = control.value;
        }
        if (this.isDateType()) {
            value = control.value.valueOf();
        }
        return value;
    };
    OTableFilterByColumnDataDialogComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-filter-by-column-data-dialog',
                    template: "\n    <span mat-dialog-title>{{ 'TABLE.BUTTONS.FILTER_BY_COLUMN' | oTranslate }}: {{ column.title | oTranslate }}</span>\n    <div mat-dialog-content fxLayout=\"row\" fxLayoutAlign=\"space-between stretch\" class=\"dialog-list-container\">\n      <div fxLayout=\"column\" class=\"content-wrapper\"  [class.content-wrapper-fixed-dimension]=\"getFixedDimensionClass()\">\n        <mat-slide-toggle #customFilterSlide (change)=\"onSlideChange($event)\" [checked]=\"(isCustomFilter | async)\"\n          *ngIf=\"isDefaultFilter | async\">\n          {{ 'TABLE.FILTER_BY_COLUMN.CUSTOM_FILTER' | oTranslate }}\n        </mat-slide-toggle>\n        <div fxFlex *ngIf=\"!(isCustomFilter | async);else customFilterTemplate\" fxLayout=\"column\">\n          <mat-form-field class=\"hinted\">\n            <mat-icon matPrefix svgIcon=\"ontimize:search\"></mat-icon>\n            <input matInput #filter placeholder=\"{{ 'TABLE.FILTER' | oTranslate }}\">\n            <mat-hint>{{ 'TABLE.FILTER_BY_COLUMN.HINT_STAR' | oTranslate }}</mat-hint>\n          </mat-form-field>\n          <mat-checkbox (change)=\"onSelectAllChange($event)\" [checked]=\"areAllSelected()\"\n            [indeterminate]=\"isIndeterminate()\" [disabled]=\"!listData\" class=\"select-all-checkbox\">\n            {{ 'TABLE.FILTER_BY_COLUMN.CHECK_ALL' | oTranslate }}\n          </mat-checkbox>\n          <span *ngIf=\"!listData\" class=\"column-filter-empty-list\">\n            {{ 'TABLE.FILTER_BY_COLUMN.LIST_EMPTY_FILTER' | oTranslate }}\n          </span>\n          <span *ngIf=\"listData?.length === 0\" class=\"column-filter-empty-list\">{{ 'TABLE.FILTER_BY_COLUMN.LIST_EMPTY' |\n            oTranslate }}</span>\n          <mat-selection-list *ngIf=\"preloadValues || listData\" #filterValueList fxFlex fxLayout=\"column\"\n            class=\"select-values-list\">\n            <mat-list-option *ngFor=\"let record of listData; let i = index\" checkboxPosition=\"before\"\n              [selected]=\"record.selected\" [value]=\"record.value\">\n              <ng-container *ngIf=\"!column.renderer\">\n                {{ record.value || ('TABLE.FILTER_BY_COLUMN.EMPTY_VALUE' | oTranslate) }}\n              </ng-container>\n              <ng-template *ngIf=\"column.renderer\" [ngTemplateOutlet]=\"column.renderer.templateref\"\n                [ngTemplateOutletContext]=\"{ cellvalue: record.value, rowvalue: getRowValue(i) }\"></ng-template>\n            </mat-list-option>\n          </mat-selection-list>\n        </div>\n\n      </div>\n    </div>\n\n    <mat-dialog-actions align=\"end\">\n      <button type=\"button\" mat-stroked-button class=\"mat-primary\" [mat-dialog-close]=\"false\">\n        {{ 'CANCEL' | oTranslate | uppercase }} </button>\n      <button type=\"button\" mat-stroked-button class=\"mat-primary\" [mat-dialog-close]=\"true\">\n        {{ 'ACCEPT' | oTranslate | uppercase }} </button>\n    </mat-dialog-actions>\n\n    <!-- TEMPLATE CUSTOM FILTER-->\n    <ng-template #customFilterTemplate>\n      <div *ngIf=\"isTextType()\">\n        <mat-form-field fxFlex class=\"hinted\">\n          <input matInput #filterText [formControl]=\"fcText\" placeholder=\"{{ 'TABLE.FILTER' | oTranslate }}\">\n          <mat-hint>{{ 'TABLE.FILTER_BY_COLUMN.HINT_STAR' | oTranslate }}</mat-hint>\n        </mat-form-field>\n      </div>\n      <div *ngIf=\"isNumericType()\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n        <mat-form-field fxFlex=\"45\">\n          <input matInput [formControl]=\"fcFrom\" placeholder=\"{{ 'TABLE.FILTER_BY_COLUMN.FROM' | oTranslate }}\">\n        </mat-form-field>\n        <mat-form-field fxFlex=\"45\">\n          <input matInput [formControl]=\"fcTo\" placeholder=\"{{ 'TABLE.FILTER_BY_COLUMN.TO' | oTranslate }}\">\n        </mat-form-field>\n      </div>\n      <div *ngIf=\"isDateType()\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n        <mat-form-field fxFlex=\"45\">\n          <input matInput [matDatepicker]=\"datepickerFrom\" [max]=\"fcTo.value\" [formControl]=\"fcFrom\"\n            placeholder=\"{{ 'TABLE.FILTER_BY_COLUMN.FROM' | oTranslate }}\">\n          <mat-datepicker-toggle matSuffix [for]=\"datepickerFrom\">\n            <mat-icon matDatepickerToggleIcon>today</mat-icon>\n          </mat-datepicker-toggle>\n          <mat-datepicker #datepickerFrom></mat-datepicker>\n        </mat-form-field>\n        <mat-form-field fxFlex=\"45\">\n          <input matInput [matDatepicker]=\"datepickerTo\" [min]=\"fcFrom.value\" [formControl]=\"fcTo\"\n            placeholder=\"{{ 'TABLE.FILTER_BY_COLUMN.TO' | oTranslate }}\">\n          <mat-datepicker-toggle matSuffix [for]=\"datepickerTo\">\n            <mat-icon matDatepickerToggleIcon>today</mat-icon>\n          </mat-datepicker-toggle>\n          <mat-datepicker #datepickerTo></mat-datepicker>\n        </mat-form-field>\n      </div>\n\n    </ng-template>\n  ",
                    styles: ["\n    .o-filter-by-column-dialog .mat-slide-toggle{padding-bottom:24px}.o-filter-by-column-dialog .content-wrapper{padding:24px 0 12px;margin:0}.o-filter-by-column-dialog .content-wrapper.content-wrapper-fixed-dimension{max-height:430px;min-height:430px;min-width:250px}.o-filter-by-column-dialog .content-wrapper .mat-form-field.hinted{margin-bottom:24px}.o-filter-by-column-dialog .content-wrapper .select-all-checkbox{padding-bottom:6px}.o-filter-by-column-dialog .content-wrapper .select-values-list{padding-top:0;overflow-y:auto;overflow-x:hidden;outline:none}.o-filter-by-column-dialog .content-wrapper .select-values-list .mat-list-item{height:30px}.o-filter-by-column-dialog .content-wrapper .select-values-list .mat-list-item .mat-list-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.o-filter-by-column-dialog .content-wrapper .select-values-list .mat-list-item .mat-list-text .mat-icon{font-size:24px}.o-filter-by-column-dialog .content-wrapper .column-filter-empty-list{text-align:center}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.o-filter-by-column-dialog]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OTableFilterByColumnDataDialogComponent.ctorParameters = function () { return [
        { type: material.MatDialogRef },
        { type: undefined, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] }] }
    ]; };
    OTableFilterByColumnDataDialogComponent.propDecorators = {
        filter: [{ type: core.ViewChild, args: ['filter',] }],
        filterValueList: [{ type: core.ViewChild, args: ['filterValueList',] }]
    };
    return OTableFilterByColumnDataDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var O_TABLE_DIALOGS = [
    OTableApplyConfigurationDialogComponent,
    OTableExportDialogComponent,
    OTableStoreConfigurationDialogComponent,
    OTableLoadFilterDialogComponent,
    OTableStoreFilterDialogComponent,
    OTableVisibleColumnsDialogComponent,
    OTableFilterByColumnDataDialogComponent
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_OPTION = [
    'oattr: attr',
    'enabled',
    'icon',
    'showActiveIcon : show-active-icon',
    'olabel: label',
    'active'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_OPTION = [
    'onClick'
];
var OTableOptionComponent = /** @class */ (function () {
    function OTableOptionComponent(injector, elRef, table) {
        this.injector = injector;
        this.elRef = elRef;
        this.table = table;
        this.onClick = new core.EventEmitter();
        this.enabled = true;
        this.showActiveIcon = false;
        this.active = false;
        try {
            this.cd = this.injector.get(core.ChangeDetectorRef);
        }
        catch (e) {
            // no parent form
        }
    }
    /**
     * @return {?}
     */
    OTableOptionComponent.prototype.innerOnClick = /**
     * @return {?}
     */
    function () {
        this.onClick.emit();
        this.setActive(!this.active);
    };
    /**
     * @return {?}
     */
    OTableOptionComponent.prototype.showActiveOptionIcon = /**
     * @return {?}
     */
    function () {
        return this.showActiveIcon && this.active;
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OTableOptionComponent.prototype.setActive = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        this.active = val;
        this.cd.detectChanges();
    };
    OTableOptionComponent.DEFAULT_INPUTS_O_TABLE_OPTION = DEFAULT_INPUTS_O_TABLE_OPTION;
    OTableOptionComponent.DEFAULT_OUTPUTS_O_TABLE_OPTION = DEFAULT_OUTPUTS_O_TABLE_OPTION;
    OTableOptionComponent.O_TABLE_OPTION_ACTIVE_CLASS = 'o-table-option-active';
    OTableOptionComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-option',
                    template: "\n    <button [disabled]=\"!enabled\" type=\"button\" (click)=\"innerOnClick()\" mat-menu-item fxLayout=\"row\" fxLayoutAlign=\"start center\">\n      <mat-icon *ngIf=\"showActiveOptionIcon()\" svgIcon=\"ontimize:done\" fxLayout></mat-icon>\n      {{ olabel | oTranslate }}\n      <mat-icon *ngIf=\"icon\"> {{ icon }}</mat-icon>\n    </button>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_TABLE_OPTION,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_OPTION,
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.o-table-option]': 'true',
                    }
                },] },
    ];
    /** @nocollapse */
    OTableOptionComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: core.ElementRef },
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableOptionComponent.prototype, "enabled", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableOptionComponent.prototype, "showActiveIcon", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableOptionComponent.prototype, "active", void 0);
    return OTableOptionComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_MENU$$1 = [
    'selectAllCheckbox: select-all-checkbox',
    'exportButton: export-button',
    'columnsVisibilityButton: columns-visibility-button'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_MENU$$1 = [];
var OTableMenuComponent$$1 = /** @class */ (function () {
    function OTableMenuComponent$$1(injector, dialog, cd, table) {
        this.injector = injector;
        this.dialog = dialog;
        this.cd = cd;
        this.table = table;
        /* Inputs */
        this.selectAllCheckbox = false;
        this.exportButton = true;
        this.columnsVisibilityButton = true;
        this.mutationObservers = [];
        this.dialogService = this.injector.get(DialogService);
        this.translateService = this.injector.get(OTranslateService$$1);
        this.snackBarService = this.injector.get(SnackBarService);
    }
    /**
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.permissions = this.table.getMenuPermissions();
    };
    /**
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.columnFilterOption) {
            this.columnFilterOption.setActive(this.table.showFilterByColumnIcon);
            this.cd.detectChanges();
        }
        if (!this.permissions.items || this.permissions.items.length === 0) {
            return;
        }
        if (this.selectAllCheckboxOption && !this.enabledSelectAllCheckbox) {
            this.disableOTableOptionComponent(this.selectAllCheckboxOption);
        }
        if (this.exportButtonOption && !this.enabledExportButton) {
            this.disableOTableOptionComponent(this.exportButtonOption);
        }
        if (this.columnsVisibilityButtonOption && !this.enabledColumnsVisibilityButton) {
            this.disableOTableOptionComponent(this.columnsVisibilityButtonOption);
        }
        if (this.filterMenuButton && !this.enabledFilterMenu) {
            this.disableButton(this.filterMenuButton);
        }
        if (this.configurationMenuButton && !this.enabledConfigurationMenu) {
            this.disableButton(this.configurationMenuButton);
        }
        this.cd.detectChanges();
    };
    /**
     * @param {?} comp
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.disableOTableOptionComponent = /**
     * @param {?} comp
     * @return {?}
     */
    function (comp) {
        comp.enabled = false;
        /** @type {?} */
        var buttonEL = comp.elRef.nativeElement.querySelector('button');
        /** @type {?} */
        var obs = PermissionsUtils.registerDisabledChangesInDom(buttonEL);
        this.mutationObservers.push(obs);
    };
    /**
     * @param {?} buttonEL
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.disableButton = /**
     * @param {?} buttonEL
     * @return {?}
     */
    function (buttonEL) {
        buttonEL.nativeElement.disabled = true;
        /** @type {?} */
        var obs = PermissionsUtils.registerDisabledChangesInDom(buttonEL.nativeElement);
        this.mutationObservers.push(obs);
    };
    /**
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.mutationObservers) {
            this.mutationObservers.forEach(function (m) {
                m.disconnect();
            });
        }
    };
    /**
     * @param {?} oTableOptions
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.registerOptions = /**
     * @param {?} oTableOptions
     * @return {?}
     */
    function (oTableOptions) {
        /** @type {?} */
        var items = this.permissions.items || [];
        /** @type {?} */
        var fixedOptions = ['select-all-checkbox', 'export', 'show-hide-columns', 'filter', 'configuration'];
        /** @type {?} */
        var userItems = items.filter(function (perm) { return fixedOptions.indexOf(perm.attr) === -1; });
        /** @type {?} */
        var self = this;
        userItems.forEach(function (perm) {
            /** @type {?} */
            var option = oTableOptions.find(function (oTableOption) { return oTableOption.oattr === perm.attr; });
            self.setPermissionsToOTableOption(perm, option);
        });
    };
    /**
     * @param {?} perm
     * @param {?} option
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.setPermissionsToOTableOption = /**
     * @param {?} perm
     * @param {?} option
     * @return {?}
     */
    function (perm, option) {
        if (perm.visible === false && option) {
            option.elRef.nativeElement.remove();
        }
        else if (perm.enabled === false && option) {
            option.enabled = false;
            /** @type {?} */
            var buttonEL = option.elRef.nativeElement.querySelector('button');
            /** @type {?} */
            var obs = PermissionsUtils.registerDisabledChangesInDom(buttonEL);
            this.mutationObservers.push(obs);
        }
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.getPermissionByAttr = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        /** @type {?} */
        var items = this.permissions.items || [];
        return items.find(function (perm) { return perm.attr === attr; });
    };
    Object.defineProperty(OTableMenuComponent$$1.prototype, "isSelectAllOptionActive", {
        get: /**
         * @return {?}
         */
        function () {
            return this.table.oTableOptions.selectColumn.visible;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableMenuComponent$$1.prototype, "showColumnsFilterOption", {
        get: /**
         * @return {?}
         */
        function () {
            return this.table.oTableColumnsFilterComponent !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableMenuComponent$$1.prototype, "enabledColumnsFilterOption", {
        get: /**
         * @return {?}
         */
        function () {
            return this.table.oTableColumnsFilterComponent !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableMenuComponent$$1.prototype, "showSelectAllCheckbox", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.selectAllCheckbox) {
                return false;
            }
            /** @type {?} */
            var perm = this.getPermissionByAttr('select-all-checkbox');
            return !(perm && perm.visible === false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableMenuComponent$$1.prototype, "rowHeightObservable", {
        get: /**
         * @return {?}
         */
        function () {
            return this.table.rowHeightObservable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableMenuComponent$$1.prototype, "enabledSelectAllCheckbox", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var perm = this.getPermissionByAttr('select-all-checkbox');
            return !(perm && perm.enabled === false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableMenuComponent$$1.prototype, "showExportButton", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.exportButton) {
                return false;
            }
            /** @type {?} */
            var perm = this.getPermissionByAttr('export');
            return !(perm && perm.visible === false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableMenuComponent$$1.prototype, "enabledExportButton", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var perm = this.getPermissionByAttr('export');
            return !(perm && perm.enabled === false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableMenuComponent$$1.prototype, "showColumnsVisibilityButton", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.columnsVisibilityButton) {
                return false;
            }
            /** @type {?} */
            var perm = this.getPermissionByAttr('show-hide-columns');
            return !(perm && perm.visible === false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableMenuComponent$$1.prototype, "enabledColumnsVisibilityButton", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var perm = this.getPermissionByAttr('show-hide-columns');
            return !(perm && perm.enabled === false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableMenuComponent$$1.prototype, "showFilterMenu", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var perm = this.getPermissionByAttr('filter');
            return !(perm && perm.visible === false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableMenuComponent$$1.prototype, "enabledFilterMenu", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var perm = this.getPermissionByAttr('filter');
            return !(perm && perm.enabled === false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableMenuComponent$$1.prototype, "showConfigurationMenu", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var perm = this.getPermissionByAttr('configuration');
            return !(perm && perm.visible === false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableMenuComponent$$1.prototype, "enabledConfigurationMenu", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var perm = this.getPermissionByAttr('configuration');
            return !(perm && perm.enabled === false);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?=} event
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.onShowsSelects = /**
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var tableOptions = this.table.oTableOptions;
        tableOptions.selectColumn.visible = !tableOptions.selectColumn.visible;
        this.table.initializeCheckboxColumn();
    };
    /**
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.onExportButtonClicked = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var tableOptions = this.table.oTableOptions;
        /** @type {?} */
        var exportCnfg = new OTableExportConfiguration();
        // Table data
        exportCnfg.data = this.table.exportMode === Codes.EXPORT_MODE_VISIBLE ? this.table.getRenderedValue() : this.table.getAllRenderedValues();
        /** @type {?} */
        var colsNotIncluded = tableOptions.columns.filter(function (c) { return void 0 !== c.renderer && c.renderer instanceof OTableCellRendererImageComponent; }).map(function (c) { return c.attr; });
        colsNotIncluded.push(OTableComponent.NAME_COLUMN_SELECT);
        colsNotIncluded.forEach(function (attr) { return exportCnfg.data.forEach(function (row) { return delete row[attr]; }); });
        // Table columns
        exportCnfg.columns = tableOptions.visibleColumns.filter(function (c) { return colsNotIncluded.indexOf(c) === -1; });
        /** @type {?} */
        var tableColumnNames = {};
        tableOptions.visibleColumns.filter(function (c) { return colsNotIncluded.indexOf(c) === -1; }).forEach(function (c) { return tableColumnNames[c] = _this.translateService.get(c); });
        exportCnfg.columnNames = tableColumnNames;
        // Table column sqlTypes
        exportCnfg.sqlTypes = this.table.getSqlTypes();
        // Table service, needed for configuring ontimize export service with table service configuration
        exportCnfg.service = this.table.service;
        /** @type {?} */
        var dialogRef = this.dialog.open(OTableExportDialogComponent, {
            data: exportCnfg,
            disableClose: true,
            panelClass: ['o-dialog-class', 'o-table-dialog']
        });
        dialogRef.afterClosed().subscribe(function (result) { return result ? _this.snackBarService.open('MESSAGES.SUCCESS_EXPORT_TABLE_DATA', { icon: 'check_circle' }) : null; });
    };
    /**
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.onChangeColumnsVisibilityClicked = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var dialogRef = this.dialog.open(OTableVisibleColumnsDialogComponent, {
            data: {
                originalVisibleColumns: Util.parseArray(this.table.originalVisibleColumns, true),
                columnsData: this.table.oTableOptions.columns,
                rowHeight: this.table.rowHeight
            },
            disableClose: true,
            panelClass: ['o-dialog-class', 'o-table-dialog']
        });
        dialogRef.afterClosed().subscribe(function (result) {
            if (result) {
                _this.table.visibleColArray = dialogRef.componentInstance.getVisibleColumns();
                /** @type {?} */
                var columnsOrder_1 = dialogRef.componentInstance.getColumnsOrder();
                _this.table.oTableOptions.columns.sort(function (a, b) { return columnsOrder_1.indexOf(a.attr) - columnsOrder_1.indexOf(b.attr); });
                _this.table.refreshColumnsWidth();
            }
        });
    };
    /**
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.onFilterByColumnClicked = /**
     * @return {?}
     */
    function () {
        if (this.table.showFilterByColumnIcon && this.table.dataSource.isColumnValueFilterActive()) {
            /** @type {?} */
            var self_1 = this;
            this.dialogService.confirm('CONFIRM', 'MESSAGES.CONFIRM_DISCARD_FILTER_BY_COLUMN').then(function (res) {
                if (res) {
                    self_1.table.dataSource.clearColumnFilters();
                }
                self_1.table.showFilterByColumnIcon = !res;
                self_1.table.cd.detectChanges();
            });
        }
        else {
            this.table.showFilterByColumnIcon = !this.table.showFilterByColumnIcon;
            this.table.cd.detectChanges();
        }
    };
    /**
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.onStoreFilterClicked = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var dialogRef = this.dialog.open(OTableStoreFilterDialogComponent, {
            data: this.table.oTableStorage.getStoredFilters().map(function (filter$$1) { return filter$$1.name; }),
            width: 'calc((75em - 100%) * 1000)',
            maxWidth: '65vw',
            minWidth: '30vw',
            disableClose: true,
            panelClass: ['o-dialog-class', 'o-table-dialog']
        });
        dialogRef.afterClosed().subscribe(function (result) {
            if (result) {
                _this.table.oTableStorage.storeFilter(dialogRef.componentInstance.getFilterAttributes());
            }
        });
    };
    /**
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.onLoadFilterClicked = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var dialogRef = this.dialog.open(OTableLoadFilterDialogComponent, {
            data: this.table.oTableStorage.getStoredFilters(),
            width: 'calc((75em - 100%) * 1000)',
            maxWidth: '65vw',
            minWidth: '30vw',
            disableClose: true,
            panelClass: ['o-dialog-class', 'o-table-dialog']
        });
        dialogRef.componentInstance.onDelete.subscribe(function (filterName) { return _this.table.oTableStorage.deleteStoredFilter(filterName); });
        dialogRef.afterClosed().subscribe(function (result) {
            if (result) {
                /** @type {?} */
                var selectedFilterName = dialogRef.componentInstance.getSelectedFilterName();
                if (selectedFilterName) {
                    /** @type {?} */
                    var storedFilter = _this.table.oTableStorage.getStoredFilterConf(selectedFilterName);
                    if (storedFilter) {
                        _this.table.setFiltersConfiguration(storedFilter);
                        _this.table.reloadPaginatedDataFromStart();
                    }
                }
            }
        });
    };
    /**
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.onClearFilterClicked = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.dialogService.confirm('CONFIRM', 'TABLE.DIALOG.CONFIRM_CLEAR_FILTER').then(function (result) {
            if (result) {
                _this.table.clearFilters();
                _this.table.reloadPaginatedDataFromStart();
            }
        });
    };
    /**
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.onStoreConfigurationClicked = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var dialogRef = this.dialog.open(OTableStoreConfigurationDialogComponent, {
            width: 'calc((75em - 100%) * 1000)',
            maxWidth: '65vw',
            minWidth: '30vw',
            disableClose: true,
            panelClass: ['o-dialog-class', 'o-table-dialog']
        });
        /** @type {?} */
        var self = this;
        dialogRef.afterClosed().subscribe(function (result) {
            if (result) {
                /** @type {?} */
                var configurationData = dialogRef.componentInstance.getConfigurationAttributes();
                /** @type {?} */
                var tableProperties = dialogRef.componentInstance.getSelectedTableProperties();
                self.table.oTableStorage.storeConfiguration(configurationData, tableProperties);
            }
        });
    };
    /**
     * @return {?}
     */
    OTableMenuComponent$$1.prototype.onApplyConfigurationClicked = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var dialogRef = this.dialog.open(OTableApplyConfigurationDialogComponent, {
            data: this.table.oTableStorage.getStoredConfigurations(),
            width: 'calc((75em - 100%) * 1000)',
            maxWidth: '65vw',
            minWidth: '30vw',
            disableClose: true,
            panelClass: ['o-dialog-class', 'o-table-dialog']
        });
        /** @type {?} */
        var self = this;
        dialogRef.componentInstance.onDelete.subscribe(function (configurationName) { return _this.table.oTableStorage.deleteStoredConfiguration(configurationName); });
        dialogRef.afterClosed().subscribe(function (result) {
            if (result && dialogRef.componentInstance.isDefaultConfigurationSelected()) {
                self.table.applyDefaultConfiguration();
            }
            else if (result) {
                /** @type {?} */
                var selectedConfigurationName = dialogRef.componentInstance.getSelectedConfigurationName();
                if (selectedConfigurationName) {
                    self.table.applyConfiguration(selectedConfigurationName);
                }
            }
        });
    };
    OTableMenuComponent$$1.DEFAULT_INPUTS_O_TABLE_MENU = DEFAULT_INPUTS_O_TABLE_MENU$$1;
    OTableMenuComponent$$1.DEFAULT_OUTPUTS_O_TABLE_MENU = DEFAULT_OUTPUTS_O_TABLE_MENU$$1;
    OTableMenuComponent$$1.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-menu',
                    template: "\n    <mat-menu #menu=\"matMenu\" x-position=\"before\" [class]=\"(rowHeightObservable | async) +' o-table-menu'\">\n      <o-table-option #selectAllCheckboxOption *ngIf=\"showSelectAllCheckbox\" [active]=\"isSelectAllOptionActive\"\n        (onClick)=\"onShowsSelects($event)\" label=\"TABLE.BUTTONS.SELECT\" show-active-icon=\"true\"></o-table-option>\n      <o-table-option #exportButtonOption *ngIf=\"showExportButton\" (onClick)=\"onExportButtonClicked()\"\n        label=\"TABLE.BUTTONS.EXPORT\"></o-table-option>\n      <o-table-option #columnsVisibilityButtonOption *ngIf=\"showColumnsVisibilityButton\"\n        (onClick)=\"onChangeColumnsVisibilityClicked()\" label=\"TABLE.BUTTONS.COLVIS\"></o-table-option>\n\n      <button type=\"button\" #filterMenuButton *ngIf=\"showFilterMenu\" mat-menu-item [matMenuTriggerFor]=\"filterMenu\">{{\n        'TABLE.BUTTONS.FILTER' | oTranslate }}</button>\n      <button type=\"button\" #configurationMenuButton *ngIf=\"showConfigurationMenu\" mat-menu-item\n        [matMenuTriggerFor]=\"configurationMenu\">{{\n        'TABLE.BUTTONS.CONFIGURATION' | oTranslate }}</button>\n      <ng-content></ng-content>\n    </mat-menu>\n\n    <mat-menu #filterMenu=\"matMenu\" [class]=\"(rowHeightObservable| async) +' o-table-menu'\">\n      <o-table-option #columnFilterOption *ngIf=\"showColumnsFilterOption\" show-active-icon=\"true\"\n        (onClick)=\"onFilterByColumnClicked()\" label=\"TABLE.BUTTONS.FILTER_BY_COLUMN\">\n      </o-table-option>\n      <button type=\"button\" mat-menu-item\n        (click)=\"onStoreFilterClicked()\">{{ 'TABLE.BUTTONS.FILTER_SAVE' | oTranslate }}</button>\n      <button type=\"button\" mat-menu-item\n        (click)=\"onLoadFilterClicked()\">{{ 'TABLE.BUTTONS.FILTER_LOAD' | oTranslate }}</button>\n      <button type=\"button\" mat-menu-item\n        (click)=\"onClearFilterClicked()\">{{ 'TABLE.BUTTONS.FILTER_CLEAR' | oTranslate }}</button>\n    </mat-menu>\n\n    <mat-menu #configurationMenu=\"matMenu\" [class]=\"(rowHeightObservable | async) +' o-table-menu'\">\n      <button type=\"button\" mat-menu-item (click)=\"onStoreConfigurationClicked()\">{{ 'TABLE.BUTTONS.SAVE_CONFIGURATION' |\n        oTranslate }}</button>\n      <button type=\"button\" mat-menu-item (click)=\"onApplyConfigurationClicked()\">{{ 'TABLE.BUTTONS.APPLY_CONFIGURATION' |\n        oTranslate }}</button>\n    </mat-menu>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_TABLE_MENU$$1,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_MENU$$1,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-table-menu]': 'true'
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    OTableMenuComponent$$1.ctorParameters = function () { return [
        { type: core.Injector },
        { type: material.MatDialog },
        { type: core.ChangeDetectorRef },
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] }
    ]; };
    OTableMenuComponent$$1.propDecorators = {
        matMenu: [{ type: core.ViewChild, args: ['menu',] }],
        selectAllCheckboxOption: [{ type: core.ViewChild, args: ['selectAllCheckboxOption',] }],
        exportButtonOption: [{ type: core.ViewChild, args: ['exportButtonOption',] }],
        columnsVisibilityButtonOption: [{ type: core.ViewChild, args: ['columnsVisibilityButtonOption',] }],
        filterMenuButton: [{ type: core.ViewChild, args: ['filterMenuButton', { read: core.ElementRef },] }],
        configurationMenuButton: [{ type: core.ViewChild, args: ['configurationMenuButton', { read: core.ElementRef },] }],
        filterMenu: [{ type: core.ViewChild, args: ['filterMenu',] }],
        configurationMenu: [{ type: core.ViewChild, args: ['configurationMenu',] }],
        columnFilterOption: [{ type: core.ViewChild, args: ['columnFilterOption',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableMenuComponent$$1.prototype, "selectAllCheckbox", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableMenuComponent$$1.prototype, "exportButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableMenuComponent$$1.prototype, "columnsVisibilityButton", void 0);
    return OTableMenuComponent$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_INSERTABLE_ROW = [
    'columns',
    'requiredColumns : required-columns',
    'position',
    'showPlaceHolder: show-placeholder',
    'includeParentKeys: include-parent-keys'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_INSERTABLE_ROW = [
    'onPostInsertRecord'
];
var OTableInsertableRowComponent = /** @class */ (function () {
    function OTableInsertableRowComponent(injector, table, resolver) {
        this.injector = injector;
        this.table = table;
        this.resolver = resolver;
        this.columnsArray = [];
        this.requiredColumnsArray = [];
        this.onPostInsertRecord = new core.EventEmitter();
        this.columnEditors = {};
        this.position = OTableInsertableRowComponent.DEFAULT_ROW_POSITION;
        this.showPlaceHolder = false;
        this.includeParentKeys = true;
        this.enabled = true;
        this.rowData = {};
        this.controls = {};
        this.translateService = this.injector.get(OTranslateService$$1);
        this.snackBarService = this.injector.get(SnackBarService);
    }
    /**
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.columnsArray = Util.parseArray(this.columns, true);
        if (this.columnsArray.length === 0) {
            this.columnsArray = this.table.oTableOptions.visibleColumns;
        }
        this.requiredColumnsArray = Util.parseArray(this.requiredColumns, true);
        if (OTableInsertableRowComponent.AVAILABLE_ROW_POSITIONS.indexOf((this.position || '').toLowerCase()) === -1) {
            this.position = OTableInsertableRowComponent.DEFAULT_ROW_POSITION;
        }
        this.table.setOTableInsertableRow(this);
    };
    /**
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.isFirstRow = /**
     * @return {?}
     */
    function () {
        return this.position === 'first';
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.isColumnInsertable = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return (this.columnsArray.indexOf(column.attr) !== -1);
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.isColumnRequired = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return (this.requiredColumnsArray.indexOf(column.attr) !== -1);
    };
    /**
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.initializeEditors = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var self = this;
        this.table.oTableOptions.columns.forEach(function (col, i, array) {
            if (self.isColumnInsertable(col)) {
                /** @type {?} */
                var columnEditorType = col.editor ? col.editor.type : col.type;
                if (col.definition) {
                    /** @type {?} */
                    var editor = col.definition.buildCellEditor(columnEditorType, _this.resolver, col.definition.container, col.definition);
                    _this.columnEditors[col.attr] = editor;
                    /** @type {?} */
                    var disabledCol = !_this.enabled;
                    if (!disabledCol) {
                        /** @type {?} */
                        var columnPermissions = _this.table.getOColumnPermissions(col.attr);
                        disabledCol = columnPermissions.enabled === false;
                    }
                    editor.enabled = !disabledCol;
                    editor.showPlaceHolder = _this.showPlaceHolder || editor.showPlaceHolder;
                    editor.table = self.table;
                    editor.tableColumn = col.editor ? col.editor.tableColumn : col.definition;
                    editor.orequired = _this.isColumnRequired(col);
                    editor.formControl = _this.getControl(col, disabledCol);
                    editor.controlArgs = { silent: true };
                    editor.rowData = self.rowData;
                    editor.startEdition(self.rowData);
                    editor.formControl.markAsUntouched();
                    col.editor = editor;
                }
            }
            array[i] = col;
        });
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.useCellEditor = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return this.isColumnInsertable(column) && Util.isDefined(this.columnEditors[column.attr]);
    };
    /**
     * @param {?} column
     * @param {?=} disabled
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.getControl = /**
     * @param {?} column
     * @param {?=} disabled
     * @return {?}
     */
    function (column, disabled) {
        if (disabled === void 0) { disabled = false; }
        if (!this.controls[column.attr]) {
            /** @type {?} */
            var validators = this.resolveValidators(column);
            /** @type {?} */
            var cfg = {
                value: undefined,
                disabled: disabled
            };
            this.controls[column.attr] = new forms.FormControl(cfg, validators);
        }
        return this.controls[column.attr];
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.resolveValidators = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var validators = [];
        if (this.isColumnRequired(column)) {
            validators.push(forms.Validators.required);
        }
        return validators;
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.getPlaceholder = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var showPlaceHolder = this.showPlaceHolder;
        /** @type {?} */
        var cellEditor = this.columnEditors[column.attr];
        if (cellEditor) {
            showPlaceHolder = cellEditor.showPlaceHolder;
        }
        else if (column.definition) {
            showPlaceHolder = showPlaceHolder || column.definition.showPlaceHolder;
        }
        return showPlaceHolder ? this.translateService.get(column.title) : undefined;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.handleKeyboardEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.keyCode !== 13) {
            // not intro
            return;
        }
        this.trWrapper = event.currentTarget;
        event.preventDefault();
        event.stopPropagation();
        this.insertRecord();
    };
    /**
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.insertRecord = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        if (!this.validateFields()) {
            // this.table.showDialogError('TABLE.ROW_VALIDATION_ERROR');
            return;
        }
        /** @type {?} */
        var values = this.getAttributesValuesToInsert();
        /** @type {?} */
        var insertObservable = this.table.insertRecord(values);
        if (insertObservable) {
            insertObservable.subscribe(function (res) {
                self.onInsertSuccess(res);
            }, function (error) {
                self.table.showDialogError(error, 'MESSAGES.ERROR_INSERT');
            });
        }
    };
    /**
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.validateFields = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var valid = true;
        // columns with no editor defined
        Object.keys(this.controls).forEach(function (controlKey) {
            /** @type {?} */
            var control = _this.controls[controlKey];
            control.markAsTouched();
            valid = valid && control.valid;
        });
        return valid;
    };
    /**
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.getAttributesValuesToInsert = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var attrValues = {};
        if (this.includeParentKeys) {
            attrValues = this.table.getParentKeysValues();
        }
        Object.keys(this.controls).forEach(function (controlKey) {
            attrValues[controlKey] = _this.controls[controlKey].value;
        });
        return attrValues;
    };
    /**
     * @param {?} res
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.onInsertSuccess = /**
     * @param {?} res
     * @return {?}
     */
    function (res) {
        ObservableWrapper.callEmit(this.onPostInsertRecord, res);
        this.snackBarService.open('MESSAGES.INSERTED', { icon: 'check_circle' });
        this.cleanFields();
        if (this.table.daoTable.usingStaticData) {
            this.table.setDataArray(res);
        }
        else {
            this.table.reloadData();
        }
    };
    /**
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.cleanFields = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var controlKeys = Object.keys(this.controls);
        controlKeys.forEach(function (controlKey) {
            _this.controls[controlKey].setValue(void 0);
        });
        /** @type {?} */
        var firstInputEl = (/** @type {?} */ (this.trWrapper)).querySelector('input');
        if (firstInputEl) {
            setTimeout(function () {
                firstInputEl.focus();
            });
        }
    };
    /**
     * @param {?} column
     * @param {?} error
     * @return {?}
     */
    OTableInsertableRowComponent.prototype.columnHasError = /**
     * @param {?} column
     * @param {?} error
     * @return {?}
     */
    function (column, error) {
        /** @type {?} */
        var control = this.controls[column.attr];
        return control && control.touched && control.hasError(error);
    };
    OTableInsertableRowComponent.DEFAULT_INPUTS_O_TABLE_INSERTABLE_ROW = DEFAULT_INPUTS_O_TABLE_INSERTABLE_ROW;
    OTableInsertableRowComponent.DEFAULT_OUTPUTS_O_TABLE_INSERTABLE_ROW = DEFAULT_OUTPUTS_O_TABLE_INSERTABLE_ROW;
    OTableInsertableRowComponent.AVAILABLE_ROW_POSITIONS = ['first', 'last'];
    OTableInsertableRowComponent.DEFAULT_ROW_POSITION = 'last';
    OTableInsertableRowComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-insertable-row',
                    template: ' ',
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_TABLE_INSERTABLE_ROW,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_INSERTABLE_ROW
                },] },
    ];
    /** @nocollapse */
    OTableInsertableRowComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] },
        { type: core.ComponentFactoryResolver }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableInsertableRowComponent.prototype, "showPlaceHolder", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableInsertableRowComponent.prototype, "includeParentKeys", void 0);
    return OTableInsertableRowComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE_QUICKFILTER = [];
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE_QUICKFILTER = [
    'onChange'
];
var OTableQuickfilterComponent = /** @class */ (function () {
    function OTableQuickfilterComponent(injector, elRef, table) {
        this.injector = injector;
        this.elRef = elRef;
        this.table = table;
        this.onChange = new core.EventEmitter();
        this.formControl = new forms.FormControl();
    }
    /**
     * @return {?}
     */
    OTableQuickfilterComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.table.registerQuickFilter(this);
        // workaround because 'x-position="before"' was not working in the template
        this.matMenu.xPosition = 'before';
    };
    /**
     * @return {?}
     */
    OTableQuickfilterComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.initializeEventFilter();
        try {
            this.oInputsOptions = this.injector.get(O_INPUTS_OPTIONS);
        }
        catch (e) {
            this.oInputsOptions = {};
        }
        Util.parseOInputsOptions(this.elRef, this.oInputsOptions);
    };
    /**
     * @return {?}
     */
    OTableQuickfilterComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.quickFilterObservable) {
            this.quickFilterObservable.unsubscribe();
        }
    };
    Object.defineProperty(OTableQuickfilterComponent.prototype, "oTableOptions", {
        get: /**
         * @return {?}
         */
        function () {
            return this.table.oTableOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableQuickfilterComponent.prototype, "quickFilterColumns", {
        get: /**
         * @return {?}
         */
        function () {
            return this.table.oTableOptions.columns.filter(function (oCol) {
                // CHECK: Why columns with renderers are not filtered?
                // return oCol.searchable && oCol.visible && !Util.isDefined(oCol.renderer);
                return oCol.searchable && oCol.visible;
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableQuickfilterComponent.prototype, "filterExpression", {
        get: /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var result = this.getUserFilter();
            if (!Util.isDefined(result) && Util.isDefined(this.value) && this.value.length > 0) {
                /** @type {?} */
                var expressions_1 = [];
                // const queryCols: string[] = [];
                this.oTableOptions.columns.forEach(function (oCol) {
                    // CHECK: Why columns with renderers are not filtered?
                    // if (oCol.searching && oCol.visible && !oCol.renderer) {
                    if (oCol.searching && oCol.visible && _this.isFilterableColumn(oCol)) {
                        if (oCol.renderer instanceof OTableCellRendererServiceComponent) { // Filter column with service renderer
                            /** @type {?} */
                            var cacheValue = Object.keys(oCol.renderer.responseMap).find(function (key) { return Util.normalizeString(oCol.renderer['responseMap'][key]).indexOf(Util.normalizeString(_this.value)) !== -1; });
                            if (cacheValue) {
                                expressions_1.push(FilterExpressionUtils.buildExpressionEquals(oCol.attr, SQLTypes.parseUsingSQLType(cacheValue, SQLTypes.getSQLTypeKey(oCol.sqlType))));
                            }
                        }
                        else if (SQLTypes.isNumericSQLType(oCol.sqlType)) { // Filter numeric column
                            /** @type {?} */
                            var numValue = SQLTypes.parseUsingSQLType(_this.value, SQLTypes.getSQLTypeKey(oCol.sqlType));
                            if (numValue) {
                                expressions_1.push(FilterExpressionUtils.buildExpressionEquals(oCol.attr, numValue));
                            }
                        }
                        else { // Default
                            // Default
                            expressions_1.push(FilterExpressionUtils.buildExpressionLike(oCol.attr, _this.value));
                        }
                        // queryCols.push(oCol.attr);
                    }
                });
                if (expressions_1.length > 0) {
                    result = expressions_1.reduce(function (a, b) { return FilterExpressionUtils.buildComplexExpression(a, b, FilterExpressionUtils.OP_OR); });
                }
                // result = FilterExpressionUtils.buildArrayExpressionLike(queryCols, this.value);
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableQuickfilterComponent.prototype.getUserFilter = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result;
        if (this.table.quickFilterCallback instanceof Function) {
            /** @type {?} */
            var userFilter = this.table.quickFilterCallback(this.value);
            if (Util.isDefined(userFilter) && FilterExpressionUtils.instanceofExpression(userFilter)) {
                result = (/** @type {?} */ (userFilter));
            }
            else if (Util.isDefined(userFilter)) {
                result = FilterExpressionUtils.buildExpressionFromObject(userFilter);
            }
        }
        return result;
    };
    /**
     * @return {?}
     */
    OTableQuickfilterComponent.prototype.initializeEventFilter = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.filter && !this.quickFilterObservable) {
            this.quickFilterObservable = fromEvent(this.filter.nativeElement, 'keyup')
                .pipe(debounceTime(150))
                .pipe(distinctUntilChanged())
                .subscribe(function () {
                /** @type {?} */
                var filterVal = _this.filter.nativeElement.value;
                if (!_this.table.dataSource || _this.value === filterVal) {
                    return;
                }
                _this.setValue(filterVal);
                _this.onChange.emit(_this.value);
            });
            /** @type {?} */
            var filterValue = this.value || this.filter.nativeElement.value;
            //this.filter.nativeElement.value = filterValue;
            this.formControl.setValue(filterValue);
            if (this.table.dataSource && filterValue && filterValue.length) {
                this.table.dataSource.quickFilter = filterValue;
            }
        }
    };
    /**
     * @param {?} value
     * @param {?=} trigger
     * @return {?}
     */
    OTableQuickfilterComponent.prototype.setValue = /**
     * @param {?} value
     * @param {?=} trigger
     * @return {?}
     */
    function (value, trigger$$1) {
        if (trigger$$1 === void 0) { trigger$$1 = true; }
        this.value = value;
        if (trigger$$1 && this.table && this.table.dataSource) {
            this.table.dataSource.quickFilter = this.value;
        }
    };
    /**
     * @return {?}
     */
    OTableQuickfilterComponent.prototype.onMenuClosed = /**
     * @return {?}
     */
    function () {
        this.setValue(this.value);
        this.onChange.emit(this.value);
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableQuickfilterComponent.prototype.isChecked = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return column.searching;
    };
    /**
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    OTableQuickfilterComponent.prototype.onCheckboxChange = /**
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    function (column, event) {
        column.searching = event.checked;
    };
    /**
     * @return {?}
     */
    OTableQuickfilterComponent.prototype.showCaseSensitiveCheckbox = /**
     * @return {?}
     */
    function () {
        return this.table.showCaseSensitiveCheckbox();
    };
    /**
     * @return {?}
     */
    OTableQuickfilterComponent.prototype.areAllColumnsChecked = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = true;
        this.quickFilterColumns.forEach(function (col) {
            result = result && col.searching;
        });
        return result;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableQuickfilterComponent.prototype.onSelectAllChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.quickFilterColumns.forEach(function (col) {
            col.searching = event.checked;
        });
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableQuickfilterComponent.prototype.isFilterableColumn = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return !column.renderer || (column.type === 'string' ||
            column.type === 'translate' ||
            column.type === 'integer' ||
            column.type === 'real' ||
            column.type === 'percentage' ||
            column.type === 'currency' ||
            column.type === 'service');
    };
    OTableQuickfilterComponent.DEFAULT_INPUTS_O_TABLE_QUICKFILTER = DEFAULT_INPUTS_O_TABLE_QUICKFILTER;
    OTableQuickfilterComponent.DEFAULT_OUTPUTS_O_TABLE_QUICKFILTER = DEFAULT_OUTPUTS_O_TABLE_QUICKFILTER;
    OTableQuickfilterComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-quickfilter',
                    template: "\n    <div class=\"quickFilter\" fxLayout=\"row\">\n      <mat-form-field floatLabel=\"never\">\n        <input matInput #filter placeholder=\"{{ 'TABLE.FILTER' | oTranslate}}\" [formControl]=\"formControl\" (click)=\"$event.stopPropagation()\">\n        <span class=\"icon-btn search-icon\" matPrefix fxFlexLayout=\"flex-end\" (menuClosed)=\"onMenuClosed()\"\n          [matMenuTriggerFor]=\"menu\" (click)=\"$event.stopPropagation()\">\n          <mat-icon svgIcon=\"ontimize:search\"></mat-icon>\n        </span>\n        <mat-menu #menu=\"matMenu\" class=\"o-table-quickfilter-menu\">\n          <div fxLayout=\"column\" class=\"checkbox-container\">\n\n            <mat-checkbox (click)=\"$event.stopPropagation()\" [checked]=\"areAllColumnsChecked()\"\n              (change)=\"onSelectAllChange($event)\">\n              {{ 'SELECT_ALL' | oTranslate}}\n            </mat-checkbox>\n            <mat-divider></mat-divider>\n\n            <ng-container *ngFor=\"let column of quickFilterColumns\">\n              <mat-checkbox (click)=\"$event.stopPropagation()\"  [checked]=\"isChecked(column)\" (change)=\"onCheckboxChange(column, $event)\">\n                {{ column.title | oTranslate }}\n              </mat-checkbox>\n            </ng-container>\n\n            <ng-container *ngIf=\"showCaseSensitiveCheckbox()\">\n              <mat-divider></mat-divider>\n              <mat-checkbox (click)=\"$event.stopPropagation()\"  [checked]=\"oTableOptions.filterCaseSensitive\"\n                (change)=\"oTableOptions.filterCaseSensitive = $event.checked\">\n                {{ 'TABLE.FILTER.CASE_SENSITIVE' | oTranslate}}\n              </mat-checkbox>\n            </ng-container>\n          </div>\n        </mat-menu>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ["\n    .o-table-quickfilter .quickFilter{padding-right:24px}.o-table-quickfilter .quickFilter .mat-form-field-flex{align-items:flex-end}.o-table-quickfilter .search-icon{cursor:pointer}.o-table-quickfilter-menu .mat-divider{margin:8px 0}.o-table-quickfilter-menu .checkbox-container{padding:6px 12px}.o-table-quickfilter-menu .checkbox-container .mat-checkbox-layout{white-space:normal}.o-table-quickfilter-menu .checkbox-container .mat-checkbox-layout .mat-checkbox-ripple{display:none}\n  "],
                    inputs: DEFAULT_INPUTS_O_TABLE_QUICKFILTER,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_QUICKFILTER,
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.o-table-quickfilter]': 'true',
                    }
                },] },
    ];
    /** @nocollapse */
    OTableQuickfilterComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: core.ElementRef },
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] }
    ]; };
    OTableQuickfilterComponent.propDecorators = {
        filter: [{ type: core.ViewChild, args: ['filter',] }],
        matMenu: [{ type: core.ViewChild, args: ['menu',] }]
    };
    return OTableQuickfilterComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var O_TABLE_HEADER_COMPONENTS = [
    OTableButtonComponent,
    OTableButtonsComponent,
    OTableColumnResizerComponent,
    OTableColumnsFilterComponent,
    OTableMenuComponent$$1,
    OTableOptionComponent,
    OTableInsertableRowComponent,
    OTableQuickfilterComponent
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var SCROLLVIRTUAL = 'scroll';
var OTableScrollEvent = /** @class */ (function () {
    function OTableScrollEvent(data) {
        this.data = data;
        this.type = SCROLLVIRTUAL;
    }
    return OTableScrollEvent;
}());
var OTableDataSource = /** @class */ (function (_super) {
    __extends(OTableDataSource, _super);
    function OTableDataSource(table) {
        var _this = _super.call(this) || this;
        _this.table = table;
        _this.dataTotalsChange = new BehaviorSubject([]);
        _this._quickFilterChange = new BehaviorSubject('');
        _this._columnValueFilterChange = new Subject();
        _this._loadDataScrollableChange = new BehaviorSubject(new OTableScrollEvent(1));
        _this.filteredData = [];
        _this.aggregateData = {};
        _this.onRenderedDataChange = new core.EventEmitter();
        _this._renderedData = [];
        _this.resultsLength = 0;
        _this.columnValueFilters = [];
        _this._database = table.daoTable;
        if (table.paginator) {
            _this._paginator = table.matpaginator;
        }
        _this._tableOptions = table.oTableOptions;
        _this._sort = table.sort;
        return _this;
    }
    Object.defineProperty(OTableDataSource.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () { return this.dataTotalsChange.value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableDataSource.prototype, "loadDataScrollable", {
        //load data in scroll
        get: /**
         * @return {?}
         */
        function () { return this._loadDataScrollableChange.getValue().data || 1; },
        set: /**
         * @param {?} page
         * @return {?}
         */
        function (page) {
            this._loadDataScrollableChange.next(new OTableScrollEvent(page));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableDataSource.prototype, "quickFilter", {
        get: /**
         * @return {?}
         */
        function () { return this._quickFilterChange.value || ''; },
        set: /**
         * @param {?} filter
         * @return {?}
         */
        function (filter$$1) {
            this._quickFilterChange.next(filter$$1);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    OTableDataSource.prototype.sortFunction = /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (a, b) {
        return this._sort.sortFunction(a, b);
    };
    Object.defineProperty(OTableDataSource.prototype, "renderedData", {
        get: /**
         * @return {?}
         */
        function () {
            return this._renderedData;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._renderedData = arg;
            this.onRenderedDataChange.emit();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Connect function called by the table to retrieve one stream containing the data to render.
     */
    /**
     * Connect function called by the table to retrieve one stream containing the data to render.
     * @return {?}
     */
    OTableDataSource.prototype.connect = /**
     * Connect function called by the table to retrieve one stream containing the data to render.
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var displayDataChanges = [
            this._database.dataChange
        ];
        if (!this.table.pageable) {
            if (this._sort) {
                displayDataChanges.push(this._sort.oSortChange);
            }
            if (this._tableOptions.filter) {
                displayDataChanges.push(this._quickFilterChange);
            }
            if (this._paginator) {
                displayDataChanges.push(this._paginator.page);
            }
            else {
                displayDataChanges.push(this._loadDataScrollableChange);
            }
        }
        if (this.table.oTableColumnsFilterComponent) {
            displayDataChanges.push(this._columnValueFilterChange);
        }
        return merge.apply(void 0, displayDataChanges).pipe(map(function (x) {
            /** @type {?} */
            var data = Object.assign([], _this._database.data);
            /*
                    it is necessary to first calculate the calculated columns and
                    then filter and sort the data
                  */
            if (x instanceof OTableScrollEvent) {
                _this.renderedData = data.slice(0, (x.data * OTableComponent.LIMIT_SCROLLVIRTUAL) - 1);
            }
            else {
                if (_this.existsAnyCalculatedColumn()) {
                    data = _this.getColumnCalculatedData(data);
                }
                if (!_this.table.pageable) {
                    data = _this.getColumnValueFilterData(data);
                    data = _this.getQuickFilterData(data);
                    data = _this.getSortedData(data);
                }
                _this.filteredData = Object.assign([], data);
                if (_this.table.pageable) {
                    /** @type {?} */
                    var totalRecordsNumber = _this.table.getTotalRecordsNumber();
                    _this.resultsLength = totalRecordsNumber !== undefined ? totalRecordsNumber : data.length;
                }
                else {
                    _this.resultsLength = data.length;
                    data = _this.getPaginationData(data);
                }
                /** in pagination virtual only show OTableComponent.LIMIT items for better performance of the table */
                if (!_this.table.pageable && !_this.table.paginationControls && data.length > OTableComponent.LIMIT_SCROLLVIRTUAL) {
                    /** @type {?} */
                    var datapaginate = data.slice(0, (_this.table.pageScrollVirtual * OTableComponent.LIMIT_SCROLLVIRTUAL) - 1);
                    data = datapaginate;
                }
                _this.renderedData = data;
                // If a o-table-column-aggregate exists then emit observable
                // if (this.table.showTotals) {
                //   this.dataTotalsChange.next(this.renderedData);
                // }
                // If a o-table-column-aggregate exists then emit observable
                // if (this.table.showTotals) {
                //   this.dataTotalsChange.next(this.renderedData);
                // }
                _this.aggregateData = _this.getAggregatesData(data);
            }
            return _this.renderedData;
        }));
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OTableDataSource.prototype.getAggregatesData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var obj = {};
        if (typeof this._tableOptions === 'undefined') {
            return obj;
        }
        this._tableOptions.columns.forEach(function (column) {
            /** @type {?} */
            var totalValue = '';
            if (column.aggregate && column.visible) {
                totalValue = self.calculateAggregate(data, column);
            }
            /** @type {?} */
            var key = column.attr;
            obj[key] = totalValue;
        });
        return obj;
    };
    /**
     * Method that get value the columns calculated
     * @param data data of the database
     */
    /**
     * Method that get value the columns calculated
     * @param {?} data data of the database
     * @return {?}
     */
    OTableDataSource.prototype.getColumnCalculatedData = /**
     * Method that get value the columns calculated
     * @param {?} data data of the database
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var calculatedCols = this._tableOptions.columns.filter(function (oCol) { return oCol.visible && oCol.calculate !== undefined; });
        return data.map(function (row) {
            calculatedCols.forEach(function (oColumn) {
                /** @type {?} */
                var value;
                if (typeof oColumn.calculate === 'string') {
                    value = self.transformFormula(oColumn.calculate, row);
                }
                else if (typeof oColumn.calculate === 'function') {
                    value = oColumn.calculate(row);
                }
                row[oColumn.attr] = isNaN(value) ? 0 : value;
            });
            return row;
        });
    };
    /**
     * @param {?} formulaArg
     * @param {?} row
     * @return {?}
     */
    OTableDataSource.prototype.transformFormula = /**
     * @param {?} formulaArg
     * @param {?} row
     * @return {?}
     */
    function (formulaArg, row) {
        /** @type {?} */
        var formula = formulaArg;
        /** @type {?} */
        var columnsAttr = this._tableOptions.columns.map(function (oCol) { return oCol.attr; });
        columnsAttr.forEach(function (column) {
            formula = formula.replace(column, row[column]);
        });
        /** @type {?} */
        var resultFormula = '';
        // 2. Transform formula
        try {
            resultFormula = (new Function('return ' + formula))();
        }
        catch (e) {
            console.error('Operation defined in the calculated column is incorrect ');
        }
        // 3. Return result
        return resultFormula;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OTableDataSource.prototype.getQuickFilterData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        /** @type {?} */
        var filterData = this.quickFilter;
        if (filterData !== undefined && filterData.length > 0) {
            return data.filter(function (item) {
                /** @type {?} */
                var searchStr = _this.getStringSearchable(item);
                if (!_this._tableOptions.filterCaseSensitive) {
                    searchStr = searchStr.toLowerCase();
                    filterData = filterData.toLowerCase();
                }
                return searchStr.indexOf(filterData) !== -1;
            });
        }
        else {
            return data;
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OTableDataSource.prototype.getPaginationData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (!this._paginator || isNaN(this._paginator.pageSize)) {
            return data;
        }
        /** @type {?} */
        var startIndex = isNaN(this._paginator.pageSize) ? 0 : this._paginator.pageIndex * this._paginator.pageSize;
        if (data.length > 0 && data.length < startIndex) {
            startIndex = 0;
            this._paginator.pageIndex = 0;
        }
        return data.splice(startIndex, this._paginator.pageSize);
    };
    /**
     * @return {?}
     */
    OTableDataSource.prototype.disconnect = /**
     * @return {?}
     */
    function () {
        // TODO
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OTableDataSource.prototype.getStringSearchable = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this._tableOptions.columns.map(function (oCol) {
            if (oCol.searching && oCol.visible) {
                /** @type {?} */
                var filterValue = item[oCol.attr];
                if (oCol.renderer && oCol.renderer.getCellData) {
                    filterValue = oCol.renderer.getCellData(filterValue, item);
                }
                return filterValue;
            }
        }).join(' ');
    };
    /** Returns a sorted copy of the database data. */
    /**
     * Returns a sorted copy of the database data.
     * @param {?} data
     * @return {?}
     */
    OTableDataSource.prototype.getSortedData = /**
     * Returns a sorted copy of the database data.
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return this._sort.getSortedData(data);
    };
    /**
     * Returns the data the table stores. No filters are applied.
     */
    /**
     * Returns the data the table stores. No filters are applied.
     * @return {?}
     */
    OTableDataSource.prototype.getTableData = /**
     * Returns the data the table stores. No filters are applied.
     * @return {?}
     */
    function () {
        return this._database.data;
    };
    /** Return data of the visible columns of the table without rendering */
    /**
     * Return data of the visible columns of the table without rendering
     * @return {?}
     */
    OTableDataSource.prototype.getCurrentData = /**
     * Return data of the visible columns of the table without rendering
     * @return {?}
     */
    function () {
        return this.getData();
    };
    /**
     * @return {?}
     */
    OTableDataSource.prototype.getCurrentAllData = /**
     * @return {?}
     */
    function () {
        return this.getAllData(false, false);
    };
    /** Return data of the visible columns of the table  rendering */
    /**
     * Return data of the visible columns of the table  rendering
     * @return {?}
     */
    OTableDataSource.prototype.getCurrentRendererData = /**
     * Return data of the visible columns of the table  rendering
     * @return {?}
     */
    function () {
        return this.getRenderedData(this.renderedData);
    };
    /** Return all data of the table rendering */
    /**
     * Return all data of the table rendering
     * @return {?}
     */
    OTableDataSource.prototype.getAllRendererData = /**
     * Return all data of the table rendering
     * @return {?}
     */
    function () {
        return this.getAllData(true, true);
    };
    Object.defineProperty(OTableDataSource.prototype, "sqlTypes", {
        /** Return sql types of the current data */
        get: /**
         * Return sql types of the current data
         * @return {?}
         */
        function () {
            return this._database.sqlTypes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableDataSource.prototype.getData = /**
     * @return {?}
     */
    function () {
        return this.renderedData;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OTableDataSource.prototype.getRenderedData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var self = this;
        return data.map(function (row, i, a) {
            /** *
             * render each column
              @type {?} */
            var obj = {};
            Object.keys(row).forEach(function (column, i, a) {
                self._tableOptions.columns.forEach(function (ocolumn, i, a) {
                    if (column === ocolumn.attr && ocolumn.visible) {
                        /** @type {?} */
                        var key = column;
                        if (ocolumn.renderer && ocolumn.renderer.getCellData) {
                            obj[key] = ocolumn.renderer.getCellData(row[column], row);
                        }
                        else {
                            obj[key] = row[column];
                        }
                    }
                });
            });
            return obj;
        });
    };
    /**
     * @param {?=} render
     * @param {?=} onlyVisibleColumns
     * @return {?}
     */
    OTableDataSource.prototype.getAllData = /**
     * @param {?=} render
     * @param {?=} onlyVisibleColumns
     * @return {?}
     */
    function (render, onlyVisibleColumns) {
        /** @type {?} */
        var self = this;
        return this.filteredData.map(function (row, i, a) {
            /** *
             * render each column
              @type {?} */
            var obj = {};
            Object.keys(row).forEach(function (column, i, a) {
                self._tableOptions.columns.forEach(function (ocolumn, i, a) {
                    if (column === ocolumn.attr) {
                        if (onlyVisibleColumns && !ocolumn.visible) {
                            return;
                        }
                        /** @type {?} */
                        var key = column;
                        if (render && ocolumn.renderer && ocolumn.renderer.getCellData) {
                            obj[key] = ocolumn.renderer.getCellData(row[column], row);
                        }
                        else {
                            obj[key] = row[column];
                        }
                    }
                });
            });
            return obj;
        });
    };
    /**
     * @param {?} ocolumn
     * @return {?}
     */
    OTableDataSource.prototype.getColumnData = /**
     * @param {?} ocolumn
     * @return {?}
     */
    function (ocolumn) {
        return this.renderedData.map(function (row, i, a) {
            /** *
             * render each column
              @type {?} */
            var obj = {};
            Object.keys(row).forEach(function (column, i, a) {
                if (column === ocolumn && ocolumn) {
                    /** @type {?} */
                    var key = column;
                    obj[key] = row[column];
                }
            });
            return obj;
        });
    };
    /**
     * @param {?} filters
     * @return {?}
     */
    OTableDataSource.prototype.initializeColumnsFilters = /**
     * @param {?} filters
     * @return {?}
     */
    function (filters) {
        var _this = this;
        this.columnValueFilters = [];
        filters.forEach(function (filter$$1) {
            _this.columnValueFilters.push(filter$$1);
        });
        if (!this.table.pageable) {
            this._columnValueFilterChange.next();
        }
    };
    /**
     * @return {?}
     */
    OTableDataSource.prototype.isColumnValueFilterActive = /**
     * @return {?}
     */
    function () {
        return this.columnValueFilters.length !== 0;
    };
    /**
     * @return {?}
     */
    OTableDataSource.prototype.getColumnValueFilters = /**
     * @return {?}
     */
    function () {
        return this.columnValueFilters;
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OTableDataSource.prototype.getColumnValueFilterByAttr = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        return this.columnValueFilters.filter(function (item) { return item.attr === attr; })[0];
    };
    /**
     * @param {?=} trigger
     * @return {?}
     */
    OTableDataSource.prototype.clearColumnFilters = /**
     * @param {?=} trigger
     * @return {?}
     */
    function (trigger$$1) {
        if (trigger$$1 === void 0) { trigger$$1 = true; }
        this.columnValueFilters = [];
        if (trigger$$1) {
            this._columnValueFilterChange.next();
        }
    };
    /**
     * @param {?} filter
     * @return {?}
     */
    OTableDataSource.prototype.addColumnFilter = /**
     * @param {?} filter
     * @return {?}
     */
    function (filter$$1) {
        /** @type {?} */
        var existingFilter = this.getColumnValueFilterByAttr(filter$$1.attr);
        if (existingFilter) {
            /** @type {?} */
            var idx = this.columnValueFilters.indexOf(existingFilter);
            this.columnValueFilters.splice(idx, 1);
        }
        if ((ColumnValueFilterOperator.IN === filter$$1.operator && filter$$1.values.length > 0) ||
            (ColumnValueFilterOperator.EQUAL === filter$$1.operator && filter$$1.values) ||
            (ColumnValueFilterOperator.BETWEEN === filter$$1.operator && filter$$1.values.length === 2) ||
            ((ColumnValueFilterOperator.LESS_EQUAL === filter$$1.operator || ColumnValueFilterOperator.MORE_EQUAL === filter$$1.operator) && filter$$1.values)) {
            this.columnValueFilters.push(filter$$1);
        }
        // If the table is paginated, filter will be applied on remote query
        if (!this.table.pageable) {
            this._columnValueFilterChange.next();
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OTableDataSource.prototype.getColumnValueFilterData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        this.columnValueFilters.forEach(function (filter$$1) {
            switch (filter$$1.operator) {
                case ColumnValueFilterOperator.IN:
                    /** @type {?} */
                    var filterColumn = _this.table.oTableOptions.columns.filter(function (col) { return col.attr === filter$$1.attr; })[0];
                    if (filterColumn) {
                        data = data.filter(function (item) {
                            return (filter$$1.values.indexOf(item[filter$$1.attr]) !== -1);
                        });
                    }
                    break;
                case ColumnValueFilterOperator.EQUAL:
                    if (filter$$1.values.indexOf('*') !== -1) {
                        data = data.filter(function (item) { return new RegExp('^' + Util.normalizeString(filter$$1.values).split('*').join('.*') + '$').test(Util.normalizeString(item[filter$$1.attr])); });
                    }
                    else {
                        data = data.filter(function (item) { return (Util.normalizeString(item[filter$$1.attr]).indexOf(Util.normalizeString(filter$$1.values)) !== -1); });
                    }
                    break;
                case ColumnValueFilterOperator.BETWEEN:
                    data = data.filter(function (item) { return item[filter$$1.attr] >= filter$$1.values[0] && item[filter$$1.attr] <= filter$$1.values[1]; });
                    break;
                case ColumnValueFilterOperator.MORE_EQUAL:
                    data = data.filter(function (item) { return item[filter$$1.attr] >= filter$$1.values; });
                    break;
                case ColumnValueFilterOperator.LESS_EQUAL:
                    data = data.filter(function (item) { return item[filter$$1.attr] <= filter$$1.values; });
                    break;
            }
        });
        return data;
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableDataSource.prototype.getAggregateData = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var obj = {};
        /** @type {?} */
        var totalValue = '';
        if (typeof this._tableOptions === 'undefined') {
            return new Array(obj);
        }
        totalValue = this.aggregateData[column.attr];
        return totalValue;
    };
    /**
     * @param {?} data
     * @param {?} column
     * @return {?}
     */
    OTableDataSource.prototype.calculateAggregate = /**
     * @param {?} data
     * @param {?} column
     * @return {?}
     */
    function (data, column) {
        /** @type {?} */
        var resultAggregate;
        /** @type {?} */
        var operator = column.aggregate.operator;
        if (typeof operator === 'string') {
            switch (operator.toLowerCase()) {
                case 'count':
                    resultAggregate = this.count(column.attr, data);
                    break;
                case 'min':
                    resultAggregate = this.min(column.attr, data);
                    break;
                case 'max':
                    resultAggregate = this.max(column.attr, data);
                    break;
                case 'avg':
                    resultAggregate = this.avg(column.attr, data);
                    break;
                default:
                    resultAggregate = this.sum(column.attr, data);
                    break;
            }
        }
        else {
            /** @type {?} */
            var data_1 = this.getColumnData(column.attr);
            if (typeof operator === 'function') {
                resultAggregate = operator(data_1);
            }
        }
        return resultAggregate;
    };
    /**
     * @param {?} column
     * @param {?} data
     * @return {?}
     */
    OTableDataSource.prototype.sum = /**
     * @param {?} column
     * @param {?} data
     * @return {?}
     */
    function (column, data) {
        /** @type {?} */
        var value = 0;
        if (data) {
            value = data.reduce(function (acumulator, currentValue) {
                return acumulator + (isNaN(currentValue[column]) ? 0 : currentValue[column]);
            }, value);
        }
        return value;
    };
    /**
     * @param {?} column
     * @param {?} data
     * @return {?}
     */
    OTableDataSource.prototype.count = /**
     * @param {?} column
     * @param {?} data
     * @return {?}
     */
    function (column, data) {
        /** @type {?} */
        var value = 0;
        if (data) {
            value = data.reduce(function (acumulator, currentValue, currentIndex) {
                return acumulator + 1;
            }, 0);
        }
        return value;
    };
    /**
     * @param {?} column
     * @param {?} data
     * @return {?}
     */
    OTableDataSource.prototype.avg = /**
     * @param {?} column
     * @param {?} data
     * @return {?}
     */
    function (column, data) {
        return this.sum(column, data) / this.count(column, data);
    };
    /**
     * @param {?} column
     * @param {?} data
     * @return {?}
     */
    OTableDataSource.prototype.min = /**
     * @param {?} column
     * @param {?} data
     * @return {?}
     */
    function (column, data) {
        /** @type {?} */
        var tempMin = data.map(function (x) { return x[column]; });
        return Math.min.apply(Math, tempMin);
    };
    /**
     * @param {?} column
     * @param {?} data
     * @return {?}
     */
    OTableDataSource.prototype.max = /**
     * @param {?} column
     * @param {?} data
     * @return {?}
     */
    function (column, data) {
        /** @type {?} */
        var tempMin = data.map(function (x) { return x[column]; });
        return Math.max.apply(Math, tempMin);
    };
    /**
     * @return {?}
     */
    OTableDataSource.prototype.existsAnyCalculatedColumn = /**
     * @return {?}
     */
    function () {
        return this._tableOptions.columns.find(function (oCol) { return oCol.calculate !== undefined; }) !== undefined;
    };
    /**
     * @param {?} rowData
     * @return {?}
     */
    OTableDataSource.prototype.updateRenderedRowData = /**
     * @param {?} rowData
     * @return {?}
     */
    function (rowData) {
        /** @type {?} */
        var tableKeys = this.table.getKeys();
        /** @type {?} */
        var record = this.renderedData.find(function (data) {
            /** @type {?} */
            var found = true;
            for (var i = 0, len = tableKeys.length; i < len; i++) {
                /** @type {?} */
                var key = tableKeys[i];
                if (data[key] !== rowData[key]) {
                    found = false;
                    break;
                }
            }
            return found;
        });
        if (Util.isDefined(record)) {
            Object.assign(record, rowData);
        }
    };
    return OTableDataSource;
}(DataSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_PAGINATOR_TABLE = [
    'pageSize: page-size',
    'showFirstLastButtons: show-first-last-buttons'
];
var OTablePaginatorComponent = /** @class */ (function () {
    function OTablePaginatorComponent(injector, table) {
        this.injector = injector;
        this.table = table;
        this._pageIndex = 0;
        this._pageSize = 10;
        this.showFirstLastButtons = true;
        this._pageIndex = 0;
        this._pageSizeOptions = [10, 25, 50, 100];
        this.pageSize = this.table.queryRows;
        this.pageIndex = this.table.currentPage;
        this.showFirstLastButtons = this.table.showPaginatorFirstLastButtons;
    }
    /**
     * @return {?}
     */
    OTablePaginatorComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.table.registerPagination(this);
    };
    Object.defineProperty(OTablePaginatorComponent.prototype, "pageLenght", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pageSize;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._pageSize = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTablePaginatorComponent.prototype, "pageIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pageIndex;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._pageIndex = value;
            if (this.table.matpaginator) {
                this.table.matpaginator.pageIndex = this._pageIndex;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTablePaginatorComponent.prototype, "pageSize", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pageSize;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (value < 0) {
                this._pageSize = this._pageSizeOptions[0];
            }
            else {
                this._pageSize = value;
            }
            /** @type {?} */
            var result = this.pageSizeOptions.filter(function (option) { return option == _this._pageSize; });
            if (result.length === 0) {
                this._pageSizeOptions.push(value);
                this._pageSizeOptions.sort(function (i, j) { return i - j; });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTablePaginatorComponent.prototype, "pageSizeOptions", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pageSizeOptions;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._pageSizeOptions = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTablePaginatorComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        this._pageIndex = 0;
    };
    /**
     * @param {?} selectedLength
     * @return {?}
     */
    OTablePaginatorComponent.prototype.isShowingAllRows = /**
     * @param {?} selectedLength
     * @return {?}
     */
    function (selectedLength) {
        // return this._pageSizeOptions.indexOf(selectedLength) === (this._pageSizeOptions.length - 1);
        // temporal while not having an option for showing all records in paginated tables
        return false;
    };
    OTablePaginatorComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-paginator',
                    template: ' ',
                    inputs: DEFAULT_PAGINATOR_TABLE,
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    OTablePaginatorComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTablePaginatorComponent.prototype, "showFirstLastButtons", void 0);
    return OTablePaginatorComponent;
}());
var OTableMatPaginatorIntl = /** @class */ (function (_super) {
    __extends(OTableMatPaginatorIntl, _super);
    function OTableMatPaginatorIntl(injector) {
        var _this = _super.call(this) || this;
        _this.injector = injector;
        _this.translateService = _this.injector.get(OTranslateService$$1);
        _this.itemsPerPageLabel = _this.translateService.get('TABLE.PAGINATE.ITEMSPERPAGELABEL');
        _this.nextPageLabel = _this.translateService.get('TABLE.PAGINATE.NEXT');
        _this.previousPageLabel = _this.translateService.get('TABLE.PAGINATE.PREVIOUS');
        _this.firstPageLabel = _this.translateService.get('TABLE.PAGINATE.FIRST');
        _this.lastPageLabel = _this.translateService.get('TABLE.PAGINATE.LAST');
        _this.getRangeLabel = _this.getORangeLabel;
        _this.onLanguageChangeSubscribe = _this.translateService.onLanguageChanged.subscribe(function (res) {
            _this.itemsPerPageLabel = _this.translateService.get('TABLE.PAGINATE.ITEMSPERPAGELABEL');
            _this.nextPageLabel = _this.translateService.get('TABLE.PAGINATE.NEXT');
            _this.previousPageLabel = _this.translateService.get('TABLE.PAGINATE.PREVIOUS');
            _this.firstPageLabel = _this.translateService.get('TABLE.PAGINATE.FIRST');
            _this.lastPageLabel = _this.translateService.get('TABLE.PAGINATE.LAST');
            _this.getRangeLabel = _this.getORangeLabel;
            _this.changes.next();
        });
        return _this;
    }
    /**
     * @param {?} page
     * @param {?} pageSize
     * @param {?} length
     * @return {?}
     */
    OTableMatPaginatorIntl.prototype.getORangeLabel = /**
     * @param {?} page
     * @param {?} pageSize
     * @param {?} length
     * @return {?}
     */
    function (page, pageSize, length) {
        if (!isNaN(pageSize) && (length === 0 || pageSize === 0)) {
            return "0  " + this.translateService.get('TABLE.PAGINATE.RANGE_LABEL') + " " + length;
        }
        length = Math.max(length, 0);
        /** @type {?} */
        var startIndex = page * pageSize;
        /** @type {?} */
        var endIndex = startIndex < length ?
            Math.min(startIndex + pageSize, length) :
            startIndex + pageSize;
        //option show all
        if (isNaN(pageSize)) {
            startIndex = 0;
            endIndex = length;
        }
        return startIndex + 1 + " - " + endIndex + "  " + this.translateService.get('TABLE.PAGINATE.RANGE_LABEL') + " " + length;
    };
    OTableMatPaginatorIntl.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OTableMatPaginatorIntl.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OTableMatPaginatorIntl;
}(material.MatPaginatorIntl));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OColumnAggregate = /** @class */ (function () {
    function OColumnAggregate() {
    }
    return OColumnAggregate;
}());
/** @type {?} */
var DEFAULT_TABLE_COLUMN_AGGREGATE = [
    'attr',
    'title',
    'aggregate',
    'functionAggregate: function-aggregate'
];
var OTableColumnAggregateComponent = /** @class */ (function () {
    function OTableColumnAggregateComponent(table, injector) {
        this.injector = injector;
        this.title = '';
        this.subscription = new Subscription();
        this.table = table;
    }
    Object.defineProperty(OTableColumnAggregateComponent.prototype, "functionAggregate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._aggregateFunction;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._aggregateFunction = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} attr
     * @return {?}
     */
    OTableColumnAggregateComponent.prototype.getColumnData = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        /** @type {?} */
        var columnData = [];
        if (this.table.dataSource) {
            columnData = this.table.dataSource.getColumnData(attr);
        }
        return columnData;
    };
    /**
     * @return {?}
     */
    OTableColumnAggregateComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.attr) {
            return;
        }
        /** @type {?} */
        var ocolumnaggregate = new OColumnAggregate();
        ocolumnaggregate.attr = this.attr;
        if (this.title) {
            ocolumnaggregate.title = this.title;
        }
        ocolumnaggregate.operator = this.aggregate ? this.aggregate : (this.functionAggregate ? this.functionAggregate : OTableColumnAggregateComponent.DEFAULT_AGGREGATE);
        this.table.registerColumnAggregate(ocolumnaggregate);
        this.subscription.add(this.table.onReinitialize.subscribe(function () { return _this.table.registerColumnAggregate(ocolumnaggregate); }));
    };
    /**
     * @return {?}
     */
    OTableColumnAggregateComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    OTableColumnAggregateComponent.DEFAULT_AGGREGATE = 'SUM';
    OTableColumnAggregateComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-column-aggregate',
                    template: "\n     <!--{{ functionAggregate(getColumnData(attr)) }}-->\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_TABLE_COLUMN_AGGREGATE
                },] },
    ];
    /** @nocollapse */
    OTableColumnAggregateComponent.ctorParameters = function () { return [
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] },
        { type: core.Injector }
    ]; };
    return OTableColumnAggregateComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var O_TABLE_FOOTER_COMPONENTS = [
    OTablePaginatorComponent,
    OTableColumnAggregateComponent
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_TABLE_CONTEXT_MENU_INPUTS = [
    'contextMenu: context-menu',
    'showInsert: insert',
    'showEdit: edit',
    'showViewDetail: view-detail',
    'showCopy: copy',
    'showSelectAll: select-all',
    'showRefresh: refresh',
    'showDelete: delete',
    'showFilter: filter'
];
var OTableContextMenuComponent = /** @class */ (function () {
    function OTableContextMenuComponent(injector, table) {
        this.injector = injector;
        this.table = table;
        this.isVisibleInsert = new BehaviorSubject(true);
        this.isVisibleEdit = new BehaviorSubject(true);
        this.isVisibleDetail = new BehaviorSubject(true);
        this.isVisibleCopy = new BehaviorSubject(true);
        this.isVisibleSelectAll = new BehaviorSubject(true);
        this.isVisibleRefresh = new BehaviorSubject(true);
        this.isVisibleDelete = new BehaviorSubject(true);
        this.isVisibleFilter = new BehaviorSubject(true);
        this.contextMenuSubscription = new Subscription();
        this.translateService = this.injector.get(OTranslateService$$1);
    }
    Object.defineProperty(OTableContextMenuComponent.prototype, "showInsert", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVisibleInsert.getValue();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value !== 'boolean') {
                value = Util.parseBoolean(/** @type {?} */ (value));
            }
            this.isVisibleInsert.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableContextMenuComponent.prototype, "showEdit", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVisibleEdit.getValue();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value !== 'boolean') {
                value = Util.parseBoolean(/** @type {?} */ (value));
            }
            this.isVisibleEdit.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableContextMenuComponent.prototype, "showViewDetail", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVisibleDetail.getValue();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value !== 'boolean') {
                value = Util.parseBoolean(/** @type {?} */ (value));
            }
            this.isVisibleDetail.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableContextMenuComponent.prototype, "showCopy", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVisibleCopy.getValue();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value !== 'boolean') {
                value = Util.parseBoolean(/** @type {?} */ (value));
            }
            this.isVisibleCopy.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableContextMenuComponent.prototype, "showSelectAll", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVisibleSelectAll.getValue();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value !== 'boolean') {
                value = Util.parseBoolean(/** @type {?} */ (value));
            }
            this.table.isSelectionModeNone() ? this.isVisibleSelectAll.next(false) : this.isVisibleSelectAll.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableContextMenuComponent.prototype, "showRefresh", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVisibleRefresh.getValue();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value !== 'boolean') {
                value = Util.parseBoolean(/** @type {?} */ (value));
            }
            this.isVisibleRefresh.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableContextMenuComponent.prototype, "showDelete", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVisibleDelete.getValue();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value !== 'boolean') {
                value = Util.parseBoolean(/** @type {?} */ (value));
            }
            this.isVisibleDelete.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableContextMenuComponent.prototype, "showFilter", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVisibleFilter.getValue();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value !== 'boolean') {
                value = Util.parseBoolean(/** @type {?} */ (value));
            }
            this.isVisibleFilter.next(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableContextMenuComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.contextMenuSubscription.add(this.defaultContextMenu.onClose.subscribe(function (param) {
            if (!_this.table.isSelectionModeMultiple()) {
                _this.table.clearSelection();
            }
        }));
        this.contextMenuSubscription.add(this.defaultContextMenu.onShow.subscribe(function (param) {
            _this.initProperties(param);
        }));
    };
    /**
     * @return {?}
     */
    OTableContextMenuComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var itemsParsed = this.defaultContextMenu.oContextMenuItems.toArray();
        if (this.contextMenu) {
            /** @type {?} */
            var items = itemsParsed.concat(this.contextMenu.oContextMenuItems.toArray());
            this.defaultContextMenu.oContextMenuItems.reset(items);
        }
        else {
            this.defaultContextMenu.oContextMenuItems.reset(itemsParsed);
        }
        if (!Util.isDefined(this.showSelectAll)) {
            this.isVisibleSelectAll.next(this.table.selectAllCheckbox);
        }
        this.table.registerContextMenu(this.defaultContextMenu);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableContextMenuComponent.prototype.gotoDetails = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var data = event.data.rowValue;
        this.table.viewDetail(data);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableContextMenuComponent.prototype.edit = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var data = event.data.rowValue;
        this.table.doHandleClick(data);
    };
    /**
     * @return {?}
     */
    OTableContextMenuComponent.prototype.add = /**
     * @return {?}
     */
    function () {
        this.table.add();
    };
    /**
     * @return {?}
     */
    OTableContextMenuComponent.prototype.selectAll = /**
     * @return {?}
     */
    function () {
        this.table.showAndSelectAllCheckbox();
    };
    /**
     * @return {?}
     */
    OTableContextMenuComponent.prototype.unSelectAll = /**
     * @return {?}
     */
    function () {
        this.table.selection.clear();
    };
    /**
     * @return {?}
     */
    OTableContextMenuComponent.prototype.copyAll = /**
     * @return {?}
     */
    function () {
        this.table.copyAll();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableContextMenuComponent.prototype.copyCell = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var cell_data = this.defaultContextMenu.origin.innerText;
        Util.copyToClipboard(cell_data);
    };
    /**
     * @return {?}
     */
    OTableContextMenuComponent.prototype.copySelection = /**
     * @return {?}
     */
    function () {
        this.table.copySelection();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableContextMenuComponent.prototype.copyRow = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var data = JSON.stringify(this.table.dataSource.getRenderedData([event.data.rowValue]));
        Util.copyToClipboard(data);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableContextMenuComponent.prototype.delete = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.table.remove();
    };
    /**
     * @return {?}
     */
    OTableContextMenuComponent.prototype.refresh = /**
     * @return {?}
     */
    function () {
        this.table.refresh();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableContextMenuComponent.prototype.filterByValue = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.table.showFilterByColumnIcon = true;
        /** @type {?} */
        var columValueFilter = {
            attr: this.column.attr,
            operator: ColumnValueFilterOperator.IN,
            values: [this.row[this.column.attr]]
        };
        this.table.dataSource.addColumnFilter(columValueFilter);
        this.table.reloadPaginatedDataFromStart();
    };
    Object.defineProperty(OTableContextMenuComponent.prototype, "labelFilterByColumn", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.column && this.column.attr) ? this.translateService.get('TABLE_CONTEXT_MENU.FILTER_BY') + ' ' + this.translateService.get(this.column.attr) : '';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    OTableContextMenuComponent.prototype.filterByColumn = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.table.oTableMenu) {
            this.table.showFilterByColumnIcon = true;
            this.table.oTableMenu.columnFilterOption.active = true;
            this.table.openColumnFilterDialog(this.column, event.event);
        }
    };
    /**
     * @return {?}
     */
    OTableContextMenuComponent.prototype.checkVisibleFilter = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isVisible = false;
        if (this.column) {
            isVisible = this.showFilter && this.table.isColumnFilterable(this.column);
        }
        this.isVisibleFilter.next(isVisible);
    };
    /**
     * @param {?} param
     * @return {?}
     */
    OTableContextMenuComponent.prototype.initProperties = /**
     * @param {?} param
     * @return {?}
     */
    function (param) {
        /** @type {?} */
        var data = param.data;
        if (data) {
            /** @type {?} */
            var columnName = data.cellName;
            this.column = this.table.getOColumn(columnName);
            this.row = data.rowValue;
            this.checkVisibleFilter();
        }
    };
    OTableContextMenuComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-context-menu',
                    template: "\n    <o-context-menu #defaultContextMenu>\n      <o-context-menu-item attr=\"refresh\" label=\"TABLE_CONTEXT_MENU.REFRESH\" svg-icon=\"ontimize:autorenew\" (execute)=\"refresh()\"\n        [visible]=\"isVisibleRefresh | async\"></o-context-menu-item>\n      <o-context-menu-item attr=\"detail\" icon=\"chevron_right\" label=\"TABLE_CONTEXT_MENU.VIEW_DETAIL\" (execute)=\"gotoDetails($event)\"\n        [visible]=\"isVisibleDetail | async\"></o-context-menu-item>\n      <o-context-menu-item attr=\"edit\" icon=\"edit\" label=\"TABLE_CONTEXT_MENU.EDIT\" (execute)=\"edit($event)\" [visible]=\"isVisibleEdit | async\">\n      </o-context-menu-item>\n      <o-context-menu-item attr=\"insert\" label=\"TABLE_CONTEXT_MENU.INSERT\" icon=\"add\" (execute)=\"add()\" [visible]=\"isVisibleInsert | async\">\n      </o-context-menu-item>\n      <o-context-menu-item attr=\"delete\" label=\"TABLE_CONTEXT_MENU.DELETE\" icon=\"delete\" (execute)=\"delete($event)\" [visible]=\"isVisibleDelete | async\">\n      </o-context-menu-item>\n      <!-- FILTER GROUP -->\n      <o-context-menu-group label=\"TABLE_CONTEXT_MENU.FILTER\" icon=\"filter_list\" type=\"group\" [visible]=\"isVisibleFilter | async\">\n        <o-context-menu-item icon=\"filter_list\" [label]=\"labelFilterByColumn\" (execute)=\"filterByColumn($event)\"></o-context-menu-item>\n        <o-context-menu-item icon=\"filter_list\" label=\"TABLE_CONTEXT_MENU.FILTER_BY_VALUE\" (execute)=\"filterByValue($event)\"></o-context-menu-item>\n      </o-context-menu-group>\n      <!-- COPY GROUP -->\n      <o-context-menu-separator [visible]=\"isVisibleCopy | async\"></o-context-menu-separator>\n      <o-context-menu-group label=\"TABLE_CONTEXT_MENU.COPY\" icon=\"file_copy\" type=\"group\" [visible]=\"isVisibleCopy | async\">\n        <o-context-menu-item icon=\"file_copy\" label=\"TABLE_CONTEXT_MENU.COPY_CELL\" (execute)=\"copyCell($event)\"></o-context-menu-item>\n        <o-context-menu-item icon=\"file_copy\" label=\"TABLE_CONTEXT_MENU.COPY_ROW\" (execute)=\"copyRow($event)\"></o-context-menu-item>\n        <o-context-menu-item label=\"TABLE_CONTEXT_MENU.COPY_ALL\" icon=\"file_copy\" (execute)=\"copyAll()\"></o-context-menu-item>\n        <o-context-menu-item label=\"TABLE_CONTEXT_MENU.COPY_SELECTION\" icon=\"file_copy\" (execute)=\"copySelection()\"></o-context-menu-item>\n      </o-context-menu-group>\n      <o-context-menu-separator [visible]=\"isVisibleSelectAll | async\"></o-context-menu-separator>\n      <o-context-menu-item attr=\"select-all\" [label]=\"table.isAllSelected() ? 'TABLE_CONTEXT_MENU.DESELECT_ALL': 'TABLE_CONTEXT_MENU.SELECT_ALL'\"\n        icon=\"select_all\" (execute)=\"table.isAllSelected() ? unSelectAll() : selectAll()\" [visible]=\"isVisibleSelectAll | async\"></o-context-menu-item>\n    </o-context-menu>\n  ",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_TABLE_CONTEXT_MENU_INPUTS
                },] },
    ];
    /** @nocollapse */
    OTableContextMenuComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] }
    ]; };
    OTableContextMenuComponent.propDecorators = {
        defaultContextMenu: [{ type: core.ViewChild, args: ['defaultContextMenu',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], OTableContextMenuComponent.prototype, "showSelectAll", null);
    return OTableContextMenuComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTableStorage = /** @class */ (function () {
    function OTableStorage(table) {
        this.table = table;
    }
    /**
     * @return {?}
     */
    OTableStorage.prototype.getDataToStore = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var dataToStore = {
            'filter': this.table.oTableQuickFilterComponent ? this.table.oTableQuickFilterComponent.value : ''
        };
        /** @type {?} */
        var properties = ['sort', 'columns-display', 'columns-filter', 'quick-filter', 'page', 'selection', 'initial-configuration'];
        Object.assign(dataToStore, this.getTablePropertiesToStore(properties));
        /** @type {?} */
        var storedFiltersArr = this.getStoredFilters();
        if (storedFiltersArr.length > 0) {
            dataToStore[OTableStorage.USER_STORED_FILTERS_KEY] = storedFiltersArr;
        }
        /** @type {?} */
        var storedConfigurationsArr = this.getStoredConfigurations();
        if (storedConfigurationsArr.length > 0) {
            dataToStore[OTableStorage.STORED_CONFIGURATIONS_KEY] = storedConfigurationsArr;
        }
        return dataToStore;
    };
    /**
     * @param {?} properties
     * @return {?}
     */
    OTableStorage.prototype.getTablePropertiesToStore = /**
     * @param {?} properties
     * @return {?}
     */
    function (properties) {
        var _this = this;
        /** @type {?} */
        var result = {};
        properties.forEach(function (prop) {
            Object.assign(result, _this.getTablePropertyToStore(prop));
        });
        return result;
    };
    /**
     * @param {?} property
     * @return {?}
     */
    OTableStorage.prototype.getTablePropertyToStore = /**
     * @param {?} property
     * @return {?}
     */
    function (property) {
        /** @type {?} */
        var result = {};
        switch (property) {
            case 'sort':
                result = this.getSortState();
                break;
            case 'columns-display':
                result = this.getColumnsDisplayState();
                break;
            case 'quick-filter':
                result = this.getColumnsQuickFilterState();
                break;
            case 'columns-filter':
                result = this.getColumnFiltersState();
                break;
            case 'page':
                result = this.getPageState();
                break;
            case 'selection':
                result = this.getSelectionState();
                break;
            case 'initial-configuration':
                result = this.getInitialConfigurationState();
                break;
        }
        return result;
    };
    /**
     * @return {?}
     */
    OTableStorage.prototype.reset = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var state$$1 = {};
        state$$1[OTableStorage.USER_STORED_FILTERS_KEY] = this.table.state[OTableStorage.USER_STORED_FILTERS_KEY];
        state$$1[OTableStorage.STORED_CONFIGURATIONS_KEY] = this.table.state[OTableStorage.STORED_CONFIGURATIONS_KEY];
        if (this.table.pageable) {
            state$$1['totalQueryRecordsNumber'] = this.table.state.totalQueryRecordsNumber;
        }
        state$$1['currentPage'] = 0;
        this.table.state = state$$1;
    };
    /**
     * @return {?}
     */
    OTableStorage.prototype.getSortState = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = {};
        /** @type {?} */
        var sortColumnsArray = this.table.sort.getSortColumns();
        if (sortColumnsArray.length > 0) {
            /** @type {?} */
            var sortColumns_1 = [];
            sortColumnsArray.forEach(function (sortData) {
                sortColumns_1.push(sortData.id + Codes.COLUMNS_ALIAS_SEPARATOR + sortData.direction);
            });
            result['sort-columns'] = sortColumns_1.join(Codes.ARRAY_INPUT_SEPARATOR);
        }
        return result;
    };
    /**
     * @return {?}
     */
    OTableStorage.prototype.getColumnFiltersState = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = {};
        if (this.table.oTableColumnsFilterComponent) {
            /** @type {?} */
            var columnValueFilters = this.table.dataSource.getColumnValueFilters();
            if (columnValueFilters.length > 0) {
                result['column-value-filters'] = columnValueFilters;
            }
        }
        return result;
    };
    /**
     * @return {?}
     */
    OTableStorage.prototype.getColumnsDisplayState = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = {};
        /** @type {?} */
        var oColumnsData = [];
        this.table.oTableOptions.columns.forEach(function (oCol) {
            oColumnsData.push({
                attr: oCol.attr,
                visible: oCol.visible,
                width: oCol.getWidthToStore()
            });
        });
        result['oColumns-display'] = oColumnsData;
        result['select-column-visible'] = this.table.oTableOptions.selectColumn.visible;
        return result;
    };
    /**
     * @return {?}
     */
    OTableStorage.prototype.getColumnsQuickFilterState = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = {};
        /** @type {?} */
        var tableOptions = this.table.oTableOptions;
        /** @type {?} */
        var oColumnsData = [];
        tableOptions.columns.forEach(function (oCol) {
            oColumnsData.push({
                attr: oCol.attr,
                searchable: oCol.searchable,
                searching: oCol.searching
            });
        });
        result['oColumns'] = oColumnsData;
        result['filter-case-sensitive'] = tableOptions.filterCaseSensitive;
        return result;
    };
    /**
     * @return {?}
     */
    OTableStorage.prototype.getPageState = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = {
            'query-rows': this.table.matpaginator ? this.table.matpaginator.pageSize : ''
        };
        if (this.table.currentPage > 0 && this.table.storePaginationState) {
            result['currentPage'] = this.table.currentPage;
        }
        if (this.table.pageable && this.table.storePaginationState) {
            /** @type {?} */
            var state$$1 = this.table.state;
            result['totalQueryRecordsNumber'] = state$$1.totalQueryRecordsNumber;
            result['queryRecordOffset'] = Math.max((state$$1.queryRecordOffset - this.table.dataSource.renderedData.length), (state$$1.queryRecordOffset - this.table.queryRows));
        }
        return result;
    };
    /**
     * @return {?}
     */
    OTableStorage.prototype.getSelectionState = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var result = {
            'selection': []
        };
        if (this.table && this.table.keepSelectedItems) {
            /** @type {?} */
            var selection_1 = [];
            this.table.getSelectedItems().forEach(function (item) {
                /** @type {?} */
                var data = {};
                _this.table.getKeys().forEach(function (key) {
                    data[key] = item[key];
                });
                selection_1.push(data);
            });
            result.selection = selection_1;
        }
        return result;
    };
    /**
     * @return {?}
     */
    OTableStorage.prototype.getInitialConfigurationState = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = {};
        /** @type {?} */
        var initialConfiguration = {};
        /** @type {?} */
        var oColumnsData = [];
        /** @type {?} */
        var self = this;
        Util.parseArray(this.table.originalVisibleColumns, true).forEach(function (x) {
            /** @type {?} */
            var oCol = self.table.getOColumn(x);
            oColumnsData.push({
                attr: oCol.attr,
                visible: true,
                width: oCol.definition ? oCol.definition.originalWidth : undefined
            });
        });
        initialConfiguration['oColumns-display'] = oColumnsData;
        initialConfiguration['sort-columns'] = this.table.originalSortColumns;
        initialConfiguration['select-column-visible'] = this.table.oTableOptions.selectColumn.visible;
        initialConfiguration['filter-case-sensitive'] = this.table.filterCaseSensitive;
        initialConfiguration['query-rows'] = this.table.originalQueryRows;
        result['initial-configuration'] = initialConfiguration;
        return result;
    };
    /**
     * @param {?} filters
     * @return {?}
     */
    OTableStorage.prototype.setStoredFilters = /**
     * @param {?} filters
     * @return {?}
     */
    function (filters) {
        return this.table.state[OTableStorage.USER_STORED_FILTERS_KEY] = filters;
    };
    /**
     * @return {?}
     */
    OTableStorage.prototype.getStoredFilters = /**
     * @return {?}
     */
    function () {
        return this.table.state[OTableStorage.USER_STORED_FILTERS_KEY] || [];
    };
    /**
     * @param {?} filterName
     * @return {?}
     */
    OTableStorage.prototype.getStoredFilter = /**
     * @param {?} filterName
     * @return {?}
     */
    function (filterName) {
        return this.getStoredFilters().find(function (item) { return item.name === filterName; });
    };
    /**
     * @param {?} filterName
     * @return {?}
     */
    OTableStorage.prototype.getStoredFilterConf = /**
     * @param {?} filterName
     * @return {?}
     */
    function (filterName) {
        return (this.getStoredFilter(filterName) || {})[OTableStorage.STORED_FILTER_KEY];
    };
    /**
     * @param {?} filterName
     * @return {?}
     */
    OTableStorage.prototype.deleteStoredFilter = /**
     * @param {?} filterName
     * @return {?}
     */
    function (filterName) {
        /** @type {?} */
        var storedFilters = this.table.state[OTableStorage.USER_STORED_FILTERS_KEY] || [];
        /** @type {?} */
        var index = storedFilters.findIndex(function (item) { return item.name === filterName; });
        if (index >= 0) {
            storedFilters.splice(index, 1);
            this.table.state[OTableStorage.USER_STORED_FILTERS_KEY] = storedFilters;
        }
    };
    /**
     * @param {?} filterArgs
     * @return {?}
     */
    OTableStorage.prototype.storeFilter = /**
     * @param {?} filterArgs
     * @return {?}
     */
    function (filterArgs) {
        /** @type {?} */
        var result = {};
        /** @type {?} */
        var storedFilter = {};
        Object.assign(storedFilter, this.getColumnFiltersState());
        Object.assign(storedFilter, this.getColumnsQuickFilterState());
        result[OTableStorage.STORED_FILTER_KEY] = storedFilter;
        Object.assign(result, filterArgs);
        /** @type {?} */
        var existingFilters = this.getStoredFilters();
        existingFilters.push(result);
        this.table.state[OTableStorage.USER_STORED_FILTERS_KEY] = existingFilters;
    };
    /**
     * @param {?=} arg
     * @return {?}
     */
    OTableStorage.prototype.getStoredColumnsFilters = /**
     * @param {?=} arg
     * @return {?}
     */
    function (arg) {
        /** @type {?} */
        var stateObj = arg || this.table.state;
        return stateObj['column-value-filters'] || [];
    };
    /**
     * @return {?}
     */
    OTableStorage.prototype.getStoredConfigurations = /**
     * @return {?}
     */
    function () {
        return this.table.state[OTableStorage.STORED_CONFIGURATIONS_KEY] || [];
    };
    /**
     * @param {?} configurationName
     * @return {?}
     */
    OTableStorage.prototype.getStoredConfiguration = /**
     * @param {?} configurationName
     * @return {?}
     */
    function (configurationName) {
        return this.getStoredConfigurations().find(function (item) { return item.name === configurationName; });
    };
    /**
     * @param {?} configurationAgs
     * @param {?} tableProperties
     * @return {?}
     */
    OTableStorage.prototype.storeConfiguration = /**
     * @param {?} configurationAgs
     * @param {?} tableProperties
     * @return {?}
     */
    function (configurationAgs, tableProperties) {
        /** @type {?} */
        var result = {};
        this.table.storePaginationState = true;
        /** @type {?} */
        var storedConfiguration = this.getTablePropertiesToStore(tableProperties);
        this.table.storePaginationState = false;
        result[OTableStorage.STORED_CONFIGURATION_KEY] = storedConfiguration;
        Object.assign(result, configurationAgs);
        result[OTableStorage.STORED_PROPERTIES_KEY] = tableProperties;
        /** @type {?} */
        var existingConfigurations = this.getStoredConfigurations();
        existingConfigurations.push(result);
        this.table.state[OTableStorage.STORED_CONFIGURATIONS_KEY] = existingConfigurations;
    };
    /**
     * @param {?} configurationName
     * @return {?}
     */
    OTableStorage.prototype.deleteStoredConfiguration = /**
     * @param {?} configurationName
     * @return {?}
     */
    function (configurationName) {
        /** @type {?} */
        var storedConfigurations = this.getStoredConfigurations();
        /** @type {?} */
        var index = storedConfigurations.findIndex(function (item) { return item.name === configurationName; });
        if (index >= 0) {
            storedConfigurations.splice(index, 1);
            this.table.state[OTableStorage.STORED_CONFIGURATIONS_KEY] = storedConfigurations;
        }
    };
    OTableStorage.STORED_FILTER_KEY = 'stored-filter';
    OTableStorage.USER_STORED_FILTERS_KEY = 'user-stored-filters';
    OTableStorage.STORED_CONFIGURATION_KEY = 'stored-configuration';
    OTableStorage.STORED_PROPERTIES_KEY = 'stored-properties';
    OTableStorage.STORED_CONFIGURATIONS_KEY = 'user-stored-configurations';
    return OTableStorage;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTableRowDirective = /** @class */ (function () {
    function OTableRowDirective(table, elementRef, renderer) {
        this.table = table;
        this.elementRef = elementRef;
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    OTableRowDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.registerResize();
    };
    /**
     * @return {?}
     */
    OTableRowDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OTableRowDirective.prototype.registerResize = /**
     * @return {?}
     */
    function () {
        if (this.table.horizontalScroll) {
            /** @type {?} */
            var self_1 = this;
            this.table.onUpdateScrolledState.subscribe(function (scrolled) {
                setTimeout(function () {
                    if (scrolled) {
                        self_1.calculateRowWidth();
                    }
                    else {
                        self_1.setRowWidth(undefined);
                    }
                }, 0);
            });
        }
    };
    /**
     * @return {?}
     */
    OTableRowDirective.prototype.calculateRowWidth = /**
     * @return {?}
     */
    function () {
        if (!this.table.horizontalScroll) {
            return;
        }
        if (this.alreadyScrolled) {
            this.setRowWidth(this.table.rowWidth);
        }
        /** @type {?} */
        var totalWidth = 0;
        try {
            this.elementRef.nativeElement.childNodes.forEach(function (element) {
                if (element && element.tagName && element.tagName.toLowerCase() === 'mat-cell') {
                    totalWidth += element.clientWidth;
                }
            });
        }
        catch (error) {
            //
        }
        if (!isNaN(totalWidth) && totalWidth > 0) {
            totalWidth += 48;
            this.setRowWidth(totalWidth);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OTableRowDirective.prototype.setRowWidth = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var widthValue = value !== undefined ? value + 'px' : 'auto';
        this.renderer.setStyle(this.elementRef.nativeElement, 'width', widthValue);
        this.table.rowWidth = value;
    };
    Object.defineProperty(OTableRowDirective.prototype, "alreadyScrolled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.table.rowWidth !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    OTableRowDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[oTableRow]'
                },] },
    ];
    /** @nocollapse */
    OTableRowDirective.ctorParameters = function () { return [
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Renderer2 }
    ]; };
    return OTableRowDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OMatSort = /** @class */ (function (_super) {
    __extends(OMatSort, _super);
    function OMatSort() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.activeArray = [];
        _this.directionById = {};
        _this.oSortChange = new core.EventEmitter();
        return _this;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    OMatSort.prototype.setMultipleSort = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        this.multipleSort = val;
    };
    /**
     * @return {?}
     */
    OMatSort.prototype.getSortColumns = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var activeData = [];
        this.activeArray.forEach(function (s) {
            activeData.push({
                id: s.id,
                direction: _this.directionById[s.id]
            });
        });
        return activeData;
    };
    /**
     * @param {?} sortColArray
     * @return {?}
     */
    OMatSort.prototype.setTableInfo = /**
     * @param {?} sortColArray
     * @return {?}
     */
    function (sortColArray) {
        var _this = this;
        sortColArray.forEach(function (colData) {
            /** @type {?} */
            var sortDirection = colData.ascendent ? Codes.ASC_SORT : Codes.DESC_SORT;
            _this.activeArray.push({
                id: colData.columnName,
                start: sortDirection,
                disableClear: false
            });
            _this.directionById[colData.columnName] = sortDirection;
        });
    };
    /**
     * @param {?} sortable
     * @return {?}
     */
    OMatSort.prototype.addSortColumn = /**
     * @param {?} sortable
     * @return {?}
     */
    function (sortable) {
        if (this.isActive(sortable)) {
            // workaround for having a propper work in getNextSortDirection;
            this.direction = this.directionById[sortable.id];
            this.directionById[sortable.id] = this.getNextSortDirection(sortable);
            this.direction = '';
            if (this.directionById[sortable.id] === '') {
                this.deleteSortColumn(sortable.id);
            }
        }
        else {
            if (!this.multipleSort) {
                this.activeArray = [];
                this.directionById = {};
            }
            this.activeArray.push(sortable);
            this.directionById[sortable.id] = sortable.start ? sortable.start : this.start;
        }
        /** @type {?} */
        var activeData = this.getSortColumns();
        this._stateChanges.next();
        this.oSortChange.emit(activeData);
    };
    /**
     * @param {?} id
     * @return {?}
     */
    OMatSort.prototype.deleteSortColumn = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        delete this.directionById[id];
        for (var i = 0, len = this.activeArray.length; i < len; i++) {
            if (this.activeArray[i].id === id) {
                this.activeArray.splice(i, 1);
                break;
            }
        }
    };
    /**
     * @param {?} sortable
     * @return {?}
     */
    OMatSort.prototype.isActive = /**
     * @param {?} sortable
     * @return {?}
     */
    function (sortable) {
        return Util.isDefined(this.activeArray.find(function (s) { return sortable.id === s.id; }));
    };
    /**
     * @param {?} id
     * @return {?}
     */
    OMatSort.prototype.hasDirection = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var direction;
        if (Util.isDefined(this.directionById[id])) {
            direction = this.directionById[id];
        }
        return (direction === 'asc' || direction === 'desc');
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OMatSort.prototype.getSortedData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        /** @type {?} */
        var sortColumns = this.getSortColumns();
        if (sortColumns.length === 0 || data.length === 0) {
            return data;
        }
        this.sortables.forEach(function (value, key) {
            _this.deregister(value);
        });
        return this.sortByColumns(data, sortColumns);
    };
    /**
     * @param {?} data
     * @param {?} sortColumns
     * @return {?}
     */
    OMatSort.prototype.sortByColumns = /**
     * @param {?} data
     * @param {?} sortColumns
     * @return {?}
     */
    function (data, sortColumns) {
        /** @type {?} */
        var sortFunctionBind = this.sortFunction.bind(this);
        for (var i = 0, len = sortColumns.length; i < len; i++) {
            /** @type {?} */
            var sortC = sortColumns[i];
            this.activeSortColumn = sortC.id;
            this.activeSortDirection = sortC.direction;
            if (i === 0) {
                data = data.sort(sortFunctionBind);
            }
            else {
                /** @type {?} */
                var groupedData = this.getDataGrouped(data, sortColumns, i);
                if (groupedData.length >= data.length) {
                    break;
                }
                data = this.sortGroupedData(groupedData);
            }
        }
        return data;
    };
    /**
     * @param {?} data
     * @param {?} sortColumns
     * @param {?} index
     * @return {?}
     */
    OMatSort.prototype.getDataGrouped = /**
     * @param {?} data
     * @param {?} sortColumns
     * @param {?} index
     * @return {?}
     */
    function (data, sortColumns, index) {
        /** @type {?} */
        var propArr = [];
        sortColumns.forEach(function (item, i) {
            if (i < index) {
                propArr.push(item.id);
            }
        });
        if (propArr.length === 0) {
            return data;
        }
        /** @type {?} */
        var result = [];
        data.forEach(function (item) {
            /** @type {?} */
            var value = '';
            propArr.forEach(function (prop) {
                value += item[prop];
            });
            /** @type {?} */
            var filtered = result.filter(function (resItem) { return resItem.key === value; });
            if (filtered.length === 0) {
                result.push({
                    key: value,
                    values: [item]
                });
            }
            else if (filtered.length === 1) {
                filtered[0].values.push(item);
            }
        });
        return result;
    };
    /**
     * @param {?} groupedData
     * @return {?}
     */
    OMatSort.prototype.sortGroupedData = /**
     * @param {?} groupedData
     * @return {?}
     */
    function (groupedData) {
        /** @type {?} */
        var self = this;
        return groupedData.reduce(function (obj, item) {
            /** @type {?} */
            var arr = item.values;
            /** @type {?} */
            var sorted = arr.length <= 1 ? arr : arr.sort(self.sortFunction.bind(self));
            obj.push.apply(obj, sorted);
            return obj;
        }, []);
    };
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    OMatSort.prototype.sortFunction = /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (a, b) {
        var _a;
        /** @type {?} */
        var propertyA = '';
        /** @type {?} */
        var propertyB = '';
        _a = [a[this.activeSortColumn], b[this.activeSortColumn]], propertyA = _a[0], propertyB = _a[1];
        /** @type {?} */
        var valueA = typeof propertyA === 'undefined' ? '' : propertyA === '' ? propertyA : isNaN(+propertyA) ? propertyA.toString().trim().toLowerCase() : +propertyA;
        /** @type {?} */
        var valueB = typeof propertyB === 'undefined' ? '' : propertyB === '' ? propertyB : isNaN(+propertyB) ? propertyB.toString().trim().toLowerCase() : +propertyB;
        return (valueA <= valueB ? -1 : 1) * (this.activeSortDirection === 'asc' ? 1 : -1);
    };
    OMatSort.decorators = [
        { type: core.Directive, args: [{
                    selector: '[oMatSort]',
                    exportAs: 'oMatSort',
                    inputs: ['disabled: oMatSortDisabled']
                },] },
    ];
    OMatSort.propDecorators = {
        oSortChange: [{ type: core.Output, args: ['matSortChange',] }]
    };
    return OMatSort;
}(material.MatSort));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OMatSortHeader = /** @class */ (function (_super) {
    __extends(OMatSortHeader, _super);
    function OMatSortHeader(_intl, changeDetectorRef, _sort, _cdkColumnDef) {
        var _this = _super.call(this, _intl, changeDetectorRef, _sort, _cdkColumnDef) || this;
        _this._intl = _intl;
        _this._sort = _sort;
        _this._cdkColumnDef = _cdkColumnDef;
        return _this;
    }
    /**
     * @return {?}
     */
    OMatSortHeader.prototype._handleClick = /**
     * @return {?}
     */
    function () {
        if (this._isDisabled()) {
            return;
        }
        this._sort.addSortColumn(this);
        // Do not show the animation if the header was already shown in the right position.
        if (this._viewState.toState === 'hint' || this._viewState.toState === 'active') {
            this._disableViewStateAnimation = true;
        }
        /** @type {?} */
        var viewState = this._isSorted() ?
            { fromState: this._arrowDirection, toState: 'active' } :
            { fromState: 'active', toState: this._arrowDirection };
        this._setAnimationTransitionState(viewState);
        this._showIndicatorHint = false;
    };
    /**
     * @return {?}
     */
    OMatSortHeader.prototype._isSorted = /**
     * @return {?}
     */
    function () {
        return this._sort.isActive(this) && this._sort.hasDirection(this.id);
    };
    /**
     * @return {?}
     */
    OMatSortHeader.prototype._updateArrowDirection = /**
     * @return {?}
     */
    function () {
        this._arrowDirection = this._isSorted() ?
            this._sort.directionById[this.id] :
            (this.start || this._sort.start);
    };
    /**
     * @return {?}
     */
    OMatSortHeader.prototype.refresh = /**
     * @return {?}
     */
    function () {
        if (this._sort.isActive(this)) {
            this._setAnimationTransitionState({
                fromState: this._sort.directionById[this.id],
                toState: 'active'
            });
            this._showIndicatorHint = false;
        }
        else {
            this._viewState.toState = 'active';
            this._intl.changes.next();
        }
    };
    OMatSortHeader.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: '[o-mat-sort-header]',
                    exportAs: 'oMatSortHeader',
                    template: "\n    <div class=\"mat-sort-header-container\"\n         [class.mat-sort-header-sorted]=\"_isSorted()\"\n         [class.mat-sort-header-position-before]=\"arrowPosition == 'before'\">\n      <button class=\"mat-sort-header-button\" type=\"button\"\n              [attr.disabled]=\"_isDisabled() || null\"\n              [attr.aria-label]=\"_intl.sortButtonLabel(id)\"\n              (focus)=\"_setIndicatorHintVisible(true)\"\n              (blur)=\"_setIndicatorHintVisible(false)\">\n        <ng-content></ng-content>\n      </button>\n\n      <!-- Disable animations while a current animation is running -->\n      <div class=\"mat-sort-header-arrow\"\n           [@arrowOpacity]=\"_getArrowViewState()\"\n           [@arrowPosition]=\"_getArrowViewState()\"\n           [@allowChildren]=\"_getArrowDirectionState()\"\n           (@arrowPosition.start)=\"_disableViewStateAnimation = true\"\n           (@arrowPosition.done)=\"_disableViewStateAnimation = false\">\n        <div class=\"mat-sort-header-stem\"></div>\n        <div class=\"mat-sort-header-indicator\" [@indicator]=\"_getArrowDirectionState()\">\n          <div class=\"mat-sort-header-pointer-left\" [@leftPointer]=\"_getArrowDirectionState()\"></div>\n          <div class=\"mat-sort-header-pointer-right\" [@rightPointer]=\"_getArrowDirectionState()\"></div>\n          <div class=\"mat-sort-header-pointer-middle\"></div>\n        </div>\n      </div>\n    </div>\n  ",
                    styles: ["\n    .mat-sort-header-container{display:flex;cursor:pointer}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-position-before{flex-direction:row-reverse}.mat-sort-header-button{border:none;background:0 0;display:flex;align-items:center;padding:0;cursor:inherit;outline:0;font:inherit;color:currentColor}.mat-sort-header-arrow{height:12px;width:12px;min-width:12px;margin:0 0 0 6px;position:relative;display:flex}.mat-sort-header-position-before .mat-sort-header-arrow{margin:0 6px 0 0}.mat-sort-header-stem{background:currentColor;height:10px;width:2px;margin:auto;display:flex;align-items:center}.mat-sort-header-indicator{width:100%;height:2px;display:flex;align-items:center;position:absolute;top:0;left:0}.mat-sort-header-pointer-middle{margin:auto;height:2px;width:2px;background:currentColor;transform:rotate(45deg)}.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{background:currentColor;width:6px;height:2px;position:absolute;top:0}.mat-sort-header-pointer-left{transform-origin:right;left:0}.mat-sort-header-pointer-right{transform-origin:left;right:0}\n  "],
                    host: {
                        '(click)': '_handleClick()',
                        '(mouseenter)': '_setIndicatorHintVisible(true)',
                        '(longpress)': '_setIndicatorHintVisible(true)',
                        '(mouseleave)': '_setIndicatorHintVisible(false)',
                        '[attr.aria-sort]': '_getAriaSortAttribute()',
                        '[class.mat-sort-header-disabled]': '_isDisabled()',
                    },
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    inputs: ['disabled'],
                    animations: [
                        material.matSortAnimations.indicator,
                        material.matSortAnimations.leftPointer,
                        material.matSortAnimations.rightPointer,
                        material.matSortAnimations.arrowOpacity,
                        material.matSortAnimations.arrowPosition,
                        material.matSortAnimations.allowChildren,
                    ]
                },] },
    ];
    /** @nocollapse */
    OMatSortHeader.ctorParameters = function () { return [
        { type: material.MatSortHeaderIntl },
        { type: core.ChangeDetectorRef },
        { type: OMatSort, decorators: [{ type: core.Optional }] },
        { type: CdkColumnDef, decorators: [{ type: core.Optional }] }
    ]; };
    return OMatSortHeader;
}(material.MatSortHeader));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OMatSortModule = /** @class */ (function () {
    function OMatSortModule() {
    }
    OMatSortModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule],
                    exports: [OMatSort, OMatSortHeader],
                    declarations: [OMatSort, OMatSortHeader],
                    providers: [material.MAT_SORT_HEADER_INTL_PROVIDER]
                },] },
    ];
    return OMatSortModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OTableExpandedFooter = /** @class */ (function () {
    function OTableExpandedFooter(table, element, renderer, injector) {
        this.table = table;
        this.element = element;
        this.renderer = renderer;
        this.injector = injector;
        this.translateService = this.injector.get(OTranslateService$$1);
    }
    /**
     * @return {?}
     */
    OTableExpandedFooter.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.element.nativeElement.childNodes[2]) {
            this.tableBody = this.element.nativeElement.childNodes[1];
            this.tableHeader = this.element.nativeElement.childNodes[0];
        }
        this.registerContentChange();
    };
    /**
     * @return {?}
     */
    OTableExpandedFooter.prototype.registerContentChange = /**
     * @return {?}
     */
    function () {
        /** *
         * Create a tr with a td and inside put the message and add to tbody
         * <tr><td><span> {message}</span><td><tr>
          @type {?} */
        var tr = this.renderer.createElement('tr');
        this.tdTableWithMessage = this.renderer.createElement('td');
        this.renderer.addClass(tr, 'o-table-no-results');
        tr.appendChild(this.tdTableWithMessage);
        this.renderer.appendChild(this.tableBody, tr);
        /** @type {?} */
        var self = this;
        this.onContentChangeSubscription = this.table.onContentChange.subscribe(function (data) {
            self.updateMessageNotResults(data);
        });
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OTableExpandedFooter.prototype.updateMessageNotResults = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        //reset span message
        if (this.spanMessageNotResults) {
            this.renderer.removeChild(this.element.nativeElement, this.spanMessageNotResults);
        }
        //generate new message
        if (data.length === 0) {
            /** @type {?} */
            var result = '';
            result = this.translateService.get('TABLE.EMPTY');
            if (this.table.quickFilter && this.table.oTableQuickFilterComponent &&
                this.table.oTableQuickFilterComponent.value && this.table.oTableQuickFilterComponent.value.length > 0) {
                result += this.translateService.get('TABLE.EMPTY_USING_FILTER', [(this.table.oTableQuickFilterComponent.value)]);
                this.spanMessageNotResults = this.renderer.createElement('span');
                /** @type {?} */
                var messageNotResults = this.renderer.createText(result);
                this.tdTableWithMessage.setAttribute('colspan', this.tableHeader.querySelectorAll('th').length);
                this.renderer.appendChild(this.spanMessageNotResults, messageNotResults);
                this.renderer.appendChild(this.tdTableWithMessage, this.spanMessageNotResults);
            }
        }
    };
    // updateColspanTr() {
    // TODO
    //LAUNCH  WHEN HAVE OBSERVER OVER VISIBLE COLUMNS
    //   if (this.spanMessageNotResults) {
    //     this.td.setAttribute('colspan', this.tableHeader.querySelectorAll('th').length);
    //     this.renderer.appendChild(this.td, this.spanMessageNotResults);
    //   }
    // }
    /**
     * @return {?}
     */
    OTableExpandedFooter.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (this.onContentChangeSubscription) {
            this.onContentChangeSubscription.unsubscribe();
        }
    };
    OTableExpandedFooter.decorators = [
        { type: core.Directive, args: [{
                    selector: '[oTableExpandedFooter]'
                },] },
    ];
    /** @nocollapse */
    OTableExpandedFooter.ctorParameters = function () { return [
        { type: OTableComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OTableComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: core.Injector }
    ]; };
    return OTableExpandedFooter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var NAME_COLUMN_SELECT = 'select';
/** @type {?} */
var DEFAULT_INPUTS_O_TABLE = OServiceComponent$$1.DEFAULT_INPUTS_O_SERVICE_COMPONENT.concat([
    'visibleColumns: visible-columns',
    'sortColumns: sort-columns',
    'quickFilterCallback: quick-filter-function',
    'deleteButton: delete-button',
    'refreshButton: refresh-button',
    'columnsVisibilityButton: columns-visibility-button',
    'exportButton: export-button',
    'showButtonsText: show-buttons-text',
    'selectAllCheckbox: select-all-checkbox',
    'paginationControls: pagination-controls',
    'fixedHeader: fixed-header',
    'showTitle: show-title',
    'editionMode: edition-mode',
    'selectionMode: selection-mode',
    'horizontalScroll: horizontal-scroll',
    'showPaginatorFirstLastButtons: show-paginator-first-last-buttons',
    'autoAlignTitles: auto-align-titles',
    'multipleSort: multiple-sort',
    'selectAllCheckboxVisible: select-all-checkbox-visible',
    'orderable',
    'resizable',
    'enabled',
    'keepSelectedItems: keep-selected-items',
    'exportMode: export-mode'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_TABLE = [
    'onClick',
    'onDoubleClick',
    'onRowSelected',
    'onRowDeselected',
    'onRowDeleted',
    'onDataLoaded',
    'onPaginatedDataLoaded'
];
var OColumn = /** @class */ (function () {
    function OColumn(attr, table, column) {
        if (attr === void 0) { attr = undefined; }
        if (table === void 0) { table = undefined; }
        if (column === void 0) { column = undefined; }
        this.multilineSubject = new BehaviorSubject(this.multiline);
        this.isMultiline = this.multilineSubject.asObservable();
        this.attr = attr;
        if (Util.isDefined(table)) {
            this.setDefaultProperties(table);
        }
        if (Util.isDefined(column)) {
            this.setColumnProperties(column);
        }
    }
    /**
     * @param {?} table
     * @return {?}
     */
    OColumn.prototype.setDefaultProperties = /**
     * @param {?} table
     * @return {?}
     */
    function (table) {
        this.type = 'string';
        this.className = 'o-column-' + (this.type) + ' ';
        this.orderable = table.orderable;
        this.resizable = table.resizable;
        this.searchable = true;
        this.searching = true;
        // column without 'attr' should contain only renderers that do not depend on cell data, but row data (e.g. actions)
        this.name = this.attr;
        this.title = this.attr;
        this.multiline = false;
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OColumn.prototype.setColumnProperties = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        this.title = Util.isDefined(column.title) ? column.title : column.attr;
        this.definition = column;
        this.multiline = column.multiline;
        if (Util.isDefined(column.minWidth)) {
            this.minWidth = column.minWidth;
        }
        if (Util.isDefined(column.maxWidth)) {
            this.maxWidth = column.maxWidth;
        }
        if (Util.isDefined(column.orderable)) {
            this.orderable = column.orderable;
        }
        if (Util.isDefined(column.resizable)) {
            this.resizable = column.resizable;
        }
        if (Util.isDefined(column.searchable)) {
            this.searchable = column.searchable;
        }
        if (Util.isDefined(column.renderer)) {
            this.renderer = column.renderer;
        }
        if (Util.isDefined(column.editor)) {
            this.editor = column.editor;
        }
        if (Util.isDefined(column.type)) {
            this.type = column.type;
            this.className = 'o-column-' + (this.type) + ' ';
        }
        if (Util.isDefined(column.getSQLType)) {
            this.sqlType = column.getSQLType();
        }
        if (Util.isDefined(column.class)) {
            this.className = Util.isDefined(this.className) ? (this.className + ' ' + column.class) : column.class;
        }
        if (column instanceof OTableColumnCalculatedComponent) {
            if (Util.isDefined(column.operation) || Util.isDefined(column.functionOperation)) {
                this.calculate = column.operation ? column.operation : column.functionOperation;
            }
        }
        if (Util.isDefined(column.tooltip) && column.tooltip) {
            this.tooltip = {
                value: column.tooltipValue,
                function: column.tooltipFunction
            };
        }
    };
    Object.defineProperty(OColumn.prototype, "searchable", {
        get: /**
         * @return {?}
         */
        function () {
            return this._searchable;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._searchable = val;
            this.searching = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OColumn.prototype, "multiline", {
        get: /**
         * @return {?}
         */
        function () {
            return this._multiline;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            val = Util.parseBoolean(String(val));
            this._multiline = val;
            this.multilineSubject.next(this._multiline);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OColumn.prototype.hasTooltip = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this.tooltip);
    };
    /**
     * @param {?} rowData
     * @return {?}
     */
    OColumn.prototype.getTooltip = /**
     * @param {?} rowData
     * @return {?}
     */
    function (rowData) {
        if (!this.hasTooltip()) {
            return undefined;
        }
        /** @type {?} */
        var tooltip;
        if (Util.isDefined(this.tooltip.value)) {
            tooltip = this.tooltip.value;
        }
        else if (Util.isDefined(this.tooltip.function)) {
            try {
                tooltip = this.tooltip.function(rowData);
            }
            catch (e) {
                console.warn('o-table-column tooltip-function didnt worked');
            }
        }
        else {
            tooltip = Util.isDefined(this.renderer) ? this.renderer.getTooltip(rowData[this.name], rowData) : rowData[this.name];
        }
        return tooltip;
    };
    /**
     * @return {?}
     */
    OColumn.prototype.getMinWidth = /**
     * @return {?}
     */
    function () {
        if (Util.isDefined(this.width)) {
            return this.width;
        }
        return this.minWidth;
    };
    /**
     * @return {?}
     */
    OColumn.prototype.getMinWidthValue = /**
     * @return {?}
     */
    function () {
        return Util.extractPixelsValue(this.minWidth, OTableComponent.DEFAULT_COLUMN_MIN_WIDTH);
    };
    /**
     * @return {?}
     */
    OColumn.prototype.getMaxWidthValue = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var value = Util.extractPixelsValue(this.maxWidth);
        return value ? value : undefined;
    };
    /**
     * @return {?}
     */
    OColumn.prototype.getRenderWidth = /**
     * @return {?}
     */
    function () {
        if (Util.isDefined(this.width)) {
            return this.width;
        }
        /** @type {?} */
        var minValue = Util.extractPixelsValue(this.minWidth, OTableComponent.DEFAULT_COLUMN_MIN_WIDTH);
        if (Util.isDefined(minValue) && this.DOMWidth < minValue) {
            this.DOMWidth = minValue;
        }
        if (Util.isDefined(this.maxWidth)) {
            /** @type {?} */
            var maxValue = Util.extractPixelsValue(this.maxWidth);
            if (Util.isDefined(maxValue) && this.DOMWidth > maxValue) {
                this.DOMWidth = maxValue;
            }
        }
        return Util.isDefined(this.DOMWidth) ? (this.DOMWidth + 'px') : undefined;
    };
    Object.defineProperty(OColumn.prototype, "width", {
        get: /**
         * @return {?}
         */
        function () {
            return this._width;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var widthVal = val;
            /** @type {?} */
            var pxVal = Util.extractPixelsValue(val);
            if (Util.isDefined(pxVal)) {
                this.DOMWidth = pxVal;
                widthVal = undefined;
            }
            this._width = widthVal;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OColumn.prototype.getWidthToStore = /**
     * @return {?}
     */
    function () {
        return this._width || this.DOMWidth;
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OColumn.prototype.setWidth = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        this.width = val + 'px';
        this.DOMWidth = val;
    };
    /**
     * @return {?}
     */
    OColumn.prototype.getTitleAlignClass = /**
     * @return {?}
     */
    function () {
        if (Util.isDefined(this.definition)) {
            return this.definition.titleAlign || Codes.COLUMN_TITLE_ALIGN_CENTER;
        }
        // default title align
        return Codes.COLUMN_TITLE_ALIGN_CENTER;
    };
    return OColumn;
}());
/** @type {?} */
var SUFFIX_COLUMN_INSERTABLE = '_insertable';
var OTableOptions = /** @class */ (function () {
    function OTableOptions() {
        this.columns = [];
        this._visibleColumns = [];
        this.filter = true;
        this.filterCaseSensitive = false;
        this.selectColumn = new OColumn();
        this.selectColumn.name = NAME_COLUMN_SELECT;
        this.selectColumn.title = '';
        this.selectColumn.visible = false;
    }
    Object.defineProperty(OTableOptions.prototype, "visibleColumns", {
        get: /**
         * @return {?}
         */
        function () {
            return this._visibleColumns;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            var _this = this;
            this._visibleColumns = arg;
            this.columns.forEach(function (oCol) {
                oCol.visible = _this._visibleColumns.indexOf(oCol.attr) !== -1;
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableOptions.prototype, "columnsInsertables", {
        get: /**
         * @return {?}
         */
        function () {
            return this._visibleColumns.map(function (col) {
                return col + SUFFIX_COLUMN_INSERTABLE;
            });
        },
        enumerable: true,
        configurable: true
    });
    return OTableOptions;
}());
var 0$5 = dataServiceFactory;
var OTableComponent = /** @class */ (function (_super) {
    __extends(OTableComponent, _super);
    function OTableComponent(injector, elRef, dialog, form) {
        var _this = _super.call(this, injector, elRef, form) || this;
        _this.dialog = dialog;
        _this.selectAllCheckbox = false;
        _this.exportButton = true;
        _this.columnsVisibilityButton = true;
        _this.showButtonsText = true;
        _this._oTableOptions = new OTableOptions();
        _this.filterCaseSensitivePvt = false;
        _this.insertButton = true;
        _this.refreshButton = true;
        _this.deleteButton = true;
        _this.paginationControls = true;
        _this.fixedHeader = false;
        _this.showTitle = false;
        _this.editionMode = Codes.DETAIL_MODE_NONE;
        _this.selectionMode = Codes.SELECTION_MODE_MULTIPLE;
        _this.horizontalScroll = false;
        _this.showPaginatorFirstLastButtons = true;
        _this.autoAlignTitles = false;
        _this.multipleSort = true;
        _this.orderable = true;
        _this.resizable = true;
        _this._enabled = true;
        _this.keepSelectedItems = true;
        _this.exportMode = Codes.EXPORT_MODE_VISIBLE;
        /*parsed inputs variables */
        _this._visibleColArray = [];
        _this.sortColArray = [];
        _this.pendingQuery = false;
        _this.pendingQueryFilter = undefined;
        _this.setStaticData = false;
        _this.avoidQueryColumns = [];
        _this.asyncLoadColumns = [];
        _this.asyncLoadSubscriptions = {};
        _this.finishQuerySubscription = false;
        _this.onClick = new core.EventEmitter();
        _this.onDoubleClick = new core.EventEmitter();
        _this.onRowSelected = new core.EventEmitter();
        _this.onRowDeselected = new core.EventEmitter();
        _this.onRowDeleted = new core.EventEmitter();
        _this.onDataLoaded = new core.EventEmitter();
        _this.onPaginatedDataLoaded = new core.EventEmitter();
        _this.onReinitialize = new core.EventEmitter();
        _this.onContentChange = new core.EventEmitter();
        _this.showFilterByColumnIcon = false;
        _this.showTotalsSubject = new BehaviorSubject(false);
        _this.showTotals = _this.showTotalsSubject.asObservable();
        _this.loadingSortingSubject = new BehaviorSubject(false);
        _this.loadingSorting = _this.loadingSortingSubject.asObservable();
        _this.loadingScrollSubject = new BehaviorSubject(false);
        _this.loadingScroll = _this.loadingScrollSubject.asObservable();
        _this.showFirstInsertableRow = false;
        _this.showLastInsertableRow = false;
        _this.clickDelay = 200;
        _this.clickPrevent = false;
        _this._currentPage = 0;
        _this.onUpdateScrolledState = new core.EventEmitter();
        _this.storePaginationState = false;
        /* In the case the table havent paginationControl and pageable, the table has pagination virtual*/
        _this.pageScrollVirtual = 1;
        try {
            _this.tabGroupContainer = _this.injector.get(material.MatTabGroup);
            _this.tabContainer = _this.injector.get(material.MatTab);
        }
        catch (error) {
            // Do nothing due to not always is contained on tab.
        }
        _this.snackBarService = _this.injector.get(SnackBarService);
        _this.oTableStorage = new OTableStorage(_this);
        return _this;
    }
    Object.defineProperty(OTableComponent.prototype, "diameterSpinner", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var minHeight = OTableComponent.DEFAULT_BASE_SIZE_SPINNER;
            /** @type {?} */
            var height = 0;
            if (this.spinnerContainer && this.spinnerContainer.nativeElement) {
                height = this.spinnerContainer.nativeElement.offsetHeight;
            }
            if (height > 0 && height <= 100) {
                return Math.floor(height - (height * 0.1));
            }
            else {
                return minHeight;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableComponent.prototype, "oTableOptions", {
        get: /**
         * @return {?}
         */
        function () {
            return this._oTableOptions;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._oTableOptions = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableComponent.prototype, "quickFilter", {
        get: /**
         * @return {?}
         */
        function () {
            return this._quickFilter;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = Util.parseBoolean(String(value));
            this._quickFilter = value;
            this._oTableOptions.filter = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableComponent.prototype, "filterCaseSensitive", {
        get: /**
         * @return {?}
         */
        function () {
            return this.filterCaseSensitivePvt;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.filterCaseSensitivePvt = BooleanConverter(value);
            if (this._oTableOptions) {
                this._oTableOptions.filterCaseSensitive = this.filterCaseSensitivePvt;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableComponent.prototype, "enabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._enabled;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            val = Util.parseBoolean(String(val));
            this._enabled = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableComponent.prototype, "selectAllCheckboxVisible", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selectAllCheckboxVisible;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._selectAllCheckboxVisible = BooleanConverter(this.state['select-column-visible']) || BooleanConverter(value);
            this.oTableOptions.selectColumn.visible = this._selectAllCheckboxVisible;
            this.initializeCheckboxColumn();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableComponent.prototype, "originalVisibleColumns", {
        get: /**
         * @return {?}
         */
        function () {
            return this.visibleColumns;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableComponent.prototype, "originalSortColumns", {
        get: /**
         * @return {?}
         */
        function () {
            return this.sortColumns;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableComponent.prototype, "visibleColArray", {
        get: /**
         * @return {?}
         */
        function () {
            return this._visibleColArray;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            /** @type {?} */
            var permissionsBlocked = this.permissions ? this.permissions.columns.filter(function (col) { return col.visible === false; }).map(function (col) { return col.attr; }) : [];
            /** @type {?} */
            var permissionsChecked = arg.filter(function (value) { return permissionsBlocked.indexOf(value) === -1; });
            this._visibleColArray = permissionsChecked;
            if (this._oTableOptions) {
                /** @type {?} */
                var containsSelectionCol = this._oTableOptions.visibleColumns.indexOf(OTableComponent.NAME_COLUMN_SELECT) !== -1;
                if (containsSelectionCol) {
                    this._visibleColArray.unshift(OTableComponent.NAME_COLUMN_SELECT);
                }
                this._oTableOptions.visibleColumns = this._visibleColArray;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableComponent.prototype, "currentPage", {
        get: /**
         * @return {?}
         */
        function () {
            return this._currentPage;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._currentPage = val;
            if (this.paginator) {
                this.paginator.pageIndex = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableComponent.prototype.updateScrolledState = /**
     * @return {?}
     */
    function () {
        if (this.horizontalScroll) {
            /** @type {?} */
            var self_1 = this;
            setTimeout(function () {
                /** @type {?} */
                var bodyWidth = self_1.tableBodyEl.nativeElement.clientWidth;
                /** @type {?} */
                var scrollWidth = self_1.tableBodyEl.nativeElement.scrollWidth;
                /** @type {?} */
                var previousState = self_1.horizontalScrolled;
                self_1.horizontalScrolled = scrollWidth > bodyWidth;
                if (previousState !== self_1.horizontalScrolled) {
                    self_1.onUpdateScrolledState.emit(self_1.horizontalScrolled);
                }
            }, 0);
        }
        // if (this.resizable) {
        // }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.initialize();
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.afterViewInit();
        this.initTableAfterViewInit();
        if (this.oTableMenu) {
            this.matMenu = this.oTableMenu.matMenu;
            this.oTableMenu.registerOptions(this.tableOptions.toArray());
        }
        if (this.oTableButtons) {
            this.oTableButtons.registerButtons(this.tableButtons.toArray());
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy();
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getSuffixColumnInsertable = /**
     * @return {?}
     */
    function () {
        return SUFFIX_COLUMN_INSERTABLE;
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getActionsPermissions = /**
     * @return {?}
     */
    function () {
        return this.permissions ? (this.permissions.actions || []) : [];
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getMenuPermissions = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = this.permissions ? this.permissions.menu : undefined;
        return result ? result : {
            visible: true,
            enabled: true,
            items: []
        };
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OTableComponent.prototype.getOColumnPermissions = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        /** @type {?} */
        var columns = this.permissions ? (this.permissions.columns || []) : [];
        return columns.find(function (comp) { return comp.attr === attr; }) || { attr: attr, enabled: true, visible: true };
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OTableComponent.prototype.getActionPermissions = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        /** @type {?} */
        var actionsPerm = this.permissions ? (this.permissions.actions || []) : [];
        /** @type {?} */
        var permissions = actionsPerm.find(function (p) { return p.attr === attr; });
        return permissions || {
            attr: attr,
            visible: true,
            enabled: true
        };
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OTableComponent.prototype.checkEnabledActionPermission = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        /** @type {?} */
        var actionsPerm = this.permissions ? (this.permissions.actions || []) : [];
        /** @type {?} */
        var permissions = actionsPerm.find(function (p) { return p.attr === attr; });
        /** @type {?} */
        var enabledPermision = PermissionsUtils.checkEnabledPermission(permissions);
        if (!enabledPermision) {
            this.snackBarService.open('MESSAGES.OPERATION_NOT_ALLOWED_PERMISSION');
        }
        return enabledPermision;
    };
    /**
     * Method what initialize vars and configuration
     */
    /**
     * Method what initialize vars and configuration
     * @return {?}
     */
    OTableComponent.prototype.initialize = /**
     * Method what initialize vars and configuration
     * @return {?}
     */
    function () {
        _super.prototype.initialize.call(this);
        if (this.tabGroupContainer && this.tabContainer) {
            this.registerTabListener();
        }
        // Initialize params of the table
        this.initializeParams();
        this.initializeDao();
        this.permissions = this.permissionsService.getTablePermissions(this.oattr, this.actRoute);
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.initializeDao = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var queryMethodName = this.pageable ? this.paginatedQueryMethod : this.queryMethod;
        /** @type {?} */
        var methods = {
            query: queryMethodName,
            update: this.updateMethod,
            delete: this.deleteMethod,
            insert: this.insertMethod
        };
        if (this.staticData) {
            this.queryOnBind = false;
            this.queryOnInit = false;
            this.daoTable = new OTableDao(undefined, this.entity, methods);
            this.setDataArray(this.staticData);
        }
        else {
            this.configureService();
            this.daoTable = new OTableDao(this.dataService, this.entity, methods);
        }
    };
    /**
     * @param {?} options
     * @return {?}
     */
    OTableComponent.prototype.reinitialize = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        if (options) {
            /** @type {?} */
            var clonedOpts = Object.assign({}, options);
            if (clonedOpts.hasOwnProperty('entity')) {
                this.entity = clonedOpts.entity;
            }
            if (clonedOpts.hasOwnProperty('service')) {
                this.service = clonedOpts.service;
            }
            if (clonedOpts.hasOwnProperty('columns')) {
                this.columns = clonedOpts.columns;
            }
            if (clonedOpts.hasOwnProperty('visibleColumns')) {
                this.visibleColumns = clonedOpts.visibleColumns;
            }
            if (clonedOpts.hasOwnProperty('keys')) {
                this.keys = clonedOpts.keys;
            }
            if (clonedOpts.hasOwnProperty('sortColumns')) {
                this.sortColumns = clonedOpts.sortColumns;
            }
            if (clonedOpts.hasOwnProperty('parentKeys')) {
                this.parentKeys = clonedOpts.parentKeys;
            }
        }
        this.destroy();
        this.initialize();
        this.initTableAfterViewInit();
        this.onReinitialize.emit(null);
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.initTableAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.parseVisibleColumns();
        this.setDatasource();
        this.registerDataSourceListeners();
        this.parseSortColumns();
        this.registerSortListener();
        this.setFiltersConfiguration(this.state);
        this.addDefaultRowButtons();
        if (this.queryOnInit) {
            this.queryData();
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.destroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.destroy.call(this);
        if (this.tabGroupChangeSubscription) {
            this.tabGroupChangeSubscription.unsubscribe();
        }
        if (this.selectionChangeSubscription) {
            this.selectionChangeSubscription.unsubscribe();
        }
        if (this.sortSubscription) {
            this.sortSubscription.unsubscribe();
        }
        if (this.onRenderedDataChange) {
            this.onRenderedDataChange.unsubscribe();
        }
        if (this.contextMenuSubscription) {
            this.contextMenuSubscription.unsubscribe();
        }
        Object.keys(this.asyncLoadSubscriptions).forEach(function (idx) {
            if (_this.asyncLoadSubscriptions[idx]) {
                _this.asyncLoadSubscriptions[idx].unsubscribe();
            }
        });
    };
    /**
     * Method update store localstorage, call of the ILocalStorage
     */
    /**
     * Method update store localstorage, call of the ILocalStorage
     * @return {?}
     */
    OTableComponent.prototype.getDataToStore = /**
     * Method update store localstorage, call of the ILocalStorage
     * @return {?}
     */
    function () {
        return this.oTableStorage.getDataToStore();
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    OTableComponent.prototype.registerQuickFilter = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        /** @type {?} */
        var quickFilter = (/** @type {?} */ (arg));
        // forcing quickFilterComponent to be undefined, table uses oTableQuickFilterComponent
        this.quickFilterComponent = undefined;
        this.oTableQuickFilterComponent = quickFilter;
        this.oTableQuickFilterComponent.setValue(this.state['filter'], false);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OTableComponent.prototype.registerPagination = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.paginationControls = true;
        this.paginator = value;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OTableComponent.prototype.registerContextMenu = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        this.tableContextMenu = value;
        /** @type {?} */
        var self = this;
        this.contextMenuSubscription = this.tableContextMenu.onShow.subscribe(function (params) {
            params.class = 'o-table-context-menu ' + _this.rowHeight;
            if (params.data && !self.selection.isSelected(params.data.rowValue)) {
                self.clearSelection();
                self.selectedRow(params.data.rowValue);
            }
        });
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableComponent.prototype.registerDefaultColumn = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        if (Util.isDefined(this.getOColumn(column))) {
            // a default column definition trying to replace an already existing definition
            return;
        }
        /** @type {?} */
        var colDef = new OColumn(column, this);
        this.pushOColumnDefinition(colDef);
    };
    /**
     * Store all columns and properties in var columnsArray
     * @param column
     */
    /**
     * Store all columns and properties in var columnsArray
     * @param {?} column
     * @return {?}
     */
    OTableComponent.prototype.registerColumn = /**
     * Store all columns and properties in var columnsArray
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var columnAttr = (typeof column === 'string') ? column : column.attr;
        /** @type {?} */
        var columnPermissions = this.getOColumnPermissions(columnAttr);
        if (!columnPermissions.visible) {
            return;
        }
        if (typeof column === 'string') {
            this.registerDefaultColumn(column);
            return;
        }
        /** @type {?} */
        var columnDef = this.getOColumn(column.attr);
        if (Util.isDefined(columnDef) && Util.isDefined(columnDef.definition)) {
            // a o-table-column definition trying to replace an already existing o-table-column definition
            return;
        }
        /** @type {?} */
        var colDef = new OColumn(column.attr, this, column);
        /** @type {?} */
        var columnWidth = column.width;
        /** @type {?} */
        var storedCols = this.state['oColumns-display'];
        if (Util.isDefined(storedCols)) {
            /** @type {?} */
            var storedData_1 = storedCols.find(function (oCol) { return oCol.attr === colDef.attr; });
            if (Util.isDefined(storedData_1) && Util.isDefined(storedData_1.width)) {
                // check that the width of the columns saved in the initial configuration
                // in the local storage is different from the original value
                if (this.state.hasOwnProperty('initial-configuration')) {
                    if (this.state['initial-configuration'].hasOwnProperty('oColumns-display')) {
                        /** @type {?} */
                        var initialStoredCols = this.state['initial-configuration']['oColumns-display'];
                        initialStoredCols.forEach(function (element) {
                            if (colDef.attr === element.attr && element.width === colDef.definition.originalWidth) {
                                columnWidth = storedData_1.width;
                            }
                        });
                    }
                    else {
                        columnWidth = storedData_1.width;
                    }
                }
            }
        }
        if (Util.isDefined(columnWidth)) {
            colDef.width = columnWidth;
        }
        if (column && (column.asyncLoad || column.type === 'action')) {
            this.avoidQueryColumns.push(column.attr);
            if (column.asyncLoad) {
                this.asyncLoadColumns.push(column.attr);
            }
        }
        this.pushOColumnDefinition(colDef);
    };
    /**
     * @param {?} colDef
     * @return {?}
     */
    OTableComponent.prototype.pushOColumnDefinition = /**
     * @param {?} colDef
     * @return {?}
     */
    function (colDef) {
        colDef.visible = (this._visibleColArray.indexOf(colDef.attr) !== -1);
        /** @type {?} */
        var alreadyExisting = this.getOColumn(colDef.attr);
        if (alreadyExisting !== undefined) {
            /** @type {?} */
            var replacingIndex = this._oTableOptions.columns.indexOf(alreadyExisting);
            this._oTableOptions.columns[replacingIndex] = colDef;
        }
        else {
            this._oTableOptions.columns.push(colDef);
        }
        this.refreshEditionModeWarn();
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.refreshEditionModeWarn = /**
     * @return {?}
     */
    function () {
        if (this.editionMode !== Codes.DETAIL_MODE_NONE) {
            return;
        }
        /** @type {?} */
        var editableColumns = this.oTableOptions.columns.filter(function (col) {
            return Util.isDefined(col.editor);
        });
        if (editableColumns.length > 0) {
            console.warn('Using a column with a editor but there is no edition-mode defined');
        }
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableComponent.prototype.registerColumnAggregate = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        this.showTotalsSubject.next(true);
        /** @type {?} */
        var alreadyExisting = this.getOColumn(column.attr);
        if (alreadyExisting !== undefined) {
            /** @type {?} */
            var replacingIndex = this._oTableOptions.columns.indexOf(alreadyExisting);
            this._oTableOptions.columns[replacingIndex].aggregate = column;
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.parseVisibleColumns = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.state.hasOwnProperty('oColumns-display')) {
            /** @type {?} */
            var stateCols_1 = [];
            /** @type {?} */
            var self_2 = this;
            this.state['oColumns-display'].forEach(function (oCol, index) {
                /** @type {?} */
                var isVisibleColInColumns = self_2._oTableOptions.columns.find(function (col) { return col.attr === oCol.attr; }) !== undefined;
                if (isVisibleColInColumns) {
                    stateCols_1.push(oCol);
                }
                else {
                    console.warn('Unable to load the column ' + oCol.attr + ' from the localstorage');
                }
            });
            stateCols_1 = this.checkChangesVisibleColummnsInInitialConfiguration(stateCols_1);
            this.visibleColArray = stateCols_1.filter(function (item) { return item.visible; }).map(function (item) { return item.attr; });
        }
        else {
            this.visibleColArray = Util.parseArray(this.visibleColumns, true);
            this._oTableOptions.columns.sort(function (a, b) { return _this.visibleColArray.indexOf(a.attr) - _this.visibleColArray.indexOf(b.attr); });
        }
    };
    /**
     * @param {?} stateCols
     * @return {?}
     */
    OTableComponent.prototype.checkChangesVisibleColummnsInInitialConfiguration = /**
     * @param {?} stateCols
     * @return {?}
     */
    function (stateCols) {
        /** @type {?} */
        var self = this;
        if (this.state.hasOwnProperty('initial-configuration')) {
            if (this.state['initial-configuration'].hasOwnProperty('oColumns-display')) {
                /** @type {?} */
                var originalVisibleColArray = this.state['initial-configuration']['oColumns-display'].map(function (x) {
                    if (x.visible === true) {
                        return x.attr;
                    }
                });
                /** @type {?} */
                var visibleColArray = Util.parseArray(this.originalVisibleColumns, true);
                /** @type {?} */
                var colToAddInVisibleCol_1 = Util.differenceArrays(visibleColArray, originalVisibleColArray);
                if (colToAddInVisibleCol_1.length > 0) {
                    colToAddInVisibleCol_1.forEach(function (colAdd, index) {
                        if (stateCols.filter(function (col) { return col.attr === colAdd; }).length > 0) {
                            stateCols = stateCols.map(function (col) {
                                if (colToAddInVisibleCol_1.indexOf(col.attr) > -1) {
                                    col.visible = true;
                                }
                                return col;
                            });
                        }
                        else {
                            self.colArray.forEach(function (element, i) {
                                if (element === colAdd) {
                                    stateCols.splice(i + 1, 0, {
                                        attr: colAdd,
                                        visible: true,
                                        width: undefined
                                    });
                                }
                            });
                        }
                    });
                }
                /** @type {?} */
                var colToDeleteInVisibleCol_1 = Util.differenceArrays(originalVisibleColArray, visibleColArray);
                if (colToDeleteInVisibleCol_1.length > 0) {
                    stateCols = stateCols.map(function (col) {
                        if (colToDeleteInVisibleCol_1.indexOf(col.attr) > -1) {
                            col.visible = false;
                        }
                        return col;
                    });
                }
            }
        }
        return stateCols;
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.parseSortColumns = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var sortColumnsParam = this.state['sort-columns'] || this.sortColumns;
        this.sortColArray = ServiceUtils$$1.parseSortColumns(sortColumnsParam);
        //checking the original sort columns with the sort columns in initial configuration in local storage
        if (this.state['sort-columns'] && this.state['initial-configuration']['sort-columns']) {
            /** @type {?} */
            var initialConfigSortColumnsArray = ServiceUtils$$1.parseSortColumns(this.state['initial-configuration']['sort-columns']);
            /** @type {?} */
            var originalSortColumnsArray = ServiceUtils$$1.parseSortColumns(this.originalSortColumns);
            /** @type {?} */
            var self_3 = this;
            /** @type {?} */
            var colToAddInVisibleCol = Util.differenceArrays(originalSortColumnsArray, initialConfigSortColumnsArray);
            if (colToAddInVisibleCol.length > 0) {
                colToAddInVisibleCol.forEach(function (colAdd) {
                    self_3.sortColArray.push(colAdd);
                });
            }
            /** @type {?} */
            var colToDelInVisibleCol = Util.differenceArrays(initialConfigSortColumnsArray, originalSortColumnsArray);
            if (colToDelInVisibleCol.length > 0) {
                colToDelInVisibleCol.forEach(function (colDel) {
                    self_3.sortColArray.forEach(function (col, i) {
                        if (col.columnName === colDel.columnName) {
                            self_3.sortColArray.splice(i, 1);
                        }
                    });
                });
            }
        }
        // ensuring column existence and checking its orderable state
        for (var i = this.sortColArray.length - 1; i >= 0; i--) {
            /** @type {?} */
            var colName = this.sortColArray[i].columnName;
            /** @type {?} */
            var oCol = this.getOColumn(colName);
            if (!Util.isDefined(oCol) || !oCol.orderable) {
                this.sortColArray.splice(i, 1);
            }
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.initializeParams = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // If visible-columns is not present then visible-columns is all columns
        if (!this.visibleColumns) {
            this.visibleColumns = this.columns;
        }
        if (this.colArray.length) {
            this.colArray.forEach(function (x) { return _this.registerColumn(x); });
            /** @type {?} */
            var columnsOrder_1 = [];
            if (this.state.hasOwnProperty('oColumns-display')) {
                columnsOrder_1 = this.state['oColumns-display'].map(function (item) { return item.attr; });
            }
            else {
                columnsOrder_1 = this.colArray.filter(function (attr) { return _this.visibleColArray.indexOf(attr) === -1; });
                columnsOrder_1.push.apply(columnsOrder_1, this.visibleColArray);
            }
            this._oTableOptions.columns.sort(function (a, b) {
                if (columnsOrder_1.indexOf(a.attr) === -1) {
                    //if it is not in local storage because it is new, keep order
                    return 0;
                }
                else {
                    return columnsOrder_1.indexOf(a.attr) - columnsOrder_1.indexOf(b.attr);
                }
            });
        }
        // Initialize quickFilter
        this._oTableOptions.filter = this.quickFilter;
        if (this.state.hasOwnProperty('currentPage')) {
            this.currentPage = this.state['currentPage'];
        }
        // Initialize paginator
        if (!this.paginator && this.paginationControls) {
            this.paginator = new OTablePaginatorComponent(this.injector, this);
        }
        if (!Util.isDefined(this.selectAllCheckboxVisible)) {
            this._oTableOptions.selectColumn.visible = !!this.state['select-column-visible'];
        }
        else {
            //checking the original selectAllCheckboxVisible with select-column-visible in initial configuration in local storage
            if (this.state.hasOwnProperty('initial-configuration') && this.state['initial-configuration'].hasOwnProperty('select-column-visible')
                && this.selectAllCheckboxVisible === this.state['initial-configuration']['select-column-visible']) {
                this._oTableOptions.selectColumn.visible = !!this.state['select-column-visible'];
            }
            else {
                this._oTableOptions.selectColumn.visible = this.selectAllCheckboxVisible;
            }
        }
        this.initializeCheckboxColumn();
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.registerTabListener = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        this.tabGroupChangeSubscription = this.tabGroupContainer.selectedTabChange.subscribe(function (evt) {
            /** @type {?} */
            var interval$$1;
            /** @type {?} */
            var timerCallback = function (tab) {
                if (tab && tab.content.isAttached) {
                    clearInterval(interval$$1);
                    if (tab === self.tabContainer) {
                        self.insideTabBugWorkaround();
                        if (self.pendingQuery) {
                            self.queryData(self.pendingQueryFilter);
                        }
                    }
                }
            };
            interval$$1 = setInterval(function () { timerCallback(evt.tab); }, 100);
        });
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.insideTabBugWorkaround = /**
     * @return {?}
     */
    function () {
        this.sortHeaders.forEach(function (sortH) {
            sortH.refresh();
        });
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.registerSortListener = /**
     * @return {?}
     */
    function () {
        if (Util.isDefined(this.sort)) {
            this.sortSubscription = this.sort.oSortChange.subscribe(this.onSortChange.bind(this));
            this.sort.setMultipleSort(this.multipleSort);
            if (Util.isDefined(this._oTableOptions.columns) && (this.sortColArray.length > 0)) {
                this.sort.setTableInfo(this.sortColArray);
            }
        }
    };
    /**
     * @param {?} sortArray
     * @return {?}
     */
    OTableComponent.prototype.onSortChange = /**
     * @param {?} sortArray
     * @return {?}
     */
    function (sortArray) {
        var _this = this;
        this.sortColArray = [];
        sortArray.forEach(function (sort) {
            if (sort.direction !== '') {
                _this.sortColArray.push({
                    columnName: sort.id,
                    ascendent: sort.direction === Codes.ASC_SORT
                });
            }
        });
        if (this.pageable) {
            this.reloadData();
        }
        else {
            this.loadingSortingSubject.next(true);
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.setDatasource = /**
     * @return {?}
     */
    function () {
        this.dataSource = new OTableDataSource(this);
        if (this.daoTable) {
            this.dataSource.resultsLength = this.daoTable.data.length;
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.registerDataSourceListeners = /**
     * @return {?}
     */
    function () {
        if (!this.pageable) {
            /** @type {?} */
            var self_4 = this;
            this.onRenderedDataChange = this.dataSource.onRenderedDataChange.subscribe(function () {
                setTimeout(function () {
                    self_4.loadingSortingSubject.next(false);
                }, 500);
            });
        }
    };
    Object.defineProperty(OTableComponent.prototype, "showLoading", {
        get: /**
         * @return {?}
         */
        function () {
            return combineLatest(this.loading, this.loadingSorting, this.loadingScroll, function (x, y, z) { return (x || y || z); });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * This method manages the call to the service
     * @param filter
     * @param ovrrArgs
     */
    /**
     * This method manages the call to the service
     * @param {?=} filter
     * @param {?=} ovrrArgs
     * @return {?}
     */
    OTableComponent.prototype.queryData = /**
     * This method manages the call to the service
     * @param {?=} filter
     * @param {?=} ovrrArgs
     * @return {?}
     */
    function (filter$$1, ovrrArgs) {
        if (filter$$1 === void 0) { filter$$1 = undefined; }
        // If tab exists and is not active then wait for queryData
        if (this.isInsideInactiveTab()) {
            this.pendingQuery = true;
            this.pendingQueryFilter = filter$$1;
            return;
        }
        this.pendingQuery = false;
        this.pendingQueryFilter = undefined;
        _super.prototype.queryData.call(this, filter$$1, ovrrArgs);
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.isInsideInactiveTab = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = false;
        if (this.tabContainer && this.tabGroupContainer) {
            result = !(this.tabContainer.isActive || (this.tabGroupContainer.selectedIndex === this.tabContainer.position));
        }
        return result;
    };
    /**
     * @param {?=} existingFilter
     * @return {?}
     */
    OTableComponent.prototype.getComponentFilter = /**
     * @param {?=} existingFilter
     * @return {?}
     */
    function (existingFilter) {
        if (existingFilter === void 0) { existingFilter = {}; }
        /** @type {?} */
        var filter$$1 = existingFilter;
        if (this.pageable) {
            if (Object.keys(filter$$1).length > 0) {
                /** @type {?} */
                var parentItemExpr = FilterExpressionUtils.buildExpressionFromObject(filter$$1);
                filter$$1 = {};
                filter$$1[FilterExpressionUtils.FILTER_EXPRESSION_KEY] = parentItemExpr;
            }
            /** @type {?} */
            var beColFilter = this.getColumnFiltersExpression();
            // Add column filters basic expression to current filter
            if (beColFilter && !Util.isDefined(filter$$1[FilterExpressionUtils.FILTER_EXPRESSION_KEY])) {
                filter$$1[FilterExpressionUtils.FILTER_EXPRESSION_KEY] = beColFilter;
            }
            else if (beColFilter) {
                filter$$1[FilterExpressionUtils.FILTER_EXPRESSION_KEY] =
                    FilterExpressionUtils.buildComplexExpression(filter$$1[FilterExpressionUtils.FILTER_EXPRESSION_KEY], beColFilter, FilterExpressionUtils.OP_AND);
            }
        }
        return _super.prototype.getComponentFilter.call(this, filter$$1);
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getQuickFilterExpression = /**
     * @return {?}
     */
    function () {
        if (Util.isDefined(this.oTableQuickFilterComponent)) {
            return this.oTableQuickFilterComponent.filterExpression;
        }
        return undefined;
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getColumnFiltersExpression = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var columnFilters = this.dataSource.getColumnValueFilters();
        /** @type {?} */
        var beColumnFilters = [];
        columnFilters.forEach(function (colFilter) {
            // Prepare basic expressions
            switch (colFilter.operator) {
                case ColumnValueFilterOperator.IN:
                    if (Util.isArray(colFilter.values)) {
                        /** @type {?} */
                        var besIn = colFilter.values.map(function (value) { return FilterExpressionUtils.buildExpressionEquals(colFilter.attr, value); });
                        /** @type {?} */
                        var beIn_1 = besIn.pop();
                        besIn.forEach(function (be) {
                            beIn_1 = FilterExpressionUtils.buildComplexExpression(beIn_1, be, FilterExpressionUtils.OP_OR);
                        });
                        beColumnFilters.push(beIn_1);
                    }
                    break;
                case ColumnValueFilterOperator.BETWEEN:
                    if (Util.isArray(colFilter.values) && colFilter.values.length === 2) {
                        /** @type {?} */
                        var beFrom = FilterExpressionUtils.buildExpressionLessEqual(colFilter.attr, colFilter.values[0]);
                        /** @type {?} */
                        var beTo = FilterExpressionUtils.buildExpressionMoreEqual(colFilter.attr, colFilter.values[1]);
                        beColumnFilters.push(FilterExpressionUtils.buildComplexExpression(beFrom, beTo, FilterExpressionUtils.OP_AND));
                    }
                    break;
                case ColumnValueFilterOperator.EQUAL:
                    beColumnFilters.push(FilterExpressionUtils.buildExpressionLike(colFilter.attr, colFilter.values));
                    break;
                case ColumnValueFilterOperator.LESS_EQUAL:
                    beColumnFilters.push(FilterExpressionUtils.buildExpressionLessEqual(colFilter.attr, colFilter.values));
                    break;
                case ColumnValueFilterOperator.MORE_EQUAL:
                    beColumnFilters.push(FilterExpressionUtils.buildExpressionMoreEqual(colFilter.attr, colFilter.values));
                    break;
            }
        });
        /** @type {?} */
        var beColFilter = beColumnFilters.pop();
        beColumnFilters.forEach(function (be) {
            beColFilter = FilterExpressionUtils.buildComplexExpression(beColFilter, be, FilterExpressionUtils.OP_AND);
        });
        return beColFilter;
    };
    /**
     * @param {?} queryRes
     * @return {?}
     */
    OTableComponent.prototype.updatePaginationInfo = /**
     * @param {?} queryRes
     * @return {?}
     */
    function (queryRes) {
        _super.prototype.updatePaginationInfo.call(this, queryRes);
    };
    /**
     * @param {?} data
     * @param {?} sqlTypes
     * @return {?}
     */
    OTableComponent.prototype.setData = /**
     * @param {?} data
     * @param {?} sqlTypes
     * @return {?}
     */
    function (data, sqlTypes) {
        this.daoTable.sqlTypesChange.next(sqlTypes);
        this.daoTable.setDataArray(data);
        this.updateScrolledState();
        if (this.pageable) {
            ObservableWrapper.callEmit(this.onPaginatedDataLoaded, data);
        }
        ObservableWrapper.callEmit(this.onDataLoaded, this.daoTable.data);
    };
    /**
     * @param {?} error
     * @param {?=} errorOptional
     * @return {?}
     */
    OTableComponent.prototype.showDialogError = /**
     * @param {?} error
     * @param {?=} errorOptional
     * @return {?}
     */
    function (error, errorOptional) {
        if (Util.isDefined(error) && !Util.isObject(error)) {
            this.dialogService.alert('ERROR', error);
        }
        else {
            this.dialogService.alert('ERROR', errorOptional);
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.projectContentChanged = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var self = this;
        setTimeout(function () {
            self.loadingSortingSubject.next(false);
        }, 500);
        this.loadingScrollSubject.next(false);
        if (this.previousRendererData !== this.dataSource.renderedData) {
            ObservableWrapper.callEmit(this.onContentChange, this.dataSource.renderedData);
            this.previousRendererData = this.dataSource.renderedData;
        }
        this.getColumnsWidthFromDOM();
        if (this.state.hasOwnProperty('selection') && this.dataSource.renderedData.length > 0 && this.getSelectedItems().length === 0) {
            this.state.selection.forEach(function (selectedItem) {
                /** @type {?} */
                var foundItem = _this.dataSource.renderedData.find(function (data) {
                    /** @type {?} */
                    var result = true;
                    Object.keys(selectedItem).forEach(function (key) {
                        result = result && (data[key] === selectedItem[key]);
                    });
                    return result;
                });
                if (foundItem) {
                    _this.selection.select(foundItem);
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getAttributesValuesToQuery = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var columns = _super.prototype.getAttributesValuesToQuery.call(this);
        if (this.avoidQueryColumns.length > 0) {
            for (var i = columns.length - 1; i >= 0; i--) {
                /** @type {?} */
                var col = columns[i];
                if (this.avoidQueryColumns.indexOf(col) !== -1) {
                    columns.splice(i, 1);
                }
            }
        }
        return columns;
    };
    /**
     * @param {?} filter
     * @param {?=} ovrrArgs
     * @return {?}
     */
    OTableComponent.prototype.getQueryArguments = /**
     * @param {?} filter
     * @param {?=} ovrrArgs
     * @return {?}
     */
    function (filter$$1, ovrrArgs) {
        /** @type {?} */
        var queryArguments = _super.prototype.getQueryArguments.call(this, filter$$1, ovrrArgs);
        queryArguments[3] = this.getSqlTypesForFilter(queryArguments[1]);
        Object.assign(queryArguments[3], ovrrArgs ? ovrrArgs.sqltypes || {} : {});
        if (this.pageable) {
            queryArguments[5] = this.paginator.isShowingAllRows(queryArguments[5]) ? this.state.totalQueryRecordsNumber : queryArguments[5];
            queryArguments[6] = this.sortColArray;
        }
        return queryArguments;
    };
    /**
     * @param {?} filter
     * @return {?}
     */
    OTableComponent.prototype.getSqlTypesForFilter = /**
     * @param {?} filter
     * @return {?}
     */
    function (filter$$1) {
        /** @type {?} */
        var allSqlTypes = {};
        this._oTableOptions.columns.forEach(function (col) {
            if (col.sqlType) {
                allSqlTypes[col.attr] = col.sqlType;
            }
        });
        Object.assign(allSqlTypes, this.getSqlTypes());
        /** @type {?} */
        var filterCols = Util.getValuesFromObject(filter$$1);
        /** @type {?} */
        var sqlTypes = {};
        Object.keys(allSqlTypes).forEach(function (key) {
            if (filterCols.indexOf(key) !== -1 && allSqlTypes[key] !== SQLTypes.OTHER) {
                sqlTypes[key] = allSqlTypes[key];
            }
        });
        return sqlTypes;
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.onExportButtonClicked = /**
     * @return {?}
     */
    function () {
        if (this.oTableMenu) {
            this.oTableMenu.onExportButtonClicked();
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.onChangeColumnsVisibilityClicked = /**
     * @return {?}
     */
    function () {
        if (this.oTableMenu) {
            this.oTableMenu.onChangeColumnsVisibilityClicked();
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.onMatTableContentChanged = /**
     * @return {?}
     */
    function () {
        //
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.add = /**
     * @return {?}
     */
    function () {
        if (!this.checkEnabledActionPermission(PermissionsUtils.ACTION_INSERT)) {
            return;
        }
        _super.prototype.insertDetail.call(this);
    };
    /**
     * @param {?=} clearSelectedItems
     * @return {?}
     */
    OTableComponent.prototype.remove = /**
     * @param {?=} clearSelectedItems
     * @return {?}
     */
    function (clearSelectedItems) {
        var _this = this;
        if (clearSelectedItems === void 0) { clearSelectedItems = false; }
        if (!this.checkEnabledActionPermission(PermissionsUtils.ACTION_DELETE)) {
            return;
        }
        /** @type {?} */
        var selectedItems = this.getSelectedItems();
        if (selectedItems.length > 0) {
            this.dialogService.confirm('CONFIRM', 'MESSAGES.CONFIRM_DELETE').then(function (res) {
                if (res === true) {
                    if (_this.dataService && (_this.deleteMethod in _this.dataService) && _this.entity && (_this.keysArray.length > 0)) {
                        /** @type {?} */
                        var filters = ServiceUtils$$1.getArrayProperties(selectedItems, _this.keysArray);
                        _this.daoTable.removeQuery(filters).subscribe(function (res) {
                            ObservableWrapper.callEmit(_this.onRowDeleted, selectedItems);
                        }, function (error) {
                            _this.showDialogError(error, 'MESSAGES.ERROR_DELETE');
                        }, function () {
                            _this.reloadData();
                        });
                    }
                    else {
                        _this.deleteLocalItems();
                    }
                }
                else if (clearSelectedItems) {
                    _this.clearSelection();
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.refresh = /**
     * @return {?}
     */
    function () {
        this.reloadData();
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.showAndSelectAllCheckbox = /**
     * @return {?}
     */
    function () {
        if (this.isSelectionModeMultiple()) {
            if (this.selectAllCheckbox) {
                this._oTableOptions.selectColumn.visible = true;
            }
            this.initializeCheckboxColumn();
            this.selectAll();
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.reloadPaginatedDataFromStart = /**
     * @return {?}
     */
    function () {
        if (this.pageable) {
            // Initialize page index
            this.currentPage = 0;
            this.reloadData();
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.reloadData = /**
     * @return {?}
     */
    function () {
        if (!this.checkEnabledActionPermission(PermissionsUtils.ACTION_REFRESH)) {
            return;
        }
        Object.assign(this.state, this.oTableStorage.getTablePropertyToStore('selection'));
        this.clearSelection();
        this.finishQuerySubscription = false;
        this.pendingQuery = true;
        /** @type {?} */
        var queryArgs;
        if (this.pageable) {
            queryArgs = {
                offset: this.currentPage * this.queryRows,
                length: this.queryRows
            };
        }
        this.queryData(void 0, queryArgs);
    };
    /**
     * @param {?} item
     * @param {?=} $event
     * @return {?}
     */
    OTableComponent.prototype.handleClick = /**
     * @param {?} item
     * @param {?=} $event
     * @return {?}
     */
    function (item, $event) {
        /** @type {?} */
        var self = this;
        this.clickTimer = setTimeout(function () {
            if (!self.clickPrevent) {
                self.doHandleClick(item, $event);
            }
            self.clickPrevent = false;
        }, this.clickDelay);
    };
    /**
     * @param {?} item
     * @param {?=} $event
     * @return {?}
     */
    OTableComponent.prototype.doHandleClick = /**
     * @param {?} item
     * @param {?=} $event
     * @return {?}
     */
    function (item, $event) {
        if (!this.oenabled) {
            return;
        }
        if ((this.detailMode === Codes.DETAIL_MODE_CLICK)) {
            ObservableWrapper.callEmit(this.onClick, item);
            this.saveDataNavigationInLocalStorage();
            this.selection.clear();
            this.selectedRow(item);
            this.viewDetail(item);
            return;
        }
        if (this.isSelectionModeMultiple() && ($event.ctrlKey || $event.metaKey)) {
            // TODO: test $event.metaKey on MAC
            this.selectedRow(item);
            ObservableWrapper.callEmit(this.onClick, item);
        }
        else if (this.isSelectionModeMultiple() && $event.shiftKey) {
            this.handleMultipleSelection(item);
        }
        else if (!this.isSelectionModeNone()) {
            /** @type {?} */
            var selectedItems = this.getSelectedItems();
            if (this.selection.isSelected(item) && selectedItems.length === 1 && this.editionEnabled) {
                return;
            }
            else {
                this.clearSelectionAndEditing();
            }
            this.selectedRow(item);
            ObservableWrapper.callEmit(this.onClick, item);
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OTableComponent.prototype.handleMultipleSelection = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var _this = this;
        if (this.selection.selected.length > 0) {
            /** @type {?} */
            var first$$1 = this.dataSource.renderedData.indexOf(this.selection.selected[0]);
            /** @type {?} */
            var last$$1 = this.dataSource.renderedData.indexOf(item);
            /** @type {?} */
            var indexFrom = Math.min(first$$1, last$$1);
            /** @type {?} */
            var indexTo = Math.max(first$$1, last$$1);
            this.clearSelection();
            this.dataSource.renderedData.slice(indexFrom, indexTo + 1).forEach(function (e) { return _this.selectedRow(e); });
            ObservableWrapper.callEmit(this.onClick, this.selection.selected);
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.saveDataNavigationInLocalStorage = /**
     * @return {?}
     */
    function () {
        _super.prototype.saveDataNavigationInLocalStorage.call(this);
        this.storePaginationState = true;
    };
    /**
     * @param {?} item
     * @param {?=} event
     * @return {?}
     */
    OTableComponent.prototype.handleDoubleClick = /**
     * @param {?} item
     * @param {?=} event
     * @return {?}
     */
    function (item, event) {
        clearTimeout(this.clickTimer);
        this.clickPrevent = true;
        ObservableWrapper.callEmit(this.onDoubleClick, item);
        if (this.oenabled && Codes.isDoubleClickMode(this.detailMode)) {
            this.saveDataNavigationInLocalStorage();
            this.viewDetail(item);
        }
    };
    Object.defineProperty(OTableComponent.prototype, "editionEnabled", {
        get: /**
         * @return {?}
         */
        function () {
            return (this._oTableOptions.columns.find(function (item) { return item.editing; }) !== undefined);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    OTableComponent.prototype.handleDOMClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._oTableOptions.selectColumn.visible) {
            return;
        }
        /** @type {?} */
        var activeEditingColumns = this._oTableOptions.columns.filter(function (item) { return item.editing; });
        if (activeEditingColumns && activeEditingColumns.length > 0) {
            return;
        }
        /** @type {?} */
        var overlayContainer = document.body.getElementsByClassName('cdk-overlay-container')[0];
        if (overlayContainer && overlayContainer.contains(event.target)) {
            return;
        }
        /** @type {?} */
        var tableContainer = this.elRef.nativeElement.querySelector('.o-table-container');
        /** @type {?} */
        var tableContent = this.elRef.nativeElement.querySelector('.o-table-container table.mat-table');
        if (tableContainer && tableContent && tableContainer.contains(event.target) && !tableContent.contains(event.target)) {
            this.clearSelection();
        }
    };
    /**
     * @param {?} column
     * @param {?} row
     * @param {?=} event
     * @return {?}
     */
    OTableComponent.prototype.handleCellClick = /**
     * @param {?} column
     * @param {?} row
     * @param {?=} event
     * @return {?}
     */
    function (column, row, event) {
        if (this.oenabled && column.editor
            && (this.detailMode !== Codes.DETAIL_MODE_CLICK)
            && (this.editionMode === Codes.DETAIL_MODE_CLICK)) {
            this.activateColumnEdition(column, row, event);
        }
    };
    /**
     * @param {?} column
     * @param {?} row
     * @param {?=} event
     * @return {?}
     */
    OTableComponent.prototype.handleCellDoubleClick = /**
     * @param {?} column
     * @param {?} row
     * @param {?=} event
     * @return {?}
     */
    function (column, row, event) {
        if (this.oenabled && column.editor
            && (!Codes.isDoubleClickMode(this.detailMode))
            && (Codes.isDoubleClickMode(this.editionMode))) {
            this.activateColumnEdition(column, row, event);
        }
    };
    /**
     * @param {?} column
     * @param {?} row
     * @param {?=} event
     * @return {?}
     */
    OTableComponent.prototype.activateColumnEdition = /**
     * @param {?} column
     * @param {?} row
     * @param {?=} event
     * @return {?}
     */
    function (column, row, event) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        if (event && column.editing && this.editingCell === event.currentTarget) {
            return;
        }
        /** @type {?} */
        var columnPermissions = this.getOColumnPermissions(column.attr);
        if (columnPermissions.enabled === false) {
            console.warn(column.attr + " edition not allowed due to permissions");
            return;
        }
        this.clearSelectionAndEditing();
        this.selectedRow(row);
        if (event) {
            this.editingCell = event.currentTarget;
        }
        /** @type {?} */
        var rowData = {};
        this.keysArray.forEach(function (key) {
            rowData[key] = row[key];
        });
        rowData[column.attr] = row[column.attr];
        this.editingRow = row;
        column.editing = true;
        column.editor.startEdition(rowData);
        this.cd.detectChanges();
    };
    /**
     * @param {?} column
     * @param {?} data
     * @param {?} saveChanges
     * @return {?}
     */
    OTableComponent.prototype.updateCellData = /**
     * @param {?} column
     * @param {?} data
     * @param {?} saveChanges
     * @return {?}
     */
    function (column, data, saveChanges) {
        if (!this.checkEnabledActionPermission(PermissionsUtils.ACTION_UPDATE)) {
            /** @type {?} */
            var res = new Observable(function (innerObserver) {
                innerObserver.error();
            });
            return res;
        }
        column.editing = false;
        this.editingCell = undefined;
        if (saveChanges && this.editingRow !== undefined) {
            Object.assign(this.editingRow, data);
        }
        this.editingRow = undefined;
        if (saveChanges && column.editor.updateRecordOnEdit) {
            /** @type {?} */
            var toUpdate = {};
            toUpdate[column.attr] = data[column.attr];
            /** @type {?} */
            var kv = this.extractKeysFromRecord(data);
            return this.updateRecord(kv, toUpdate);
        }
        return undefined;
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getKeysValues = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var data = this.getAllValues();
        /** @type {?} */
        var _self = this;
        return data.map(function (row) {
            /** @type {?} */
            var obj = {};
            _self.keysArray.forEach(function (key) {
                if (row[key] !== undefined) {
                    obj[key] = row[key];
                }
            });
            return obj;
        });
    };
    /**
     * @param {?=} event
     * @return {?}
     */
    OTableComponent.prototype.onShowsSelects = /**
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        if (this.oTableMenu) {
            this.oTableMenu.onShowsSelects(event);
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.initializeCheckboxColumn = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Initializing row selection listener
        if (!this.selectionChangeSubscription && this.oTableOptions.selectColumn.visible) {
            this.selectionChangeSubscription = this.selection.onChange.subscribe(function (selectionData) {
                if (selectionData && selectionData.added.length > 0) {
                    ObservableWrapper.callEmit(_this.onRowSelected, selectionData.added);
                }
                if (selectionData && selectionData.removed.length > 0) {
                    ObservableWrapper.callEmit(_this.onRowDeselected, selectionData.removed);
                }
            });
        }
        this.updateSelectionColumnState();
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.updateSelectionColumnState = /**
     * @return {?}
     */
    function () {
        if (!this._oTableOptions.selectColumn.visible) {
            this.clearSelection();
        }
        if (this._oTableOptions.visibleColumns && this._oTableOptions.selectColumn.visible && this._oTableOptions.visibleColumns[0] !== OTableComponent.NAME_COLUMN_SELECT) {
            this._oTableOptions.visibleColumns.unshift(OTableComponent.NAME_COLUMN_SELECT);
        }
        else if (this._oTableOptions.visibleColumns && !this._oTableOptions.selectColumn.visible && this._oTableOptions.visibleColumns[0] === OTableComponent.NAME_COLUMN_SELECT) {
            this._oTableOptions.visibleColumns.shift();
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.isAllSelected = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var numSelected = this.selection.selected.length;
        /** @type {?} */
        var numRows = this.dataSource ? this.dataSource.renderedData.length : undefined;
        return numSelected > 0 && numSelected === numRows;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OTableComponent.prototype.masterToggle = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.checked ? this.selectAll() : this.clearSelection();
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.selectAll = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.dataSource.renderedData.forEach(function (row) { return _this.selection.select(row); });
    };
    /**
     * @param {?} event
     * @param {?} row
     * @return {?}
     */
    OTableComponent.prototype.selectionCheckboxToggle = /**
     * @param {?} event
     * @param {?} row
     * @return {?}
     */
    function (event, row) {
        if (this.isSelectionModeSingle()) {
            this.clearSelection();
        }
        this.selectedRow(row);
    };
    /**
     * @param {?} row
     * @return {?}
     */
    OTableComponent.prototype.selectedRow = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        this.setSelected(row);
        this.cd.detectChanges();
    };
    Object.defineProperty(OTableComponent.prototype, "showDeleteButton", {
        get: /**
         * @return {?}
         */
        function () {
            return this.deleteButton;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableComponent.prototype.getTrackByFunction = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        return function (index, item) {
            if (self.hasScrollableContainer() && index < (self.pageScrollVirtual - 1) * OTableComponent.LIMIT_SCROLLVIRTUAL) {
                return null;
            }
            /** @type {?} */
            var itemId = '';
            /** @type {?} */
            var keysLenght = self.keysArray.length;
            self.keysArray.forEach(function (key, idx) {
                /** @type {?} */
                var suffix = idx < (keysLenght - 1) ? ';' : '';
                itemId += item[key] + suffix;
            });
            /** @type {?} */
            var asyncAndVisible = self.asyncLoadColumns.filter(function (c) { return self._oTableOptions.visibleColumns.indexOf(c) !== -1; });
            if (self.asyncLoadColumns.length && asyncAndVisible.length > 0 && !self.finishQuerySubscription) {
                self.queryRowAsyncData(index, item);
                if (self.paginator && index === (self.paginator.pageSize - 1)) {
                    self.finishQuerySubscription = true;
                }
                return itemId;
            }
            else {
                return itemId;
            }
        };
    };
    /**
     * @param {?} rowIndex
     * @param {?} rowData
     * @return {?}
     */
    OTableComponent.prototype.queryRowAsyncData = /**
     * @param {?} rowIndex
     * @param {?} rowData
     * @return {?}
     */
    function (rowIndex, rowData) {
        var _this = this;
        /** @type {?} */
        var kv = ServiceUtils$$1.getObjectProperties(rowData, this.keysArray);
        /** @type {?} */
        var av = this.asyncLoadColumns.filter(function (c) { return _this._oTableOptions.visibleColumns.indexOf(c) !== -1; });
        if (av.length === 0) {
            // Skipping query if there are not visible asyncron columns
            return;
        }
        /** @type {?} */
        var columnQueryArgs = [kv, av, this.entity, undefined, undefined, undefined, undefined];
        /** @type {?} */
        var queryMethodName = this.pageable ? this.paginatedQueryMethod : this.queryMethod;
        if (this.dataService && (queryMethodName in this.dataService) && this.entity) {
            if (this.asyncLoadSubscriptions[rowIndex]) {
                this.asyncLoadSubscriptions[rowIndex].unsubscribe();
            }
            this.asyncLoadSubscriptions[rowIndex] = this.dataService[queryMethodName].apply(this.dataService, columnQueryArgs).subscribe(function (res) {
                if (res.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                    /** @type {?} */
                    var data = undefined;
                    if (Util.isArray(res.data) && res.data.length === 1) {
                        data = res.data[0];
                    }
                    else if (Util.isObject(res.data)) {
                        data = res.data;
                    }
                    _this.daoTable.setAsynchronousColumn(data, rowData);
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getValue = /**
     * @return {?}
     */
    function () {
        return this.dataSource.getCurrentData();
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getAllValues = /**
     * @return {?}
     */
    function () {
        return this.dataSource.getCurrentAllData();
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getAllRenderedValues = /**
     * @return {?}
     */
    function () {
        return this.dataSource.getAllRendererData();
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getRenderedValue = /**
     * @return {?}
     */
    function () {
        return this.dataSource.getCurrentRendererData();
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getSqlTypes = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this.dataSource.sqlTypes) ? this.dataSource.sqlTypes : {};
    };
    /**
     * @param {?} tableColumnsFilter
     * @return {?}
     */
    OTableComponent.prototype.setOTableColumnsFilter = /**
     * @param {?} tableColumnsFilter
     * @return {?}
     */
    function (tableColumnsFilter) {
        this.oTableColumnsFilterComponent = tableColumnsFilter;
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getStoredColumnsFilters = /**
     * @return {?}
     */
    function () {
        return this.oTableStorage.getStoredColumnsFilters();
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.onFilterByColumnClicked = /**
     * @return {?}
     */
    function () {
        if (this.oTableMenu) {
            this.oTableMenu.onFilterByColumnClicked();
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.onStoreFilterClicked = /**
     * @return {?}
     */
    function () {
        if (this.oTableMenu) {
            this.oTableMenu.onStoreFilterClicked();
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.onLoadFilterClicked = /**
     * @return {?}
     */
    function () {
        if (this.oTableMenu) {
            this.oTableMenu.onLoadFilterClicked();
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.onClearFilterClicked = /**
     * @return {?}
     */
    function () {
        if (this.oTableMenu) {
            this.oTableMenu.onClearFilterClicked();
        }
    };
    /**
     * @param {?=} triggerDatasourceUpdate
     * @return {?}
     */
    OTableComponent.prototype.clearFilters = /**
     * @param {?=} triggerDatasourceUpdate
     * @return {?}
     */
    function (triggerDatasourceUpdate) {
        if (triggerDatasourceUpdate === void 0) { triggerDatasourceUpdate = true; }
        this.dataSource.clearColumnFilters(triggerDatasourceUpdate);
        if (this.oTableMenu && this.oTableMenu.columnFilterOption) {
            this.oTableMenu.columnFilterOption.setActive(this.showFilterByColumnIcon);
        }
        if (this.oTableQuickFilterComponent) {
            this.oTableQuickFilterComponent.setValue(void 0);
        }
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableComponent.prototype.isColumnFilterable = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return (this.oTableColumnsFilterComponent && this.oTableColumnsFilterComponent.isColumnFilterable(column.attr));
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableComponent.prototype.isModeColumnFilterable = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return this.showFilterByColumnIcon &&
            (this.oTableColumnsFilterComponent && this.oTableColumnsFilterComponent.isColumnFilterable(column.attr));
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableComponent.prototype.isColumnFilterActive = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return this.showFilterByColumnIcon &&
            this.dataSource.getColumnValueFilterByAttr(column.attr) !== undefined;
    };
    /**
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    OTableComponent.prototype.openColumnFilterDialog = /**
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    function (column, event) {
        event.stopPropagation();
        event.preventDefault();
        /** @type {?} */
        var dialogRef = this.dialog.open(OTableFilterByColumnDataDialogComponent, {
            data: {
                previousFilter: this.dataSource.getColumnValueFilterByAttr(column.attr),
                column: column,
                tableData: this.dataSource.getTableData(),
                preloadValues: this.oTableColumnsFilterComponent.preloadValues,
                mode: this.oTableColumnsFilterComponent.mode
            },
            disableClose: true,
            panelClass: ['o-dialog-class', 'o-table-dialog']
        });
        /** @type {?} */
        var self = this;
        dialogRef.afterClosed().subscribe(function (result) {
            if (result) {
                /** @type {?} */
                var columnValueFilter = dialogRef.componentInstance.getColumnValuesFilter();
                self.dataSource.addColumnFilter(columnValueFilter);
                self.reloadPaginatedDataFromStart();
            }
        });
    };
    Object.defineProperty(OTableComponent.prototype, "disableTableMenuButton", {
        get: /**
         * @return {?}
         */
        function () {
            return !!(this.permissions && this.permissions.menu && this.permissions.menu.enabled === false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableComponent.prototype, "showTableMenuButton", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var permissionHidden = !!(this.permissions && this.permissions.menu && this.permissions.menu.visible === false);
            if (permissionHidden) {
                return false;
            }
            /** @type {?} */
            var staticOpt = this.selectAllCheckbox || this.exportButton || this.columnsVisibilityButton || this.oTableColumnsFilterComponent !== undefined;
            return staticOpt || this.tableOptions.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} tableInsertableRow
     * @return {?}
     */
    OTableComponent.prototype.setOTableInsertableRow = /**
     * @param {?} tableInsertableRow
     * @return {?}
     */
    function (tableInsertableRow) {
        /** @type {?} */
        var insertPerm = this.getActionPermissions(PermissionsUtils.ACTION_INSERT);
        if (insertPerm.visible) {
            tableInsertableRow.enabled = insertPerm.enabled;
            this.oTableInsertableRowComponent = tableInsertableRow;
            this.showFirstInsertableRow = this.oTableInsertableRowComponent.isFirstRow();
            this.showLastInsertableRow = !this.showFirstInsertableRow;
            this.oTableInsertableRowComponent.initializeEditors();
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.clearSelectionAndEditing = /**
     * @return {?}
     */
    function () {
        this.selection.clear();
        this._oTableOptions.columns.forEach(function (item) {
            item.editing = false;
        });
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableComponent.prototype.useDetailButton = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return column.type === 'editButtonInRow' || column.type === 'detailButtonInRow';
    };
    /**
     * @param {?} column
     * @param {?} row
     * @param {?} event
     * @return {?}
     */
    OTableComponent.prototype.onDetailButtonClick = /**
     * @param {?} column
     * @param {?} row
     * @param {?} event
     * @return {?}
     */
    function (column, row, event) {
        event.preventDefault();
        event.stopPropagation();
        switch (column.type) {
            case 'editButtonInRow':
                this.editDetail(row);
                break;
            case 'detailButtonInRow':
                this.viewDetail(row);
                break;
        }
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableComponent.prototype.getDetailButtonIcon = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var result = '';
        switch (column.type) {
            case 'editButtonInRow':
                result = this.editButtonInRowIcon;
                break;
            case 'detailButtonInRow':
                result = this.detailButtonInRowIcon;
                break;
        }
        return result;
    };
    /**
     * @param {?} column
     * @param {?} row
     * @return {?}
     */
    OTableComponent.prototype.usePlainRender = /**
     * @param {?} column
     * @param {?} row
     * @return {?}
     */
    function (column, row) {
        return !this.useDetailButton(column) && !column.renderer && (!column.editor || (!column.editing || !this.selection.isSelected(row)));
    };
    /**
     * @param {?} column
     * @param {?} row
     * @return {?}
     */
    OTableComponent.prototype.useCellRenderer = /**
     * @param {?} column
     * @param {?} row
     * @return {?}
     */
    function (column, row) {
        return column.renderer && (!column.editing || column.editing && !this.selection.isSelected(row));
    };
    /**
     * @param {?} column
     * @param {?} row
     * @return {?}
     */
    OTableComponent.prototype.useCellEditor = /**
     * @param {?} column
     * @param {?} row
     * @return {?}
     */
    function (column, row) {
        if (column.editor && column.editor instanceof OTableCellEditorBooleanComponent && column.editor.autoCommit) {
            return false;
        }
        return column.editor && column.editing && this.selection.isSelected(row);
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.isSelectionModeMultiple = /**
     * @return {?}
     */
    function () {
        return this.selectionMode === Codes.SELECTION_MODE_MULTIPLE;
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.isSelectionModeSingle = /**
     * @return {?}
     */
    function () {
        return this.selectionMode === Codes.SELECTION_MODE_SINGLE;
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.isSelectionModeNone = /**
     * @return {?}
     */
    function () {
        return this.selectionMode === Codes.SELECTION_MODE_NONE;
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    OTableComponent.prototype.onChangePage = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        this.finishQuerySubscription = false;
        if (!this.pageable) {
            this.currentPage = evt.pageIndex;
            return;
        }
        /** @type {?} */
        var tableState = this.state;
        /** @type {?} */
        var goingBack = evt.pageIndex < this.currentPage;
        this.currentPage = evt.pageIndex;
        /** @type {?} */
        var pageSize = this.paginator.isShowingAllRows(evt.pageSize) ? tableState.totalQueryRecordsNumber : evt.pageSize;
        /** @type {?} */
        var oldQueryRows = this.queryRows;
        /** @type {?} */
        var changingPageSize = (oldQueryRows !== pageSize);
        this.queryRows = pageSize;
        /** @type {?} */
        var newStartRecord;
        /** @type {?} */
        var queryLength;
        if (goingBack || changingPageSize) {
            newStartRecord = (this.currentPage * this.queryRows);
            queryLength = this.queryRows;
        }
        else {
            newStartRecord = Math.max(tableState.queryRecordOffset, (this.currentPage * this.queryRows));
            /** @type {?} */
            var newEndRecord = Math.min(newStartRecord + this.queryRows, tableState.totalQueryRecordsNumber);
            queryLength = Math.min(this.queryRows, newEndRecord - newStartRecord);
        }
        /** @type {?} */
        var queryArgs = {
            offset: newStartRecord,
            length: queryLength
        };
        this.finishQuerySubscription = false;
        this.queryData(void 0, queryArgs);
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OTableComponent.prototype.getOColumn = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        return this._oTableOptions ? this._oTableOptions.columns.find(function (item) { return item.name === attr; }) : undefined;
    };
    /**
     * @param {?} recordData
     * @param {?=} sqlTypes
     * @return {?}
     */
    OTableComponent.prototype.insertRecord = /**
     * @param {?} recordData
     * @param {?=} sqlTypes
     * @return {?}
     */
    function (recordData, sqlTypes) {
        if (!this.checkEnabledActionPermission(PermissionsUtils.ACTION_INSERT)) {
            return undefined;
        }
        if (!Util.isDefined(sqlTypes)) {
            /** @type {?} */
            var allSqlTypes_1 = this.getSqlTypes();
            sqlTypes = {};
            Object.keys(recordData).forEach(function (key) {
                sqlTypes[key] = allSqlTypes_1[key];
            });
        }
        return this.daoTable.insertQuery(recordData, sqlTypes);
    };
    /**
     * @param {?} filter
     * @param {?} updateData
     * @param {?=} sqlTypes
     * @return {?}
     */
    OTableComponent.prototype.updateRecord = /**
     * @param {?} filter
     * @param {?} updateData
     * @param {?=} sqlTypes
     * @return {?}
     */
    function (filter$$1, updateData, sqlTypes) {
        if (!this.checkEnabledActionPermission(PermissionsUtils.ACTION_UPDATE)) {
            return of(this.dataSource.data);
        }
        /** @type {?} */
        var sqlTypesArg = sqlTypes || {};
        if (!Util.isDefined(sqlTypes)) {
            /** @type {?} */
            var allSqlTypes_2 = this.getSqlTypes();
            Object.keys(filter$$1).forEach(function (key) {
                sqlTypesArg[key] = allSqlTypes_2[key];
            });
            Object.keys(updateData).forEach(function (key) {
                sqlTypesArg[key] = allSqlTypes_2[key];
            });
        }
        return this.daoTable.updateQuery(filter$$1, updateData, sqlTypesArg);
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getDataArray = /**
     * @return {?}
     */
    function () {
        return this.daoTable.data;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OTableComponent.prototype.setDataArray = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (this.daoTable) {
            // remote pagination has no sense when using static-data
            this.pageable = false;
            this.staticData = data;
            this.daoTable.usingStaticData = true;
            this.daoTable.setDataArray(this.staticData);
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.deleteLocalItems = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var dataArray = this.getDataArray();
        /** @type {?} */
        var selectedItems = this.getSelectedItems();
        for (var i = 0; i < selectedItems.length; i++) {
            for (var j = dataArray.length - 1; j >= 0; --j) {
                if (Util.equals(selectedItems[i], dataArray[j])) {
                    dataArray.splice(j, 1);
                    break;
                }
            }
        }
        this.clearSelection();
        this.setDataArray(dataArray);
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableComponent.prototype.isColumnSortActive = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var found = this.sortColArray.find(function (sortC) { return sortC.columnName === column.attr; });
        return found !== undefined;
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableComponent.prototype.isColumnDescSortActive = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var found = this.sortColArray.find(function (sortC) { return sortC.columnName === column.attr && !sortC.ascendent; });
        return found !== undefined;
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.hasTabGroupChangeSubscription = /**
     * @return {?}
     */
    function () {
        return this.tabGroupChangeSubscription !== undefined;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OTableComponent.prototype.isEmpty = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return !Util.isDefined(value) || ((typeof value === 'string') && !value);
    };
    /**
     * @param {?} conf
     * @return {?}
     */
    OTableComponent.prototype.setFiltersConfiguration = /**
     * @param {?} conf
     * @return {?}
     */
    function (conf) {
        var _this = this;
        //initialize filterCaseSensitive
        /*
              Checking the original filterCaseSensitive with the filterCaseSensitive in initial configuration in local storage
              if filterCaseSensitive in initial configuration is equals to original filterCaseSensitive input
              filterCaseSensitive will be the value in local storage
            */
        if (Util.isDefined(this.filterCaseSensitive) && this.state.hasOwnProperty('initial-configuration') &&
            this.state['initial-configuration'].hasOwnProperty('filter-case-sensitive') &&
            this.filterCaseSensitive === conf['initial-configuration']['filter-case-sensitive']) {
            this.filterCaseSensitive = conf.hasOwnProperty('filter-case-sensitive') ? conf['filter-case-sensitive'] : this.filterCaseSensitive;
        }
        /** @type {?} */
        var storedColumnFilters = this.oTableStorage.getStoredColumnsFilters(conf);
        this.showFilterByColumnIcon = storedColumnFilters.length > 0;
        if (this.oTableMenu && this.oTableMenu.columnFilterOption) {
            this.oTableMenu.columnFilterOption.setActive(this.showFilterByColumnIcon);
        }
        if (this.oTableColumnsFilterComponent) {
            this.dataSource.initializeColumnsFilters(storedColumnFilters);
        }
        if (this.oTableQuickFilterComponent) {
            this.oTableQuickFilterComponent.setValue(conf['filter']);
            /** @type {?} */
            var storedColumnsData = conf['oColumns'] || [];
            storedColumnsData.forEach(function (oColData) {
                /** @type {?} */
                var oCol = _this.getOColumn(oColData.attr);
                if (oCol) {
                    if (oColData.hasOwnProperty('searching')) {
                        oCol.searching = oColData.searching;
                    }
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.onStoreConfigurationClicked = /**
     * @return {?}
     */
    function () {
        if (this.oTableMenu) {
            this.oTableMenu.onStoreConfigurationClicked();
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.onApplyConfigurationClicked = /**
     * @return {?}
     */
    function () {
        if (this.oTableMenu) {
            this.oTableMenu.onApplyConfigurationClicked();
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.applyDefaultConfiguration = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.oTableStorage.reset();
        this.initializeParams();
        this.parseVisibleColumns();
        this._oTableOptions.columns.sort(function (a, b) { return _this.visibleColArray.indexOf(a.attr) - _this.visibleColArray.indexOf(b.attr); });
        this.insideTabBugWorkaround();
        this.onReinitialize.emit(null);
        this.clearFilters(false);
        this.reloadData();
    };
    /**
     * @param {?} configurationName
     * @return {?}
     */
    OTableComponent.prototype.applyConfiguration = /**
     * @param {?} configurationName
     * @return {?}
     */
    function (configurationName) {
        var _this = this;
        /** @type {?} */
        var storedConfiguration = this.oTableStorage.getStoredConfiguration(configurationName);
        if (storedConfiguration) {
            /** @type {?} */
            var properties = storedConfiguration[OTableStorage.STORED_PROPERTIES_KEY] || [];
            /** @type {?} */
            var conf_1 = storedConfiguration[OTableStorage.STORED_CONFIGURATION_KEY];
            properties.forEach(function (property) {
                switch (property) {
                    case 'sort':
                        _this.state['sort-columns'] = conf_1['sort-columns'];
                        _this.parseSortColumns();
                        break;
                    case 'columns-display':
                        _this.state['oColumns-display'] = conf_1['oColumns-display'];
                        _this.parseVisibleColumns();
                        _this.state['select-column-visible'] = conf_1['select-column-visible'];
                        _this.initializeCheckboxColumn();
                        break;
                    case 'quick-filter':
                    case 'columns-filter':
                        _this.setFiltersConfiguration(conf_1);
                        break;
                    case 'page':
                        _this.state['currentPage'] = conf_1['currentPage'];
                        _this.currentPage = conf_1['currentPage'];
                        if (_this.pageable) {
                            _this.state['totalQueryRecordsNumber'] = conf_1['totalQueryRecordsNumber'];
                            _this.state['queryRecordOffset'] = conf_1['queryRecordOffset'];
                        }
                        _this.queryRows = conf_1['query-rows'];
                        break;
                }
            });
            this.reloadData();
        }
    };
    /**
     * @param {?} oCol
     * @return {?}
     */
    OTableComponent.prototype.getTitleAlignClass = /**
     * @param {?} oCol
     * @return {?}
     */
    function (oCol) {
        /** @type {?} */
        var align;
        /** @type {?} */
        var hasTitleAlign = Util.isDefined(oCol.definition) && Util.isDefined(oCol.definition.titleAlign);
        /** @type {?} */
        var autoAlign = (this.autoAlignTitles && !hasTitleAlign) || (hasTitleAlign && oCol.definition.titleAlign === Codes.COLUMN_TITLE_ALIGN_AUTO);
        if (!autoAlign) {
            return oCol.getTitleAlignClass();
        }
        switch (oCol.type) {
            case 'image':
            case 'date':
            case 'action':
            case 'boolean':
                align = Codes.COLUMN_TITLE_ALIGN_CENTER;
                break;
            case 'currency':
            case 'integer':
            case 'real':
            case 'percentage':
                align = Codes.COLUMN_TITLE_ALIGN_END;
                break;
            case 'service':
            default:
                align = Codes.COLUMN_TITLE_ALIGN_START;
                break;
        }
        return align;
    };
    /**
     * @param {?} column
     * @return {?}
     */
    OTableComponent.prototype.getCellAlignClass = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return Util.isDefined(column.definition) && Util.isDefined(column.definition.contentAlign) ? 'o-' + column.definition.contentAlign : '';
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OTableComponent.prototype.onTableScroll = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (this.hasScrollableContainer()) {
            /** @type {?} */
            var tableViewHeight = e.target.offsetHeight;
            /** @type {?} */
            var tableScrollHeight = e.target.scrollHeight;
            /** @type {?} */
            var scrollLocation = e.target.scrollTop;
            /** @type {?} */
            var buffer$$1 = 100;
            /** @type {?} */
            var limit_SCROLLVIRTUAL = tableScrollHeight - tableViewHeight - buffer$$1;
            if (scrollLocation > limit_SCROLLVIRTUAL) {
                this.getDataScrollable();
            }
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getDataScrollable = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var pageVirtualBefore = this.pageScrollVirtual;
        /** @type {?} */
        var pageVirtualEnd = Math.ceil(this.dataSource.resultsLength / OTableComponent.LIMIT_SCROLLVIRTUAL);
        if (pageVirtualEnd !== this.pageScrollVirtual) {
            this.pageScrollVirtual++;
        }
        // throw event change scroll
        if (pageVirtualBefore !== this.pageScrollVirtual) {
            this.loadingScrollSubject.next(true);
            this.dataSource.loadDataScrollable = this.pageScrollVirtual;
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.hasScrollableContainer = /**
     * @return {?}
     */
    function () {
        return this.dataSource && !this.paginationControls && !this.pageable;
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.addDefaultRowButtons = /**
     * @return {?}
     */
    function () {
        // check permissions
        if (this.editButtonInRow) {
            this.addButtonInRow('editButtonInRow');
        }
        if (this.detailButtonInRow) {
            this.addButtonInRow('detailButtonInRow');
        }
    };
    /**
     * @param {?} name
     * @return {?}
     */
    OTableComponent.prototype.addButtonInRow = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        /** @type {?} */
        var colDef = new OColumn(name, this);
        colDef.type = name;
        colDef.visible = true;
        colDef.searchable = false;
        colDef.orderable = false;
        colDef.resizable = false;
        colDef.title = undefined;
        colDef.width = '48px';
        this.pushOColumnDefinition(colDef);
        this._oTableOptions.visibleColumns.push(name);
    };
    Object.defineProperty(OTableComponent.prototype, "headerHeight", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var height = 0;
            if (this.tableHeaderEl && this.tableHeaderEl.nativeElement) {
                height += this.tableHeaderEl.nativeElement.offsetHeight;
            }
            if (this.tableToolbarEl && this.tableToolbarEl.nativeElement) {
                height += this.tableToolbarEl.nativeElement.offsetHeight;
            }
            return height;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OTableComponent.prototype.isDetailMode = /**
     * @return {?}
     */
    function () {
        return this.detailMode !== Codes.DETAIL_MODE_NONE;
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.copyAll = /**
     * @return {?}
     */
    function () {
        Util.copyToClipboard(JSON.stringify(this.getRenderedValue()));
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.copySelection = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var selectedItems = this.dataSource.getRenderedData(this.getSelectedItems());
        Util.copyToClipboard(JSON.stringify(selectedItems));
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OTableComponent.prototype.viewDetail = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (!this.checkEnabledActionPermission('detail')) {
            return;
        }
        _super.prototype.viewDetail.call(this, item);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OTableComponent.prototype.editDetail = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (!this.checkEnabledActionPermission('edit')) {
            return;
        }
        _super.prototype.editDetail.call(this, item);
    };
    /**
     * @param {?} th
     * @return {?}
     */
    OTableComponent.prototype.getOColumnFromTh = /**
     * @param {?} th
     * @return {?}
     */
    function (th) {
        /** @type {?} */
        var result;
        /** @type {?} */
        var classList = [].slice.call((/** @type {?} */ (th)).classList);
        /** @type {?} */
        var columnClass = classList.find(function (className) { return (className.startsWith('mat-column-')); });
        if (Util.isDefined(columnClass)) {
            result = this.getOColumn(columnClass.substr('mat-column-'.length));
        }
        return result;
    };
    /**
     * @param {?} name
     * @return {?}
     */
    OTableComponent.prototype.getColumnInsertable = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        return name + this.getSuffixColumnInsertable();
    };
    /**
     * @param {?} row
     * @return {?}
     */
    OTableComponent.prototype.isRowSelected = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        return !this.isSelectionModeNone() && this.selection.isSelected(row);
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.getColumnsWidthFromDOM = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (Util.isDefined(this.tableHeaderEl)) {
            [].slice.call(this.tableHeaderEl.nativeElement.children).forEach(function (thEl) {
                /** @type {?} */
                var oCol = _this.getOColumnFromTh(thEl);
                if (Util.isDefined(oCol) && thEl.clientWidth > 0 && oCol.DOMWidth !== thEl.clientWidth) {
                    oCol.DOMWidth = thEl.clientWidth;
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OTableComponent.prototype.refreshColumnsWidth = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.oTableOptions.columns.filter(function (c) { return c.visible; }).forEach(function (c) {
            c.DOMWidth = undefined;
        });
        this.cd.detectChanges();
        setTimeout(function () {
            _this.getColumnsWidthFromDOM();
            _this.oTableOptions.columns.filter(function (c) { return c.visible; }).forEach(function (c) {
                if (Util.isDefined(c.definition) && Util.isDefined(c.definition.width)) {
                    c.width = c.definition.width;
                }
                c.getRenderWidth();
            });
            _this.cd.detectChanges();
        }, 0);
    };
    OTableComponent.DEFAULT_INPUTS_O_TABLE = DEFAULT_INPUTS_O_TABLE;
    OTableComponent.DEFAULT_OUTPUTS_O_TABLE = DEFAULT_OUTPUTS_O_TABLE;
    OTableComponent.DEFAULT_BASE_SIZE_SPINNER = 100;
    OTableComponent.FIRST_LAST_CELL_PADDING = 24;
    OTableComponent.DEFAULT_COLUMN_MIN_WIDTH = 80;
    OTableComponent.NAME_COLUMN_SELECT = NAME_COLUMN_SELECT;
    OTableComponent.LIMIT_SCROLLVIRTUAL = 50;
    OTableComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table',
                    template: "\n    <div class=\"o-table-container\" fxLayout=\"column\" fxLayoutAlign=\"start stretch\"\n      [style.display]=\"isVisible()? '' : 'none'\" (scroll)=\"onTableScroll($event)\" [class.block-events]=\"showLoading | async\"\n      [class.o-scrollable-container]=\"hasScrollableContainer()\">\n      <div #tableToolbar *ngIf=\"hasControls()\" class=\"toolbar\">\n        <div fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n          <o-table-buttons #tableButtons [insert-button]=\"insertButton\" [refresh-button]=\"refreshButton\"\n            [delete-button]=\"showDeleteButton\">\n            <ng-content select=\"o-table-button\"></ng-content>\n          </o-table-buttons>\n          <div fxLayout fxFlex>\n            <span *ngIf=\"showTitle\" class=\"table-title\" fxFlex>{{ title | oTranslate }}</span>\n          </div>\n          <o-table-quickfilter *ngIf=\"quickFilter\" (onChange)=\"reloadPaginatedDataFromStart()\"></o-table-quickfilter>\n          <button type=\"button\" *ngIf=\"showTableMenuButton\" mat-icon-button class=\"o-table-menu-button\"\n            [matMenuTriggerFor]=\"tableMenu.matMenu\" (click)=\"$event.stopPropagation()\">\n            <mat-icon svgIcon=\"ontimize:more_vert\"></mat-icon>\n          </button>\n          <o-table-menu #tableMenu [select-all-checkbox]=\"selectAllCheckbox\" [export-button]=\"exportButton\"\n            [columns-visibility-button]=\"columnsVisibilityButton\">\n            <ng-content select=\"o-table-option\"></ng-content>\n          </o-table-menu>\n        </div>\n      </div>\n\n      <div #tableBody class=\"o-table-body o-scroll\" [class.horizontal-scroll]=\"horizontalScroll\"\n        [class.scrolled]=\"horizontalScrolled\">\n        <div class=\"o-table-overflow o-scroll\">\n          <table mat-table #table [trackBy]=\"getTrackByFunction()\" [dataSource]=\"dataSource\" oMatSort\n            [ngClass]=\"rowHeightObservable | async\" (scroll)=\"onTableScroll($event)\"\n            (cdkObserveContent)=\"projectContentChanged()\" oTableExpandedFooter>\n\n            <!--Checkbox Column -->\n            <ng-container [matColumnDef]=\"oTableOptions.selectColumn.name\" *ngIf=\"oTableOptions.selectColumn.visible\">\n              <th mat-header-cell *matHeaderCellDef>\n                <mat-checkbox (click)=\"$event.stopPropagation()\" (change)=\"masterToggle($event)\" [checked]=\"isAllSelected()\"\n                  [indeterminate]=\"selection.hasValue() && !isAllSelected()\"></mat-checkbox>\n              </th>\n              <td mat-cell *matCellDef=\"let row\">\n                <mat-checkbox name=\"id[]\" (click)=\"$event.stopPropagation()\" (change)=\"selectionCheckboxToggle($event, row)\"\n                  [checked]=\"selection.isSelected(row)\"> </mat-checkbox>\n              </td>\n            </ng-container>\n\n            <!-- Generic column definition -->\n            <ng-container *ngFor=\"let column of oTableOptions.columns\" [matColumnDef]=\"column.name\">\n              <!--Define header-cell-->\n\n              <th mat-header-cell *matHeaderCellDef [ngClass]=\"getTitleAlignClass(column)\"\n                [style.width]=\"column.getRenderWidth()\" [class.resizable]=\"resizable\">\n\n                <mat-icon *ngIf=\"isModeColumnFilterable(column)\" class=\"column-filter-icon\"\n                  [class.active]=\"isColumnFilterActive(column)\" (click)=\"openColumnFilterDialog(column, $event)\"\n                  svgIcon=\"ontimize:filter_list\">\n                </mat-icon>\n\n                <ng-container *ngIf=\"column.orderable\">\n                  <span o-mat-sort-header>{{ column.title | oTranslate }}</span>\n                </ng-container>\n                <ng-container *ngIf=\"!column.orderable\">\n                  <span class=\"header-title-container\">{{ column.title | oTranslate }}</span>\n                </ng-container>\n\n                <o-table-column-resizer *ngIf=\"resizable\" [column]=\"column\"></o-table-column-resizer>\n\n              </th>\n\n              <!--Define mat-cell-->\n              <td mat-cell *matCellDef=\"let row\" [ngClass]=\"[column.className, getCellAlignClass(column)]\"\n                (click)=\"handleCellClick(column, row, $event)\" (dblclick)=\"handleCellDoubleClick(column, row, $event)\"\n                [class.empty-cell]=\"isEmpty(row[column.name])\" [matTooltipDisabled]=\"!column.hasTooltip()\"\n                [matTooltip]=\"column.getTooltip(row)\" matTooltipPosition=\"below\" matTooltipShowDelay=\"750\"\n                matTooltipClass=\"o-table-cell-tooltip\" [class.o-mat-cell-multiline]=\"(column.isMultiline | async)\"\n                [oContextMenu]=\"tableContextMenu\" [oContextMenuData]=\"{ cellName:column.name, rowValue:row}\">\n\n                <ng-container *ngIf=\"usePlainRender(column, row); else cellRender\">\n                  {{ row[column.name] }}\n                </ng-container>\n\n                <ng-template #cellRender *ngIf=\"useCellRenderer(column, row); else cellEditor\"\n                  [ngTemplateOutlet]=\"column.renderer.templateref\"\n                  [ngTemplateOutletContext]=\"{ cellvalue: row[column.name], rowvalue:row }\">\n                </ng-template>\n\n                <ng-template #cellEditor *ngIf=\"useCellEditor(column, row)\" [ngTemplateOutlet]=\"column.editor.templateref\"\n                  [ngTemplateOutletContext]=\"{ cellvalue: row[column.name], rowvalue:row }\">\n                </ng-template>\n\n                <ng-container *ngIf=\"useDetailButton(column)\">\n                  <div fxLayoutAlign=\"center center\" class=\"o-action-cell-renderer\"\n                    (click)=\"onDetailButtonClick(column, row, $event)\">\n                    <mat-icon>{{ getDetailButtonIcon(column) }}</mat-icon>\n                  </div>\n                </ng-container>\n              </td>\n              <!--Define mat-footer-cell-->\n              <ng-container *ngIf=\"showTotals | async\">\n                <td mat-footer-cell *matFooterCellDef [ngClass]=\"column.className\">\n                  <div class=\"title\" *ngIf=\"column.aggregate && column.aggregate.title\">\n                    {{ column.aggregate.title | oTranslate }}\n                  </div>\n                  <ng-container *ngIf=\"!column.renderer\">\n                    {{ dataSource.getAggregateData(column) }}\n                  </ng-container>\n                  <ng-template *ngIf=\"column.renderer && column.aggregate\" [ngTemplateOutlet]=\"column.renderer.templateref\"\n                    [ngTemplateOutletContext]=\"{cellvalue: dataSource.getAggregateData(column)}\"></ng-template>\n                </td>\n              </ng-container>\n\n            </ng-container>\n\n            <!--FOOTER-INSERTABLE-->\n            <ng-container *ngIf=\"showLastInsertableRow && oTableInsertableRowComponent\">\n              <ng-container [matColumnDef]=\"oTableOptions.selectColumn.name + getSuffixColumnInsertable()\"\n                *ngIf=\"oTableOptions.selectColumn.visible\">\n                <td mat-footer-cell *matFooterCellDef>\n                </td>\n              </ng-container>\n              <ng-container *ngFor=\"let column of oTableOptions.columns\"\n                [matColumnDef]=\"column.name+ getSuffixColumnInsertable()\">\n\n                <td mat-footer-cell *matFooterCellDef [ngClass]=\"column.className\">\n                  <ng-container\n                    *ngIf=\"oTableInsertableRowComponent.isColumnInsertable(column) && !oTableInsertableRowComponent.useCellEditor(column)\">\n                    <mat-form-field class=\"insertable-form-field\" [hideRequiredMarker]=\"false\" floatLabel=\"never\">\n                      <input matInput type=\"text\" [placeholder]=\"oTableInsertableRowComponent.getPlaceholder(column)\"\n                        [id]=\"column.attr\" [formControl]=\"oTableInsertableRowComponent.getControl(column)\"\n                        [required]=\"oTableInsertableRowComponent.isColumnRequired(column)\">\n                      <mat-error *ngIf=\"oTableInsertableRowComponent.columnHasError(column, 'required')\">\n                        {{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\n                      </mat-error>\n                    </mat-form-field>\n                  </ng-container>\n\n                  <ng-container\n                    *ngIf=\"oTableInsertableRowComponent.isColumnInsertable(column) && oTableInsertableRowComponent.useCellEditor(column)\">\n                    <ng-template [ngTemplateOutlet]=\"oTableInsertableRowComponent.columnEditors[column.attr].templateref\"\n                      [ngTemplateOutletContext]=\"{ rowvalue: oTableInsertableRowComponent.rowData }\">\n                    </ng-template>\n                  </ng-container>\n                </td>\n              </ng-container>\n\n            </ng-container>\n\n            <ng-container *ngIf=\"showFirstInsertableRow && oTableInsertableRowComponent\">\n              <ng-container [matColumnDef]=\"getColumnInsertable(oTableOptions.selectColumn.name)\"\n                *ngIf=\"oTableOptions.selectColumn.visible\">\n                <td mat-header-cell *matHeaderCellDef>\n                </td>\n              </ng-container>\n              <ng-container *ngFor=\"let column of oTableOptions.columns\" [matColumnDef]=\"getColumnInsertable(column.name)\">\n\n                <td mat-header-cell *matHeaderCellDef [ngClass]=\"column.className\">\n                  <ng-container\n                    *ngIf=\"oTableInsertableRowComponent.isColumnInsertable(column) && !oTableInsertableRowComponent.useCellEditor(column)\">\n                    <mat-form-field class=\"insertable-form-field\" [hideRequiredMarker]=\"false\" floatLabel=\"never\">\n                      <input matInput type=\"text\" [placeholder]=\"oTableInsertableRowComponent.getPlaceholder(column)\"\n                        [id]=\"column.attr\" [formControl]=\"oTableInsertableRowComponent.getControl(column)\"\n                        [required]=\"oTableInsertableRowComponent.isColumnRequired(column)\">\n                      <mat-error *ngIf=\"oTableInsertableRowComponent.columnHasError(column, 'required')\">\n                        {{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\n                      </mat-error>\n                    </mat-form-field>\n                  </ng-container>\n\n                  <ng-container\n                    *ngIf=\"oTableInsertableRowComponent.isColumnInsertable(column) && oTableInsertableRowComponent.useCellEditor(column)\">\n                    <ng-template [ngTemplateOutlet]=\"oTableInsertableRowComponent.columnEditors[column.attr].templateref\"\n                      [ngTemplateOutletContext]=\"{ rowvalue: oTableInsertableRowComponent.rowData }\">\n                    </ng-template>\n                  </ng-container>\n                </td>\n              </ng-container>\n\n            </ng-container>\n\n\n            <tr #tableHeader mat-header-row *matHeaderRowDef=\"oTableOptions.visibleColumns; sticky: fixedHeader\"></tr>\n\n            <tr mat-row oTableRow *matRowDef=\"let row; columns: oTableOptions.visibleColumns;\"\n              (click)=\"handleClick(row, $event)\" (dblclick)=\"handleDoubleClick(row, $event)\"\n              [class.selected]=\"isRowSelected(row)\">\n            </tr>\n            <ng-container *ngIf=\"showLastInsertableRow\">\n              <tr mat-footer-row *matFooterRowDef=\"oTableOptions.columnsInsertables; sticky: true\"\n                (keyup)=\"oTableInsertableRowComponent.handleKeyboardEvent($event)\" class=\"o-table-insertable\"></tr>\n            </ng-container>\n            <ng-container *ngIf=\"showFirstInsertableRow\">\n              <tr mat-header-row *matHeaderRowDef=\"oTableOptions.columnsInsertables; sticky: true\"\n                (keyup)=\"oTableInsertableRowComponent.handleKeyboardEvent($event)\" class=\"o-table-insertable\"> </tr>\n            </ng-container>\n            <ng-container *ngIf=\"showTotals | async\">\n              <tr mat-footer-row *matFooterRowDef=\"oTableOptions.visibleColumns; sticky: true\" class=\"o-table-aggregate\">\n              </tr>\n            </ng-container>\n          </table>\n        </div>\n      </div>\n\n      <!--TABLE PAGINATOR-->\n      <mat-paginator *ngIf=\"paginator\" #matpaginator [length]=\"dataSource?.resultsLength\" [pageIndex]=\"paginator.pageIndex\"\n        [pageSize]=\"queryRows\" [pageSizeOptions]=\"paginator.pageSizeOptions\" (page)=\"onChangePage($event)\"\n        [showFirstLastButtons]=\"paginator.showFirstLastButtons\">\n      </mat-paginator>\n\n      <!--LOADING-->\n      <div #spinnerContainer *ngIf=\"showLoading | async\" fxLayout=\"column\" fxLayoutAlign=\"center center\"\n        [ngStyle]=\"{'top.px': headerHeight}\" class=\"spinner-container\"\n        [class.spinner-container-scrollable]=\"loadingScroll | async\">\n        <mat-progress-spinner mode=\"indeterminate\" strokeWidth=\"3\" [diameter]=\"diameterSpinner\"></mat-progress-spinner>\n      </div>\n\n      <!-- Disable blocker -->\n      <div *ngIf=\"!enabled\" class=\"o-table-disabled-blocker\"></div>\n    </div>\n  ",
                    styles: ["\n    .o-table{height:100%;max-height:100%}.o-table.o-table-disabled{opacity:.4}.o-table .o-table-container{height:100%;display:flex;flex-direction:column;flex-wrap:nowrap;justify-content:flex-start;align-items:flex-start;align-content:stretch;position:relative;margin:0 .5%}.o-table .o-table-container .o-table-body{display:flex;flex:1 1 auto}.o-table .o-table-container .o-table-body .o-table-overflow{overflow-y:auto}.o-table .o-table-container .o-table-body thead .mat-header-row th:last-child .o-table-column-resizer{display:none}.o-table .o-table-container.block-events{pointer-events:none}.o-table .o-table-container.block-events>.toolbar,.o-table .o-table-container.block-events>.o-table-body .mat-header-row{opacity:.75}.o-table .o-table-container .toolbar{height:40px}.o-table .o-table-container .toolbar .buttons{margin:0 10px 0 4px}.o-table .o-table-container .toolbar .table-title{font-size:18px;font-weight:400;text-align:center}.o-table .o-table-container .o-table-body{max-width:100%;height:100%;overflow:hidden;position:relative}.o-table .o-table-container .o-table-body:not(.horizontal-scroll){overflow-x:hidden}.o-table .o-table-container .o-table-body .table-title{font-size:18px;font-weight:400;text-align:center}.o-table .o-table-container .o-table-body .spinner-container{position:absolute;top:0;left:0;right:0;bottom:0;z-index:500;visibility:visible;opacity:1;-moz-transition:opacity .25s linear;-webkit-transition:opacity .25s linear;transition:opacity .25s linear}.o-table .o-table-container .o-table-body.horizontal-scroll{overflow-x:auto;padding-bottom:16px}.o-table .o-table-container .o-table-body.horizontal-scroll .mat-header-cell{width:150px}.o-table .o-table-container .o-table-body .o-table-no-results{cursor:default;text-align:center}.o-table .o-table-container .o-table-body .o-table-no-results td{text-align:center}.o-table .o-table-container .mat-table{table-layout:fixed;width:100%}.o-table .o-table-container .mat-table.small .column-filter-icon,.o-table .o-table-container .mat-table.small .mat-sort-header-arrow{margin-top:2px}.o-table .o-table-container .mat-table.small .mat-header-row .mat-checkbox-inner-container,.o-table .o-table-container .mat-table.small .mat-row .mat-checkbox-inner-container{height:16px;width:16px}.o-table .o-table-container .mat-table.small .mat-header-row .mat-checkbox-inner-container .mat-checkbox-checkmark-path,.o-table .o-table-container .mat-table.small .mat-row .mat-checkbox-inner-container .mat-checkbox-checkmark-path{width:2.13333px}.o-table .o-table-container .mat-table.small .mat-header-row .mat-checkbox-inner-container .mat-checkbox-mixedmark,.o-table .o-table-container .mat-table.small .mat-row .mat-checkbox-inner-container .mat-checkbox-mixedmark{height:2px}.o-table .o-table-container .mat-table.small .mat-header-row .mat-cell .image-avatar,.o-table .o-table-container .mat-table.small .mat-header-row .mat-header-cell .image-avatar,.o-table .o-table-container .mat-table.small .mat-row .mat-cell .image-avatar,.o-table .o-table-container .mat-table.small .mat-row .mat-header-cell .image-avatar{width:22px;height:22px}.o-table .o-table-container .mat-table.medium .column-filter-icon{margin-top:4px}.o-table .o-table-container .mat-table.medium .mat-sort-header-arrow{margin-top:6px}.o-table .o-table-container .mat-table.medium .mat-header-row .mat-cell .image-avatar,.o-table .o-table-container .mat-table.medium .mat-header-row .mat-header-cell .image-avatar,.o-table .o-table-container .mat-table.medium .mat-row .mat-cell .image-avatar,.o-table .o-table-container .mat-table.medium .mat-row .mat-header-cell .image-avatar{width:28px;height:28px}.o-table .o-table-container .mat-table.medium .mat-header-row .mat-checkbox-inner-container,.o-table .o-table-container .mat-table.medium .mat-row .mat-checkbox-inner-container{height:18px;width:18px}.o-table .o-table-container .mat-table.medium .mat-header-row .mat-checkbox-inner-container .mat-checkbox-checkmark-path,.o-table .o-table-container .mat-table.medium .mat-row .mat-checkbox-inner-container .mat-checkbox-checkmark-path{width:2.4px}.o-table .o-table-container .mat-table.medium .mat-header-row .mat-checkbox-inner-container .mat-checkbox-mixedmark,.o-table .o-table-container .mat-table.medium .mat-row .mat-checkbox-inner-container .mat-checkbox-mixedmark{height:2px}.o-table .o-table-container .mat-table.large .column-filter-icon,.o-table .o-table-container .mat-table.large .mat-sort-header-arrow{margin-top:8px}.o-table .o-table-container .mat-table .mat-row{box-sizing:border-box;transition:background-color .2s;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.o-table .o-table-container .mat-table .mat-row .mat-cell{padding:0 12px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.o-table .o-table-container .mat-table .mat-row .mat-cell:not(.o-column-image):first-of-type{padding-left:24px}.o-table .o-table-container .mat-table .mat-row .mat-cell:last-of-type{padding-right:24px}.o-table .o-table-container .mat-table .mat-row .mat-cell.empty-cell{min-height:16px}.o-table .o-table-container .mat-table .mat-row .mat-cell .action-cell-renderer{cursor:pointer}.o-table .o-table-container .mat-table .mat-row .mat-cell.o-start{text-align:start}.o-table .o-table-container .mat-table .mat-row .mat-cell.o-center{text-align:center}.o-table .o-table-container .mat-table .mat-row .mat-cell.o-end{text-align:end}.o-table .o-table-container .mat-table .mat-row .mat-cell *{vertical-align:middle}.o-table .o-table-container .mat-table .mat-row .mat-cell.o-mat-cell-multiline{overflow:initial;white-space:normal;text-overflow:unset}.o-table .o-table-container .mat-table .mat-row .mat-cell.o-mat-cell-multiline:not(.mat-header-cell){padding:6px 12px}.o-table .o-table-container .mat-table .mat-row .mat-cell .image-avatar{width:34px;height:34px;margin:1px auto;overflow:hidden;border-radius:50%;position:relative;z-index:1}.o-table .o-table-container .mat-table .mat-row .mat-cell .image-avatar img{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%, -50%);-moz-transform:translate(-50%, -50%);-ms-transform:translate(-50%, -50%);-o-transform:translate(-50%, -50%);transform:translate(-50%, -50%);width:100%;max-width:inherit;max-height:inherit}.o-table .o-table-container .mat-table .o-action-cell-renderer{display:inline-block;cursor:pointer}.o-table .o-table-container .mat-table .mat-header-cell{overflow:hidden;position:relative;box-sizing:border-box;padding:0 12px;vertical-align:middle}.o-table .o-table-container .mat-table .mat-header-cell.resizable{padding-right:24px}.o-table .o-table-container .mat-table .mat-header-cell:first-of-type,.o-table .o-table-container .mat-table .mat-header-cell:last-of-type{padding-left:0;padding-right:0}.o-table .o-table-container .mat-table .mat-header-cell:not(.o-column-image){overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.o-table .o-table-container .mat-table .mat-header-cell.o-mat-cell-multiline{overflow:initial;white-space:normal;text-overflow:unset}.o-table .o-table-container .mat-table .mat-header-cell.o-mat-cell-multiline:not(.mat-header-cell){padding:6px 12px}.o-table .o-table-container .mat-table .mat-header-cell .column-filter-icon{cursor:pointer;float:left;font-size:20px;width:20px;height:20px;margin-right:2px;line-height:1}.o-table .o-table-container .mat-table .mat-header-cell .mat-sort-header-button{flex:1;display:block;place-content:center}.o-table .o-table-container .mat-table .mat-header-cell .mat-sort-header-arrow{position:absolute;right:0}.o-table .o-table-container .mat-table .mat-header-cell .header-title-container{cursor:default}.o-table .o-table-container .mat-table .mat-header-cell.resizable .mat-sort-header-arrow{margin-right:12px}.o-table .o-table-container .mat-table .mat-header-cell .header-title-container,.o-table .o-table-container .mat-table .mat-header-cell .mat-sort-header-button{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.o-table .o-table-container .mat-table .mat-header-cell.start,.o-table .o-table-container .mat-table .mat-header-cell.start .mat-sort-header-button{text-align:left}.o-table .o-table-container .mat-table .mat-header-cell.center,.o-table .o-table-container .mat-table .mat-header-cell.center .mat-sort-header-button{text-align:center}.o-table .o-table-container .mat-table .mat-header-cell.center [o-mat-sort-header] .mat-sort-header-button{padding-left:12px}.o-table .o-table-container .mat-table .mat-header-cell.end,.o-table .o-table-container .mat-table .mat-header-cell.end .mat-sort-header-button{text-align:right}.o-table .o-table-container .mat-table .mat-header-cell .mat-sort-header-container{padding-top:4px}.o-table .o-table-container .mat-table .mat-cell.mat-column-select,.o-table .o-table-container .mat-table .mat-header-cell.mat-column-select{width:18px;box-sizing:content-box;padding:0 0 0 24px;overflow:initial}.o-table .o-table-container .o-table-disabled-blocker{bottom:0;left:0;position:absolute;right:0;top:0;z-index:100}.o-table .spinner-container{position:absolute;top:0;left:0;right:0;bottom:0;z-index:500;visibility:visible;opacity:1;-moz-transition:opacity .25s linear;-webkit-transition:opacity .25s linear;transition:opacity .25s linear}.o-table .spinner-container-scrollable{position:relative}.o-table.o-table-fixed{display:flex}.o-table.o-table-fixed .o-table-container{display:flex;flex-direction:column}.o-table.o-table-fixed .o-table-body{display:flex;flex:1}.o-table.o-table-fixed .o-table-body .o-table-overflow{flex:1;overflow:auto}.mat-tooltip.o-table-cell-tooltip{word-wrap:break-word;max-height:64px;overflow:hidden;min-width:140px}\n  "],
                    providers: [
                        { provide: OntimizeService$$1, useFactory: 0$5, deps: [core.Injector] }
                    ],
                    inputs: DEFAULT_INPUTS_O_TABLE,
                    outputs: DEFAULT_OUTPUTS_O_TABLE,
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class.o-table]': 'true',
                        '[class.ontimize-table]': 'true',
                        '[class.o-table-fixed]': 'fixedHeader',
                        '[class.o-table-disabled]': '!enabled',
                        '(document:click)': 'handleDOMClick($event)'
                    }
                },] },
    ];
    /** @nocollapse */
    OTableComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: core.ElementRef },
        { type: material.MatDialog },
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] }
    ]; };
    OTableComponent.propDecorators = {
        matpaginator: [{ type: core.ViewChild, args: [material.MatPaginator,] }],
        sort: [{ type: core.ViewChild, args: [OMatSort,] }],
        sortHeaders: [{ type: core.ViewChildren, args: [OMatSortHeader,] }],
        spinnerContainer: [{ type: core.ViewChild, args: ['spinnerContainer', { read: core.ElementRef },] }],
        tableBodyEl: [{ type: core.ViewChild, args: ['tableBody',] }],
        tableHeaderEl: [{ type: core.ViewChild, args: ['tableHeader', { read: core.ElementRef },] }],
        tableToolbarEl: [{ type: core.ViewChild, args: ['tableToolbar', { read: core.ElementRef },] }],
        updateScrolledState: [{ type: core.HostListener, args: ['window:resize', ['$event'],] }],
        oTableMenu: [{ type: core.ViewChild, args: ['tableMenu',] }],
        tableOptions: [{ type: core.ContentChildren, args: [OTableOptionComponent,] }],
        oTableButtons: [{ type: core.ViewChild, args: ['tableButtons',] }],
        tableButtons: [{ type: core.ContentChildren, args: [OTableButtonComponent,] }],
        oTableExpandedFooter: [{ type: core.ViewChild, args: [OTableExpandedFooter,] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "selectAllCheckbox", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "exportButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "columnsVisibilityButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "showButtonsText", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], OTableComponent.prototype, "filterCaseSensitive", null);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "insertButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "refreshButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "deleteButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "paginationControls", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "fixedHeader", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "showTitle", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "horizontalScroll", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "showPaginatorFirstLastButtons", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "autoAlignTitles", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "multipleSort", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "orderable", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "resizable", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTableComponent.prototype, "keepSelectedItems", void 0);
    return OTableComponent;
}(OServiceComponent$$1));
var OTableModule = /** @class */ (function () {
    function OTableModule() {
    }
    OTableModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [
                        OTableComponent,
                        OTableColumnComponent,
                        OTableColumnCalculatedComponent,
                        OTableContextMenuComponent,
                        OTableRowDirective,
                        OTableExpandedFooter
                    ].concat(O_TABLE_CELL_RENDERERS, O_TABLE_CELL_EDITORS, O_TABLE_DIALOGS, O_TABLE_HEADER_COMPONENTS, O_TABLE_FOOTER_COMPONENTS),
                    imports: [
                        common.CommonModule,
                        OSharedModule,
                        CdkTableModule,
                        DndModule,
                        OContextMenuModule,
                        ObserversModule,
                        OMatSortModule,
                        NgxMaterialTimepickerModule
                    ],
                    exports: [
                        OTableComponent,
                        OTableColumnComponent,
                        CdkTableModule,
                        OTableColumnCalculatedComponent,
                        OTableContextMenuComponent,
                        OTableRowDirective,
                        OTableExpandedFooter,
                        OMatSortModule
                    ].concat(O_TABLE_HEADER_COMPONENTS, O_TABLE_CELL_RENDERERS, O_TABLE_CELL_EDITORS, O_TABLE_FOOTER_COMPONENTS),
                    entryComponents: [
                        OTableColumnAggregateComponent,
                        OTableContextMenuComponent
                    ].concat(O_TABLE_CELL_RENDERERS, O_TABLE_CELL_EDITORS, O_TABLE_DIALOGS),
                    providers: [{
                            provide: material.MatPaginatorIntl,
                            useClass: OTableMatPaginatorIntl
                        }]
                },] },
    ];
    return OTableModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OFormLayoutManagerService = /** @class */ (function () {
    function OFormLayoutManagerService(injector) {
        this.injector = injector;
        this.registeredFormLayoutManagers = {};
    }
    /**
     * @param {?} comp
     * @return {?}
     */
    OFormLayoutManagerService.prototype.registerFormLayoutManager = /**
     * @param {?} comp
     * @return {?}
     */
    function (comp) {
        this.registeredFormLayoutManagers[comp.getAttribute()] = comp;
    };
    /**
     * @param {?} comp
     * @return {?}
     */
    OFormLayoutManagerService.prototype.removeFormLayoutManager = /**
     * @param {?} comp
     * @return {?}
     */
    function (comp) {
        delete this.registeredFormLayoutManagers[comp.getAttribute()];
    };
    Object.defineProperty(OFormLayoutManagerService.prototype, "activeFormLayoutManager", {
        get: /**
         * @return {?}
         */
        function () {
            return this._activeFormLayoutManager;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._activeFormLayoutManager = arg;
        },
        enumerable: true,
        configurable: true
    });
    OFormLayoutManagerService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OFormLayoutManagerService.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return OFormLayoutManagerService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_FORM_LAYOUT_DIALOG_OPTIONS = [
    'width',
    'minWidth: min-width',
    'maxWidth: max-width',
    'height',
    'minHeight: min-height',
    'maxHeight max-height',
    'class',
    'position',
    'backdropClass: backdrop-class',
    'closeOnNavigation: close-on-navigation',
    'disableClose:disable-close'
];
var OFormLayoutDialogOptionsComponent = /** @class */ (function () {
    function OFormLayoutDialogOptionsComponent(oFormLayoutManager) {
        this.oFormLayoutManager = oFormLayoutManager;
        this.width = '';
        this.height = '';
        this.class = '';
        this.closeOnNavigation = true;
        this.disableClose = true;
    }
    OFormLayoutDialogOptionsComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-form-layout-dialog-options',
                    template: ' ',
                    inputs: DEFAULT_INPUTS_O_FORM_LAYOUT_DIALOG_OPTIONS,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-form-layout-dialog-options]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OFormLayoutDialogOptionsComponent.ctorParameters = function () { return [
        { type: OFormLayoutManagerComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OFormLayoutManagerComponent; }),] }] }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormLayoutDialogOptionsComponent.prototype, "closeOnNavigation", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormLayoutDialogOptionsComponent.prototype, "disableClose", void 0);
    return OFormLayoutDialogOptionsComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CanActivateFormLayoutChildGuard = /** @class */ (function () {
    function CanActivateFormLayoutChildGuard(injector) {
        this.injector = injector;
        this.shareCanActivateChildService = this.injector.get(ShareCanActivateChildService);
        try {
            this.oFormLayoutService = this.injector.get(OFormLayoutManagerService);
        }
        catch (e) {
            console.error(e);
        }
    }
    /**
     * @param {?} childRoute
     * @param {?} state
     * @return {?}
     */
    CanActivateFormLayoutChildGuard.prototype.canActivateChild = /**
     * @param {?} childRoute
     * @param {?} state
     * @return {?}
     */
    function (childRoute, state$$1) {
        /** @type {?} */
        var formLayoutManager = this.oFormLayoutService.activeFormLayoutManager;
        this.oFormLayoutService.activeFormLayoutManager = undefined;
        if (formLayoutManager) {
            /** @type {?} */
            var oPermission = childRoute.data ? childRoute.data['oPermission'] : undefined;
            /** @type {?} */
            var permissionId = (oPermission || {})['permissionId'];
            if (Util.isDefined(permissionId)) {
                /** @type {?} */
                var restricted = !this.shareCanActivateChildService.canActivateChildUsingPermissions(childRoute, state$$1);
                if (restricted) {
                    return false;
                }
            }
            formLayoutManager.addDetailComponent(childRoute, state$$1.url.substring(0, state$$1.url.indexOf('?')));
            return false;
        }
        return true;
    };
    CanActivateFormLayoutChildGuard.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    CanActivateFormLayoutChildGuard.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    return CanActivateFormLayoutChildGuard;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_FORM_LAYOUT_TABGROUP = [
    'title',
    'options'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_FORM_LAYOUT_TABGROUP = [
    'onMainTabSelected',
    'onSelectedTabChange',
    'onCloseTab'
];
var OFormLayoutTabGroupComponent = /** @class */ (function () {
    function OFormLayoutTabGroupComponent(injector, componentFactoryResolver, location, elRef) {
        this.injector = injector;
        this.componentFactoryResolver = componentFactoryResolver;
        this.location = location;
        this.elRef = elRef;
        this.data = [];
        this.showLoading = new BehaviorSubject(false);
        this.loading = false;
        this.onMainTabSelected = new core.EventEmitter();
        this.onSelectedTabChange = new core.EventEmitter();
        this.onCloseTab = new core.EventEmitter();
        this.dialogService = injector.get(DialogService);
        this.formLayoutManager = this.injector.get(OFormLayoutManagerComponent);
        this.router = this.injector.get(router.Router);
    }
    /**
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.tabsDirectivesSubscription = this.tabsDirectives.changes.subscribe(function (changes) {
            if (_this.tabsDirectives.length) {
                /** @type {?} */
                var tabItem = _this.tabsDirectives.last;
                /** @type {?} */
                var tabData = _this.data[tabItem.index];
                if (tabData && !tabData.rendered) {
                    _this.createTabComponent(tabData, tabItem);
                }
            }
        });
    };
    /**
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.tabsDirectivesSubscription) {
            this.tabsDirectivesSubscription.unsubscribe();
        }
        if (this.closeTabSubscription) {
            this.closeTabSubscription.unsubscribe();
        }
    };
    Object.defineProperty(OFormLayoutTabGroupComponent.prototype, "disableAnimation", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options && this.options.disableAnimation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormLayoutTabGroupComponent.prototype, "headerPosition", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var headerPosition;
            if (this.options && this.options.headerPosition) {
                headerPosition = this.options.headerPosition;
            }
            return headerPosition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormLayoutTabGroupComponent.prototype, "color", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var color;
            if (this.options && this.options.color) {
                color = this.options.color;
            }
            return color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormLayoutTabGroupComponent.prototype, "backgroundColor", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var backgroundColor;
            if (this.options && this.options.backgroundColor) {
                backgroundColor = this.options.backgroundColor;
            }
            return backgroundColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormLayoutTabGroupComponent.prototype, "templateMatTabLabel", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var templateMatTabLabel;
            if (this.options && this.options.templateMatTabLabel) {
                templateMatTabLabel = this.options.templateMatTabLabel;
            }
            return templateMatTabLabel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormLayoutTabGroupComponent.prototype, "icon", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var icon;
            if (this.options && this.options.icon) {
                icon = this.options.icon;
            }
            return icon;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormLayoutTabGroupComponent.prototype, "isIconPositionLeft", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options && this.options.iconPosition === 'left';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} compData
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.addTab = /**
     * @param {?} compData
     * @return {?}
     */
    function (compData) {
        /** @type {?} */
        var addNewComp = true;
        /** @type {?} */
        var navData = this.formLayoutManager.navigationService.getLastItem();
        if (navData.isInsertFormRoute()) {
            /** @type {?} */
            var existingData = this.data.find(function (item) { return item.insertionMode; });
            addNewComp = !existingData;
        }
        /** @type {?} */
        var newCompParams = compData.params;
        if (addNewComp) {
            this.data.forEach(function (comp) {
                /** @type {?} */
                var currParams = comp.params || {};
                Object.keys(currParams).forEach(function (key) {
                    addNewComp = addNewComp && (currParams[key] !== newCompParams[key]);
                });
            });
        }
        if (addNewComp) {
            this.data.push(compData);
        }
        else {
            this.reloadTab(compData);
        }
    };
    /**
     * @param {?} compData
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.reloadTab = /**
     * @param {?} compData
     * @return {?}
     */
    function (compData) {
        /** @type {?} */
        var compIndex = -1;
        /** @type {?} */
        var compParams = compData.params;
        this.data.forEach(function (comp, i) {
            /** @type {?} */
            var currParams = comp.params || {};
            /** @type {?} */
            var sameParams = Util.isEquivalent(currParams, compParams);
            if (sameParams) {
                compIndex = i;
            }
        });
        if (compIndex >= 0) {
            this.tabGroup.selectedIndex = (compIndex + 1);
        }
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.onTabSelectChange = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        if (this.formLayoutManager && this.tabGroup.selectedIndex === 0) {
            this.formLayoutManager.updateIfNeeded();
            this.onMainTabSelected.emit();
        }
        if (Util.isDefined(this.state) && Util.isDefined(this.state.tabsData)) {
            if (this.state.tabsData.length > 1) {
                if ((arg.index === this.state.tabsData.length) && Util.isDefined(this.state.selectedIndex)) {
                    this.selectedTabIndex = this.state.selectedIndex;
                    this.state = undefined;
                }
            }
            else {
                this.state = undefined;
            }
        }
        this.onSelectedTabChange.emit(this.data[this.selectedTabIndex - 1]);
    };
    /**
     * @param {?} id
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.closeTab = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        if (!this.formLayoutManager) {
            return;
        }
        /** @type {?} */
        var onCloseTabAccepted = new core.EventEmitter();
        /** @type {?} */
        var self = this;
        this.closeTabSubscription = onCloseTabAccepted.asObservable().subscribe(function (res) {
            if (res) {
                /** @type {?} */
                var tabData_1 = void 0;
                for (var i = self.data.length - 1; i >= 0; i--) {
                    if (self.data[i].id === id) {
                        tabData_1 = self.data.splice(i, 1)[0];
                        break;
                    }
                }
                self.onCloseTab.emit(tabData_1);
            }
        });
        /** @type {?} */
        var tabData = this.data.find(function (item) { return item.id === id; });
        if (Util.isDefined(tabData) && tabData.modified) {
            this.dialogService.confirm('CONFIRM', 'MESSAGES.FORM_CHANGES_WILL_BE_LOST').then(function (res) {
                onCloseTabAccepted.emit(res);
            });
        }
        else {
            onCloseTabAccepted.emit(true);
        }
    };
    /**
     * @param {?} tabData
     * @param {?} content
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.createTabComponent = /**
     * @param {?} tabData
     * @param {?} content
     * @return {?}
     */
    function (tabData, content) {
        /** @type {?} */
        var component = tabData.component;
        /** @type {?} */
        var componentFactory = this.componentFactoryResolver.resolveComponentFactory(component);
        /** @type {?} */
        var viewContainerRef = content.viewContainerRef;
        viewContainerRef.clear();
        viewContainerRef.createComponent(componentFactory);
        tabData.rendered = true;
    };
    /**
     * @param {?} idArg
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.getFormCacheData = /**
     * @param {?} idArg
     * @return {?}
     */
    function (idArg) {
        return this.data.filter(function (cacheItem) { return cacheItem.id === idArg; })[0];
    };
    /**
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.getLastTabId = /**
     * @return {?}
     */
    function () {
        return this.data.length > 0 ? this.data[this.data.length - 1].id : undefined;
    };
    /**
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.getRouteOfActiveItem = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var route = [];
        if (this.data.length && this.tabGroup.selectedIndex > 0) {
            /** @type {?} */
            var urlSegments = this.data[this.tabGroup.selectedIndex - 1].urlSegments || [];
            urlSegments.forEach(function (segment) {
                route.push(segment.path);
            });
            return route;
        }
        return route;
    };
    /**
     * @param {?} modified
     * @param {?} id
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.setModifiedState = /**
     * @param {?} modified
     * @param {?} id
     * @return {?}
     */
    function (modified, id) {
        for (var i = 0, len = this.data.length; i < len; i++) {
            if (this.data[i].id === id) {
                this.data[i].modified = modified;
                break;
            }
        }
    };
    /**
     * @param {?} data
     * @param {?} id
     * @param {?=} insertionMode
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.updateNavigation = /**
     * @param {?} data
     * @param {?} id
     * @param {?=} insertionMode
     * @return {?}
     */
    function (data, id, insertionMode) {
        /** @type {?} */
        var index = this.data.findIndex(function (item) { return item.id === id; });
        if (index >= 0) {
            /** @type {?} */
            var label = this.formLayoutManager.getLabelFromData(data);
            this.tabGroup.selectedIndex = (index + 1);
            label = label.length ? label : this.formLayoutManager.getLabelFromUrlParams(this.data[index].params);
            this.data[index].label = label;
            this.data[index].insertionMode = insertionMode;
            if (Object.keys(data).length > 0) {
                this.data[index].formDataByLabelColumns = this.formLayoutManager.getFormDataFromLabelColumns(data);
            }
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.updateActiveData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var index = this.tabGroup.selectedIndex - 1;
        if (Util.isDefined(this.data[index])) {
            this.data[index] = Object.assign(this.data[index], data);
        }
    };
    /**
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.getDataToStore = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var tabsData = [];
        this.data.map(function (data) {
            tabsData.push({
                params: data.params,
                queryParams: data.queryParams,
                urlSegments: data.urlSegments,
                url: data.url
            });
        });
        return {
            tabsData: tabsData,
            selectedIndex: this.tabGroup.selectedIndex
        };
    };
    /**
     * @param {?} state
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.initializeComponentState = /**
     * @param {?} state
     * @return {?}
     */
    function (state$$1) {
        if (Util.isDefined(state$$1) && Util.isDefined(state$$1.tabsData) && Util.isDefined(state$$1.tabsData[0])) {
            this.state = state$$1;
            /** @type {?} */
            var extras = {};
            extras[Codes.QUERY_PARAMS] = state$$1.tabsData[0].queryParams;
            /** @type {?} */
            var self_1 = this;
            if (this.formLayoutManager) {
                this.formLayoutManager.setAsActiveFormLayoutManager();
            }
            this.router.navigate([state$$1.tabsData[0].url], extras).then(function (val) {
                if (self_1.data[0]) {
                    setTimeout(function () {
                        self_1.createTabsFromState();
                    }, 0);
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.createTabsFromState = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var tabComponent = self.data[0].component;
        this.state.tabsData.forEach(function (tabData, index) {
            if (tabComponent && index > 0) {
                setTimeout(function () {
                    /** @type {?} */
                    var newDetailData = self.createDetailComponent(tabComponent, tabData);
                    self.data.push(newDetailData);
                }, 0);
            }
        });
    };
    /**
     * @param {?} component
     * @param {?} paramsObj
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.createDetailComponent = /**
     * @param {?} component
     * @param {?} paramsObj
     * @return {?}
     */
    function (component, paramsObj) {
        /** @type {?} */
        var newDetailComp = {
            params: paramsObj.params,
            queryParams: paramsObj.queryParams,
            urlSegments: paramsObj.urlSegments,
            component: component,
            url: paramsObj.url,
            id: Math.random().toString(36),
            label: '',
            modified: false
        };
        return newDetailComp;
    };
    Object.defineProperty(OFormLayoutTabGroupComponent.prototype, "state", {
        get: /**
         * @return {?}
         */
        function () {
            return this._state;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._state = arg;
            if (Util.isDefined(arg)) {
                this.showLoading.next(true);
            }
            else {
                this.showLoading.next(false);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OFormLayoutTabGroupComponent.prototype.getParams = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this.data[0]) ? this.data[0].params : undefined;
    };
    Object.defineProperty(OFormLayoutTabGroupComponent.prototype, "elementRef", {
        get: /**
         * @return {?}
         */
        function () {
            return this.elRef;
        },
        enumerable: true,
        configurable: true
    });
    OFormLayoutTabGroupComponent.DEFAULT_INPUTS_O_FORM_LAYOUT_TABGROUP = DEFAULT_INPUTS_O_FORM_LAYOUT_TABGROUP;
    OFormLayoutTabGroupComponent.DEFAULT_OUTPUTS_O_FORM_LAYOUT_TABGROUP = DEFAULT_OUTPUTS_O_FORM_LAYOUT_TABGROUP;
    OFormLayoutTabGroupComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-form-layout-tabgroup',
                    inputs: DEFAULT_INPUTS_O_FORM_LAYOUT_TABGROUP,
                    outputs: DEFAULT_OUTPUTS_O_FORM_LAYOUT_TABGROUP,
                    template: "\n    <mat-tab-group #tabGroup oTabGroup=\"ontimize\" fxFill [(selectedIndex)]=\"selectedTabIndex\"\n      (selectedTabChange)=\"onTabSelectChange($event)\" [color]=\"color\" [backgroundColor]=\"backgroundColor\"\n      [headerPosition]=\"headerPosition\" [@.disabled]=\"disableAnimation\">\n      <mat-tab label=\"{{ (title || 'LAYOUT_MANANGER.MAIN_TAB_LABEL') | oTranslate }}\">\n        <ng-content></ng-content>\n      </mat-tab>\n\n\n      <mat-tab *ngFor=\"let tabData of data; let i = index\">\n        <ng-template mat-tab-label>\n\n          <span class=\"tab-label\" [class.modified]=\"tabData.modified\">\n            <ng-container *ngIf=\"icon && isIconPositionLeft\">\n              <mat-icon>{{ icon }}</mat-icon>\n            </ng-container>\n            <ng-container *ngIf=\"templateMatTabLabel && tabData.formDataByLabelColumns && !tabData.insertionMode \">\n              <ng-container *ngTemplateOutlet=\"templateMatTabLabel;context:{$implicit:tabData.formDataByLabelColumns}\">\n              </ng-container>\n            </ng-container>\n            <ng-container *ngIf=\"!templateMatTabLabel || tabData.insertionMode\">\n              {{ tabData.label }}\n            </ng-container>\n            <ng-container *ngIf=\"icon && !isIconPositionLeft\">\n              <mat-icon>{{ icon }}</mat-icon>\n            </ng-container>\n          </span>\n          <mat-icon (click)=\"closeTab(tabData.id)\" svgIcon=\"ontimize:close\"></mat-icon>\n        </ng-template>\n        <ng-template o-form-layout-manager-content [index]=\"i\"></ng-template>\n      </mat-tab>\n    </mat-tab-group>\n    <div *ngIf=\"showLoading | async\" class=\"spinner-container\" fxLayout=\"column\" fxLayoutAlign=\"center center\">\n      <mat-progress-spinner mode=\"indeterminate\" strokeWidth=\"3\"></mat-progress-spinner>\n    </div>\n  ",
                    styles: ["\n    .o-form-layout-tabgroup .mat-tab-group .mat-tab-label span.tab-label{width:100%;max-width:120px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.o-form-layout-tabgroup .mat-tab-group .mat-tab-label span.tab-label.modified{font-weight:700}.o-form-layout-tabgroup .mat-tab-group .mat-tab-label span.tab-label.modified:after{content:'*'}.o-form-layout-tabgroup .mat-tab-group .mat-tab-label .mat-icon{height:16px;width:16px;font-size:16px;padding-left:6px;vertical-align:middle}.o-form-layout-tabgroup .mat-tab-group .mat-tab-body-wrapper{flex:1 1 auto}.o-form-layout-tabgroup .mat-tab-group o-form-toolbar{padding:0;top:0px !important}.o-form-layout-tabgroup .mat-tab-group o-form-toolbar .mat-toolbar{box-shadow:none;border-radius:0}.o-form-layout-tabgroup .spinner-container{position:absolute;top:0;left:0;right:0;bottom:0;z-index:500;visibility:visible;opacity:1;-moz-transition:opacity .25s linear;-webkit-transition:opacity .25s linear;transition:opacity .25s linear}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-form-layout-tabgroup]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OFormLayoutTabGroupComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: core.ComponentFactoryResolver },
        { type: core.ViewContainerRef },
        { type: core.ElementRef }
    ]; };
    OFormLayoutTabGroupComponent.propDecorators = {
        tabGroup: [{ type: core.ViewChild, args: ['tabGroup',] }],
        tabsDirectives: [{ type: core.ViewChildren, args: [OFormLayoutManagerContentDirective,] }]
    };
    return OFormLayoutTabGroupComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_FORM_LAYOUT_TABGROUP_OPTIONS = [
    'backgroundColor:background-color',
    'color',
    'headerPosition:header-position',
    'disableAnimation:disable-animation',
    'icon',
    'iconPosition:icon-position'
];
var OFormLayoutTabGroupOptionsComponent = /** @class */ (function () {
    function OFormLayoutTabGroupOptionsComponent(oFormLayoutManager) {
        this.oFormLayoutManager = oFormLayoutManager;
        this.iconPosition = 'left';
    }
    OFormLayoutTabGroupOptionsComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-form-layout-tabgroup-options',
                    template: ' ',
                    encapsulation: core.ViewEncapsulation.None,
                    inputs: DEFAULT_INPUTS_O_FORM_LAYOUT_TABGROUP_OPTIONS,
                    host: {
                        '[class.o-form-layout-tabgroup-options]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OFormLayoutTabGroupOptionsComponent.ctorParameters = function () { return [
        { type: OFormLayoutManagerComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OFormLayoutManagerComponent; }),] }] }
    ]; };
    OFormLayoutTabGroupOptionsComponent.propDecorators = {
        templateMatTabLabel: [{ type: core.ContentChild, args: [core.TemplateRef,] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormLayoutTabGroupOptionsComponent.prototype, "disableAnimation", void 0);
    return OFormLayoutTabGroupOptionsComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_FORM_LAYOUT_MANAGER = [
    'oattr: attr',
    'mode',
    'labelColumns: label-columns',
    'separator',
    'title',
    'storeState: store-state',
    'titleDataOrigin: title-data-origin',
    'dialogWidth: dialog-width',
    'dialogMinWidth: dialog-min-width',
    'dialogMaxWidth: dialog-max-width',
    'dialogHeight: dialog-height',
    'dialogMinHeight: dialog-min-height',
    'dialogMaxHeight dialog-max-height',
    'dialogClass: dialog-class'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_FORM_LAYOUT_MANAGER = [
    'onMainTabSelected',
    'onSelectedTabChange',
    'onCloseTab'
];
var OFormLayoutManagerComponent = /** @class */ (function () {
    function OFormLayoutManagerComponent(injector, router$$1, actRoute, dialog, elRef, parentFormLayoutManager) {
        var _this = this;
        this.injector = injector;
        this.router = router$$1;
        this.actRoute = actRoute;
        this.dialog = dialog;
        this.elRef = elRef;
        this.parentFormLayoutManager = parentFormLayoutManager;
        this.separator = ' ';
        this.storeState = true;
        this.dialogClass = '';
        this.onMainTabSelected = new core.EventEmitter();
        this.onSelectedTabChange = new core.EventEmitter();
        this.onCloseTab = new core.EventEmitter();
        this.labelColsArray = [];
        this.addingGuard = false;
        this.markForUpdate = false;
        this.onTriggerUpdate = new core.EventEmitter();
        this.oFormLayoutManagerService = this.injector.get(OFormLayoutManagerService);
        this.localStorageService = this.injector.get(LocalStorageService);
        this.translateService = this.injector.get(OTranslateService$$1);
        this.navigationService = this.injector.get(NavigationService);
        if (this.storeState) {
            this.onRouteChangeStorageSubscription = this.localStorageService.onRouteChange.subscribe(function (res) {
                _this.updateStateStorage();
            });
        }
    }
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var availableModeValues = [OFormLayoutManagerComponent.DIALOG_MODE, OFormLayoutManagerComponent.TAB_MODE];
        this.mode = (this.mode || '').toLowerCase();
        if (availableModeValues.indexOf(this.mode) === -1) {
            this.mode = OFormLayoutManagerComponent.DIALOG_MODE;
        }
        this.labelColsArray = Util.parseArray(this.labelColumns);
        this.addActivateChildGuard();
        if (!Util.isDefined(this.oattr)) {
            this.oattr = this.title + this.mode;
            console.warn('o-form-layout-manager must have an unique attr');
        }
        this.oFormLayoutManagerService.registerFormLayoutManager(this);
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            if (_this.elRef) {
                _this.elRef.nativeElement.removeAttribute('title');
            }
            if (_this.storeState && _this.isTabMode() && Util.isDefined(_this.oTabGroup)) {
                /** @type {?} */
                var state$$1 = _this.localStorageService.getComponentStorage(_this);
                _this.oTabGroup.initializeComponentState(state$$1);
            }
        });
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.onRouteChangeStorageSubscription) {
            this.onRouteChangeStorageSubscription.unsubscribe();
        }
        this.updateStateStorage();
        this.oFormLayoutManagerService.removeFormLayoutManager(this);
        this.destroyAactivateChildGuard();
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.getAttribute = /**
     * @return {?}
     */
    function () {
        return this.oattr;
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.getComponentKey = /**
     * @return {?}
     */
    function () {
        return 'OFormLayoutManagerComponent_' + this.oattr;
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.getDataToStore = /**
     * @return {?}
     */
    function () {
        // only storing in tab mode
        if (this.isTabMode() && Util.isDefined(this.oTabGroup)) {
            return this.oTabGroup.getDataToStore();
        }
        return {};
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.beforeunloadHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.updateStateStorage();
    };
    /**
     * @param {?} urlParams
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.getLabelFromUrlParams = /**
     * @param {?} urlParams
     * @return {?}
     */
    function (urlParams) {
        var _this = this;
        /** @type {?} */
        var label = '';
        /** @type {?} */
        var keys = Object.keys(urlParams);
        keys.forEach(function (param, i) {
            label += urlParams[param] + ((i < keys.length - 1) ? _this.separator : '');
        });
        return label;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.getFormDataFromLabelColumns = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        /** @type {?} */
        var formData = {};
        Object.keys(data).map(function (x) {
            if (_this.labelColsArray.indexOf(x) > -1) {
                formData[x] = data[x];
            }
        });
        return formData;
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.addActivateChildGuard = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var routeConfig = this.getParentActRouteRoute();
        if (Util.isDefined(routeConfig)) {
            /** @type {?} */
            var canActivateChildArray = (routeConfig.canActivateChild || []);
            /** @type {?} */
            var previouslyAdded = false;
            for (var i = 0, len = canActivateChildArray.length; i < len; i++) {
                previouslyAdded = (canActivateChildArray[i].name === OFormLayoutManagerComponent.guardClassName);
                if (previouslyAdded) {
                    break;
                }
            }
            if (!previouslyAdded) {
                this.addingGuard = true;
                canActivateChildArray.push(CanActivateFormLayoutChildGuard);
                routeConfig.canActivateChild = canActivateChildArray;
            }
        }
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.destroyAactivateChildGuard = /**
     * @return {?}
     */
    function () {
        if (!this.addingGuard) {
            return;
        }
        /** @type {?} */
        var routeConfig = this.getParentActRouteRoute();
        if (Util.isDefined(routeConfig)) {
            for (var i = (routeConfig.canActivateChild || []).length - 1; i >= 0; i--) {
                if (routeConfig.canActivateChild[i].name === OFormLayoutManagerComponent.guardClassName) {
                    routeConfig.canActivateChild.splice(i, 1);
                    break;
                }
            }
        }
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.isDialogMode = /**
     * @return {?}
     */
    function () {
        return this.mode === OFormLayoutManagerComponent.DIALOG_MODE;
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.isTabMode = /**
     * @return {?}
     */
    function () {
        return this.mode === OFormLayoutManagerComponent.TAB_MODE;
    };
    /**
     * @param {?} childRoute
     * @param {?} url
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.addDetailComponent = /**
     * @param {?} childRoute
     * @param {?} url
     * @return {?}
     */
    function (childRoute, url) {
        /** @type {?} */
        var newDetailComp = {
            params: childRoute.params,
            queryParams: childRoute.queryParams,
            urlSegments: childRoute.url,
            component: childRoute.routeConfig.component,
            url: url,
            id: Math.random().toString(36),
            label: '',
            modified: false
        };
        if (this.isTabMode() && Util.isDefined(this.oTabGroup)) {
            this.oTabGroup.addTab(newDetailComp);
        }
        else if (this.isDialogMode()) {
            this.openFormLayoutDialog(newDetailComp);
        }
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.closeDetail = /**
     * @param {?=} id
     * @return {?}
     */
    function (id) {
        if (this.isTabMode() && Util.isDefined(this.oTabGroup)) {
            this.oTabGroup.closeTab(id);
        }
        else if (this.isDialogMode() && Util.isDefined(this.dialogRef)) {
            this.dialogRef.close();
            this.reloadMainComponents();
        }
    };
    /**
     * @param {?} detailComp
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.openFormLayoutDialog = /**
     * @param {?} detailComp
     * @return {?}
     */
    function (detailComp) {
        var _this = this;
        /** @type {?} */
        var cssclass = ['o-form-layout-dialog-overlay'];
        if (this.dialogClass) {
            cssclass.push(this.dialogClass);
        }
        /** @type {?} */
        var dialogConfig = {
            data: {
                data: detailComp,
                layoutManagerComponent: this,
                title: this.title,
            },
            width: this.dialogOptions ? this.dialogOptions.width : this.dialogWidth,
            minWidth: this.dialogOptions ? this.dialogOptions.minWidth : this.dialogMinWidth,
            maxWidth: this.dialogOptions ? this.dialogOptions.maxWidth : this.dialogMaxWidth,
            height: this.dialogOptions ? this.dialogOptions.height : this.dialogHeight,
            minHeight: this.dialogOptions ? this.dialogOptions.minHeight : this.dialogMinHeight,
            maxHeight: this.dialogOptions ? this.dialogOptions.maxHeight : this.dialogMaxHeight,
            disableClose: this.dialogOptions ? this.dialogOptions.disableClose : true,
            panelClass: this.dialogOptions ? this.dialogOptions.class : cssclass
        };
        if (this.dialogOptions) {
            dialogConfig.closeOnNavigation = this.dialogOptions.closeOnNavigation;
            dialogConfig.backdropClass = this.dialogOptions.backdropClass;
            dialogConfig.position = this.dialogOptions.position;
            dialogConfig.disableClose = this.dialogOptions.disableClose;
        }
        this.dialogRef = this.dialog.open(OFormLayoutDialogComponent, dialogConfig);
        this.dialogRef.afterClosed().subscribe(function () {
            _this.updateIfNeeded();
        });
    };
    /**
     * @param {?} formId
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.getFormCacheData = /**
     * @param {?} formId
     * @return {?}
     */
    function (formId) {
        if (this.isTabMode() && Util.isDefined(this.oTabGroup)) {
            return this.oTabGroup.getFormCacheData(formId);
        }
        else if (this.isDialogMode() && Util.isDefined(this.dialogRef)) {
            return this.dialogRef.componentInstance.data;
        }
        return undefined;
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.getLastTabId = /**
     * @return {?}
     */
    function () {
        if (this.isTabMode() && Util.isDefined(this.oTabGroup)) {
            return this.oTabGroup.getLastTabId();
        }
        return undefined;
    };
    /**
     * @param {?} modified
     * @param {?} id
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.setModifiedState = /**
     * @param {?} modified
     * @param {?} id
     * @return {?}
     */
    function (modified, id) {
        if (this.isTabMode() && Util.isDefined(this.oTabGroup)) {
            this.oTabGroup.setModifiedState(modified, id);
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.getLabelFromData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        /** @type {?} */
        var label = '';
        /** @type {?} */
        var isDataDefined = Util.isDefined(data);
        if (isDataDefined && data.hasOwnProperty('new_tab_title')) {
            label = this.translateService.get(data['new_tab_title']);
        }
        else if (isDataDefined && this.labelColsArray.length !== 0) {
            this.labelColsArray.forEach(function (col, idx) {
                if (data[col] !== undefined) {
                    label += data[col] + ((idx < _this.labelColsArray.length - 1) ? _this.separator : '');
                }
            });
        }
        return label;
    };
    /**
     * @param {?} data
     * @param {?} id
     * @param {?=} insertionMode
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.updateNavigation = /**
     * @param {?} data
     * @param {?} id
     * @param {?=} insertionMode
     * @return {?}
     */
    function (data, id, insertionMode) {
        if (this.isTabMode() && Util.isDefined(this.oTabGroup)) {
            this.oTabGroup.updateNavigation(data, id, insertionMode);
        }
        else if (this.isDialogMode() && Util.isDefined(this.dialogRef)) {
            this.dialogRef.componentInstance.updateNavigation(data, id);
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.updateActiveData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (this.isTabMode() && Util.isDefined(this.oTabGroup)) {
            this.oTabGroup.updateActiveData(data);
        }
        else if (this.isDialogMode() && Util.isDefined(this.dialogRef)) {
            this.dialogRef.componentInstance.updateActiveData(data);
        }
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.getRouteOfActiveItem = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var route = [];
        if (this.isTabMode() && Util.isDefined(this.oTabGroup)) {
            route = this.oTabGroup.getRouteOfActiveItem();
        }
        else if (this.isDialogMode() && Util.isDefined(this.dialogRef)) {
            route = this.dialogRef.componentInstance.getRouteOfActiveItem();
        }
        return route;
    };
    /**
     * @param {?} comp
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.isMainComponent = /**
     * @param {?} comp
     * @return {?}
     */
    function (comp) {
        /** @type {?} */
        var result = false;
        if (this.isTabMode() && Util.isDefined(this.oTabGroup)) {
            /** @type {?} */
            var firstTab = this.oTabGroup.elementRef.nativeElement.getElementsByTagName('mat-tab-body')[0];
            if (firstTab) {
                result = firstTab.contains(comp.elementRef.nativeElement);
            }
        }
        else if (this.isDialogMode()) {
            result = !comp.oFormLayoutDialog;
        }
        return result;
    };
    /**
     * @param {?} comp
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.getRouteForComponent = /**
     * @param {?} comp
     * @return {?}
     */
    function (comp) {
        /** @type {?} */
        var result = [];
        if (this.parentFormLayoutManager) {
            /** @type {?} */
            var parentRoute = this.parentFormLayoutManager.getRouteForComponent(comp);
            if (parentRoute && parentRoute.length > 0) {
                result.push.apply(result, parentRoute);
            }
        }
        if (!this.isMainComponent(comp)) {
            /** @type {?} */
            var activeRoute = this.getRouteOfActiveItem();
            if (activeRoute && activeRoute.length > 0) {
                result.push.apply(result, activeRoute);
            }
        }
        return result;
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.setAsActiveFormLayoutManager = /**
     * @return {?}
     */
    function () {
        this.oFormLayoutManagerService.activeFormLayoutManager = this;
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.reloadMainComponents = /**
     * @return {?}
     */
    function () {
        this.onTriggerUpdate.emit();
    };
    /**
     * @param {?} formAttr
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.allowToUpdateNavigation = /**
     * @param {?} formAttr
     * @return {?}
     */
    function (formAttr) {
        return (this.isTabMode() && Util.isDefined(this.oTabGroup) && Util.isDefined(this.titleDataOrigin)) ?
            this.titleDataOrigin === formAttr :
            true;
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.updateStateStorage = /**
     * @return {?}
     */
    function () {
        if (this.localStorageService && this.isTabMode() && Util.isDefined(this.oTabGroup) && this.storeState) {
            this.localStorageService.updateComponentStorage(this);
        }
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.getParentActRouteRoute = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var actRoute = this.actRoute;
        while (actRoute.parent !== undefined && actRoute.parent !== null) {
            if (actRoute.routeConfig.children || actRoute.routeConfig.loadChildren) {
                break;
            }
            actRoute = actRoute.parent;
        }
        return actRoute.routeConfig;
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.updateIfNeeded = /**
     * @return {?}
     */
    function () {
        if (this.markForUpdate) {
            this.markForUpdate = false;
            this.onTriggerUpdate.emit();
        }
    };
    /**
     * @return {?}
     */
    OFormLayoutManagerComponent.prototype.getParams = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var data;
        if (this.isTabMode() && Util.isDefined(this.oTabGroup)) {
            data = this.oTabGroup.getParams();
        }
        else if (this.isDialogMode() && Util.isDefined(this.dialogRef)) {
            data = this.dialogRef.componentInstance.getParams();
        }
        return data;
    };
    OFormLayoutManagerComponent.guardClassName = 'CanActivateFormLayoutChildGuard';
    OFormLayoutManagerComponent.DEFAULT_INPUTS_O_FORM_LAYOUT_MANAGER = DEFAULT_INPUTS_O_FORM_LAYOUT_MANAGER;
    OFormLayoutManagerComponent.DEFAULT_OUTPUTS_O_FORM_LAYOUT_MANAGER = DEFAULT_OUTPUTS_O_FORM_LAYOUT_MANAGER;
    OFormLayoutManagerComponent.DIALOG_MODE = 'dialog';
    OFormLayoutManagerComponent.TAB_MODE = 'tab';
    OFormLayoutManagerComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-form-layout-manager',
                    inputs: DEFAULT_INPUTS_O_FORM_LAYOUT_MANAGER,
                    outputs: DEFAULT_OUTPUTS_O_FORM_LAYOUT_MANAGER,
                    template: "\n    <o-form-layout-tabgroup #tabGroup *ngIf=\"isTabMode(); else elseBlock\" [title]=\"title\"\n      (onMainTabSelected)=\"onMainTabSelected.emit($event)\" (onSelectedTabChange)=\"onSelectedTabChange.emit($event)\"\n      (onCloseTab)=\"onCloseTab.emit($event)\" [options]=\"tabGroupOptions\">\n      <ng-content *ngTemplateOutlet=\"elseBlock\"></ng-content>\n    </o-form-layout-tabgroup>\n\n    <ng-template #elseBlock>\n      <ng-content></ng-content>\n    </ng-template>\n  ",
                    host: {
                        '[class.o-form-layout-manager]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OFormLayoutManagerComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: router.Router },
        { type: router.ActivatedRoute },
        { type: material.MatDialog },
        { type: core.ElementRef },
        { type: OFormLayoutManagerComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }] }
    ]; };
    OFormLayoutManagerComponent.propDecorators = {
        oTabGroup: [{ type: core.ViewChild, args: ['tabGroup',] }],
        tableComponents: [{ type: core.ContentChildren, args: [OTableComponent, { descendants: true },] }],
        listComponents: [{ type: core.ContentChildren, args: [OListComponent, { descendants: true },] }],
        tabGroupOptions: [{ type: core.ContentChild, args: [OFormLayoutTabGroupOptionsComponent,] }],
        dialogOptions: [{ type: core.ContentChild, args: [OFormLayoutDialogOptionsComponent,] }],
        beforeunloadHandler: [{ type: core.HostListener, args: ['window:beforeunload', ['$event'],] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormLayoutManagerComponent.prototype, "storeState", void 0);
    return OFormLayoutManagerComponent;
}());
var OFormLayoutManagerModule = /** @class */ (function () {
    function OFormLayoutManagerModule() {
    }
    OFormLayoutManagerModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule, OSharedModule, router.RouterModule],
                    declarations: [
                        OFormLayoutDialogComponent,
                        OFormLayoutManagerComponent,
                        OFormLayoutTabGroupComponent,
                        OFormLayoutManagerContentDirective,
                        OFormLayoutDialogOptionsComponent,
                        OFormLayoutTabGroupOptionsComponent
                    ],
                    exports: [
                        OFormLayoutManagerComponent,
                        OFormLayoutDialogOptionsComponent,
                        OFormLayoutTabGroupOptionsComponent
                    ],
                    entryComponents: [OFormLayoutDialogComponent],
                    providers: [{
                            provide: CanActivateFormLayoutChildGuard,
                            useClass: CanActivateFormLayoutChildGuard
                        }],
                    schemas: [core.CUSTOM_ELEMENTS_SCHEMA]
                },] },
    ];
    return OFormLayoutManagerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OFormNavigationClass = /** @class */ (function () {
    function OFormNavigationClass(injector, form, router$$1, actRoute) {
        this.injector = injector;
        this.form = form;
        this.router = router$$1;
        this.actRoute = actRoute;
        this.urlSegments = [];
        this.onUrlParamChangedStream = new core.EventEmitter();
        this.navigationStream = new core.EventEmitter();
        this.dialogService = injector.get(DialogService);
        this.navigationService = injector.get(NavigationService);
        try {
            this.formLayoutManager = this.injector.get(OFormLayoutManagerComponent);
        }
        catch (e) {
            // No parent formLayoutManager
        }
        try {
            this.formLayoutDialog = this.injector.get(OFormLayoutDialogComponent);
        }
        catch (e) {
            // No parent form layout dialog
        }
        if (this.formLayoutDialog && !this.formLayoutManager) {
            this.formLayoutManager = this.formLayoutDialog.formLayoutManager;
        }
        /** @type {?} */
        var self = this;
        this.combinedNavigationStream = combineLatest(self.onUrlParamChangedStream.asObservable());
        this.combinedNavigationStream.subscribe(function (valArr) {
            if (Util.isArray(valArr) && valArr.length === 1 && valArr[0]) {
                self.navigationStream.emit(true);
            }
        });
    }
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.initialize = /**
     * @return {?}
     */
    function () {
        if (this.formLayoutManager && this.formLayoutManager.isTabMode()) {
            this.id = this.formLayoutManager.getLastTabId();
        }
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (this.qParamSub) {
            this.qParamSub.unsubscribe();
        }
        if (this.urlParamSub) {
            this.urlParamSub.unsubscribe();
        }
        if (this.urlSub) {
            this.urlSub.unsubscribe();
        }
        if (this.combinedNavigationStreamSubscription) {
            this.combinedNavigationStreamSubscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.subscribeToQueryParams = /**
     * @return {?}
     */
    function () {
        if (this.formLayoutManager) {
            /** @type {?} */
            var cacheData = this.formLayoutManager.getFormCacheData(this.id);
            if (Util.isDefined(cacheData)) {
                this.queryParams = cacheData.queryParams || {};
                this.parseQueryParams();
            }
        }
        else {
            /** @type {?} */
            var self_1 = this;
            this.qParamSub = this.actRoute.queryParams.subscribe(function (params) {
                if (params) {
                    self_1.queryParams = params;
                    self_1.parseQueryParams();
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.parseQueryParams = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isDetail = this.queryParams[Codes.IS_DETAIL];
        // ensuring isdetail = false when using form layout manager
        this.form.isDetailForm = this.formLayoutManager ? false : (isDetail === 'true');
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.subscribeToUrlParams = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.formLayoutManager) {
            /** @type {?} */
            var cacheData = this.formLayoutManager.getFormCacheData(this.id);
            if (Util.isDefined(cacheData)) {
                this.urlParams = cacheData.params;
                this.parseUrlParams();
            }
        }
        else {
            /** @type {?} */
            var self_2 = this;
            this.urlParamSub = this.actRoute.params.subscribe(function (params) {
                self_2.urlParams = params;
                _this.parseUrlParams();
            });
        }
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.parseUrlParams = /**
     * @return {?}
     */
    function () {
        if (Util.isDefined(this.urlParams) && Util.isDefined(this.urlParams[Codes.PARENT_KEYS_KEY])) {
            this.form.formParentKeysValues = Util.decodeParentKeys(this.urlParams[Codes.PARENT_KEYS_KEY]);
        }
        //TODO Obtain 'datatype' of each key contained into urlParams for
        // for building correctly query filter!!!!
        if (this.urlParams) {
            this.onUrlParamChangedStream.emit(true);
        }
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.subscribeToUrl = /**
     * @return {?}
     */
    function () {
        if (this.formLayoutManager) {
            /** @type {?} */
            var cacheData = this.formLayoutManager.getFormCacheData(this.id);
            if (Util.isDefined(cacheData)) {
                this.urlSegments = cacheData.urlSegments;
            }
        }
        else {
            /** @type {?} */
            var self_3 = this;
            this.urlSub = this.actRoute.url.subscribe(function (urlSegments) {
                self_3.urlSegments = urlSegments;
            });
        }
    };
    /**
     * @param {?} onCacheEmptyStateChanges
     * @return {?}
     */
    OFormNavigationClass.prototype.subscribeToCacheChanges = /**
     * @param {?} onCacheEmptyStateChanges
     * @return {?}
     */
    function (onCacheEmptyStateChanges) {
        var _this = this;
        this.cacheStateSubscription = onCacheEmptyStateChanges.asObservable().subscribe(function (res) {
            _this.setModifiedState(!res);
        });
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.getCurrentKeysValues = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var filter$$1 = {};
        if (this.urlParams) {
            filter$$1 = this.getFilterFromObject(this.urlParams);
        }
        return filter$$1;
    };
    /**
     * @param {?} objectParam
     * @return {?}
     */
    OFormNavigationClass.prototype.getFilterFromObject = /**
     * @param {?} objectParam
     * @return {?}
     */
    function (objectParam) {
        var _this = this;
        /** @type {?} */
        var filter$$1 = {};
        if (!objectParam || Object.keys(objectParam).length === 0) {
            return filter$$1;
        }
        if (this.form.keysArray) {
            this.form.keysArray.forEach(function (key, index) {
                if (objectParam[key]) {
                    filter$$1[key] = SQLTypes.parseUsingSQLType(objectParam[key], _this.form.keysSqlTypesArray[index]);
                }
            });
        }
        Object.keys(this.form._pKeysEquiv).forEach(function (item, index) {
            /** @type {?} */
            var urlVal = objectParam[_this.form._pKeysEquiv[item]];
            if (urlVal) {
                filter$$1[item] = SQLTypes.parseUsingSQLType(urlVal, _this.form.keysSqlTypesArray[index]);
            }
        });
        return filter$$1;
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.getFilterFromUrlParams = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var filter$$1 = Object.assign({}, this.getUrlParams() || {});
        /** @type {?} */
        var urlParamsKeys = Object.keys(filter$$1 || {});
        if (urlParamsKeys.length > 0) {
            urlParamsKeys.forEach(function (key) {
                if (key === Codes.PARENT_KEYS_KEY) {
                    delete filter$$1[key];
                    Object.assign(filter$$1, _this.form.formParentKeysValues);
                }
            });
        }
        return filter$$1;
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.getUrlSegments = /**
     * @return {?}
     */
    function () {
        return this.urlSegments;
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.getQueryParams = /**
     * @return {?}
     */
    function () {
        return this.queryParams;
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OFormNavigationClass.prototype.setUrlParams = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        this.urlParams = val;
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.getUrlParams = /**
     * @return {?}
     */
    function () {
        return this.urlParams;
    };
    /**
     * @param {?} modified
     * @return {?}
     */
    OFormNavigationClass.prototype.setModifiedState = /**
     * @param {?} modified
     * @return {?}
     */
    function (modified) {
        if (this.formLayoutManager) {
            this.formLayoutManager.setModifiedState(modified, this.id);
        }
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.updateNavigation = /**
     * @return {?}
     */
    function () {
        if (this.formLayoutManager) {
            /** @type {?} */
            var isInInsertMode = this.form.isInInsertMode();
            /** @type {?} */
            var formData_1 = void 0;
            if (isInInsertMode) {
                formData_1 = {};
                formData_1['new_tab_title'] = 'LAYOUT_MANANGER.INSERTION_MODE_TITLE';
            }
            else if (this.formLayoutManager.allowToUpdateNavigation(this.form.oattr)) {
                formData_1 = {};
                /** @type {?} */
                var self_4 = this;
                Object.keys(this.form.formData).forEach(function (key) {
                    formData_1[key] = self_4.form.formData[key].value;
                });
            }
            if (formData_1) {
                this.formLayoutManager.updateNavigation(formData_1, this.id, isInInsertMode);
            }
        }
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.navigateBack = /**
     * @return {?}
     */
    function () {
        if (!this.formLayoutManager && this.navigationService) {
            /** @type {?} */
            var navData = this.navigationService.getPreviousRouteData();
            if (navData) {
                /** @type {?} */
                var extras = {};
                extras[Codes.QUERY_PARAMS] = navData.queryParams;
                this.router.navigate([navData.url], extras);
            }
        }
    };
    /**
     * @param {?=} options
     * @return {?}
     */
    OFormNavigationClass.prototype.closeDetailAction = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        var _this = this;
        if (this.formLayoutManager) {
            this.formLayoutManager.closeDetail(this.id);
        }
        else if (this.navigationService) {
            this.form.beforeCloseDetail.emit();
            /** @type {?} */
            var navData = this.navigationService.getPreviousRouteData();
            if (navData) {
                /** @type {?} */
                var extras = {};
                extras[Codes.QUERY_PARAMS] = navData.queryParams;
                this.router.navigate([navData.url], extras).then(function (val) {
                    if (val && options && options.changeToolbarMode) {
                        _this.form.getFormToolbar().setInitialMode();
                    }
                });
            }
        }
    };
    /**
     * @param {?} insertedKeys
     * @return {?}
     */
    OFormNavigationClass.prototype.stayInRecordAfterInsert = /**
     * @param {?} insertedKeys
     * @return {?}
     */
    function (insertedKeys) {
        if (this.formLayoutManager) {
            this.form.setInitialMode();
            /** @type {?} */
            var self_5 = this;
            /** @type {?} */
            var subscription_1 = this.form.onDataLoaded.subscribe(function () {
                /** @type {?} */
                var keys = self_5.form.getKeysValues();
                self_5.formLayoutManager.updateActiveData({ params: keys });
                /** @type {?} */
                var cacheData = self_5.formLayoutManager.getFormCacheData(self_5.id);
                if (Util.isDefined(cacheData)) {
                    self_5.urlParams = cacheData.params;
                }
                subscription_1.unsubscribe();
            });
            this.form.queryData(insertedKeys);
        }
        else if (this.navigationService && this.form.keysArray && insertedKeys) {
            /** @type {?} */
            var params_1 = [];
            this.form.keysArray.forEach(function (current, index) {
                if (insertedKeys[current]) {
                    params_1.push(insertedKeys[current]);
                }
            });
            /** @type {?} */
            var extras = {};
            /** @type {?} */
            var qParams = Object.assign({}, this.getQueryParams(), Codes.getIsDetailObject());
            extras[Codes.QUERY_PARAMS] = qParams;
            /** @type {?} */
            var route = [];
            /** @type {?} */
            var navData = this.navigationService.getPreviousRouteData();
            if (navData) {
                route.push(navData.url);
                /** @type {?} */
                var detailRoute = navData.getDetailFormRoute();
                if (Util.isDefined(detailRoute)) {
                    route.push(detailRoute);
                }
                route.push.apply(route, params_1);
                // deleting insertFormRoute as active mode (because stayInRecordAfterInsert changes it)
                this.navigationService.deleteActiveFormMode(navData);
            }
            else {
                extras.relativeTo = this.actRoute;
                route = ['../'].concat(params_1);
            }
            this.router.navigate(route, extras);
        }
    };
    /**
    * Navigates to 'insert' mode
    */
    /**
     * Navigates to 'insert' mode
     * @param {?=} options
     * @return {?}
     */
    OFormNavigationClass.prototype.goInsertMode = /**
     * Navigates to 'insert' mode
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        var _this = this;
        if (this.formLayoutManager && this.formLayoutManager.isDialogMode()) {
            this.form.setInsertMode();
        }
        else if (this.navigationService) {
            /** @type {?} */
            var route = [];
            /** @type {?} */
            var extras = {};
            /** @type {?} */
            var navData = this.navigationService.getPreviousRouteData();
            if (!this.formLayoutManager && navData) {
                route.push(navData.url);
                /** @type {?} */
                var detailRoute = navData.getDetailFormRoute();
                if (Util.isDefined(detailRoute)) {
                    route.push(detailRoute);
                }
                route.push(navData.getInsertFormRoute());
            }
            else {
                extras.relativeTo = this.actRoute;
                route = ['../' + Codes.DEFAULT_INSERT_ROUTE];
            }
            this.storeNavigationFormRoutes('insertFormRoute');
            this.router.navigate(route, extras).then(function (val) {
                if (val && options && options.changeToolbarMode) {
                    _this.form.getFormToolbar().setInsertMode();
                }
            });
        }
    };
    /**
     * Navigates to 'edit' mode
     */
    /**
     * Navigates to 'edit' mode
     * @param {?=} options
     * @return {?}
     */
    OFormNavigationClass.prototype.goEditMode = /**
     * Navigates to 'edit' mode
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        var _this = this;
        if (this.formLayoutManager && this.formLayoutManager.isDialogMode()) {
            this.form.setUpdateMode();
        }
        else if (this.navigationService) {
            /** @type {?} */
            var route = [];
            /** @type {?} */
            var extras = {};
            if (this.form.isDetailForm) {
                extras[Codes.QUERY_PARAMS] = Codes.getIsDetailObject();
            }
            extras[Codes.QUERY_PARAMS] = Object.assign({}, this.getQueryParams(), extras[Codes.QUERY_PARAMS] || {});
            /** @type {?} */
            var params_2 = [];
            /** @type {?} */
            var urlParams_1 = this.getUrlParams();
            this.form.keysArray.map(function (key) {
                if (urlParams_1[key]) {
                    params_2.push(urlParams_1[key]);
                }
            });
            /** @type {?} */
            var navData = this.navigationService.getPreviousRouteData();
            if (Util.isDefined(navData)) {
                route.push(navData.url);
                /** @type {?} */
                var detailRoute = navData.getDetailFormRoute();
                if (Util.isDefined(detailRoute)) {
                    route.push(detailRoute);
                }
                route.push.apply(route, params_2);
                route.push(navData.getEditFormRoute());
            }
            else {
                extras.relativeTo = this.actRoute;
                route = ['../'].concat(params_2, [Codes.DEFAULT_EDIT_ROUTE]);
            }
            this.storeNavigationFormRoutes('editFormRoute');
            this.form.beforeGoEditMode.emit();
            this.router.navigate(route, extras).then(function (val) {
                if (val && options && options.changeToolbarMode) {
                    _this.form.getFormToolbar().setEditMode();
                }
            });
        }
    };
    /**
    * @deprecated
    */
    /**
     * @deprecated
     * @return {?}
     */
    OFormNavigationClass.prototype.getNestedLevelsNumber = /**
     * @deprecated
     * @return {?}
     */
    function () {
        /** @type {?} */
        var actRoute = this.actRoute;
        /** @type {?} */
        var i = 0;
        while (actRoute.parent) {
            actRoute = actRoute.parent;
            actRoute.url.subscribe(function (x) {
                if (x && x.length) {
                    i++;
                }
            });
        }
        return i;
    };
    /**
    * @deprecated
    */
    /**
     * @deprecated
     * @return {?}
     */
    OFormNavigationClass.prototype.getFullUrlSegments = /**
     * @deprecated
     * @return {?}
     */
    function () {
        /** @type {?} */
        var fullUrlSegments = [];
        /** @type {?} */
        var router$$1 = this.router;
        if (router$$1 && router$$1.url && router$$1.url.length) {
            /** @type {?} */
            var root = router$$1.parseUrl(router$$1.url).root;
            if (root && root.hasChildren() && root.children["primary"]) {
                fullUrlSegments = root.children["primary"].segments;
            }
        }
        return fullUrlSegments;
    };
    /**
     * @return {?}
     */
    OFormNavigationClass.prototype.showConfirmDiscardChanges = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var subscription = undefined;
        if (this.form.isInitialStateChanged() && !this.form.isInInsertMode()) {
            subscription = this.dialogService.confirm('CONFIRM', 'MESSAGES.FORM_CHANGES_WILL_BE_LOST');
        }
        if (subscription === undefined) {
            /** @type {?} */
            var observable$$1 = Observable.create(function (observer) {
                observer.next(true);
                observer.complete();
            });
            subscription = observable$$1.toPromise();
        }
        return subscription;
    };
    /**
     * @param {?} activeMode
     * @return {?}
     */
    OFormNavigationClass.prototype.storeNavigationFormRoutes = /**
     * @param {?} activeMode
     * @return {?}
     */
    function (activeMode) {
        this.navigationService.storeFormRoutes({
            detailFormRoute: Codes.DEFAULT_DETAIL_ROUTE,
            editFormRoute: Codes.DEFAULT_EDIT_ROUTE,
            insertFormRoute: Codes.DEFAULT_INSERT_ROUTE
        }, activeMode);
    };
    return OFormNavigationClass;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_FORM_CONTAINER$$1 = [
    'breadcrumb',
    'breadcrumbSeparator : breadcrumb-separator',
    'breadcrumbLabelColumns : breadcrumb-label-columns'
];
var OFormContainerComponent$$1 = /** @class */ (function () {
    function OFormContainerComponent$$1(resolver) {
        this.resolver = resolver;
        this.breadcrumb = false;
        this.breadcrumbSeparator = ' ';
    }
    /**
     * @return {?}
     */
    OFormContainerComponent$$1.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.breadcrumb = this.breadcrumb && this.form && !this.formMananger;
        if (this.breadcrumb) {
            this.createBreadcrumb(this.breadContainer);
        }
    };
    /**
     * @param {?} form
     * @return {?}
     */
    OFormContainerComponent$$1.prototype.setForm = /**
     * @param {?} form
     * @return {?}
     */
    function (form) {
        this.form = form;
        this.formMananger = form.getFormManager();
    };
    /**
     * @param {?} container
     * @return {?}
     */
    OFormContainerComponent$$1.prototype.createBreadcrumb = /**
     * @param {?} container
     * @return {?}
     */
    function (container) {
        /** @type {?} */
        var factory = this.resolver.resolveComponentFactory(OBreadcrumbComponent$$1);
        /** @type {?} */
        var ref = container.createComponent(factory);
        ref.instance._formRef = this.form;
        ref.instance.labelColumns = this.breadcrumbLabelColumns;
        ref.instance.separator = this.breadcrumbSeparator;
    };
    OFormContainerComponent$$1.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-form-container',
                    template: "\n    <div class=\"o-form-container-content\">\n      <ng-template #breadcrumb></ng-template>\n      <ng-content></ng-content>\n    </div>\n  ",
                    styles: ["\n    .application-layout-content-wrapper .o-form-container{position:relative;width:100%;height:100%;display:block}.application-layout-content-wrapper .o-form-container .o-form-container-content{display:flex;flex:auto;flex-direction:column;max-height:100%}.application-layout-content-wrapper .o-form-container .o-form-container-content>.o-breadcrumb{padding-left:8px;padding-right:8px}\n  "],
                    inputs: DEFAULT_INPUTS_O_FORM_CONTAINER$$1,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-form-container]': 'true',
                        '[class.breadcrumb]': 'breadcrumb'
                    }
                },] },
    ];
    /** @nocollapse */
    OFormContainerComponent$$1.ctorParameters = function () { return [
        { type: core.ComponentFactoryResolver }
    ]; };
    OFormContainerComponent$$1.propDecorators = {
        breadContainer: [{ type: core.ViewChild, args: ['breadcrumb', { read: core.ViewContainerRef },] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormContainerComponent$$1.prototype, "breadcrumb", void 0);
    return OFormContainerComponent$$1;
}());
var OFormContainerModule$$1 = /** @class */ (function () {
    function OFormContainerModule$$1() {
    }
    OFormContainerModule$$1.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OFormContainerComponent$$1],
                    imports: [OSharedModule, common.CommonModule],
                    entryComponents: [OBreadcrumbComponent$$1],
                    exports: [OFormContainerComponent$$1]
                },] },
    ];
    return OFormContainerModule$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var 0$6 = dataServiceFactory;
var OFormNavigationComponent = /** @class */ (function () {
    function OFormNavigationComponent(injector, _form, router$$1) {
        this.injector = injector;
        this._form = _form;
        this.router = router$$1;
        this.navigationData = [];
        this._currentIndex = 0;
        this.formNavigation = this._form.getFormNavigation();
        this.navigationService = this.injector.get(NavigationService);
        this.formLayoutManager = this._form.getFormManager();
        /** @type {?} */
        var navData;
        if (this.formLayoutManager && this.formLayoutManager.isDialogMode()) {
            navData = this.navigationService.getLastItem();
        }
        else {
            navData = this.navigationService.getPreviousRouteData();
        }
        if (Util.isDefined(navData)) {
            this.navigationData = navData.keysValues || [];
            this.queryConf = navData.queryConfiguration;
        }
        this.currentIndex = this.getCurrentIndex();
        this.configureService();
    }
    /**
     * @return {?}
     */
    OFormNavigationComponent.prototype.configureService = /**
     * @return {?}
     */
    function () {
        if (!this.queryConf) {
            return;
        }
        /** @type {?} */
        var loadingService = OntimizeService$$1;
        if (this.queryConf.serviceType) {
            loadingService = this.queryConf.serviceType;
        }
        try {
            this.dataService = this.injector.get(loadingService);
            if (Util.isDataService(this.dataService)) {
                /** @type {?} */
                var serviceCfg = this.dataService.getDefaultServiceConfiguration(this.queryConf.service);
                if (this.queryConf.entity) {
                    serviceCfg['entity'] = this.queryConf.entity;
                }
                this.dataService.configureService(serviceCfg);
            }
        }
        catch (e) {
            console.error(e);
        }
    };
    /**
     * @param {?} offset
     * @param {?=} length
     * @return {?}
     */
    OFormNavigationComponent.prototype.queryNavigationData = /**
     * @param {?} offset
     * @param {?=} length
     * @return {?}
     */
    function (offset, length) {
        if (length === void 0) { length = undefined; }
        /** @type {?} */
        var self = this;
        return new Promise(function (resolve, reject) {
            /** @type {?} */
            var conf = self.queryConf;
            /** @type {?} */
            var queryArgs = conf.queryArguments;
            queryArgs[1] = self.getKeysArray();
            queryArgs[4] = offset;
            queryArgs[5] = length ? length : conf.queryRows;
            self.querySubscription = self.dataService[conf.queryMethod].apply(self.dataService, queryArgs).subscribe(function (res) {
                if (res.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                    self.navigationData = res.data;
                    self.queryConf.queryRecordOffset = offset;
                }
                resolve();
            }, function () {
                reject();
            });
        });
    };
    /**
     * @return {?}
     */
    OFormNavigationComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.querySubscription) {
            this.querySubscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OFormNavigationComponent.prototype.getKeysArray = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var navData = this.navigationData ? (this.navigationData[0] || {}) : {};
        /** @type {?} */
        var keysArray = [];
        this._form.keysArray.forEach(function (key) {
            if (navData.hasOwnProperty(key)) {
                keysArray.push(key);
            }
        });
        return keysArray;
    };
    /**
     * @return {?}
     */
    OFormNavigationComponent.prototype.getCurrentIndex = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var keysArray = this.getKeysArray();
        /** @type {?} */
        var currentKeys = {};
        /** @type {?} */
        var currentItem = this.formNavigation.getUrlParams();
        keysArray.forEach(function (key) {
            currentKeys[key] = currentItem[key];
        });
        /** @type {?} */
        var index = (this.navigationData || []).findIndex(function (item) {
            /** @type {?} */
            var itemKeys = {};
            keysArray.forEach(function (key) {
                itemKeys[key] = item[key];
            });
            return Util.isEquivalent(itemKeys, currentKeys);
        });
        return index >= 0 ? index : 0;
    };
    /**
     * @return {?}
     */
    OFormNavigationComponent.prototype.next = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var total = this.navigationData.length;
        /** @type {?} */
        var index = this.currentIndex + 1;
        if (total > index) {
            this.move(index);
        }
        else if (this.queryConf) {
            /** @type {?} */
            var offset = (this.queryConf.queryRecordOffset || 0) + this.queryConf.queryRows;
            this.queryNavigationData(offset).then(function () {
                _this.move(0);
            });
        }
        else {
            console.error('form-toolbar->next(): total > index');
        }
    };
    /**
     * @return {?}
     */
    OFormNavigationComponent.prototype.previous = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var index = this.currentIndex - 1;
        if (index >= 0) {
            this.move(index);
        }
        else if (this.queryConf) {
            /** @type {?} */
            var offset = this.queryConf.queryRecordOffset - this.queryConf.queryRows;
            this.queryNavigationData(offset).then(function () {
                _this.move(_this.navigationData.length - 1);
            });
        }
        else {
            console.error('form-toolbar->next(): index < 0');
        }
    };
    /**
     * @return {?}
     */
    OFormNavigationComponent.prototype.first = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.queryConf || this.queryConf.queryRecordOffset === 0) {
            this.move(0);
        }
        else {
            this.queryNavigationData(0).then(function () {
                _this.move(0);
            });
        }
    };
    /**
     * @return {?}
     */
    OFormNavigationComponent.prototype.last = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.queryConf || this.isLast()) {
            /** @type {?} */
            var index = this.navigationData.length - 1;
            this.move(index);
        }
        else {
            /** @type {?} */
            var offset = this.queryConf.totalRecordsNumber - this.queryConf.queryRows;
            this.queryNavigationData(offset, this.queryConf.queryRows).then(function () {
                _this.move(_this.navigationData.length - 1);
            });
        }
    };
    /**
     * @return {?}
     */
    OFormNavigationComponent.prototype.isFirst = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = this.currentIndex === 0;
        if (result && this.queryConf) {
            result = this.queryConf.queryRecordOffset === 0;
        }
        return result;
    };
    /**
     * @return {?}
     */
    OFormNavigationComponent.prototype.isLast = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = this.currentIndex === (this.navigationData.length - 1);
        if (result && this.queryConf) {
            result = (this.queryConf.queryRecordOffset + this.queryConf.queryRows)
                >= this.queryConf.totalRecordsNumber;
        }
        return result;
    };
    /**
     * @param {?} index
     * @return {?}
     */
    OFormNavigationComponent.prototype.move = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        var _this = this;
        this._form.showConfirmDiscardChanges().then(function (res) {
            if (res === true) {
                _this.currentIndex = index;
                if (_this.formLayoutManager && _this.formLayoutManager.isDialogMode()) {
                    _this.moveInDialogManager(_this.formLayoutManager, index);
                }
                else {
                    _this.moveWithoutManager(index);
                }
            }
        });
    };
    /**
     * @param {?} index
     * @return {?}
     */
    OFormNavigationComponent.prototype.moveWithoutManager = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        var _this = this;
        /** @type {?} */
        var route = this.getRouteOfSelectedRow(this.navigationData[index]);
        if (route.length > 0) {
            this.navigationService.removeLastItem();
            /** @type {?} */
            var navData = this.navigationService.getLastItem();
            if (navData) {
                /** @type {?} */
                var extras = {};
                extras[Codes.QUERY_PARAMS] = Codes.getIsDetailObject();
                /** @type {?} */
                var detailRoute = navData.getDetailFormRoute();
                if (Util.isDefined(detailRoute)) {
                    route.unshift(detailRoute);
                }
                route.unshift(navData.url);
                this._form.canDiscardChanges = true;
                this.router.navigate(route, extras).then(function (navigationDone) {
                    if (navigationDone) {
                        _this.currentIndex = index;
                    }
                });
            }
        }
    };
    /**
     * @param {?} formLayoutManager
     * @param {?} index
     * @return {?}
     */
    OFormNavigationComponent.prototype.moveInDialogManager = /**
     * @param {?} formLayoutManager
     * @param {?} index
     * @return {?}
     */
    function (formLayoutManager, index) {
        formLayoutManager.dialogRef.componentInstance.urlParams = this.navigationData[index];
        this._form.setUrlParamsAndReload(this.navigationData[index]);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OFormNavigationComponent.prototype.getRouteOfSelectedRow = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var route = [];
        if (Util.isObject(item)) {
            this._form.keysArray.forEach(function (key) {
                if (Util.isDefined(item[key])) {
                    route.push(item[key]);
                }
            });
        }
        return route;
    };
    /**
     * @return {?}
     */
    OFormNavigationComponent.prototype.showNavigation = /**
     * @return {?}
     */
    function () {
        return (this.navigationData || []).length > 1;
    };
    Object.defineProperty(OFormNavigationComponent.prototype, "currentIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this._currentIndex;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._currentIndex = arg;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OFormNavigationComponent.prototype.getRecordIndex = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var index = this.currentIndex + 1;
        if (this.queryConf) {
            index += this.queryConf.queryRecordOffset;
        }
        return index;
    };
    /**
     * @return {?}
     */
    OFormNavigationComponent.prototype.getTotalRecordsNumber = /**
     * @return {?}
     */
    function () {
        if (this.queryConf && this.queryConf.totalRecordsNumber) {
            return this.queryConf.totalRecordsNumber;
        }
        return this.navigationData.length;
    };
    OFormNavigationComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-form-navigation',
                    template: "\n    <ng-container *ngIf=\"showNavigation()\">\n      <button mat-icon-button class=\"o-form-toolbar-button\" [disabled]=\"isFirst()\" (click)=\"first()\">\n        <mat-icon aria-label=\"First\" layout-padding svgIcon=\"ontimize:first_page\"></mat-icon>\n      </button>\n      <button mat-icon-button class=\"o-form-toolbar-button\" [disabled]=\"isFirst()\" (click)=\"previous()\">\n        <mat-icon aria-label=\"Previous\" layout-padding svgIcon=\"ontimize:keyboard_arrow_left\"></mat-icon>\n      </button>\n      <span layout-padding>{{ getRecordIndex() }} / {{ getTotalRecordsNumber() }}</span>\n      <button mat-icon-button class=\"o-form-toolbar-button\" [disabled]=\"isLast()\" (click)=\"next()\">\n        <mat-icon aria-label=\"Next\" layout-padding svgIcon=\"ontimize:keyboard_arrow_right\"></mat-icon>\n      </button>\n      <button mat-icon-button class=\"o-form-toolbar-button\" [disabled]=\"isLast()\" (click)=\"last()\">\n        <mat-icon aria-label=\"Last\" layout-padding svgIcon=\"ontimize:last_page\"></mat-icon>\n      </button>\n    </ng-container>\n  ",
                    styles: ["\n    .o-form-navigation .mat-icon{cursor:pointer}.o-form-navigation span{cursor:default}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-form-navigation]': 'true'
                    },
                    providers: [
                        { provide: OntimizeService$$1, useFactory: 0$6, deps: [core.Injector] }
                    ]
                },] },
    ];
    /** @nocollapse */
    OFormNavigationComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: OFormComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: router.Router }
    ]; };
    return OFormNavigationComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_FORM_TOOLBAR = [
    'labelHeader: label-header',
    'labelHeaderAlign: label-header-align',
    'headeractions: header-actions',
    'showHeaderActionsText: show-header-actions-text',
    'showHeaderNavigation:show-header-navigation'
];
var OFormToolbarComponent = /** @class */ (function () {
    function OFormToolbarComponent(_form, element, injector) {
        this._form = _form;
        this.element = element;
        this.injector = injector;
        this.labelHeader = '';
        this.headeractions = '';
        this.labelHeaderAlign = 'center';
        this.showHeaderActionsText = true;
        this.showHeaderNavigation = true;
        this.isDetail = true;
        this.editMode = false;
        this.insertMode = false;
        this.initialMode = true;
        this.refreshBtnEnabled = false;
        this.insertBtnEnabled = false;
        this.deleteBtnEnabled = false;
        this._changesToSave = false;
        this._editBtnEnabled = false;
        this._saveBtnEnabled = false;
        this.mutationObservers = [];
        this._isSaveBtnEnabledSubject = new BehaviorSubject(false);
        this._isEditBtnEnabledSubject = new BehaviorSubject(false);
        this._existsChangesToSaveSubject = new BehaviorSubject(false);
        this.isSaveBtnEnabled = this._isSaveBtnEnabledSubject.asObservable();
        this.isEditBtnEnabled = this._isEditBtnEnabledSubject.asObservable();
        this.existsChangesToSave = this._existsChangesToSaveSubject.asObservable();
        this._form.registerToolbar(this);
        this._dialogService = this.injector.get(DialogService);
        this._navigationService = this.injector.get(NavigationService);
        this.snackBarService = this.injector.get(SnackBarService);
    }
    Object.defineProperty(OFormToolbarComponent.prototype, "changesToSave", {
        get: /**
         * @return {?}
         */
        function () {
            return this._changesToSave;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._changesToSave = val;
            /** @type {?} */
            var attr = this._form.isEditableDetail() ? PermissionsUtils.ACTION_UPDATE : PermissionsUtils.ACTION_INSERT;
            /** @type {?} */
            var permissions = (this.actionsPermissions || []).find(function (p) { return p.attr === attr; });
            if (Util.isDefined(permissions) && permissions.enabled === false) {
                return;
            }
            this._existsChangesToSaveSubject.next(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormToolbarComponent.prototype, "editBtnEnabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._editBtnEnabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._editBtnEnabled = value;
            this._isEditBtnEnabledSubject.next(this._editBtnEnabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormToolbarComponent.prototype, "saveBtnEnabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._saveBtnEnabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._saveBtnEnabled = value;
            this._isSaveBtnEnabledSubject.next(this._saveBtnEnabled);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.formActions = Util.parseArray(this.headeractions);
        if (this.formActions && this.formActions.length > 0) {
            this.refreshBtnEnabled = this.formActions.indexOf('R') !== -1;
            this.insertBtnEnabled = this.formActions.indexOf('I') !== -1;
            this.editBtnEnabled = this.formActions.indexOf('U') !== -1;
            this.deleteBtnEnabled = !this.insertMode && this.formActions.indexOf('D') !== -1;
        }
        if (this._navigationService) {
            /** @type {?} */
            var self_1 = this;
            this._navigationService.onTitleChange(function (title) {
                self_1.labelHeader = title;
            });
        }
        this.includeBreadcrumb = this._form.includeBreadcrumb && this._form.formContainer.breadcrumb;
        if (this.includeBreadcrumb) {
            this._form.formContainer.breadcrumb = false;
        }
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.formCacheSubscription) {
            this.formCacheSubscription.unsubscribe();
        }
        if (this.mutationObservers) {
            this.mutationObservers.forEach(function (m) {
                m.disconnect();
            });
        }
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.parsePermissions();
        if (this.includeBreadcrumb) {
            this._form.formContainer.createBreadcrumb(this.breadContainer);
        }
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.setInitialMode = /**
     * @return {?}
     */
    function () {
        this.manageEditableDetail();
        this.initialMode = true;
        this.insertMode = false;
        this.editMode = false;
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.setInsertMode = /**
     * @return {?}
     */
    function () {
        this.initialMode = false;
        this.insertMode = true;
        this.editMode = false;
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.setEditMode = /**
     * @return {?}
     */
    function () {
        this.initialMode = false;
        this.insertMode = false;
        this.editMode = true;
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.onCloseDetail = /**
     * @return {?}
     */
    function () {
        this._form.executeToolbarAction(OFormComponent.CLOSE_DETAIL_ACTION, {
            changeToolbarMode: true
        });
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.onBack = /**
     * @return {?}
     */
    function () {
        this._form.executeToolbarAction(OFormComponent.BACK_ACTION);
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.onReload = /**
     * @return {?}
     */
    function () {
        if (!this.checkEnabledPermission(PermissionsUtils.ACTION_REFRESH)) {
            return;
        }
        /** @type {?} */
        var self = this;
        this._form.showConfirmDiscardChanges().then(function (val) {
            if (val) {
                self._form.executeToolbarAction(OFormComponent.RELOAD_ACTION);
            }
        });
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.onInsert = /**
     * @return {?}
     */
    function () {
        if (!this.checkEnabledPermission(PermissionsUtils.ACTION_INSERT)) {
            return;
        }
        this._form.executeToolbarAction(OFormComponent.GO_INSERT_ACTION, {
            changeToolbarMode: true
        });
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.onEdit = /**
     * @return {?}
     */
    function () {
        if (!this.checkEnabledPermission(PermissionsUtils.ACTION_UPDATE)) {
            return;
        }
        this._form.executeToolbarAction(OFormComponent.GO_EDIT_ACTION, {
            changeToolbarMode: true
        });
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    OFormToolbarComponent.prototype.onDelete = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        if (!this.checkEnabledPermission(PermissionsUtils.ACTION_DELETE)) {
            return;
        }
        this.showConfirmDelete(evt);
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    OFormToolbarComponent.prototype.onSave = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        if (!this.checkEnabledPermission(PermissionsUtils.ACTION_UPDATE)) {
            return;
        }
        this.handleAcceptEditOperation();
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.cancelOperation = /**
     * @return {?}
     */
    function () {
        if (this.isDetail) {
            this.onCloseDetail();
        }
        else if (!this.isDetail && this.insertMode) {
            this.onCloseDetail();
        }
        else {
            this.onReload();
            this._form.setInitialMode();
        }
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.acceptOperation = /**
     * @return {?}
     */
    function () {
        if (this.editMode) {
            if (!this.checkEnabledPermission(PermissionsUtils.ACTION_UPDATE)) {
                return;
            }
            this.handleAcceptEditOperation();
        }
        else if (this.insertMode) {
            if (!this.checkEnabledPermission(PermissionsUtils.ACTION_INSERT)) {
                return;
            }
            this.handleAcceptInsertOperation();
        }
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.handleAcceptInsertOperation = /**
     * @return {?}
     */
    function () {
        this._form.executeToolbarAction(OFormComponent.INSERT_ACTION);
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.handleAcceptEditOperation = /**
     * @return {?}
     */
    function () {
        this._form.executeToolbarAction(OFormComponent.EDIT_ACTION);
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    OFormToolbarComponent.prototype.showConfirmDelete = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        var _this = this;
        this._dialogService.confirm('CONFIRM', 'MESSAGES.CONFIRM_DELETE').then(function (res) {
            if (res === true) {
                _this._form.executeToolbarAction(OFormComponent.DELETE_ACTION).subscribe(function (resp) {
                    _this._form.onDelete.emit(resp);
                    _this.onCloseDetail();
                }, function (err) {
                    console.error('OFormToolbar.delete error', err);
                });
            }
        });
    };
    Object.defineProperty(OFormToolbarComponent.prototype, "showNavigation", {
        get: /**
         * @return {?}
         */
        function () {
            return this.showHeaderNavigation && !(this._form.getFormManager() && this._form.getFormManager().isTabMode());
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.getLabelHeaderAlign = /**
     * @return {?}
     */
    function () {
        return this.labelHeaderAlign;
    };
    Object.defineProperty(OFormToolbarComponent.prototype, "showUndoButton", {
        get: /**
         * @return {?}
         */
        function () {
            return this._form.undoButton && (!this.initialMode || this._form.isEditableDetail());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormToolbarComponent.prototype, "isChangesStackEmpty", {
        get: /**
         * @return {?}
         */
        function () {
            return this._form.isCacheStackEmpty;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.onUndoLastChange = /**
     * @return {?}
     */
    function () {
        this._form.executeToolbarAction(OFormComponent.UNDO_LAST_CHANGE_ACTION);
    };
    Object.defineProperty(OFormToolbarComponent.prototype, "isRefreshBtnEnabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.refreshBtnEnabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormToolbarComponent.prototype, "isInsertBtnEnabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.insertBtnEnabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormToolbarComponent.prototype, "isDeleteBtnEnabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.deleteBtnEnabled;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} permission
     * @return {?}
     */
    OFormToolbarComponent.prototype.hasEnabledPermission = /**
     * @param {?} permission
     * @return {?}
     */
    function (permission) {
        return permission ? permission.enabled : true;
    };
    Object.defineProperty(OFormToolbarComponent.prototype, "includeBreadcrumb", {
        get: /**
         * @return {?}
         */
        function () {
            return this._includeBreadcrumb;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._includeBreadcrumb = arg;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.manageEditableDetail = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isEditableDetail = this._form.isEditableDetail();
        /** @type {?} */
        var updatePermissions = (this.actionsPermissions || []).find(function (p) { return p.attr === PermissionsUtils.ACTION_UPDATE; });
        if (this.hasEnabledPermission(updatePermissions)) {
            this.saveBtnEnabled = isEditableDetail;
        }
        this.refreshBtnEnabled = this.refreshBtnEnabled && isEditableDetail;
        this.insertBtnEnabled = this.insertBtnEnabled && isEditableDetail;
        this.editBtnEnabled = this.editBtnEnabled && !isEditableDetail;
        /** @type {?} */
        var self = this;
        this._form.getFormCache().onCacheStateChanges.asObservable().subscribe(function (value) {
            if (self._form.isEditableDetail()) {
                self.changesToSave = self._form.isInitialStateChanged();
            }
        });
    };
    /**
     * @return {?}
     */
    OFormToolbarComponent.prototype.parsePermissions = /**
     * @return {?}
     */
    function () {
        if (this._form.oattr) {
            this.actionsPermissions = this._form.getActionsPermissions();
            if (!Util.isDefined(this.actionsPermissions)) {
                return;
            }
            /** @type {?} */
            var self_2 = this;
            this.actionsPermissions.forEach(function (permission) {
                // others actions
                // others actions
                self_2.permissionManagement(permission);
                if (PermissionsUtils.STANDARD_ACTIONS.indexOf(permission.attr) > -1) {
                    // actions R;I;U;D
                    if (permission.attr === PermissionsUtils.ACTION_UPDATE) {
                        self_2.permissionManagement(permission, 'edit');
                    }
                }
            });
        }
    };
    /**
     * @param {?} permission
     * @param {?=} attr
     * @return {?}
     */
    OFormToolbarComponent.prototype.permissionManagement = /**
     * @param {?} permission
     * @param {?=} attr
     * @return {?}
     */
    function (permission, attr) {
        /** @type {?} */
        var attrAction = Util.isDefined(attr) ? attr : permission.attr;
        /** @type {?} */
        var elementByAction = this.element.nativeElement.querySelector('[attr="' + attrAction + '"]');
        if (Util.isDefined(elementByAction)) {
            if (!permission.visible) {
                elementByAction.remove();
            }
            else {
                if (!permission.enabled) {
                    elementByAction.disabled = true;
                    /** @type {?} */
                    var mutationObserver = PermissionsUtils.registerDisabledChangesInDom(elementByAction);
                    this.mutationObservers.push(mutationObserver);
                }
            }
        }
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OFormToolbarComponent.prototype.checkEnabledPermission = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        /** @type {?} */
        var permissions = (this.actionsPermissions || []).find(function (p) { return p.attr === attr; });
        /** @type {?} */
        var enabledPermision = PermissionsUtils.checkEnabledPermission(permissions);
        if (!enabledPermision) {
            this.snackBarService.open('MESSAGES.OPERATION_NOT_ALLOWED_PERMISSION');
        }
        return enabledPermision;
    };
    OFormToolbarComponent.DEFAULT_INPUTS_O_FORM_TOOLBAR = DEFAULT_INPUTS_O_FORM_TOOLBAR;
    OFormToolbarComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-form-toolbar',
                    template: "\n    <mat-toolbar class=\"o-form-toolbar-header\" [class.breadcrumb]=\"includeBreadcrumb\" fxLayout=\"column\"\n      fxLayoutAlign=\"center center\">\n\n      <ng-template *ngIf=\"includeBreadcrumb\" #breadcrumb></ng-template>\n\n      <div class=\"mat-toolbar-tools\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n        <button type=\"button\" mat-icon-button (click)=\"onCloseDetail()\" *ngIf=\"isDetail\" class=\"o-form-toolbar-button o-form-toolbar-back\">\n          <mat-icon svgIcon=\"ontimize:arrow_back\"></mat-icon>\n        </button>\n\n        <o-form-navigation #formNavigation *ngIf=\"showNavigation\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n        </o-form-navigation>\n\n        <span *ngIf=\"getLabelHeaderAlign() === 'center' || getLabelHeaderAlign() === 'end'\" class=\"fill-remaining\"></span>\n        <div *ngIf=\"labelHeader!=''\" fxLayout=\"row\" fxLayoutAlign=\"center center\">\n          <span>{{ labelHeader | oTranslate }}</span>\n        </div>\n        <span *ngIf=\"getLabelHeaderAlign() === 'start' || getLabelHeaderAlign() === 'center'\" class=\"fill-remaining\"></span>\n\n        <ng-content select=\"[o-custom-form-toolbar-buttons-wrapper]\"></ng-content>\n\n        <ng-template [ngIf]=\"showHeaderActionsText\" [ngIfElse]=\"undoBtnWithoutText\">\n          <button type=\"button\" class=\"o-form-toolbar-button o-form-toolbar-button-undo\" mat-stroked-button (click)=\"onUndoLastChange()\"\n            [disabled]=\"isChangesStackEmpty\" *ngIf=\"showUndoButton\">\n            <mat-icon svgIcon=\"ontimize:undo\"></mat-icon>\n            <span>{{ 'UNDO' | oTranslate }}</span>\n          </button>\n        </ng-template>\n        <ng-template #undoBtnWithoutText>\n          <button type=\"button\" class=\"o-form-toolbar-button o-form-toolbar-button-undo\" mat-icon-button (click)=\"onUndoLastChange()\"\n            [disabled]=\"isChangesStackEmpty\" *ngIf=\"showUndoButton\">\n            <mat-icon svgIcon=\"ontimize:undo\"></mat-icon>\n          </button>\n        </ng-template>\n\n        <ng-container *ngIf=\"initialMode\">\n          <ng-template [ngIf]=\"showHeaderActionsText\" [ngIfElse]=\"buttonsWithouText\">\n            <button type=\"button\" class=\"o-form-toolbar-button o-form-toolbar-button-refresh\" mat-stroked-button (click)=\"onReload($event)\"\n              *ngIf=\"isRefreshBtnEnabled\" attr=\"refresh\">\n              <mat-icon svgIcon=\"ontimize:autorenew\"></mat-icon>\n              <span>{{ 'REFRESH' | oTranslate }}</span>\n            </button>\n            <button type=\"button\" class=\"o-form-toolbar-button o-form-toolbar-button-insert\" mat-stroked-button (click)=\"onInsert($event)\"\n              *ngIf=\"isInsertBtnEnabled\" attr=\"insert\">\n              <mat-icon svgIcon=\"ontimize:add\"></mat-icon>\n              <span>{{ 'ADD' | oTranslate }}</span>\n            </button>\n            <button type=\"button\" class=\"o-form-toolbar-button o-form-toolbar-button-edit\" mat-stroked-button (click)=\"onEdit($event)\"\n              *ngIf=\"isEditBtnEnabled | async\" attr=\"edit\">\n              <mat-icon svgIcon=\"ontimize:edit\"></mat-icon>\n              <span>{{ 'EDIT' | oTranslate }}</span>\n            </button>\n            <button type=\"button\" class=\"o-form-toolbar-button o-form-toolbar-button-delete\" mat-stroked-button (click)=\"onDelete($event)\"\n              *ngIf=\"isDeleteBtnEnabled\" attr=\"delete\">\n              <mat-icon svgIcon=\"ontimize:delete\"></mat-icon>\n              <span>{{ 'DELETE' | oTranslate }}</span>\n            </button>\n            <button type=\"button\" class=\"o-form-toolbar-button o-form-toolbar-button-save\" mat-stroked-button (click)=\"onSave($event)\"\n              [disabled]=\"!(existsChangesToSave | async)\" *ngIf=\"isSaveBtnEnabled | async\" attr=\"update\">\n              <mat-icon svgIcon=\"ontimize:save\"></mat-icon>\n              <span>{{ 'SAVE' | oTranslate }}</span>\n            </button>\n          </ng-template>\n          <ng-template #buttonsWithouText>\n            <button type=\"button\" class=\"o-form-toolbar-button o-form-toolbar-button-refresh\" mat-icon-button (click)=\"onReload($event)\"\n              *ngIf=\"isRefreshBtnEnabled\" attr=\"refresh\">\n              <mat-icon svgIcon=\"ontimize:autorenew\"></mat-icon>\n            </button>\n            <button type=\"button\" class=\"o-form-toolbar-button o-form-toolbar-button-insert\" mat-icon-button (click)=\"onInsert($event)\"\n              *ngIf=\"isInsertBtnEnabled\" attr=\"insert\">\n              <mat-icon svgIcon=\"ontimize:add\"></mat-icon>\n            </button>\n            <button type=\"button\" class=\"o-form-toolbar-button-o-form-toolbar-button-edit\" mat-icon-button (click)=\"onEdit($event)\"\n              *ngIf=\"isEditBtnEnabled | async\" attr=\"edit\">\n              <mat-icon svgIcon=\"ontimize:edit\"></mat-icon>\n            </button>\n            <button type=\"button\" class=\"o-form-toolbar-button o-form-toolbar-button-delete\" mat-icon-button (click)=\"onDelete($event)\"\n              *ngIf=\"isDeleteBtnEnabled\" attr=\"delete\">\n              <mat-icon svgIcon=\"ontimize:delete\"></mat-icon>\n            </button>\n            <button type=\"button\" class=\"o-form-toolbar-button o-form-toolbar-button-save\" mat-icon-button (click)=\"onSave($event)\"\n              [disabled]=\"!existsChangesToSave\" *ngIf=\"isSaveBtnEnabled | async\" attr=\"update\">\n              <mat-icon svgIcon=\"ontimize:save\"></mat-icon>\n            </button>\n          </ng-template>\n        </ng-container>\n\n        <ng-container *ngIf=\"editMode || insertMode\">\n          <button type=\"button\" class=\"o-form-toolbar-button o-form-toolbar-button-cancel\" mat-stroked-button (click)=\"cancelOperation($event)\">\n            <mat-icon svgIcon=\"ontimize:clear\"></mat-icon>\n            <span *ngIf=\"showHeaderActionsText\">{{ 'CANCEL' | oTranslate }}</span>\n          </button>\n          <button type=\"button\" class=\"o-form-toolbar-button o-form-toolbar-button-insert\" mat-stroked-button color=\"primary\"\n            (click)=\"acceptOperation($event)\">\n            <mat-icon svgIcon=\"ontimize:done\"></mat-icon>\n            <span *ngIf=\"showHeaderActionsText\">{{ 'INSERT' | oTranslate }}</span>\n          </button>\n        </ng-container>\n      </div>\n\n    </mat-toolbar>\n  ",
                    styles: ["\n    .o-form-toolbar{flex:none;display:block}.o-form-toolbar .o-form-toolbar-header{min-height:50px;max-height:50px;padding:0 16px 0 4px}.o-form-toolbar .o-form-toolbar-header.breadcrumb{padding:16px;min-height:84px;max-height:84px}.o-form-toolbar .o-form-toolbar-header .mat-toolbar-tools{width:100%}.o-form-toolbar .o-form-toolbar-header .mat-toolbar-tools button.o-form-toolbar-button[disabled]{cursor:default}.o-form-toolbar .o-form-toolbar-header .mat-toolbar-tools button.o-form-toolbar-button:not(.mat-icon-button) .mat-button-wrapper{display:flex;align-items:center}.o-form-toolbar .o-form-toolbar-header .mat-toolbar-tools button.o-form-toolbar-button:not(.mat-icon-button) .mat-button-wrapper span{flex:1}.o-form-toolbar .o-form-toolbar-header .mat-toolbar-tools button:not(.mat-icon-button){padding:0 6px}.o-form-toolbar .o-form-toolbar-header .mat-toolbar-tools button.mat-icon-button{padding:0;margin:0}.o-form-toolbar .o-form-toolbar-header .mat-toolbar-tools button.mat-stroked-button{min-width:100px;margin:0 6px}.o-form-toolbar .o-form-toolbar-header .o-breadcrumb{width:100%;height:32px;min-height:initial}.o-form-toolbar .o-form-toolbar-header .o-breadcrumb .mat-toolbar{padding:0;min-height:initial;max-height:initial;height:100%}\n  "],
                    inputs: DEFAULT_INPUTS_O_FORM_TOOLBAR,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-form-toolbar]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OFormToolbarComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    OFormToolbarComponent.propDecorators = {
        breadContainer: [{ type: core.ViewChild, args: ['breadcrumb', { read: core.ViewContainerRef },] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormToolbarComponent.prototype, "showHeaderActionsText", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormToolbarComponent.prototype, "showHeaderNavigation", void 0);
    return OFormToolbarComponent;
}());
var OFormToolbarModule = /** @class */ (function () {
    function OFormToolbarModule() {
    }
    OFormToolbarModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OFormNavigationComponent, OFormToolbarComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OFormNavigationComponent, OFormToolbarComponent]
                },] },
    ];
    return OFormToolbarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_FORM = [
    'showHeader: show-header',
    'headerMode: header-mode',
    'headerPosition: header-position',
    'labelheader: label-header',
    'labelHeaderAlign: label-header-align',
    'headeractions: header-actions',
    'showHeaderActionsText: show-header-actions-text',
    'entity',
    'keys',
    'columns',
    'service',
    'stayInRecordAfterInsert: stay-in-record-after-insert',
    'stayInRecordAfterEdit: stay-in-record-after-edit',
    'serviceType : service-type',
    'queryOnInit : query-on-init',
    'parentKeys: parent-keys',
    'queryMethod: query-method',
    'insertMethod: insert-method',
    'updateMethod: update-method',
    'deleteMethod: delete-method',
    'layoutDirection: layout-direction',
    'layoutAlign: layout-align',
    'editableDetail: editable-detail',
    'keysSqlTypes: keys-sql-types',
    'undoButton: undo-button',
    'showHeaderNavigation: show-header-navigation',
    'oattr:attr',
    'includeBreadcrumb: include-breadcrumb',
    'detectChangesOnBlur: detect-changes-on-blur',
    'confirmExit: confirm-exit'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_FORM = [
    'onDataLoaded',
    'beforeCloseDetail',
    'beforeGoEditMode',
    'onFormModeChange',
    'onInsert',
    'onUpdate',
    'onDelete'
];
var 0$7 = dataServiceFactory;
var OFormComponent = /** @class */ (function () {
    function OFormComponent(router$$1, actRoute, zone, cd, injector, elRef) {
        this.router = router$$1;
        this.actRoute = actRoute;
        this.zone = zone;
        this.cd = cd;
        this.injector = injector;
        this.elRef = elRef;
        /* inputs variables */
        this.showHeader = true;
        this.headerMode = 'floating';
        this.headerPosition = 'top';
        this.labelheader = '';
        this.labelHeaderAlign = 'center';
        this.headeractions = '';
        this.showHeaderActionsText = 'yes';
        this.keys = '';
        this.columns = '';
        this.stayInRecordAfterInsert = false;
        this.stayInRecordAfterEdit = false;
        this.queryOnInit = true;
        this.queryMethod = Codes.QUERY_METHOD;
        this.insertMethod = Codes.INSERT_METHOD;
        this.updateMethod = Codes.UPDATE_METHOD;
        this.deleteMethod = Codes.DELETE_METHOD;
        this._layoutDirection = OFormComponent.DEFAULT_LAYOUT_DIRECTION;
        this.editableDetail = true;
        this.undoButton = true;
        this.showHeaderNavigation = false;
        this.oattr = '';
        this.includeBreadcrumb = false;
        this.detectChangesOnBlur = true;
        this.confirmExit = true;
        /* end of inputs variables */
        /*parsed inputs variables */
        this.isDetailForm = false;
        this.keysArray = [];
        this.colsArray = [];
        this._pKeysEquiv = {};
        this.keysSqlTypesArray = [];
        this.onDataLoaded = new core.EventEmitter();
        this.beforeCloseDetail = new core.EventEmitter();
        this.beforeGoEditMode = new core.EventEmitter();
        this.onFormModeChange = new core.EventEmitter();
        this.onInsert = new core.EventEmitter();
        this.onUpdate = new core.EventEmitter();
        this.onDelete = new core.EventEmitter();
        this.loadingSubject = new BehaviorSubject(false);
        this.loading = this.loadingSubject.asObservable();
        this.formData = {};
        this.navigationData = [];
        this.currentIndex = 0;
        this.mode = OFormComponent.Mode().INITIAL;
        this._components = {};
        this._compSQLTypes = {};
        this.onFormInitStream = new core.EventEmitter();
        this.ignoreFormCacheKeys = [];
        this.formCache = new OFormCacheClass(this);
        this.formNavigation = new OFormNavigationClass(this.injector, this, this.router, this.actRoute);
        this.dialogService = injector.get(DialogService);
        this.navigationService = injector.get(NavigationService);
        this.snackBarService = injector.get(SnackBarService);
        this.permissionsService = this.injector.get(PermissionsService);
        /** @type {?} */
        var self = this;
        this.reloadStream = combineLatest(self.onFormInitStream.asObservable(), self.formNavigation.navigationStream.asObservable());
        this.reloadStreamSubscription = this.reloadStream.subscribe(function (valArr) {
            if (Util.isArray(valArr) && valArr.length === 2 && !self.isInInsertMode()) {
                /** @type {?} */
                var valArrValues = valArr[0] === true && valArr[1] === true;
                if (self.queryOnInit && valArrValues) {
                    self._reloadAction(true);
                }
                else {
                    self.initializeFields();
                }
            }
        });
        try {
            this.formContainer = injector.get(OFormContainerComponent$$1);
            this.formContainer.setForm(this);
        }
        catch (e) {
            //
        }
    }
    /**
     * @return {?}
     */
    OFormComponent.Mode = /**
     * @return {?}
     */
    function () {
        /** @enum {number} */
        var m = {
            QUERY: 0,
            INSERT: 1,
            UPDATE: 2,
            INITIAL: 3,
        };
        m[m.QUERY] = 'QUERY';
        m[m.INSERT] = 'INSERT';
        m[m.UPDATE] = 'UPDATE';
        m[m.INITIAL] = 'INITIAL';
        return m;
    };
    /**
     * @param {?} comp
     * @return {?}
     */
    OFormComponent.prototype.registerFormComponent = /**
     * @param {?} comp
     * @return {?}
     */
    function (comp) {
        if (comp) {
            /** @type {?} */
            var attr = comp.getAttribute();
            if (attr && attr.length > 0) {
                if (!comp.isAutomaticRegistering()) {
                    return;
                }
                if (this._components.hasOwnProperty(attr)) {
                    comp.repeatedAttr = true;
                    console.error('There is already a component registered in the form with the attr: ' + attr);
                    return;
                }
                this._components[attr] = comp;
                // Setting parent key values...
                if (this.formParentKeysValues && this.formParentKeysValues[attr] !== undefined) {
                    /** @type {?} */
                    var val = this.formParentKeysValues[attr];
                    this._components[attr].setValue(val, {
                        emitModelToViewChange: false,
                        emitEvent: false
                    });
                }
                /** @type {?} */
                var cachedValue = this.formCache.getCachedValue(attr);
                if (Util.isDefined(cachedValue) && this.getDataValues() && this._components.hasOwnProperty(attr)) {
                    this._components[attr].setValue(cachedValue, {
                        emitModelToViewChange: false,
                        emitEvent: false
                    });
                }
            }
        }
    };
    /**
     * @param {?} comp
     * @return {?}
     */
    OFormComponent.prototype.registerSQLTypeFormComponent = /**
     * @param {?} comp
     * @return {?}
     */
    function (comp) {
        if ((/** @type {?} */ (comp)).repeatedAttr) {
            return;
        }
        if (comp) {
            /** @type {?} */
            var type = comp.getSQLType();
            /** @type {?} */
            var attr = comp.getAttribute();
            if (type !== SQLTypes.OTHER && attr && attr.length > 0 && this.ignoreFormCacheKeys.indexOf(attr) === -1) {
                // Right now just store values different of 'OTHER'
                this._compSQLTypes[attr] = type;
            }
        }
    };
    /**
     * @param {?} comp
     * @return {?}
     */
    OFormComponent.prototype.registerFormControlComponent = /**
     * @param {?} comp
     * @return {?}
     */
    function (comp) {
        if ((/** @type {?} */ (comp)).repeatedAttr) {
            return;
        }
        if (comp) {
            /** @type {?} */
            var attr = comp.getAttribute();
            if (attr && attr.length > 0) {
                /** @type {?} */
                var control = comp.getControl();
                if (control) {
                    this.formGroup.registerControl(attr, control);
                    if (!comp.isAutomaticRegistering()) {
                        this.ignoreFormCacheKeys.push(comp.getAttribute());
                    }
                }
            }
        }
    };
    /**
     * @param {?} comp
     * @return {?}
     */
    OFormComponent.prototype.unregisterFormComponent = /**
     * @param {?} comp
     * @return {?}
     */
    function (comp) {
        if (comp) {
            /** @type {?} */
            var attr = comp.getAttribute();
            if (attr && attr.length > 0 && this._components.hasOwnProperty(attr)) {
                delete this._components[attr];
            }
        }
    };
    /**
     * @param {?} comp
     * @return {?}
     */
    OFormComponent.prototype.unregisterFormControlComponent = /**
     * @param {?} comp
     * @return {?}
     */
    function (comp) {
        if (comp && comp.isAutomaticRegistering()) {
            /** @type {?} */
            var control = comp.getControl();
            /** @type {?} */
            var attr = comp.getAttribute();
            if (control && attr && attr.length > 0) {
                this.formGroup.removeControl(attr);
            }
        }
    };
    /**
     * @param {?} comp
     * @return {?}
     */
    OFormComponent.prototype.unregisterSQLTypeFormComponent = /**
     * @param {?} comp
     * @return {?}
     */
    function (comp) {
        if (comp) {
            /** @type {?} */
            var attr = comp.getAttribute();
            if (attr && attr.length > 0) {
                delete this._compSQLTypes[attr];
            }
        }
    };
    /**
     * @param {?} fToolbar
     * @return {?}
     */
    OFormComponent.prototype.registerToolbar = /**
     * @param {?} fToolbar
     * @return {?}
     */
    function (fToolbar) {
        if (fToolbar) {
            this._formToolbar = fToolbar;
            this._formToolbar.isDetail = this.isDetailForm;
        }
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getComponents = /**
     * @return {?}
     */
    function () {
        return this._components;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.load = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var zone = this.injector.get(core.NgZone);
        /** @type {?} */
        var loadObservable = new Observable(function (observer) {
            /** @type {?} */
            var timer$$1 = window.setTimeout(function () {
                observer.next(true);
            }, 250);
            return function () {
                window.clearTimeout(timer$$1);
                zone.run(function () {
                    self.loadingSubject.next(false);
                });
            };
        });
        /** @type {?} */
        var subscription = loadObservable.subscribe(function (val) {
            zone.run(function () {
                self.loadingSubject.next(/** @type {?} */ (val));
            });
        });
        return subscription;
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OFormComponent.prototype.getDataValue = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        if (this.isInInsertMode()) {
            /** @type {?} */
            var urlParams = this.formNavigation.getFilterFromUrlParams();
            /** @type {?} */
            var val = this.formGroup.value[attr] || urlParams[attr];
            return new OFormValue(val);
        }
        else if (this.isInInitialMode() && !this.isEditableDetail()) {
            /** @type {?} */
            var data = this.formData;
            if (data && data.hasOwnProperty(attr)) {
                return data[attr];
            }
        }
        else if (this.isInUpdateMode() || this.isEditableDetail()) {
            if (this.formData && Object.keys(this.formData).length > 0) {
                /** @type {?} */
                var val = this.formCache.getCachedValue(attr);
                if (this.formGroup.dirty && val) {
                    if (val instanceof OFormValue) {
                        return val;
                    }
                    return new OFormValue(val);
                }
                else {
                    /** @type {?} */
                    var data = this.formData;
                    if (data && data.hasOwnProperty(attr)) {
                        return data[attr];
                    }
                }
            }
        }
        return new OFormValue();
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getDataValues = /**
     * @return {?}
     */
    function () {
        return this.formData;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.clearData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var filter$$1 = this.formNavigation.getFilterFromUrlParams();
        this.formGroup.reset({}, {
            emitEvent: false
        });
        this._setData(filter$$1);
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.canDeactivate = /**
     * @return {?}
     */
    function () {
        if (!this.confirmExit) {
            return true;
        }
        /** @type {?} */
        var canDiscardChanges = this.canDiscardChanges;
        this.canDiscardChanges = false;
        return canDiscardChanges || this.showConfirmDiscardChanges();
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.showConfirmDiscardChanges = /**
     * @return {?}
     */
    function () {
        return this.formNavigation.showConfirmDiscardChanges();
    };
    /**
     * @param {?} action
     * @param {?=} options
     * @return {?}
     */
    OFormComponent.prototype.executeToolbarAction = /**
     * @param {?} action
     * @param {?=} options
     * @return {?}
     */
    function (action, options) {
        switch (action) {
            case OFormComponent.BACK_ACTION:
                this._backAction();
                break;
            case OFormComponent.CLOSE_DETAIL_ACTION:
                this._closeDetailAction(options);
                break;
            case OFormComponent.RELOAD_ACTION:
                this._reloadAction(true);
                break;
            case OFormComponent.GO_INSERT_ACTION:
                this._goInsertMode(options);
                break;
            case OFormComponent.INSERT_ACTION:
                this._insertAction();
                break;
            case OFormComponent.GO_EDIT_ACTION:
                this._goEditMode(options);
                break;
            case OFormComponent.EDIT_ACTION:
                this._editAction();
                break;
            case OFormComponent.UNDO_LAST_CHANGE_ACTION:
                this._undoLastChangeAction();
                break;
            case OFormComponent.DELETE_ACTION: return this._deleteAction();
            default: break;
        }
        return undefined;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.addDeactivateGuard();
        this.formGroup = new forms.FormGroup({});
        this.formNavigation.initialize();
        this.initialize();
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.addDeactivateGuard = /**
     * @return {?}
     */
    function () {
        if (this.isInInitialMode() && !this.isEditableDetail()) {
            return;
        }
        if (!this.actRoute || !this.actRoute.routeConfig) {
            return;
        }
        this.deactivateGuard = this.injector.get(CanDeactivateFormGuard);
        this.deactivateGuard.setForm(this);
        /** @type {?} */
        var canDeactivateArray = (this.actRoute.routeConfig.canDeactivate || []);
        /** @type {?} */
        var previouslyAdded = false;
        for (var i = 0, len = canDeactivateArray.length; i < len; i++) {
            previouslyAdded = (canDeactivateArray[i].name === OFormComponent.guardClassName);
            if (previouslyAdded) {
                break;
            }
        }
        if (!previouslyAdded) {
            canDeactivateArray.push(this.deactivateGuard.constructor);
            this.actRoute.routeConfig.canDeactivate = canDeactivateArray;
        }
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.destroyDeactivateGuard = /**
     * @return {?}
     */
    function () {
        try {
            if (!this.deactivateGuard || !this.actRoute || !this.actRoute.routeConfig || !this.actRoute.routeConfig.canDeactivate) {
                return;
            }
            this.deactivateGuard.setForm(undefined);
            for (var i = this.actRoute.routeConfig.canDeactivate.length - 1; i >= 0; i--) {
                if (this.actRoute.routeConfig.canDeactivate[i].name === OFormComponent.guardClassName) {
                    this.actRoute.routeConfig.canDeactivate.splice(i, 1);
                    break;
                }
            }
            if (this.actRoute.routeConfig.canDeactivate.length === 0) {
                delete this.actRoute.routeConfig.canDeactivate;
            }
        }
        catch (e) {
            //
        }
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.hasDeactivateGuard = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this.deactivateGuard);
    };
    /**
     * Angular methods
     */
    /**
     * Angular methods
     * @return {?}
     */
    OFormComponent.prototype.initialize = /**
     * Angular methods
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        if (this.headeractions === 'all') {
            this.headeractions = 'R;I;U;D';
        }
        this.keysArray = Util.parseArray(this.keys, true);
        this.colsArray = Util.parseArray(this.columns, true);
        /** @type {?} */
        var pkArray = Util.parseArray(this.parentKeys);
        this._pKeysEquiv = Util.parseParentKeysEquivalences(pkArray);
        this.keysSqlTypesArray = Util.parseArray(this.keysSqlTypes);
        this.configureService();
        this.formNavigation.subscribeToQueryParams();
        this.formNavigation.subscribeToUrlParams();
        this.formNavigation.subscribeToUrl();
        this.formNavigation.subscribeToCacheChanges(this.formCache.onCacheEmptyStateChanges);
        if (this.navigationService) {
            this.navigationService.onVisibleChange(function (visible) {
                self.showHeader = visible;
            });
        }
        this.mode = OFormComponent.Mode().INITIAL;
        this.permissions = this.permissionsService.getFormPermissions(this.oattr, this.actRoute);
    };
    /**
     * @param {?} options
     * @return {?}
     */
    OFormComponent.prototype.reinitialize = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        if (options && Object.keys(options).length) {
            /** @type {?} */
            var clonedOpts = Object.assign({}, options);
            for (var prop in clonedOpts) {
                if (clonedOpts.hasOwnProperty(prop)) {
                    this[prop] = clonedOpts[prop];
                }
            }
            this.destroy();
            this.initialize();
        }
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.configureService = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var loadingService = OntimizeService$$1;
        if (this.serviceType) {
            loadingService = this.serviceType;
        }
        try {
            this.dataService = this.injector.get(loadingService);
            if (Util.isDataService(this.dataService)) {
                /** @type {?} */
                var serviceCfg = this.dataService.getDefaultServiceConfiguration(this.service);
                if (this.entity) {
                    serviceCfg['entity'] = this.entity;
                }
                this.dataService.configureService(serviceCfg);
            }
        }
        catch (e) {
            console.error(e);
        }
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy();
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (this.reloadStreamSubscription) {
            this.reloadStreamSubscription.unsubscribe();
        }
        if (this.querySubscription) {
            this.querySubscription.unsubscribe();
        }
        if (this.loaderSubscription) {
            this.loaderSubscription.unsubscribe();
        }
        this.formCache.destroy();
        this.formNavigation.destroy();
        this.destroyDeactivateGuard();
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            _this.determinateFormMode();
            _this.onFormInitStream.emit(true);
        });
    };
    /*
     * Inner methods
     */
    /**
     * @param {?} state
     * @return {?}
     */
    OFormComponent.prototype._setComponentsEditable = /**
     * @param {?} state
     * @return {?}
     */
    function (state$$1) {
        /** @type {?} */
        var components = this.getComponents();
        Object.keys(components).forEach(function (compKey) {
            /** @type {?} */
            var component = components[compKey];
            component.isReadOnly = !state$$1;
        });
    };
    /**
     * Sets form operation mode.
     * @param mode The mode to be established
     */
    /**
     * Sets form operation mode.
     * @param {?} mode The mode to be established
     * @return {?}
     */
    OFormComponent.prototype.setFormMode = /**
     * Sets form operation mode.
     * @param {?} mode The mode to be established
     * @return {?}
     */
    function (mode) {
        switch (mode) {
            case OFormComponent.Mode().INITIAL:
                this.mode = mode;
                if (this._formToolbar) {
                    this._formToolbar.setInitialMode();
                }
                this._setComponentsEditable(this.isEditableDetail());
                this.onFormModeChange.emit(this.mode);
                break;
            case OFormComponent.Mode().INSERT:
                this.mode = mode;
                if (this._formToolbar) {
                    this._formToolbar.setInsertMode();
                }
                this.clearData();
                this._setComponentsEditable(true);
                this.onFormModeChange.emit(this.mode);
                break;
            case OFormComponent.Mode().UPDATE:
                this.mode = mode;
                if (this._formToolbar) {
                    this._formToolbar.setEditMode();
                }
                this._setComponentsEditable(true);
                this.onFormModeChange.emit(this.mode);
            default:
                break;
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OFormComponent.prototype._setData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (Util.isArray(data)) {
            if (data.lenght > 1) {
                console.warn('[OFormComponent] Form data has more than a single record. Storing empty data');
            }
            /** @type {?} */
            var currentData = data.length === 1 ? data[0] : {};
            this._updateFormData(this.toFormValueData(currentData));
            this._emitData(currentData);
        }
        else if (Util.isObject(data)) {
            this._updateFormData(this.toFormValueData(data));
            this._emitData(data);
        }
        else {
            console.warn('Form has received not supported service data. Supported data are Array or Object');
            this._updateFormData({});
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OFormComponent.prototype._emitData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.onDataLoaded.emit(data);
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype._backAction = /**
     * @return {?}
     */
    function () {
        this.formNavigation.navigateBack();
    };
    /**
     * @param {?=} options
     * @return {?}
     */
    OFormComponent.prototype._closeDetailAction = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        this.formNavigation.closeDetailAction(options);
    };
    /**
     * @param {?} insertedKeys
     * @return {?}
     */
    OFormComponent.prototype._stayInRecordAfterInsert = /**
     * @param {?} insertedKeys
     * @return {?}
     */
    function (insertedKeys) {
        this.formNavigation.stayInRecordAfterInsert(insertedKeys);
    };
    /**
     * @param {?=} useFilter
     * @return {?}
     */
    OFormComponent.prototype._reloadAction = /**
     * @param {?=} useFilter
     * @return {?}
     */
    function (useFilter) {
        if (useFilter === void 0) { useFilter = false; }
        /** @type {?} */
        var filter$$1 = {};
        if (useFilter) {
            filter$$1 = this.getCurrentKeysValues();
        }
        this.queryData(filter$$1);
    };
    /**
     * Navigates to 'insert' mode
     */
    /**
     * Navigates to 'insert' mode
     * @param {?=} options
     * @return {?}
     */
    OFormComponent.prototype._goInsertMode = /**
     * Navigates to 'insert' mode
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        this.formNavigation.goInsertMode(options);
    };
    /**
     * Performs insert action.
     */
    /**
     * Performs insert action.
     * @return {?}
     */
    OFormComponent.prototype._insertAction = /**
     * Performs insert action.
     * @return {?}
     */
    function () {
        var _this = this;
        Object.keys(this.formGroup.controls).forEach(function (control) {
            _this.formGroup.controls[control].markAsTouched();
        });
        if (!this.formGroup.valid) {
            this.dialogService.alert('ERROR', 'MESSAGES.FORM_VALIDATION_ERROR');
            return;
        }
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var values = this.getAttributesValuesToInsert();
        /** @type {?} */
        var sqlTypes = this.getAttributesSQLTypes();
        this.insertData(values, sqlTypes).subscribe(function (resp) {
            self.postCorrectInsert(resp);
            self.formCache.setCacheSnapshot();
            self.markFormLayoutManagerToUpdate();
            if (self.stayInRecordAfterInsert) {
                self._stayInRecordAfterInsert(resp);
            }
            else {
                self._closeDetailAction();
            }
        }, function (error) {
            self.postIncorrectInsert(error);
        });
    };
    /**
     * Navigates to 'edit' mode
     */
    /**
     * Navigates to 'edit' mode
     * @param {?=} options
     * @return {?}
     */
    OFormComponent.prototype._goEditMode = /**
     * Navigates to 'edit' mode
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        this.formNavigation.goEditMode();
    };
    /**
     * Performs 'edit' action
     */
    /**
     * Performs 'edit' action
     * @return {?}
     */
    OFormComponent.prototype._editAction = /**
     * Performs 'edit' action
     * @return {?}
     */
    function () {
        var _this = this;
        Object.keys(this.formGroup.controls).forEach(function (control) {
            _this.formGroup.controls[control].markAsTouched();
        });
        if (!this.formGroup.valid) {
            this.dialogService.alert('ERROR', 'MESSAGES.FORM_VALIDATION_ERROR');
            return;
        }
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var filter$$1 = this.getKeysValues();
        /** @type {?} */
        var values = this.getAttributesValuesToUpdate();
        /** @type {?} */
        var sqlTypes = this.getAttributesSQLTypes();
        if (Object.keys(values).length === 0) {
            // Nothing to update
            this.dialogService.alert('INFO', 'MESSAGES.FORM_NOTHING_TO_UPDATE_INFO');
            return;
        }
        // invoke update method...
        this.updateData(filter$$1, values, sqlTypes).subscribe(function (resp) {
            self.postCorrectUpdate(resp);
            self.formCache.setCacheSnapshot();
            self.markFormLayoutManagerToUpdate();
            if (self.stayInRecordAfterEdit) {
                self._reloadAction(true);
            }
            else {
                self._closeDetailAction();
            }
        }, function (error) {
            self.postIncorrectUpdate(error);
        });
    };
    /**
     * Performs 'delete' action
     */
    /**
     * Performs 'delete' action
     * @return {?}
     */
    OFormComponent.prototype._deleteAction = /**
     * Performs 'delete' action
     * @return {?}
     */
    function () {
        /** @type {?} */
        var filter$$1 = this.getKeysValues();
        return this.deleteData(filter$$1);
    };
    /*
    Utility methods
    */
    /**
     * @param {?} filter
     * @return {?}
     */
    OFormComponent.prototype.queryData = /**
     * @param {?} filter
     * @return {?}
     */
    function (filter$$1) {
        if (!Util.isDefined(this.dataService)) {
            console.warn('OFormComponent: no service configured! aborting query');
            return;
        }
        if (!Util.isDefined(filter$$1) || Object.keys(filter$$1).length === 0) {
            console.warn('OFormComponent: no filter configured! aborting query');
            return;
        }
        this.formCache.restartCache();
        this.clearComponentsOldValue();
        if (this.querySubscription) {
            this.querySubscription.unsubscribe();
        }
        if (this.loaderSubscription) {
            this.loaderSubscription.unsubscribe();
        }
        /** @type {?} */
        var self = this;
        this.loaderSubscription = this.load();
        /** @type {?} */
        var av = this.getAttributesToQuery();
        /** @type {?} */
        var sqlTypes = this.getAttributesSQLTypes();
        this.querySubscription = this.dataService[this.queryMethod](filter$$1, av, this.entity, sqlTypes).subscribe(function (resp) {
            if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                self._setData(resp.data);
            }
            else {
                self._updateFormData({});
                self.dialogService.alert('ERROR', 'MESSAGES.ERROR_QUERY');
                console.error('ERROR: ' + resp.message);
            }
            self.loaderSubscription.unsubscribe();
        }, function (err) {
            console.error(err);
            self._updateFormData({});
            if (err && err.statusText) {
                self.dialogService.alert('ERROR', err.statusText);
            }
            else {
                self.dialogService.alert('ERROR', 'MESSAGES.ERROR_QUERY');
            }
            self.loaderSubscription.unsubscribe();
        });
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getAttributesToQuery = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var attributes = [];
        // add form keys...
        if (this.keysArray && this.keysArray.length > 0) {
            attributes.push.apply(attributes, this.keysArray);
        }
        /** @type {?} */
        var components = this.getComponents();
        // add only the fields contained into the form...
        Object.keys(components).forEach(function (item) {
            if (attributes.indexOf(item) < 0 &&
                components[item].isAutomaticRegistering() && components[item].isAutomaticBinding()) {
                attributes.push(item);
            }
        });
        /** @type {?} */
        var dataCache = this.formCache.getDataCache();
        if (dataCache) {
            Object.keys(dataCache).forEach(function (item) {
                if (item !== undefined && attributes.indexOf(item) === -1) {
                    attributes.push(item);
                }
            });
        }
        attributes = attributes.concat(this.colsArray.filter(function (col) { return attributes.indexOf(col) < 0; }));
        return attributes;
    };
    /**
     * @param {?} values
     * @param {?=} sqlTypes
     * @return {?}
     */
    OFormComponent.prototype.insertData = /**
     * @param {?} values
     * @param {?=} sqlTypes
     * @return {?}
     */
    function (values, sqlTypes) {
        var _this = this;
        if (this.loaderSubscription) {
            this.loaderSubscription.unsubscribe();
        }
        this.loaderSubscription = this.load();
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var observable$$1 = new Observable(function (observer) {
            _this.dataService[_this.insertMethod](values, _this.entity, sqlTypes).subscribe(function (resp) {
                if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                    observer.next(resp.data);
                    observer.complete();
                }
                else {
                    observer.error(resp.message);
                }
                self.loaderSubscription.unsubscribe();
            }, function (err) {
                observer.error(err);
                self.loaderSubscription.unsubscribe();
            });
        });
        return observable$$1;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getAttributesValuesToInsert = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var attrValues = {};
        if (this.formParentKeysValues) {
            Object.assign(attrValues, this.formParentKeysValues);
        }
        return Object.assign(attrValues, this.getRegisteredFieldsValues());
    };
    /**
     * Returns an object with the sql types from the form components and the form keys
     * @return {?}
     */
    OFormComponent.prototype.getAttributesSQLTypes = /**
     * Returns an object with the sql types from the form components and the form keys
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var types = {};
        // Add form keys sql types
        this.keysSqlTypesArray.forEach(function (kst, i) { return types[_this.keysArray[i]] = SQLTypes.getSQLTypeValue(kst); });
        // Add form components sql types
        if (this._compSQLTypes && Object.keys(this._compSQLTypes).length > 0) {
            Object.assign(types, this._compSQLTypes);
        }
        return types;
    };
    /**
     * @param {?} filter
     * @param {?} values
     * @param {?=} sqlTypes
     * @return {?}
     */
    OFormComponent.prototype.updateData = /**
     * @param {?} filter
     * @param {?} values
     * @param {?=} sqlTypes
     * @return {?}
     */
    function (filter$$1, values, sqlTypes) {
        var _this = this;
        if (this.loaderSubscription) {
            this.loaderSubscription.unsubscribe();
        }
        this.loaderSubscription = this.load();
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var observable$$1 = new Observable(function (observer) {
            _this.dataService[_this.updateMethod](filter$$1, values, _this.entity, sqlTypes).subscribe(function (resp) {
                if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                    observer.next(resp.data);
                    observer.complete();
                }
                else {
                    observer.error(resp.message);
                }
                self.loaderSubscription.unsubscribe();
            }, function (err) {
                observer.error(err);
                self.loaderSubscription.unsubscribe();
            });
        });
        return observable$$1;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getAttributesValuesToUpdate = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var values = {};
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var changedAttrs = this.formCache.getChangedFormControlsAttr();
        Object.keys(this.formGroup.controls).filter(function (controlName) {
            return self.ignoreFormCacheKeys.indexOf(controlName) === -1 &&
                changedAttrs.indexOf(controlName) !== -1;
        }).forEach(function (item) {
            /** @type {?} */
            var control = self.formGroup.controls[item];
            if (control instanceof OFormControl) {
                values[item] = control.getValue();
            }
            else {
                values[item] = control.value;
            }
            if (values[item] === undefined) {
                values[item] = null;
            }
        });
        return values;
    };
    /**
     * @param {?} filter
     * @return {?}
     */
    OFormComponent.prototype.deleteData = /**
     * @param {?} filter
     * @return {?}
     */
    function (filter$$1) {
        var _this = this;
        if (this.loaderSubscription) {
            this.loaderSubscription.unsubscribe();
        }
        this.loaderSubscription = this.load();
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var observable$$1 = new Observable(function (observer) {
            _this.canDiscardChanges = true;
            _this.dataService[_this.deleteMethod](filter$$1, _this.entity).subscribe(function (resp) {
                if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                    self.formCache.setCacheSnapshot();
                    self.markFormLayoutManagerToUpdate();
                    self.postCorrectDelete(resp);
                    observer.next(resp.data);
                    observer.complete();
                }
                else {
                    self.postIncorrectDelete(resp);
                    observer.error(resp.message);
                }
                self.loaderSubscription.unsubscribe();
            }, function (err) {
                self.postIncorrectDelete(err);
                observer.error(err);
                self.loaderSubscription.unsubscribe();
            });
        });
        return observable$$1;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OFormComponent.prototype.toJSONData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (!data) {
            data = {};
        }
        /** @type {?} */
        var valueData = {};
        Object.keys(data).forEach(function (item) {
            valueData[item] = data[item].value;
        });
        return valueData;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OFormComponent.prototype.toFormValueData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (data && Util.isArray(data)) {
            /** @type {?} */
            var valueData_1 = [];
            /** @type {?} */
            var self_1 = this;
            data.forEach(function (item) {
                valueData_1.push(self_1.objectToFormValueData(item));
            });
            return valueData_1;
        }
        else if (data && Util.isObject(data)) {
            return this.objectToFormValueData(data);
        }
        return undefined;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getKeysValues = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var filter$$1 = {};
        /** @type {?} */
        var currentRecord = this.formData;
        if (!this.keysArray) {
            return filter$$1;
        }
        this.keysArray.forEach(function (key) {
            if (currentRecord[key] !== undefined) {
                /** @type {?} */
                var currentData = currentRecord[key];
                if (currentData instanceof OFormValue) {
                    currentData = currentData.value;
                }
                filter$$1[key] = currentData;
            }
        });
        return filter$$1;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.isInQueryMode = /**
     * @return {?}
     */
    function () {
        return this.mode === OFormComponent.Mode().QUERY;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.isInInsertMode = /**
     * @return {?}
     */
    function () {
        return this.mode === OFormComponent.Mode().INSERT;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.isInUpdateMode = /**
     * @return {?}
     */
    function () {
        return this.mode === OFormComponent.Mode().UPDATE;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.isInInitialMode = /**
     * @return {?}
     */
    function () {
        return this.mode === OFormComponent.Mode().INITIAL;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.setQueryMode = /**
     * @return {?}
     */
    function () {
        this.setFormMode(OFormComponent.Mode().QUERY);
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.setInsertMode = /**
     * @return {?}
     */
    function () {
        this.setFormMode(OFormComponent.Mode().INSERT);
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.setUpdateMode = /**
     * @return {?}
     */
    function () {
        this.setFormMode(OFormComponent.Mode().UPDATE);
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.setInitialMode = /**
     * @return {?}
     */
    function () {
        this.setFormMode(OFormComponent.Mode().INITIAL);
    };
    /**
     * @param {?} dynamicForm
     * @return {?}
     */
    OFormComponent.prototype.registerDynamicFormComponent = /**
     * @param {?} dynamicForm
     * @return {?}
     */
    function (dynamicForm) {
        if (!Util.isDefined(dynamicForm)) {
            return;
        }
        /** @type {?} */
        var self = this;
        this.dynamicFormSubscription = dynamicForm.render.subscribe(function (res) {
            if (res) {
                self.refreshComponentsEditableState();
                if (!self.isInInsertMode() && self.queryOnInit) {
                    self._reloadAction(true);
                }
                if (self.formParentKeysValues) {
                    Object.keys(self.formParentKeysValues).forEach(function (parentKey) {
                        /** @type {?} */
                        var value = self.formParentKeysValues[parentKey];
                        /** @type {?} */
                        var comp = self.getFieldReference(parentKey);
                        if (Util.isFormDataComponent(comp) && comp.isAutomaticBinding()) {
                            comp.setValue(value, {
                                emitModelToViewChange: false,
                                emitEvent: false
                            });
                        }
                    });
                }
            }
        });
    };
    /**
     * @param {?} dynamicForm
     * @return {?}
     */
    OFormComponent.prototype.unregisterDynamicFormComponent = /**
     * @param {?} dynamicForm
     * @return {?}
     */
    function (dynamicForm) {
        if (dynamicForm && this.dynamicFormSubscription) {
            this.dynamicFormSubscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getRequiredComponents = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var requiredCompontents = {};
        /** @type {?} */
        var components = this.getComponents();
        if (components) {
            Object.keys(components).forEach(function (key) {
                /** @type {?} */
                var comp = components[key];
                /** @type {?} */
                var attr = comp.getAttribute();
                if ((/** @type {?} */ (comp)).isRequired && attr && attr.length > 0) {
                    requiredCompontents[attr] = comp;
                }
            });
        }
        return requiredCompontents;
    };
    Object.defineProperty(OFormComponent.prototype, "layoutDirection", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layoutDirection;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var parsedVal = (val || '').toLowerCase();
            this._layoutDirection = ['row', 'column', 'row-reverse', 'column-reverse'].indexOf(parsedVal) !== -1 ? parsedVal : OFormComponent.DEFAULT_LAYOUT_DIRECTION;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormComponent.prototype, "layoutAlign", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layoutAlign;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._layoutAlign = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormComponent.prototype, "showFloatingToolbar", {
        get: /**
         * @return {?}
         */
        function () {
            return this.showHeader && this.headerMode === 'floating';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFormComponent.prototype, "showNotFloatingToolbar", {
        get: /**
         * @return {?}
         */
        function () {
            return this.showHeader && this.headerMode !== 'floating';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OFormComponent.prototype.isEditableDetail = /**
     * @return {?}
     */
    function () {
        return this.editableDetail;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.isInitialStateChanged = /**
     * @return {?}
     */
    function () {
        return this.formCache.isInitialStateChanged();
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype._undoLastChangeAction = /**
     * @return {?}
     */
    function () {
        this.formCache.undoLastChange();
    };
    Object.defineProperty(OFormComponent.prototype, "isCacheStackEmpty", {
        get: /**
         * @return {?}
         */
        function () {
            return this.formCache.isCacheStackEmpty;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OFormComponent.prototype.undoKeyboardPressed = /**
     * @return {?}
     */
    function () {
        this.formCache.undoLastChange({
            keyboardEvent: true
        });
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getFormToolbar = /**
     * @return {?}
     */
    function () {
        return this._formToolbar;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getFormManager = /**
     * @return {?}
     */
    function () {
        return this.formNavigation.formLayoutManager;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getFormNavigation = /**
     * @return {?}
     */
    function () {
        return this.formNavigation;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getFormCache = /**
     * @return {?}
     */
    function () {
        return this.formCache;
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    OFormComponent.prototype.getUrlParam = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        return this.getFormNavigation().getUrlParams()[arg];
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getUrlParams = /**
     * @return {?}
     */
    function () {
        return this.getFormNavigation().getUrlParams();
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OFormComponent.prototype.setUrlParamsAndReload = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        this.formNavigation.setUrlParams(val);
        this._reloadAction(true);
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getRegisteredFieldsValues = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var values = {};
        /** @type {?} */
        var components = this.getComponents();
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var componentsKeys = Object.keys(components).filter(function (key) { return self.ignoreFormCacheKeys.indexOf(key) === -1; });
        componentsKeys.forEach(function (compKey) {
            /** @type {?} */
            var comp = components[compKey];
            values[compKey] = comp.getValue();
        });
        return values;
    };
    /**
     * Return the current value of the control in the form
     * @param attr
     */
    /**
     * Return the current value of the control in the form
     * @param {?} attr
     * @return {?}
     */
    OFormComponent.prototype.getFieldValue = /**
     * Return the current value of the control in the form
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        /** @type {?} */
        var value = null;
        /** @type {?} */
        var comp = this.getFieldReference(attr);
        if (comp) {
            value = comp.getValue();
        }
        return value;
    };
    /**
     * Return an object with the values of each attribute
     * @param attrs
     */
    /**
     * Return an object with the values of each attribute
     * @param {?} attrs
     * @return {?}
     */
    OFormComponent.prototype.getFieldValues = /**
     * Return an object with the values of each attribute
     * @param {?} attrs
     * @return {?}
     */
    function (attrs) {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var arr = {};
        attrs.forEach(function (key) {
            arr[key] = self.getFieldValue(key);
        });
        return arr;
    };
    /**
     * Sets the value of the control in the form.
     * @param attr attribute of control
     * @param value value
     */
    /**
     * Sets the value of the control in the form.
     * @param {?} attr attribute of control
     * @param {?} value value
     * @param {?=} options
     * @return {?}
     */
    OFormComponent.prototype.setFieldValue = /**
     * Sets the value of the control in the form.
     * @param {?} attr attribute of control
     * @param {?} value value
     * @param {?=} options
     * @return {?}
     */
    function (attr, value, options) {
        /** @type {?} */
        var comp = this.getFieldReference(attr);
        if (comp) {
            comp.setValue(value, options);
        }
    };
    /**
     * Sets the value of each control in the form.
     * @param values
     */
    /**
     * Sets the value of each control in the form.
     * @param {?} values
     * @param {?=} options
     * @return {?}
     */
    OFormComponent.prototype.setFieldValues = /**
     * Sets the value of each control in the form.
     * @param {?} values
     * @param {?=} options
     * @return {?}
     */
    function (values, options) {
        for (var key in values) {
            this.setFieldValue(key, values[key], options);
        }
    };
    /**
     * Clear the value of each control in the form
     * @param attr
     */
    /**
     * Clear the value of each control in the form
     * @param {?} attr
     * @param {?=} options
     * @return {?}
     */
    OFormComponent.prototype.clearFieldValue = /**
     * Clear the value of each control in the form
     * @param {?} attr
     * @param {?=} options
     * @return {?}
     */
    function (attr, options) {
        /** @type {?} */
        var comp = this.getFieldReference(attr);
        if (comp) {
            comp.clearValue(options);
        }
    };
    /**
     * Reset the value of each control in the form
     * @param attrs
     */
    /**
     * Reset the value of each control in the form
     * @param {?} attrs
     * @param {?=} options
     * @return {?}
     */
    OFormComponent.prototype.clearFieldValues = /**
     * Reset the value of each control in the form
     * @param {?} attrs
     * @param {?=} options
     * @return {?}
     */
    function (attrs, options) {
        /** @type {?} */
        var self = this;
        attrs.forEach(function (key) {
            self.clearFieldValue(key, options);
        });
    };
    /**
     * Retrieves the reference of the control in the form.
     * @param attr
     */
    /**
     * Retrieves the reference of the control in the form.
     * @param {?} attr
     * @return {?}
     */
    OFormComponent.prototype.getFieldReference = /**
     * Retrieves the reference of the control in the form.
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        return this._components[attr];
    };
    /**
     * Retrieves the reference of each control in the form
     * @param attrs
     */
    /**
     * Retrieves the reference of each control in the form
     * @param {?} attrs
     * @return {?}
     */
    OFormComponent.prototype.getFieldReferences = /**
     * Retrieves the reference of each control in the form
     * @param {?} attrs
     * @return {?}
     */
    function (attrs) {
        /** @type {?} */
        var arr = {};
        /** @type {?} */
        var self = this;
        attrs.forEach(function (key, index) {
            arr[key] = self.getFieldReference(key);
        });
        return arr;
    };
    /**
     * @param {?} attr
     * @return {?}
     */
    OFormComponent.prototype.getFormComponentPermissions = /**
     * @param {?} attr
     * @return {?}
     */
    function (attr) {
        /** @type {?} */
        var permissions;
        if (Util.isDefined(this.permissions)) {
            permissions = (this.permissions.components || []).find(function (comp) { return comp.attr === attr; });
        }
        return permissions;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getActionsPermissions = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var permissions;
        if (Util.isDefined(this.permissions)) {
            permissions = (this.permissions.actions || []);
        }
        return permissions;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.determinateFormMode = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var urlSegments = this.formNavigation.getUrlSegments();
        if (urlSegments.length > 0) {
            /** @type {?} */
            var segment = urlSegments[urlSegments.length - 1];
            this.determinateModeFromUrlSegment(segment);
        }
        else if (this.actRoute.parent) {
            this.actRoute.parent.url.subscribe(function (segments) {
                /** @type {?} */
                var segment = segments[segments.length - 1];
                _this.determinateModeFromUrlSegment(segment);
            });
        }
        else {
            this.setFormMode(OFormComponent.Mode().INITIAL);
        }
        // stayInRecordAfterEdit is true if form has editable detail = true
        this.stayInRecordAfterEdit = this.stayInRecordAfterEdit || this.isEditableDetail();
    };
    /**
     * @param {?} segment
     * @return {?}
     */
    OFormComponent.prototype.determinateModeFromUrlSegment = /**
     * @param {?} segment
     * @return {?}
     */
    function (segment) {
        /** @type {?} */
        var _path = segment ? segment['path'] : '';
        if (this.isInsertModePath(_path)) {
            this.setInsertMode();
            return;
        }
        else if (this.isUpdateModePath(_path)) {
            this.setUpdateMode();
        }
        else {
            this.setInitialMode();
        }
    };
    /**
     * @param {?} newFormData
     * @return {?}
     */
    OFormComponent.prototype._updateFormData = /**
     * @param {?} newFormData
     * @return {?}
     */
    function (newFormData) {
        var _this = this;
        /** @type {?} */
        var self = this;
        this.zone.run(function () {
            _this.formData = newFormData;
            /** @type {?} */
            var components = _this.getComponents();
            if (components) {
                Object.keys(components).forEach(function (key) {
                    /** @type {?} */
                    var comp = components[key];
                    if (Util.isFormDataComponent(comp)) {
                        try {
                            if (comp.isAutomaticBinding()) {
                                comp.data = self.getDataValue(key);
                            }
                        }
                        catch (error) {
                            console.error(error);
                        }
                    }
                });
                self.initializeFields();
            }
        });
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.initializeFields = /**
     * @return {?}
     */
    function () {
        var _this = this;
        Object.keys(this.formGroup.controls).forEach(function (control) {
            _this.formGroup.controls[control].markAsPristine();
        });
        this.formCache.registerCache();
        this.formNavigation.updateNavigation();
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.clearComponentsOldValue = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var components = this.getComponents();
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var componentsKeys = Object.keys(components).filter(function (key) { return self.ignoreFormCacheKeys.indexOf(key) === -1; });
        componentsKeys.forEach(function (compKey) {
            /** @type {?} */
            var comp = components[compKey];
            (/** @type {?} */ (comp)).oldValue = undefined;
            comp.getFormControl().setValue(undefined);
        });
    };
    /**
     * @param {?} result
     * @return {?}
     */
    OFormComponent.prototype.postCorrectInsert = /**
     * @param {?} result
     * @return {?}
     */
    function (result) {
        this.snackBarService.open('MESSAGES.INSERTED', { icon: 'check_circle' });
        this.onInsert.emit(result);
    };
    /**
     * @param {?} result
     * @return {?}
     */
    OFormComponent.prototype.postIncorrectInsert = /**
     * @param {?} result
     * @return {?}
     */
    function (result) {
        this.showError('insert', result);
    };
    /**
     * @param {?} result
     * @return {?}
     */
    OFormComponent.prototype.postIncorrectDelete = /**
     * @param {?} result
     * @return {?}
     */
    function (result) {
        this.showError('delete', result);
    };
    /**
     * @param {?} result
     * @return {?}
     */
    OFormComponent.prototype.postIncorrectUpdate = /**
     * @param {?} result
     * @return {?}
     */
    function (result) {
        this.showError('update', result);
    };
    /**
     * @param {?} result
     * @return {?}
     */
    OFormComponent.prototype.postCorrectUpdate = /**
     * @param {?} result
     * @return {?}
     */
    function (result) {
        this.snackBarService.open('MESSAGES.SAVED', { icon: 'check_circle' });
        this.onUpdate.emit(result);
    };
    /**
     * @param {?} result
     * @return {?}
     */
    OFormComponent.prototype.postCorrectDelete = /**
     * @param {?} result
     * @return {?}
     */
    function (result) {
        this.snackBarService.open('MESSAGES.DELETED', { icon: 'check_circle' });
        this.onDelete.emit(result);
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.markFormLayoutManagerToUpdate = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var formLayoutManager = this.getFormManager();
        if (Util.isDefined(formLayoutManager)) {
            formLayoutManager.markForUpdate = true;
        }
    };
    /**
     * @param {?=} data
     * @return {?}
     */
    OFormComponent.prototype.objectToFormValueData = /**
     * @param {?=} data
     * @return {?}
     */
    function (data) {
        if (data === void 0) { data = {}; }
        /** @type {?} */
        var valueData = {};
        Object.keys(data).forEach(function (item) {
            valueData[item] = new OFormValue(data[item]);
        });
        return valueData;
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.getCurrentKeysValues = /**
     * @return {?}
     */
    function () {
        return this.formNavigation.getCurrentKeysValues();
    };
    /**
     * @return {?}
     */
    OFormComponent.prototype.refreshComponentsEditableState = /**
     * @return {?}
     */
    function () {
        switch (this.mode) {
            case OFormComponent.Mode().INITIAL:
                this._setComponentsEditable(this.isEditableDetail());
                break;
            case OFormComponent.Mode().INSERT:
            case OFormComponent.Mode().UPDATE:
                this._setComponentsEditable(true);
            default:
                break;
        }
    };
    /**
     * @param {?} path
     * @return {?}
     */
    OFormComponent.prototype.isInsertModePath = /**
     * @param {?} path
     * @return {?}
     */
    function (path) {
        /** @type {?} */
        var navData = this.navigationService.getPreviousRouteData();
        return Util.isDefined(navData) && path === navData.getInsertFormRoute();
    };
    /**
     * @param {?} path
     * @return {?}
     */
    OFormComponent.prototype.isUpdateModePath = /**
     * @param {?} path
     * @return {?}
     */
    function (path) {
        /** @type {?} */
        var navData = this.navigationService.getPreviousRouteData();
        return Util.isDefined(navData) && path === navData.getEditFormRoute();
    };
    /**
     * @param {?} operation
     * @param {?} result
     * @return {?}
     */
    OFormComponent.prototype.showError = /**
     * @param {?} operation
     * @param {?} result
     * @return {?}
     */
    function (operation, result) {
        if (result && typeof result !== 'object') {
            this.dialogService.alert('ERROR', result);
        }
        else {
            /** @type {?} */
            var message = 'MESSAGES.ERROR_DELETE';
            switch (operation) {
                case 'update':
                    message = 'MESSAGES.ERROR_UPDATE';
                    break;
                case 'insert':
                    message = 'MESSAGES.ERROR_INSERT';
                    break;
            }
            this.dialogService.alert('ERROR', message);
        }
    };
    OFormComponent.DEFAULT_INPUTS_O_FORM = DEFAULT_INPUTS_O_FORM;
    OFormComponent.DEFAULT_OUTPUTS_O_FORM = DEFAULT_OUTPUTS_O_FORM;
    OFormComponent.BACK_ACTION = 'BACK';
    OFormComponent.CLOSE_DETAIL_ACTION = 'CLOSE';
    OFormComponent.RELOAD_ACTION = 'RELOAD';
    OFormComponent.GO_EDIT_ACTION = 'GO_EDIT';
    OFormComponent.EDIT_ACTION = 'EDIT';
    OFormComponent.INSERT_ACTION = 'INSERT';
    OFormComponent.GO_INSERT_ACTION = 'GO_INSERT';
    OFormComponent.DELETE_ACTION = 'DELETE';
    OFormComponent.UNDO_LAST_CHANGE_ACTION = 'UNDO_LAST_CHANGE';
    OFormComponent.DEFAULT_LAYOUT_DIRECTION = 'column';
    OFormComponent.guardClassName = 'CanDeactivateFormGuard';
    OFormComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-form',
                    providers: [
                        { provide: OntimizeService$$1, useFactory: 0$7, deps: [core.Injector] }
                    ],
                    template: "\n    <ng-template #customFormToolbarButtons>\n      <ng-content select=\"[o-form-toolbar-buttons]\"></ng-content>\n    </ng-template>\n\n    <o-form-toolbar *ngIf=\"showFloatingToolbar && headerPosition==='top'\" [label-header]=\"labelheader\"\n      [label-header-align]=\"labelHeaderAlign\" [header-actions]=\"headeractions\"\n      [show-header-navigation]=\"showHeaderNavigation\" [show-header-actions-text]=\"showHeaderActionsText\" layout-padding>\n      <div o-custom-form-toolbar-buttons-wrapper fxLayout=\"row\" fxLayoutAlign=\"end center\">\n        <ng-container *ngTemplateOutlet=\"customFormToolbarButtons\"></ng-container>\n      </div>\n    </o-form-toolbar>\n\n    <ng-host oKeyboardListener keyboardKeys=\"17;90\" (onKeysPressed)=\"undoKeyboardPressed()\" class=\"scrolling o-scroll\">\n      <div fxFlex=\"grow\">\n        <o-form-toolbar *ngIf=\"showNotFloatingToolbar && headerPosition==='top'\" [label-header]=\"labelheader\"\n          [label-header-align]=\"labelHeaderAlign\" [header-actions]=\"headeractions\"\n          [show-header-navigation]=\"showHeaderNavigation\" [show-header-actions-text]=\"showHeaderActionsText\" layout-padding>\n          <div o-custom-form-toolbar-buttons-wrapper fxLayout=\"row\" fxLayoutAlign=\"end center\">\n            <div o-custom-form-toolbar-buttons-wrapper fxLayout=\"row\" fxLayoutAlign=\"end center\">\n              <ng-container *ngTemplateOutlet=\"customFormToolbarButtons\"></ng-container>\n            </div>\n          </div>\n        </o-form-toolbar>\n\n        <form #innerForm [formGroup]=\"formGroup\" class=\"inner-form\" [class.form-no-toolbar]=\"!showHeader\" autocomplete=\"off\"\n          autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n          <div *ngIf=\"loading | async\" class=\"progress-bar-container\">\n            <mat-progress-bar mode=\"indeterminate\"></mat-progress-bar>\n          </div>\n          <div layout-padding [fxLayout]=\"layoutDirection\" [fxLayoutAlign]=\"layoutAlign\" class=\"o-form-content-wrapper\">\n            <ng-content></ng-content>\n          </div>\n        </form>\n\n        <o-form-toolbar *ngIf=\"showNotFloatingToolbar && headerPosition==='bottom'\" [label-header]=\"labelheader\"\n          [label-header-align]=\"labelHeaderAlign\" [header-actions]=\"headeractions\"\n          [show-header-navigation]=\"showHeaderNavigation\" [show-header-actions-text]=\"showHeaderActionsText\" layout-padding>\n          <div o-custom-form-toolbar-buttons-wrapper fxLayout=\"row\" fxLayoutAlign=\"end center\">\n            <ng-container *ngTemplateOutlet=\"customFormToolbarButtons\"></ng-container>\n          </div>\n        </o-form-toolbar>\n      </div>\n    </ng-host>\n\n    <o-form-toolbar *ngIf=\"showFloatingToolbar && headerPosition==='bottom'\" [label-header]=\"labelheader\"\n      [label-header-align]=\"labelHeaderAlign\" [header-actions]=\"headeractions\"\n      [show-header-navigation]=\"showHeaderNavigation\" [show-header-actions-text]=\"showHeaderActionsText\" layout-padding>\n      <div o-custom-form-toolbar-buttons-wrapper fxLayout=\"row\" fxLayoutAlign=\"end center\">\n        <ng-container *ngTemplateOutlet=\"customFormToolbarButtons\"></ng-container>\n      </div>\n    </o-form-toolbar>\n  ",
                    styles: ["\n    .o-form{display:flex;flex:auto;flex-direction:column;max-height:100%}.o-form .scrolling{display:flex;flex:auto;overflow-y:auto;flex-direction:column}.o-form form.inner-form{display:flex;flex:auto;flex-direction:column;max-height:100%}.o-form form.inner-form .progress-bar-container{padding:8px}.o-form form.form-no-toolbar{top:0}.o-form form .o-form-content-wrapper{height:100%;width:100%;box-sizing:border-box}\n  "],
                    inputs: DEFAULT_INPUTS_O_FORM,
                    outputs: DEFAULT_OUTPUTS_O_FORM,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-form]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OFormComponent.ctorParameters = function () { return [
        { type: router.Router },
        { type: router.ActivatedRoute },
        { type: core.NgZone },
        { type: core.ChangeDetectorRef },
        { type: core.Injector },
        { type: core.ElementRef }
    ]; };
    OFormComponent.propDecorators = {
        innerFormEl: [{ type: core.ViewChild, args: ['innerForm',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormComponent.prototype, "showHeader", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormComponent.prototype, "stayInRecordAfterInsert", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormComponent.prototype, "stayInRecordAfterEdit", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormComponent.prototype, "queryOnInit", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormComponent.prototype, "editableDetail", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormComponent.prototype, "undoButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormComponent.prototype, "showHeaderNavigation", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormComponent.prototype, "includeBreadcrumb", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormComponent.prototype, "detectChangesOnBlur", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormComponent.prototype, "confirmExit", void 0);
    return OFormComponent;
}());
var OFormModule = /** @class */ (function () {
    function OFormModule() {
    }
    OFormModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OFormComponent],
                    imports: [common.CommonModule, OFormToolbarModule, OSharedModule],
                    exports: [OFormComponent, OFormToolbarModule],
                    providers: [{ provide: CanDeactivateFormGuard, useClass: CanDeactivateFormGuard }],
                    schemas: [core.CUSTOM_ELEMENTS_SCHEMA]
                },] },
    ];
    return OFormModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_CONTAINER = [
    'oattr: attr',
    'title',
    'layoutAlign: layout-align',
    'elevation',
    'icon',
    'appearance',
    'layoutGap: layout-gap'
];
var OContainerComponent = /** @class */ (function () {
    function OContainerComponent(form, elRef, injector, matFormDefaultOption) {
        var _this = this;
        this.form = form;
        this.elRef = elRef;
        this.injector = injector;
        this.matFormDefaultOption = matFormDefaultOption;
        this._elevation = 0;
        this.defaultLayoutAlign = 'start start';
        this._outlineGapCalculationNeededImmediately = false;
        this.titleObserver = new MutationObserver(function () { return _this.updateOutlineGap(); });
    }
    Object.defineProperty(OContainerComponent.prototype, "containerTitle", {
        set: /**
         * @param {?} elem
         * @return {?}
         */
        function (elem) {
            this._titleEl = elem;
            if (this._titleEl) {
                this.registerObserver();
                this.updateOutlineGap(); // This must be triggered when title container is re-registered
            }
            else {
                this.unRegisterObserver();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OContainerComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.elRef) {
            this.elRef.nativeElement.removeAttribute('title');
        }
        this.registerObserver();
    };
    /**
     * @return {?}
     */
    OContainerComponent.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        if (this._outlineGapCalculationNeededImmediately) {
            this.updateOutlineGap();
        }
    };
    /**
     * @return {?}
     */
    OContainerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.unRegisterObserver();
    };
    /**
     * @return {?}
     */
    OContainerComponent.prototype.getAttribute = /**
     * @return {?}
     */
    function () {
        if (this.oattr) {
            return this.oattr;
        }
        else if (this.elRef && this.elRef.nativeElement.attributes['attr']) {
            return this.elRef.nativeElement.attributes['attr'].value;
        }
    };
    Object.defineProperty(OContainerComponent.prototype, "appearance", {
        get: /**
         * @return {?}
         */
        function () {
            return this._appearance;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            this._appearance = value;
            setTimeout(function () { _this.updateOutlineGap(); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OContainerComponent.prototype, "elevation", {
        get: /**
         * @return {?}
         */
        function () {
            return this._elevation;
        },
        set: /**
         * @param {?} elevation
         * @return {?}
         */
        function (elevation) {
            this._elevation = elevation;
            this.propagateElevationToDOM();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OContainerComponent.prototype, "layoutAlign", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layoutAlign;
        },
        set: /**
         * @param {?} align
         * @return {?}
         */
        function (align) {
            if (!align || align.length === 0) {
                align = this.defaultLayoutAlign;
            }
            this._layoutAlign = align;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OContainerComponent.prototype, "layoutGap", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layoutGap;
        },
        set: /**
         * @param {?} layoutGap
         * @return {?}
         */
        function (layoutGap) {
            this._layoutGap = layoutGap;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OContainerComponent.prototype.hasHeader = /**
     * @return {?}
     */
    function () {
        return !!this.title || !!this.icon;
    };
    /**
     * @return {?}
     */
    OContainerComponent.prototype.isAppearanceOutline = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isAppearanceOutline = (this.matFormDefaultOption && this.matFormDefaultOption.appearance === OContainerComponent.APPEARANCE_OUTLINE);
        if (Util.isDefined(this.appearance)) {
            isAppearanceOutline = this.appearance === OContainerComponent.APPEARANCE_OUTLINE;
        }
        return isAppearanceOutline;
    };
    /**
     * @return {?}
     */
    OContainerComponent.prototype.hasTitleInAppearanceOutline = /**
     * @return {?}
     */
    function () {
        return this.isAppearanceOutline() && this.hasHeader();
    };
    /**
     * @return {?}
     */
    OContainerComponent.prototype.propagateElevationToDOM = /**
     * @return {?}
     */
    function () {
        this.cleanElevationCSSclasses();
        if (this.elevation > 0 && this.elevation <= 12) {
            this.elRef.nativeElement.classList.add('mat-elevation-z' + this.elevation);
        }
    };
    /**
     * @return {?}
     */
    OContainerComponent.prototype.cleanElevationCSSclasses = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var classList = [].slice.call(this.elRef.nativeElement.classList);
        if (classList && classList.length) {
            classList.forEach(function (item) {
                if (item.startsWith('mat-elevation')) {
                    _this.elRef.nativeElement.classList.remove(item);
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OContainerComponent.prototype.updateOutlineGap = /**
     * @return {?}
     */
    function () {
        if (this.isAppearanceOutline()) {
            /** @type {?} */
            var titleEl = this._titleEl ? this._titleEl.nativeElement : null;
            if (!this._containerRef) {
                return;
            }
            if (!/** @type {?} */ ((document.documentElement)).contains(this.elRef.nativeElement)) {
                this._outlineGapCalculationNeededImmediately = true;
                return;
            }
            /** @type {?} */
            var container = this._containerRef.nativeElement;
            /** @type {?} */
            var containerRect = container.getBoundingClientRect();
            if (containerRect.width === 0 && containerRect.height === 0) {
                return;
            }
            /** @type {?} */
            var containerStart = containerRect.left;
            /** @type {?} */
            var labelStart = titleEl.getBoundingClientRect().left;
            /** @type {?} */
            var labelWidth = this.hasHeader() ? titleEl.offsetWidth : 0;
            /** @type {?} */
            var startWidth = labelStart - containerStart;
            /** @type {?} */
            var startEls = container.querySelectorAll('.o-container-outline-start');
            /** @type {?} */
            var gapEls = container.querySelectorAll('.o-container-outline-gap');
            gapEls[0].style.width = labelWidth + "px";
            startEls[0].style.width = startWidth + "px";
            this._outlineGapCalculationNeededImmediately = false;
        }
    };
    /**
     * @return {?}
     */
    OContainerComponent.prototype.registerObserver = /**
     * @return {?}
     */
    function () {
        if (this._titleEl) {
            this.titleObserver.observe(this._titleEl.nativeElement, {
                childList: true,
                characterData: true,
                subtree: true
            });
        }
    };
    /**
     * @return {?}
     */
    OContainerComponent.prototype.unRegisterObserver = /**
     * @return {?}
     */
    function () {
        if (this.titleObserver) {
            this.titleObserver.disconnect();
        }
    };
    OContainerComponent.APPEARANCE_OUTLINE = 'outline';
    OContainerComponent.DEFAULT_INPUTS_O_CONTAINER = DEFAULT_INPUTS_O_CONTAINER;
    /** @nocollapse */
    OContainerComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [material.MAT_FORM_FIELD_DEFAULT_OPTIONS,] }] }
    ]; };
    OContainerComponent.propDecorators = {
        containerTitle: [{ type: core.ViewChild, args: ['containerTitle',] }],
        _containerRef: [{ type: core.ViewChild, args: ['container',] }]
    };
    return OContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_COLUMN = DEFAULT_INPUTS_O_CONTAINER.slice();
var OColumnComponent = /** @class */ (function (_super) {
    __extends(OColumnComponent, _super);
    function OColumnComponent(form, elRef, injector, matFormDefaultOption) {
        var _this = _super.call(this, form, elRef, injector, matFormDefaultOption) || this;
        _this.form = form;
        _this.elRef = elRef;
        _this.injector = injector;
        _this.matFormDefaultOption = matFormDefaultOption;
        return _this;
    }
    OColumnComponent.DEFAULT_INPUTS_O_COLUMN = DEFAULT_INPUTS_O_COLUMN;
    OColumnComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-column',
                    template: "\n    <div #container fxLayout=\"column\" class=\"o-container\" fxFill>\n      <div #containerTitle *ngIf=\"hasHeader()\" fxLayoutAlign=\"start center\" class=\"o-container-title\" layout-padding>\n        <mat-icon *ngIf=\"icon\">{{ icon }}</mat-icon>\n        <span *ngIf=\"title\">{{ title | oTranslate }}</span>\n      </div>\n      <div [class.o-container-gap]=\"hasHeader() || (elevation > 0 && elevation <= 12)\" class=\"o-container-scroll o-scroll\">\n        <div class=\"o-container-outline\" *ngIf=\"isAppearanceOutline() && hasHeader()\">\n          <div class=\"o-container-outline-start\"></div>\n          <div class=\"o-container-outline-gap\"></div>\n          <div class=\"o-container-outline-end\"></div>\n        </div>\n        <div fxLayout=\"column\" fxLayoutAlign=\"{{ layoutAlign }}\" fxLayoutGap=\"{{ layoutGap }}\" fxFlex=\"grow\">\n          <ng-content></ng-content>\n        </div>\n    </div>\n  ",
                    styles: ["\n    .o-column .o-container{flex:1;display:flex;flex-direction:column}.o-column .o-container .o-container-scroll{overflow:auto;position:relative}\n  "],
                    inputs: DEFAULT_INPUTS_O_COLUMN,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-column]': 'true',
                        '[class.o-appearance-outline]': 'isAppearanceOutline()',
                        '[class.o-appearance-outline-title]': 'hasTitleInAppearanceOutline()'
                    }
                },] },
    ];
    /** @nocollapse */
    OColumnComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [material.MAT_FORM_FIELD_DEFAULT_OPTIONS,] }] }
    ]; };
    return OColumnComponent;
}(OContainerComponent));
var OColumnModule = /** @class */ (function () {
    function OColumnModule() {
    }
    OColumnModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OColumnComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OColumnComponent]
                },] },
    ];
    return OColumnModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_ROW = DEFAULT_INPUTS_O_CONTAINER.slice();
var ORowComponent = /** @class */ (function (_super) {
    __extends(ORowComponent, _super);
    function ORowComponent(form, elRef, injector, matFormDefaultOption) {
        var _this = _super.call(this, form, elRef, injector, matFormDefaultOption) || this;
        _this.form = form;
        _this.elRef = elRef;
        _this.injector = injector;
        _this.matFormDefaultOption = matFormDefaultOption;
        return _this;
    }
    ORowComponent.DEFAULT_INPUTS_O_ROW = DEFAULT_INPUTS_O_ROW;
    ORowComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-row',
                    template: "\n    <div #container fxLayout=\"column\" class=\"o-container\" fxFill>\n      <div #containerTitle *ngIf=\"hasHeader()\" fxLayoutAlign=\"start center\" class=\"o-container-title\" layout-padding>\n        <mat-icon *ngIf=\"icon\">{{ icon }}</mat-icon>\n        <span *ngIf=\"title\">{{ title | oTranslate }}</span>\n      </div>\n      <div [class.o-container-gap]=\"hasHeader() || (elevation > 0 && elevation <= 12)\" class=\"o-container-scroll o-scroll\">\n        <div class=\"o-container-outline\" *ngIf=\"isAppearanceOutline() && hasHeader()\">\n          <div class=\"o-container-outline-start\"></div>\n          <div class=\"o-container-outline-gap\"></div>\n          <div class=\"o-container-outline-end\"></div>\n        </div>\n        <div fxLayout=\"row\" fxLayoutAlign=\"{{ layoutAlign }}\" fxLayoutGap=\"{{ layoutGap }}\" fxFlex=\"grow\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  ",
                    styles: ["\n    .o-row>.o-container{width:100%}.o-row>.o-container .o-container-scroll{overflow:auto;position:relative}\n  "],
                    inputs: DEFAULT_INPUTS_O_ROW,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-row]': 'true',
                        '[class.o-appearance-outline]': 'isAppearanceOutline()',
                        '[class.o-appearance-outline-title]': 'hasTitleInAppearanceOutline()'
                    }
                },] },
    ];
    /** @nocollapse */
    ORowComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [material.MAT_FORM_FIELD_DEFAULT_OPTIONS,] }] }
    ]; };
    return ORowComponent;
}(OContainerComponent));
var ORowModule = /** @class */ (function () {
    function ORowModule() {
    }
    ORowModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [ORowComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [ORowComponent]
                },] },
    ];
    return ORowModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_CONTAINER_COLLAPSIBLE = OContainerComponent.DEFAULT_INPUTS_O_CONTAINER.concat([
    'expanded',
    'description',
    'collapsedHeight:collapsed-height',
    'expandedHeight:expanded-height'
]);
var OContainerCollapsibleComponent = /** @class */ (function (_super) {
    __extends(OContainerCollapsibleComponent, _super);
    function OContainerCollapsibleComponent(form, elRef, injector, matFormDefaultOption) {
        var _this = _super.call(this, form, elRef, injector, matFormDefaultOption) || this;
        _this.form = form;
        _this.elRef = elRef;
        _this.injector = injector;
        _this.matFormDefaultOption = matFormDefaultOption;
        _this.expanded = true;
        _this.collapsedHeight = '37px';
        _this.expandedHeight = '37px';
        _this.contentObserver = new MutationObserver(function () { return _this.updateHeightExpansionPanelContent(); });
        return _this;
    }
    /**
     * @return {?}
     */
    OContainerCollapsibleComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.expPanel) {
            this._containerCollapsibleRef = this.expPanel._body;
            this.registerContentObserver();
        }
        else {
            this.unregisterContentObserver();
        }
    };
    /**
     * @return {?}
     */
    OContainerCollapsibleComponent.prototype.updateOutlineGap = /**
     * @return {?}
     */
    function () {
        if (this.isAppearanceOutline()) {
            /** @type {?} */
            var exPanelHeader = this._titleEl ? (/** @type {?} */ (this._titleEl))._element.nativeElement : null;
            if (!this._containerRef) {
                return;
            }
            /** @type {?} */
            var containerOutline = this._containerRef.nativeElement;
            /** @type {?} */
            var containerOutlineRect = containerOutline.getBoundingClientRect();
            if (containerOutlineRect.width === 0 && containerOutlineRect.height === 0) {
                return;
            }
            /** @type {?} */
            var titleEl = exPanelHeader.querySelector('.o-container-title.mat-expansion-panel-header-title');
            /** @type {?} */
            var descrEl = exPanelHeader.querySelector('.mat-expansion-panel-header-description');
            /** @type {?} */
            var containerStart = containerOutlineRect.left;
            /** @type {?} */
            var descrStart = descrEl.getBoundingClientRect().left;
            /** @type {?} */
            var titleWidth = 0;
            if (this.hasHeader()) {
                titleWidth += this.icon ? titleEl.querySelector('mat-icon').offsetWidth : 0; // icon
                titleWidth += this.title ? titleEl.querySelector('span').offsetWidth : 0; // title
                titleWidth = titleWidth === 0 ? 0 : titleWidth + 4;
            }
            /** @type {?} */
            var descrWidth = this.description ? descrEl.querySelector('span').offsetWidth + 8 : 0;
            /** @type {?} */
            var empty1Width = descrStart - containerStart - 14 - titleWidth - 4;
            /** @type {?} */
            var gapTitleEls = containerOutline.querySelectorAll('.o-container-outline-gap-title');
            /** @type {?} */
            var gapEmpty1Els = containerOutline.querySelectorAll('.o-container-outline-gap-empty1');
            /** @type {?} */
            var gapDescrEls = containerOutline.querySelectorAll('.o-container-outline-gap-description');
            gapTitleEls[0].style.width = titleWidth + "px";
            gapEmpty1Els[0].style.width = empty1Width + "px";
            gapDescrEls[0].style.width = descrWidth + "px";
        }
    };
    /**
     * @return {?}
     */
    OContainerCollapsibleComponent.prototype.registerObserver = /**
     * @return {?}
     */
    function () {
        if (this._titleEl) {
            this.titleObserver.observe((/** @type {?} */ (this._titleEl))._element.nativeElement, {
                childList: true,
                characterData: true,
                subtree: true
            });
        }
    };
    /**
     * @return {?}
     */
    OContainerCollapsibleComponent.prototype.updateHeightExpansionPanelContent = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var exPanelHeader = this._titleEl ? (/** @type {?} */ (this._titleEl))._element.nativeElement : null;
        /** @type {?} */
        var exPanelContent = this._containerCollapsibleRef ? this._containerCollapsibleRef.nativeElement.querySelector('.o-container-scroll') : null;
        /** @type {?} */
        var parentHeight = exPanelHeader.parentNode ? exPanelHeader.parentNode.offsetHeight : null;
        /** @type {?} */
        var height = (OContainerComponent.APPEARANCE_OUTLINE === this.appearance) ? parentHeight : (parentHeight - exPanelHeader.offsetHeight);
        if (height > 0) {
            exPanelContent.style.height = height + 'px';
        }
    };
    /**
     * @return {?}
     */
    OContainerCollapsibleComponent.prototype.unregisterContentObserver = /**
     * @return {?}
     */
    function () {
        if (this.contentObserver) {
            this.contentObserver.disconnect();
        }
    };
    /**
     * @return {?}
     */
    OContainerCollapsibleComponent.prototype.registerContentObserver = /**
     * @return {?}
     */
    function () {
        if (this._containerCollapsibleRef) {
            this.contentObserver.observe(this._containerCollapsibleRef.nativeElement, {
                childList: true,
                attributes: true,
                attributeFilter: ['style']
            });
        }
    };
    OContainerCollapsibleComponent.DEFAULT_INPUTS_O_CONTAINER_COLLAPSIBLE = DEFAULT_INPUTS_O_CONTAINER_COLLAPSIBLE;
    /** @nocollapse */
    OContainerCollapsibleComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [material.MAT_FORM_FIELD_DEFAULT_OPTIONS,] }] }
    ]; };
    OContainerCollapsibleComponent.propDecorators = {
        expPanel: [{ type: core.ViewChild, args: ['expPanel',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OContainerCollapsibleComponent.prototype, "expanded", void 0);
    return OContainerCollapsibleComponent;
}(OContainerComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_COLUMN_COLLAPSIBLE = OContainerCollapsibleComponent.DEFAULT_INPUTS_O_CONTAINER_COLLAPSIBLE.slice();
var OColumnCollapsibleComponent = /** @class */ (function (_super) {
    __extends(OColumnCollapsibleComponent, _super);
    function OColumnCollapsibleComponent(form, elRef, injector, matFormDefaultOption) {
        var _this = _super.call(this, form, elRef, injector, matFormDefaultOption) || this;
        _this.form = form;
        _this.elRef = elRef;
        _this.injector = injector;
        _this.matFormDefaultOption = matFormDefaultOption;
        return _this;
    }
    OColumnCollapsibleComponent.DEFAULT_INPUTS_O_COLUMN_COLLAPSIBLE = DEFAULT_INPUTS_O_COLUMN_COLLAPSIBLE;
    OColumnCollapsibleComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-column-collapsible',
                    template: "\n    <mat-expansion-panel #expPanel [expanded]=\"expanded\" class=\"o-container\">\n      <mat-expansion-panel-header #containerTitle [expandedHeight]=\"expandedHeight\" [collapsedHeight]=\"collapsedHeight\">\n        <mat-panel-title fxLayout=\"row\" fxLayoutAlign=\"start center\" class=\"o-container-title\">\n          <mat-icon *ngIf=\"icon\">{{ icon }}</mat-icon>\n          <span *ngIf=\"title\">{{ title | oTranslate }}</span>\n        </mat-panel-title>\n        <mat-panel-description fxLayout=\"row\" fxLayoutAlign=\"start center\">\n          <span>{{ description | oTranslate }}</span>\n        </mat-panel-description>\n      </mat-expansion-panel-header>\n      <div #containerContent id=\"innerCol\" fxLayout=\"column\" fxLayoutAlign=\"{{ layoutAlign }}\" fxLayoutGap=\"{{ layoutGap }}\"\n        class=\"o-container-scroll o-scroll\" fxFlex=\"grow\">\n        <ng-content></ng-content>\n      </div>\n    </mat-expansion-panel>\n    <div #container [class.o-container-outline-expanded]=\"expPanel.expanded\" class=\"o-container-outline\"\n      *ngIf=\"isAppearanceOutline()\">\n      <div class=\"o-container-outline-start\"></div>\n      <div class=\"o-container-outline-gap-title\"></div>\n      <div class=\"o-container-outline-gap-empty1\"></div>\n      <div class=\"o-container-outline-gap-description\"></div>\n      <div class=\"o-container-outline-gap-empty2\"></div>\n      <div class=\"o-container-outline-gap-icon\"></div>\n      <div class=\"o-container-outline-end\"></div>\n    </div>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_COLUMN_COLLAPSIBLE,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-column-collapsible]': 'true',
                        '[class.o-appearance-outline]': 'isAppearanceOutline()',
                        '[class.o-appearance-outline-title]': 'hasTitleInAppearanceOutline()'
                    }
                },] },
    ];
    /** @nocollapse */
    OColumnCollapsibleComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [material.MAT_FORM_FIELD_DEFAULT_OPTIONS,] }] }
    ]; };
    return OColumnCollapsibleComponent;
}(OContainerCollapsibleComponent));
var OColumnCollapsibleModule = /** @class */ (function () {
    function OColumnCollapsibleModule() {
    }
    OColumnCollapsibleModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OColumnCollapsibleComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OColumnCollapsibleComponent]
                },] },
    ];
    return OColumnCollapsibleModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_ROW_COLLAPSIBLE = OContainerCollapsibleComponent.DEFAULT_INPUTS_O_CONTAINER_COLLAPSIBLE.slice();
var ORowCollapsibleComponent = /** @class */ (function (_super) {
    __extends(ORowCollapsibleComponent, _super);
    function ORowCollapsibleComponent(form, elRef, injector, matFormDefaultOption) {
        var _this = _super.call(this, form, elRef, injector, matFormDefaultOption) || this;
        _this.form = form;
        _this.elRef = elRef;
        _this.injector = injector;
        _this.matFormDefaultOption = matFormDefaultOption;
        return _this;
    }
    ORowCollapsibleComponent.DEFAULT_INPUTS_O_ROW_COLLAPSIBLE = DEFAULT_INPUTS_O_ROW_COLLAPSIBLE;
    ORowCollapsibleComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-row-collapsible',
                    template: "\n    <mat-expansion-panel #expPanel [expanded]=\"expanded\" class=\"o-container\">\n      <mat-expansion-panel-header #containerTitle [expandedHeight]=\"expandedHeight\" [collapsedHeight]=\"collapsedHeight\">\n        <mat-panel-title fxLayout=\"row\" fxLayoutAlign=\"start center\" class=\"o-container-title\">\n          <mat-icon *ngIf=\"icon\">{{ icon }}</mat-icon>\n          <span *ngIf=\"title\">{{ title | oTranslate }}</span>\n        </mat-panel-title>\n        <mat-panel-description fxLayout=\"row\" fxLayoutAlign=\"start center\">\n          <span>{{ description | oTranslate }}</span>\n        </mat-panel-description>\n      </mat-expansion-panel-header>\n      <div #containerContent id=\"innerRow\" fxLayout=\"row\" fxLayoutAlign=\"{{ layoutAlign }}\" fxLayoutGap=\"{{ layoutGap }}\"\n        class=\"o-container-scroll o-scroll\" fxFlex=\"grow\">\n        <ng-content></ng-content>\n      </div>\n    </mat-expansion-panel>\n    <div #container [class.o-container-outline-expanded]=\"expPanel.expanded\" class=\"o-container-outline\"\n      *ngIf=\"isAppearanceOutline()\">\n      <div class=\"o-container-outline-start\"></div>\n      <div class=\"o-container-outline-gap-title\"></div>\n      <div class=\"o-container-outline-gap-empty1\"></div>\n      <div class=\"o-container-outline-gap-description\"></div>\n      <div class=\"o-container-outline-gap-empty2\"></div>\n      <div class=\"o-container-outline-gap-icon\"></div>\n      <div class=\"o-container-outline-end\"></div>\n    </div>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_ROW_COLLAPSIBLE,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-row-collapsible]': 'true',
                        '[class.o-appearance-outline]': 'isAppearanceOutline()',
                        '[class.o-appearance-outline-title]': 'hasTitleInAppearanceOutline()'
                    }
                },] },
    ];
    /** @nocollapse */
    ORowCollapsibleComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [material.MAT_FORM_FIELD_DEFAULT_OPTIONS,] }] }
    ]; };
    return ORowCollapsibleComponent;
}(OContainerCollapsibleComponent));
var ORowCollapsibleModule = /** @class */ (function () {
    function ORowCollapsibleModule() {
    }
    ORowCollapsibleModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [ORowCollapsibleComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [ORowCollapsibleComponent]
                },] },
    ];
    return ORowCollapsibleModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ODialogConfig = /** @class */ (function () {
    function ODialogConfig() {
    }
    return ODialogConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ODialogComponent = /** @class */ (function () {
    function ODialogComponent(dialogRef) {
        this.dialogRef = dialogRef;
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    ODialogComponent.prototype.onOkClick = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        if (this.dialogRef) {
            this.dialogRef.close(true);
        }
    };
    /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    ODialogComponent.prototype.alert = /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    function (title, message, config$$1) {
        config$$1 = this.ensureConfig(config$$1);
        this.configureDefaultAlert(title, message, config$$1);
    };
    /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    ODialogComponent.prototype.info = /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    function (title, message, config$$1) {
        config$$1 = this.ensureConfig(config$$1);
        config$$1.alertType = 'info';
        if (typeof (config$$1.icon) === 'undefined') {
            config$$1.icon = 'info';
        }
        this.configureDefaultAlert(title, message, config$$1);
    };
    /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    ODialogComponent.prototype.warn = /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    function (title, message, config$$1) {
        config$$1 = this.ensureConfig(config$$1);
        config$$1.alertType = 'warn';
        if (typeof (config$$1.icon) === 'undefined') {
            config$$1.icon = 'warning';
        }
        this.configureDefaultAlert(title, message, config$$1);
    };
    /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    ODialogComponent.prototype.error = /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    function (title, message, config$$1) {
        config$$1 = this.ensureConfig(config$$1);
        config$$1.alertType = 'error';
        if (typeof (config$$1.icon) === 'undefined') {
            config$$1.icon = 'error';
        }
        this.configureDefaultAlert(title, message, config$$1);
    };
    /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    ODialogComponent.prototype.confirm = /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    function (title, message, config$$1) {
        config$$1 = this.ensureConfig(config$$1);
        this.configureDefaultAlert(title, message, config$$1);
        this.twoOptions = true;
    };
    /* Utility methods */
    /**
     * @param {?} config
     * @return {?}
     */
    ODialogComponent.prototype.ensureConfig = /**
     * @param {?} config
     * @return {?}
     */
    function (config$$1) {
        if (!config$$1) {
            config$$1 = {};
        }
        return config$$1;
    };
    /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    ODialogComponent.prototype.configureDefaultAlert = /**
     * @param {?} title
     * @param {?} message
     * @param {?=} config
     * @return {?}
     */
    function (title, message, config$$1) {
        this.twoOptions = false;
        this.title = title;
        this.message = message;
        this.icon = (typeof (config$$1.icon) !== 'undefined') ? config$$1.icon : undefined;
        if (this.icon !== undefined) {
            this.useIcon = true;
        }
        this.alertType = config$$1.alertType;
        this.okButtonText = (typeof (config$$1.okButtonText) !== 'undefined') ? config$$1.okButtonText : ODialogComponent.DEFAULT_OK_BUTTON_TEXT;
        this.cancelButtonText = (typeof (config$$1.cancelButtonText) !== 'undefined') ? config$$1.cancelButtonText : ODialogComponent.DEFAULT_CANCEL_BUTTON_TEXT;
    };
    Object.defineProperty(ODialogComponent.prototype, "isInfo", {
        get: /**
         * @return {?}
         */
        function () {
            return this.alertType === 'info';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODialogComponent.prototype, "isWarn", {
        get: /**
         * @return {?}
         */
        function () {
            return this.alertType === 'warn';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODialogComponent.prototype, "isError", {
        get: /**
         * @return {?}
         */
        function () {
            return this.alertType === 'error';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODialogComponent.prototype, "title", {
        get: /**
         * @return {?}
         */
        function () {
            return this._title;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._title = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODialogComponent.prototype, "message", {
        get: /**
         * @return {?}
         */
        function () {
            return this._message;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._message = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODialogComponent.prototype, "okButtonText", {
        get: /**
         * @return {?}
         */
        function () {
            return this._okButtonText;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._okButtonText = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODialogComponent.prototype, "cancelButtonText", {
        get: /**
         * @return {?}
         */
        function () {
            return this._cancelButtonText;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._cancelButtonText = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODialogComponent.prototype, "icon", {
        get: /**
         * @return {?}
         */
        function () {
            return this._icon;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._icon = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODialogComponent.prototype, "alertType", {
        get: /**
         * @return {?}
         */
        function () {
            return this._alertType;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._alertType = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODialogComponent.prototype, "twoOptions", {
        get: /**
         * @return {?}
         */
        function () {
            return this._twoOptions;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._twoOptions = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODialogComponent.prototype, "useIcon", {
        get: /**
         * @return {?}
         */
        function () {
            return this._useIcon;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._useIcon = val;
        },
        enumerable: true,
        configurable: true
    });
    ODialogComponent.DEFAULT_OK_BUTTON_TEXT = 'OK';
    ODialogComponent.DEFAULT_CANCEL_BUTTON_TEXT = 'CANCEL';
    ODialogComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-dialog',
                    template: "\n    <div *ngIf=\"title && title.length > 0\" mat-dialog-title>{{ title | oTranslate }}</div>\n    <div mat-dialog-content>\n      <div fxLayout=\"row\" class=\"alert-content\" [class.alert-content-icon]=\"useIcon\" fxLayoutAlign=\"space-between center\">\n        <mat-icon *ngIf=\"useIcon\" class=\"alert-icon\" [class.info]=\"isInfo\" [class.warn]=\"isWarn\" [class.error]=\"isError\">\n          {{ icon }}\n        </mat-icon>\n        <span [innerHTML]=\"message | oTranslate\"></span>\n      </div>\n    </div>\n    <mat-dialog-actions align=\"end\">\n      <span fxFlex></span>\n      <button type=\"button\" *ngIf=\"twoOptions\" mat-stroked-button class=\"mat-primary\"\n        mat-dialog-close>{{ cancelButtonText | oTranslate | uppercase }}</button>\n      <button type=\"button\" mat-stroked-button class=\"mat-primary\"\n        (click)=\"onOkClick($event)\">{{ okButtonText | oTranslate | uppercase }}</button>\n    </mat-dialog-actions>\n  ",
                    styles: ["\n    .o-dialog{cursor:default}.o-dialog .alert-content{box-sizing:border-box;flex:1 1 100%;display:flex;flex-direction:row;place-content:center space-between;align-items:center;padding:12px 0}.o-dialog .alert-content-icon{min-height:70px}.o-dialog .alert-icon{font-size:50px;margin-right:16px;min-height:50px;min-width:50px}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-dialog]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    ODialogComponent.ctorParameters = function () { return [
        { type: material.MatDialogRef }
    ]; };
    return ODialogComponent;
}());
var ODialogModule = /** @class */ (function () {
    function ODialogModule() {
    }
    ODialogModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [ODialogComponent],
                    imports: [common.CommonModule, OSharedModule, OTranslateModule],
                    exports: [ODialogComponent, common.CommonModule]
                },] },
    ];
    return ODialogModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OFilterBuilderClearDirective$$1 = /** @class */ (function () {
    function OFilterBuilderClearDirective$$1(filterBuilder) {
        if (Util.isDefined(filterBuilder)) {
            this._filterBuilder = filterBuilder;
        }
    }
    /**
     * @param {?=} e
     * @return {?}
     */
    OFilterBuilderClearDirective$$1.prototype.onClick = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (this._filterBuilder) {
            this._filterBuilder.clearFilter();
        }
    };
    OFilterBuilderClearDirective$$1.decorators = [
        { type: core.Directive, args: [{
                    selector: '[oFilterBuilderClear]',
                    inputs: [
                        '_filterBuilder: oFilterBuilderClear'
                    ],
                    host: {
                        '(click)': 'onClick($event)'
                    },
                    exportAs: 'oFilterBuilderClear'
                },] },
    ];
    /** @nocollapse */
    OFilterBuilderClearDirective$$1.ctorParameters = function () { return [
        { type: OFilterBuilderComponent$$1, decorators: [{ type: core.Optional }] }
    ]; };
    return OFilterBuilderClearDirective$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OFilterBuilderQueryDirective$$1 = /** @class */ (function () {
    function OFilterBuilderQueryDirective$$1(filterBuilder) {
        if (Util.isDefined(filterBuilder)) {
            this._filterBuilder = filterBuilder;
        }
    }
    /**
     * @param {?=} e
     * @return {?}
     */
    OFilterBuilderQueryDirective$$1.prototype.onClick = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (this._filterBuilder) {
            this._filterBuilder.triggerReload();
        }
    };
    OFilterBuilderQueryDirective$$1.decorators = [
        { type: core.Directive, args: [{
                    selector: '[oFilterBuilderQuery]',
                    inputs: [
                        '_filterBuilder: oFilterBuilderQuery'
                    ],
                    host: {
                        '(click)': 'onClick($event)'
                    },
                    exportAs: 'oFilterBuilderQuery'
                },] },
    ];
    /** @nocollapse */
    OFilterBuilderQueryDirective$$1.ctorParameters = function () { return [
        { type: OFilterBuilderComponent$$1, decorators: [{ type: core.Optional }] }
    ]; };
    return OFilterBuilderQueryDirective$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_FILTER_BUILDER$$1 = [
    'filters',
    'targetCmp: target',
    'expressionBuilder: expression-builder',
    'queryOnChange: query-on-change',
    'queryOnChangeDelay: query-on-change-delay'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_FILTER_BUILDER$$1 = [
    'onFilter',
    'onClear'
];
var OFilterBuilderComponent$$1 = /** @class */ (function () {
    function OFilterBuilderComponent$$1(form, injector) {
        this.form = form;
        this.onFilter = new core.EventEmitter();
        this.onClear = new core.EventEmitter();
        this.queryOnChange = false;
        this.queryOnChangeDelay = 0;
        this.filterComponents = [];
        this.subscriptions = new Subscription();
    }
    /**
     * @return {?}
     */
    OFilterBuilderComponent$$1.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.initialize();
    };
    /**
     * @return {?}
     */
    OFilterBuilderComponent$$1.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.initializeListeners();
    };
    /**
     * @return {?}
     */
    OFilterBuilderComponent$$1.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OFilterBuilderComponent$$1.prototype.initialize = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Parse filters
        if (this.filters) {
            /** @type {?} */
            var filterArray = Util.parseArray(this.filters);
            filterArray.forEach(function (filter$$1) {
                /** @type {?} */
                var filterElms = filter$$1.split(Codes.COLUMNS_ALIAS_SEPARATOR);
                _this.filterComponents.push({
                    targetAttr: filterElms[0],
                    formComponentAttr: filterElms[1] ? filterElms[1] : filterElms[0]
                });
            });
        }
        if (Util.isDefined(this.targetCmp)) {
            this.targetCmp.setFilterBuilder(this);
        }
    };
    /**
     * @return {?}
     */
    OFilterBuilderComponent$$1.prototype.initializeListeners = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.queryOnChange) {
            this.filterComponents.forEach(function (filterComponent) {
                /** @type {?} */
                var formComponent = _this.form.getComponents()[filterComponent.formComponentAttr];
                if (formComponent) {
                    _this.subscriptions.add(formComponent.getFormControl().valueChanges
                        .pipe(debounceTime(_this.queryOnChangeDelay))
                        .subscribe(function (a) { return _this.triggerReload(); }));
                }
            });
        }
    };
    /**
     * Returns an `IExpression` object with the filter.
     * @returns the `IExpression` object with the filter.
     */
    /**
     * Returns an `IExpression` object with the filter.
     * @return {?} the `IExpression` object with the filter.
     */
    OFilterBuilderComponent$$1.prototype.getExpression = /**
     * Returns an `IExpression` object with the filter.
     * @return {?} the `IExpression` object with the filter.
     */
    function () {
        /** @type {?} */
        var formComponents = this.form.getComponents();
        /** @type {?} */
        var params = [];
        this.filterComponents.forEach(function (filterComponent) {
            /** @type {?} */
            var formComponent = formComponents[filterComponent.formComponentAttr];
            /** @type {?} */
            var value = formComponent.getValue();
            params.push({
                attr: filterComponent.targetAttr,
                value: value
            });
        });
        // Trigger the function provided by the user
        if (this.expressionBuilder) {
            return this.expressionBuilder(params);
        }
        /** @type {?} */
        var expressions = [];
        params.forEach(function (elem) {
            if (Util.isDefined(elem.value)) {
                expressions.push(FilterExpressionUtils.buildExpressionEquals(elem.attr, elem.value));
            }
        });
        return expressions.length ? expressions.reduce(function (fe1, fe2) { return FilterExpressionUtils.buildComplexExpression(fe1, fe2, FilterExpressionUtils.OP_OR); }) : undefined;
    };
    /**
     * Returns an `IBasicExpression` object with the filter.
     * @returns the `IBasicExpression` object with the filter.
     */
    /**
     * Returns an `IBasicExpression` object with the filter.
     * @return {?} the `IBasicExpression` object with the filter.
     */
    OFilterBuilderComponent$$1.prototype.getBasicExpression = /**
     * Returns an `IBasicExpression` object with the filter.
     * @return {?} the `IBasicExpression` object with the filter.
     */
    function () {
        return FilterExpressionUtils.buildBasicExpression(this.getExpression());
    };
    /**
     * Returns the filter builder target component.
     * @returns the target component.
     */
    /**
     * Returns the filter builder target component.
     * @return {?} the target component.
     */
    OFilterBuilderComponent$$1.prototype.getTargetComponent = /**
     * Returns the filter builder target component.
     * @return {?} the target component.
     */
    function () {
        return this.targetCmp;
    };
    /**
     * Trigger the `reloadData` method from the target component.
     */
    /**
     * Trigger the `reloadData` method from the target component.
     * @return {?}
     */
    OFilterBuilderComponent$$1.prototype.triggerReload = /**
     * Trigger the `reloadData` method from the target component.
     * @return {?}
     */
    function () {
        if (!this.targetCmp) {
            return;
        }
        if (this.targetCmp.pageable) {
            this.targetCmp.reloadPaginatedDataFromStart();
        }
        else {
            this.targetCmp.reloadData();
        }
        this.onFilter.emit();
    };
    /**
     * Clear the form components used for the filter.
     */
    /**
     * Clear the form components used for the filter.
     * @return {?}
     */
    OFilterBuilderComponent$$1.prototype.clearFilter = /**
     * Clear the form components used for the filter.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var formComponents = this.form.getComponents();
        this.getFilterAttrs().forEach(function (attr) {
            formComponents[attr].setValue(void 0);
        });
        this.onClear.emit();
    };
    /**
     * Returns an array with the attributes of the filterable components
     */
    /**
     * Returns an array with the attributes of the filterable components
     * @return {?}
     */
    OFilterBuilderComponent$$1.prototype.getFilterAttrs = /**
     * Returns an array with the attributes of the filterable components
     * @return {?}
     */
    function () {
        return this.filterComponents.map(function (elem) { return elem.formComponentAttr; });
    };
    OFilterBuilderComponent$$1.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-filter-builder',
                    template: "\n\n  ",
                    inputs: DEFAULT_INPUTS_O_FILTER_BUILDER$$1,
                    outputs: DEFAULT_OUTPUTS_O_FILTER_BUILDER$$1
                },] },
    ];
    /** @nocollapse */
    OFilterBuilderComponent$$1.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.Injector }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFilterBuilderComponent$$1.prototype, "queryOnChange", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OFilterBuilderComponent$$1.prototype, "queryOnChangeDelay", void 0);
    return OFilterBuilderComponent$$1;
}());
var OFilterBuilderModule$$1 = /** @class */ (function () {
    function OFilterBuilderModule$$1() {
    }
    OFilterBuilderModule$$1.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        OSharedModule,
                        common.CommonModule
                    ],
                    declarations: [
                        OFilterBuilderComponent$$1,
                        OFilterBuilderClearDirective$$1,
                        OFilterBuilderQueryDirective$$1
                    ],
                    exports: [
                        OFilterBuilderComponent$$1,
                        OFilterBuilderClearDirective$$1,
                        OFilterBuilderQueryDirective$$1
                    ]
                },] },
    ];
    return OFilterBuilderModule$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OFullScreenDialogComponent = /** @class */ (function () {
    function OFullScreenDialogComponent(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.data = data;
        if (Util.isDefined(data)) {
            this.imageSrc = data;
        }
    }
    OFullScreenDialogComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-fullscreen-dialog',
                    template: "\n    <mat-toolbar color=\"primary\" class=\"mat-elevation-z5\">\n      <span fxFlex></span>\n      <button type=\"button\" mat-icon-button mat-dialog-close>\n        <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n      </button>\n    </mat-toolbar>\n    <mat-dialog-content fxLayoutAlign=\"center center\" class=\"o-fullscreen-dialog-content\">\n      <img [src]=\"imageSrc\" />\n    </mat-dialog-content>\n  ",
                    styles: ["\n    .o-image-fullscreen-dialog-cdk-overlay .mat-dialog-container{padding:0}.o-image-fullscreen-dialog-cdk-overlay .mat-dialog-container .o-fullscreen-dialog{height:100%;display:block}.o-image-fullscreen-dialog-cdk-overlay .mat-dialog-container .o-fullscreen-dialog .mat-dialog-content.o-fullscreen-dialog-content{margin:12px;height:100%;max-height:calc(100% - 64px - 24px)}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-fullscreen-dialog]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OFullScreenDialogComponent.ctorParameters = function () { return [
        { type: material.MatDialogRef },
        { type: undefined, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] }] }
    ]; };
    return OFullScreenDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_IMAGE = DEFAULT_INPUTS_O_FORM_DATA_COMPONENT.concat([
    'emptyimage: empty-image',
    'emptyicon: empty-icon',
    'showControls: show-controls',
    'height',
    'autoFit: auto-fit',
    'fullScreenButton: full-screen-button',
    'acceptFileType: accept-file-type'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_IMAGE = DEFAULT_OUTPUTS_O_FORM_DATA_COMPONENT.slice();
var OImageComponent = /** @class */ (function (_super) {
    __extends(OImageComponent, _super);
    function OImageComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.acceptFileType = 'image/*';
        _this.autoFit = true;
        _this.currentFileName = '';
        _this.showControls = true;
        _this._fullScreenButton = false;
        _this._useEmptyIcon = true;
        _this._useEmptyImage = false;
        _this._domSanitizer = _this.injector.get(platformBrowser.DomSanitizer);
        _this._defaultSQLTypeKey = 'BASE64';
        _this.dialog = _this.injector.get(material.MatDialog);
        _this.stateCtrl = new forms.FormControl();
        return _this;
    }
    Object.defineProperty(OImageComponent.prototype, "fullScreenButton", {
        get: /**
         * @return {?}
         */
        function () {
            return this._fullScreenButton;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            val = Util.parseBoolean(String(val));
            this._fullScreenButton = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OImageComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        if (this.emptyimage && this.emptyimage.length > 0) {
            this._useEmptyIcon = false;
            this._useEmptyImage = true;
        }
        if (this.emptyicon === undefined && !this._useEmptyImage) {
            this.emptyicon = 'photo';
            this._useEmptyIcon = true;
            this._useEmptyImage = false;
        }
    };
    /**
     * @return {?}
     */
    OImageComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OImageComponent.prototype.ensureOFormValue = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        if (val instanceof OFormValue) {
            if (val.value && val.value.bytes !== undefined) {
                this.value = new OFormValue(val.value.bytes);
                return;
            }
            this.value = new OFormValue(val.value);
        }
        else if (val && !(val instanceof OFormValue)) {
            if (val.bytes !== undefined) {
                val = val.bytes;
            }
            else if (val.length > 300 && val.substring(0, 4) === 'data') {
                // Removing "data:image/*;base64,"
                val = val.substring(val.indexOf('base64') + 7);
            }
            this.value = new OFormValue(val);
        }
        else {
            this.value = new OFormValue(undefined);
        }
    };
    /**
     * @return {?}
     */
    OImageComponent.prototype.isEmpty = /**
     * @return {?}
     */
    function () {
        return !this.getValue() || this.getValue().length === 0;
    };
    /**
     * @return {?}
     */
    OImageComponent.prototype.createFormControl = /**
     * @return {?}
     */
    function () {
        this._fControl = _super.prototype.createFormControl.call(this);
        this._fControl.fControlChildren = [this.stateCtrl];
        return this._fControl;
    };
    /**
     * @param {?} input
     * @return {?}
     */
    OImageComponent.prototype.fileChange = /**
     * @param {?} input
     * @return {?}
     */
    function (input) {
        if (input.files[0]) {
            /** @type {?} */
            var reader = new FileReader();
            /** @type {?} */
            var self_1 = this;
            reader.addEventListener('load', function (event) {
                /** @type {?} */
                var result = event.target['result'];
                if (result && result.length > 300 && result.substring(0, 4) === 'data') {
                    // Removing "data:image/*;base64,"
                    result = result.substring(result.indexOf('base64') + 7);
                }
                self_1.setValue(result);
                if (self_1._fControl) {
                    self_1._fControl.markAsTouched();
                }
                event.stopPropagation();
            }, false);
            if (input.files[0]) {
                reader.readAsDataURL(input.files[0]);
            }
            // if (this.titleLabel) {
            //   this.titleLabel.nativeElement.textContent = input.files[0].name;
            // }
            this.currentFileName = input.files[0].name;
            this.stateCtrl.setValue(this.currentFileName);
        }
    };
    /**
     * @return {?}
     */
    OImageComponent.prototype.getSrcValue = /**
     * @return {?}
     */
    function () {
        if (this.value && this.value.value) {
            if (this.value.value instanceof Object && this.value.value.bytes) {
                /** @type {?} */
                var src = '';
                if (this.value.value.bytes.substring(0, 4) === 'data') {
                    src = 'data:image/*;base64,' + this.value.value.bytes.substring(this.value.value.bytes.indexOf('base64') + 7);
                }
                else {
                    src = 'data:image/*;base64,' + this.value.value.bytes;
                }
                return this._domSanitizer.bypassSecurityTrustUrl(src);
            }
            else if (typeof this.value.value === 'string' &&
                this.value.value.length > 300) {
                /** @type {?} */
                var src = '';
                if (this.value.value.substring(0, 4) === 'data') {
                    src = 'data:image/*;base64,' + this.value.value.substring(this.value.value.indexOf('base64') + 7);
                }
                else {
                    src = 'data:image/*;base64,' + this.value.value;
                }
                return this._domSanitizer.bypassSecurityTrustUrl(src);
            }
            return this.value.value ? this.value.value : this.emptyimage;
        }
        else if (this.emptyimage) {
            return this.emptyimage;
        }
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    OImageComponent.prototype.onClickBlocker = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        evt.stopPropagation();
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OImageComponent.prototype.onClickClearValue = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!this.isReadOnly && this.enabled) {
            _super.prototype.onClickClearValue.call(this, e);
            this.fileInput.nativeElement.value = '';
            // if (this.titleLabel) {
            //   this.titleLabel.nativeElement.textContent = '';
            // }
            this.stateCtrl.reset();
            this.currentFileName = '';
        }
        if (this._fControl) {
            this._fControl.markAsTouched();
        }
    };
    /**
     * @return {?}
     */
    OImageComponent.prototype.hasControls = /**
     * @return {?}
     */
    function () {
        return this.showControls;
    };
    /**
     * @return {?}
     */
    OImageComponent.prototype.useEmptyIcon = /**
     * @return {?}
     */
    function () {
        return this._useEmptyIcon && this.isEmpty();
    };
    /**
     * @return {?}
     */
    OImageComponent.prototype.useEmptyImage = /**
     * @return {?}
     */
    function () {
        return this._useEmptyImage && this.isEmpty();
    };
    /**
     * @return {?}
     */
    OImageComponent.prototype.getFormGroup = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var formGroup = _super.prototype.getFormGroup.call(this);
        if (!formGroup) {
            formGroup = new forms.FormGroup({});
            formGroup.addControl(this.getAttribute(), this.getControl());
        }
        return formGroup;
    };
    Object.defineProperty(OImageComponent.prototype, "hostHeight", {
        get: /**
         * @return {?}
         */
        function () {
            return this.height;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?=} e
     * @return {?}
     */
    OImageComponent.prototype.openFullScreen = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        this.dialog.open(OFullScreenDialogComponent, {
            width: '90%',
            height: '90%',
            role: 'dialog',
            disableClose: false,
            panelClass: 'o-image-fullscreen-dialog-cdk-overlay',
            data: this.getSrcValue()
        });
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OImageComponent.prototype.openFileSelector = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (Util.isDefined(this.fileInput)) {
            this.fileInput.nativeElement.click();
        }
    };
    /**
     * @return {?}
     */
    OImageComponent.prototype.internalFormControl = /**
     * @return {?}
     */
    function () {
        return this.getAttribute() + '_value';
    };
    OImageComponent.DEFAULT_INPUTS_O_IMAGE = DEFAULT_INPUTS_O_IMAGE;
    OImageComponent.DEFAULT_OUTPUTS_O_IMAGE = DEFAULT_OUTPUTS_O_IMAGE;
    OImageComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-image',
                    template: "\n    <div fxLayout=\"column\" [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\" [matTooltipPosition]=\"tooltipPosition\"\n      [matTooltipShowDelay]=\"tooltipShowDelay\" [matTooltipHideDelay]=\"tooltipHideDelay\" [class.o-image-auto-fit]=\"autoFit\"\n      class=\"o-image-content\" fxFill>\n\n      <mat-form-field *ngIf=\"hasControls()\" class=\"o-image-form-field\">\n        <input matInput readonly (click)=\"input.click()\" [placeholder]=\"olabel | oTranslate\" [required]=\"isRequired\" [formControl]=\"stateCtrl\" />\n        <input matInput [formControlName]=\"getAttribute()\" type=\"text\" [id]=\"getAttribute()\" class=\"o-image-form-field-input\" [required]=\"isRequired\" />\n        <input #input type=\"file\" [disabled]=\"!enabled\" [accept]=\"acceptFileType ? acceptFileType.replace(';',',') : 'image/*'\" (change)=\"fileChange(input)\"\n          class=\"o-image-form-field-hidden\" fxFlex />\n\n        <button type=\"button\" *ngIf=\"fullScreenButton\" [disabled]=\"!enabled\" matSuffix mat-icon-button\n          (click)=\"openFullScreen($event)\">\n          <mat-icon svgIcon=\"ontimize:fullscreen\"></mat-icon>\n        </button>\n        <button type=\"button\" [disabled]=\"!enabled\" matSuffix mat-icon-button (click)=\"input.click()\">\n          <mat-icon svgIcon=\"ontimize:folder_open\"></mat-icon>\n        </button>\n        <button type=\"button\" [disabled]=\"!enabled\" matSuffix mat-icon-button (click)=\"onClickClearValue($event)\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n        <mat-error *ngIf=\"hasError('required')\">{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}</mat-error>\n      </mat-form-field>\n\n      <div fxLayout=\"column\" fxLayoutAlign=\"center center\" fxFlex=\"grow\" class=\"o-image-display-container\">\n        <img *ngIf=\"!(isEmpty())\" [src]=\"getSrcValue()\" alt=\"\" (click)=\"openFileSelector()\" />\n        <mat-icon class=\"empty-icon\" [class.mat-disabled]=\"!enabled\" aria-label=\"empty image\" *ngIf=\"useEmptyIcon()\" (click)=\"openFileSelector()\">\n          {{ emptyicon }}</mat-icon>\n        <img [src]=\"getSrcValue()\" alt=\"empty image\" *ngIf=\"useEmptyImage()\" (click)=\"openFileSelector()\" />\n      </div>\n      <div *ngIf=\"isReadOnly\" fxFill class=\"read-only-blocker\" (click)=\"onClickBlocker($event)\"></div>\n    </div>\n  ",
                    styles: ["\n    .o-image{display:flex;height:inherit}.o-image .o-image-content{position:relative;width:100%}.o-image .o-image-content .o-image-form-field{width:100%}.o-image .o-image-content .o-image-form-field .o-image-form-field-hidden{display:none !important}.o-image .o-image-content .o-image-form-field .o-image-form-field-input{opacity:0;outline:none;width:0}.o-image .o-image-content .o-image-display-container{width:100%}.o-image .o-image-content .o-image-display-container>img{height:100%;width:100%}.o-image .o-image-content.o-image-auto-fit .o-image-display-container>img{height:auto;max-height:100%;max-width:100%;object-fit:contain;width:auto}.o-image .o-image-content .read-only-blocker{left:0;right:0;position:absolute;top:0;z-index:2}\n  "],
                    inputs: DEFAULT_INPUTS_O_IMAGE,
                    outputs: DEFAULT_OUTPUTS_O_IMAGE,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-image]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OImageComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    OImageComponent.propDecorators = {
        fileInput: [{ type: core.ViewChild, args: ['input',] }],
        hostHeight: [{ type: core.HostBinding, args: ['style.height',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OImageComponent.prototype, "autoFit", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OImageComponent.prototype, "showControls", void 0);
    return OImageComponent;
}(OFormDataComponent));
var OImageModule = /** @class */ (function () {
    function OImageModule() {
    }
    OImageModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OImageComponent, OFullScreenDialogComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OImageComponent, OFullScreenDialogComponent],
                    entryComponents: [OFullScreenDialogComponent]
                },] },
    ];
    return OImageModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_CHECKBOX = [
    'trueValue: true-value',
    'falseValue: false-value',
    'booleanType: boolean-type',
    'color',
    'labelPosition: label-position'
].concat(DEFAULT_INPUTS_O_FORM_DATA_COMPONENT);
/** @type {?} */
var DEFAULT_OUTPUTS_O_CHECKBOX = DEFAULT_OUTPUTS_O_FORM_DATA_COMPONENT.slice();
var OCheckboxComponent = /** @class */ (function (_super) {
    __extends(OCheckboxComponent, _super);
    function OCheckboxComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.trueValue = true;
        _this.falseValue = false;
        _this.booleanType = 'boolean';
        _this.labelPosition = 'after';
        _this._defaultSQLTypeKey = 'BOOLEAN';
        return _this;
    }
    /**
     * @return {?}
     */
    OCheckboxComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        _super.prototype.initialize.call(this);
        if (!Util.isDefined(this.sqlType)) {
            switch (this.booleanType) {
                case 'number':
                    this.sqlType = 'INTEGER';
                    break;
                case 'string':
                    this.sqlType = 'VARCHAR';
                    break;
                case 'boolean':
                default:
                    this.sqlType = 'BOOLEAN';
            }
        }
        /** @type {?} */
        var context = this;
        (/** @type {?} */ (this.getFormControl())).getValue.bind(context);
        (/** @type {?} */ (this.getFormControl())).getValue = function () {
            return this.value ? context.trueValue : context.falseValue;
        };
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OCheckboxComponent.prototype.ensureOFormValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.parseInputs();
        if (value instanceof OFormValue) {
            if (value.value === undefined) {
                value.value = false;
            }
            this.value = new OFormValue(this.parseValueByType(value.value) === this.trueValue);
        }
        else if (typeof value === 'boolean') {
            this.value = new OFormValue(value);
        }
        else {
            this.value = new OFormValue(this.parseValueByType(value) === this.trueValue);
        }
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    OCheckboxComponent.prototype.onClickBlocker = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        evt.stopPropagation();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OCheckboxComponent.prototype.parseValueByType = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var result;
        switch (this.booleanType) {
            case 'string':
                result = value + '';
                break;
            case 'number':
                result = parseInt(value);
                break;
            default:
                result = value;
                break;
        }
        return result;
    };
    /**
     * @return {?}
     */
    OCheckboxComponent.prototype.parseStringInputs = /**
     * @return {?}
     */
    function () {
        if ((this.trueValue || '').length === 0) {
            this.trueValue = undefined;
        }
        if ((this.falseValue || '').length === 0) {
            this.falseValue = undefined;
        }
    };
    /**
     * @return {?}
     */
    OCheckboxComponent.prototype.parseNumberInputs = /**
     * @return {?}
     */
    function () {
        this.trueValue = parseInt(this.trueValue);
        if (isNaN(this.trueValue)) {
            this.trueValue = 1;
        }
        this.falseValue = parseInt(this.falseValue);
        if (isNaN(this.falseValue)) {
            this.falseValue = 0;
        }
    };
    /**
     * @return {?}
     */
    OCheckboxComponent.prototype.parseInputs = /**
     * @return {?}
     */
    function () {
        switch (this.booleanType) {
            case 'string':
                this.parseStringInputs();
                break;
            case 'number':
                this.parseNumberInputs();
                break;
            default:
                this.trueValue = true;
                this.falseValue = false;
                break;
        }
    };
    OCheckboxComponent.DEFAULT_INPUTS_O_CHECKBOX = DEFAULT_INPUTS_O_CHECKBOX;
    OCheckboxComponent.DEFAULT_OUTPUTS_O_CHECKBOX = DEFAULT_OUTPUTS_O_CHECKBOX;
    OCheckboxComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-checkbox',
                    inputs: DEFAULT_INPUTS_O_CHECKBOX,
                    outputs: DEFAULT_OUTPUTS_O_CHECKBOX,
                    template: "\n    <div [class.custom-width]=\"hasCustomWidth\" [formGroup]=\"getFormGroup()\" class=\"relative\" [matTooltip]=\"tooltip\"\n      [matTooltipClass]=\"tooltipClass\" [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\" fxLayout=\"row\" fxLayoutAlign=\"start center\" fxFill>\n      <mat-checkbox [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\" (change)=\"onChangeEvent($event)\"\n        [labelPosition]=\"labelPosition\" [color]=\"color\">\n        {{ olabel | oTranslate }}\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-checkbox>\n      <div *ngIf=\"isReadOnly\" (click)=\"onClickBlocker($event)\" class=\"read-only-blocker\" fxFill></div>\n    </div>\n  ",
                    styles: ["\n    .o-checkbox mat-checkbox{z-index:1}.o-checkbox .mat-checkbox-disabled .mat-checkbox-layout .mat-checkbox-label{color:rgba(0,0,0,0.36)}.o-checkbox .custom-width{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.o-checkbox .read-only-blocker{z-index:2;position:absolute;top:0;left:0;right:0}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-checkbox]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OCheckboxComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    return OCheckboxComponent;
}(OFormDataComponent));
var OCheckboxModule = /** @class */ (function () {
    function OCheckboxModule() {
    }
    OCheckboxModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OCheckboxComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OCheckboxComponent]
                },] },
    ];
    return OCheckboxModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_FORM_SERVICE_COMPONENT = DEFAULT_INPUTS_O_FORM_DATA_COMPONENT.concat([
    'staticData: static-data',
    'entity',
    'service',
    'columns',
    'valueColumn: value-column',
    'valueColumnType: value-column-type',
    'parentKeys: parent-keys',
    'visibleColumns: visible-columns',
    'descriptionColumns: description-columns',
    'separator',
    'queryOnInit: query-on-init',
    'queryOnBind: query-on-bind',
    'queryOnEvent: query-on-event',
    'queryMethod: query-method',
    'serviceType: service-type',
    'queryWithNullParentKeys: query-with-null-parent-keys',
    'setValueOnValueChange: set-value-on-value-change'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_FORM_SERVICE_COMPONENT = DEFAULT_OUTPUTS_O_FORM_DATA_COMPONENT.concat([
    'onSetValueOnValueChange',
    'onDataLoaded'
]);
var OFormServiceComponent = /** @class */ (function (_super) {
    __extends(OFormServiceComponent, _super);
    function OFormServiceComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.valueColumnType = Codes.TYPE_INT;
        _this.separator = Codes.SPACE_SEPARATOR;
        _this.queryOnInit = true;
        _this.queryOnBind = false;
        _this.queryMethod = Codes.QUERY_METHOD;
        _this.queryWithNullParentKeys = false;
        _this.onSetValueOnValueChange = new core.EventEmitter();
        _this.onDataLoaded = new core.EventEmitter();
        /* Internal variables */
        _this.dataArray = [];
        _this.colArray = [];
        _this.visibleColArray = [];
        _this.descriptionColArray = [];
        _this.loading = false;
        _this.cacheQueried = false;
        _this._pKeysEquiv = {};
        _this._setValueOnValueChangeEquiv = {};
        _this.delayLoad = 250;
        _this.loadingSubject = new BehaviorSubject(false);
        _this.form = form;
        _this.elRef = elRef;
        _this.dialogService = injector.get(DialogService);
        return _this;
    }
    /**
     * @return {?}
     */
    OFormServiceComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.initialize.call(this);
        this.cacheQueried = false;
        this.colArray = Util.parseArray(this.columns, true);
        this.visibleColArray = Util.parseArray(this.visibleColumns, true);
        if (Util.isArrayEmpty(this.visibleColArray)) {
            // It is necessary to assing value to visibleColumns to propagate the parameter.
            this.visibleColumns = this.columns;
            this.visibleColArray = this.colArray;
        }
        this.descriptionColArray = Util.parseArray(this.descriptionColumns);
        if (Util.isArrayEmpty(this.descriptionColArray)) {
            this.descriptionColArray = this.visibleColArray;
        }
        /** @type {?} */
        var pkArray = Util.parseArray(this.parentKeys);
        this._pKeysEquiv = Util.parseParentKeysEquivalences(pkArray);
        /** @type {?} */
        var setValueSetArray = Util.parseArray(this.setValueOnValueChange);
        this._setValueOnValueChangeEquiv = Util.parseParentKeysEquivalences(setValueSetArray);
        if (this.form && this.queryOnBind) {
            /** @type {?} */
            var self_1 = this;
            this._formDataSubcribe = this.form.onDataLoaded.subscribe(function () { return self_1.queryData(); });
        }
        if (this.staticData) {
            this.queryOnBind = false;
            this.queryOnInit = false;
            this.setDataArray(this.staticData);
        }
        else {
            this.configureService();
        }
        if (this.queryOnEvent !== undefined && this.queryOnEvent.subscribe !== undefined) {
            /** @type {?} */
            var self_2 = this;
            this.queryOnEventSubscription = this.queryOnEvent.subscribe(function (value) {
                if (Util.isDefined(value) || _this.queryWithNullParentKeys) {
                    self_2.queryData();
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OFormServiceComponent.prototype.destroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.destroy.call(this);
        if (this._formDataSubcribe) {
            this._formDataSubcribe.unsubscribe();
        }
        if (this.queryOnEventSubscription) {
            this.queryOnEventSubscription.unsubscribe();
        }
        if (this.loaderSubscription) {
            this.loaderSubscription.unsubscribe();
        }
    };
    /**
     * @param {?} type
     * @param {?} newValue
     * @param {?} oldValue
     * @return {?}
     */
    OFormServiceComponent.prototype.emitOnValueChange = /**
     * @param {?} type
     * @param {?} newValue
     * @param {?} oldValue
     * @return {?}
     */
    function (type, newValue, oldValue) {
        var _this = this;
        _super.prototype.emitOnValueChange.call(this, type, newValue, oldValue);
        /** @type {?} */
        var record = this.getSelectedRecord();
        this.onSetValueOnValueChange.emit(record);
        /** @type {?} */
        var setValueSetKeys = Object.keys(this._setValueOnValueChangeEquiv);
        if (setValueSetKeys.length) {
            /** @type {?} */
            var formComponents_1 = this.form.getComponents();
            if (Util.isDefined(record)) {
                setValueSetKeys.forEach(function (key) {
                    /** @type {?} */
                    var comp = formComponents_1[_this._setValueOnValueChangeEquiv[key]];
                    if (Util.isDefined(comp)) {
                        comp.setValue(record[key]);
                    }
                });
            }
        }
    };
    /* Utility methods */
    /**
     * @return {?}
     */
    OFormServiceComponent.prototype.configureService = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var loadingService = OntimizeService$$1;
        if (this.serviceType) {
            loadingService = this.serviceType;
        }
        try {
            this.dataService = this.injector.get(loadingService);
            if (Util.isDataService(this.dataService)) {
                /** @type {?} */
                var serviceCfg = this.dataService.getDefaultServiceConfiguration(this.service);
                if (this.entity) {
                    serviceCfg['entity'] = this.entity;
                }
                this.dataService.configureService(serviceCfg);
            }
        }
        catch (e) {
            console.error(e);
        }
    };
    /**
     * @param {?=} columns
     * @return {?}
     */
    OFormServiceComponent.prototype.getAttributesValuesToQuery = /**
     * @param {?=} columns
     * @return {?}
     */
    function (columns) {
        /** @type {?} */
        var result = Util.isDefined(columns) ? columns : this.colArray;
        if (result.indexOf(this.valueColumn) === -1) {
            result.push(this.valueColumn);
        }
        return result;
    };
    /**
     * @param {?=} filter
     * @return {?}
     */
    OFormServiceComponent.prototype.queryData = /**
     * @param {?=} filter
     * @return {?}
     */
    function (filter$$1) {
        var _this = this;
        if (filter$$1 === void 0) { filter$$1 = undefined; }
        /** @type {?} */
        var self = this;
        if (!this.dataService || !(this.queryMethod in this.dataService) || !this.entity) {
            console.warn('Service not properly configured! aborting query');
            return;
        }
        filter$$1 = Object.assign(filter$$1 || {}, ServiceUtils$$1.getParentKeysFromForm(this._pKeysEquiv, this.form));
        if (!ServiceUtils$$1.filterContainsAllParentKeys(filter$$1, this._pKeysEquiv) && !this.queryWithNullParentKeys) {
            this.setDataArray([]);
        }
        else {
            if (this.querySuscription) {
                this.querySuscription.unsubscribe();
            }
            if (this.loaderSubscription) {
                this.loaderSubscription.unsubscribe();
            }
            /** @type {?} */
            var queryCols = this.getAttributesValuesToQuery();
            this.loaderSubscription = this.load();
            this.querySuscription = this.dataService[this.queryMethod](filter$$1, queryCols, this.entity).subscribe(function (resp) {
                if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                    self.cacheQueried = true;
                    self.setDataArray(resp.data);
                }
                //window.setTimeout(() => { this.loading = false; self.loadingSubject.next(false); self.loaderSubscription.unsubscribe(); }, 10000);
                self.loadingSubject.next(false);
                self.loaderSubscription.unsubscribe();
            }, function (err) {
                console.error(err);
                self.loadingSubject.next(false);
                self.loaderSubscription.unsubscribe();
                if (err && !Util.isObject(err)) {
                    _this.dialogService.alert('ERROR', err);
                }
                else {
                    _this.dialogService.alert('ERROR', 'MESSAGES.ERROR_QUERY');
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OFormServiceComponent.prototype.getDataArray = /**
     * @return {?}
     */
    function () {
        return this.dataArray;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OFormServiceComponent.prototype.setDataArray = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (Util.isArray(data)) {
            this.dataArray = data;
            this.syncDataIndex(false);
        }
        else if (Util.isObject(data) && Object.keys(data).length > 0) {
            this.dataArray = [data];
        }
        else {
            console.warn('Component has received not supported service data. Supported data are Array or not empty Object');
            this.dataArray = [];
        }
        this.onDataLoaded.emit(this.dataArray);
    };
    /**
     * @param {?=} queryIfNotFound
     * @return {?}
     */
    OFormServiceComponent.prototype.syncDataIndex = /**
     * @param {?=} queryIfNotFound
     * @return {?}
     */
    function (queryIfNotFound) {
        var _this = this;
        if (queryIfNotFound === void 0) { queryIfNotFound = true; }
        this._currentIndex = undefined;
        if (this.value && this.value.value && this.dataArray) {
            /** @type {?} */
            var self_3 = this;
            this.dataArray.forEach(function (item, index) {
                if (_this.value.value instanceof Array) {
                    _this._currentIndex = [];
                    _this.value.value.forEach(function (itemValue, indexValue) {
                        if (item[self_3.valueColumn] === itemValue) {
                            _this._currentIndex[_this._currentIndex.length] = indexValue;
                        }
                    });
                }
                else if (item[self_3.valueColumn] === _this.value.value) {
                    self_3._currentIndex = index;
                }
                if (item[self_3.valueColumn] === _this.value.value) {
                    self_3._currentIndex = index;
                }
            });
            if (this._currentIndex === undefined && queryIfNotFound) {
                if (this.queryOnBind && this.dataArray && this.dataArray.length === 0
                    && !this.cacheQueried && !this.isEmpty()) {
                    this.queryData();
                }
                return;
            }
        }
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OFormServiceComponent.prototype.parseByValueColumnType = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        /** @type {?} */
        var value = val;
        if (this.valueColumnType === Codes.TYPE_INT) {
            /** @type {?} */
            var parsed = parseInt(value);
            if (!isNaN(parsed)) {
                value = parsed;
            }
        }
        return value;
    };
    /**
     * @param {?} val
     * @param {?=} options
     * @return {?}
     */
    OFormServiceComponent.prototype.setValue = /**
     * @param {?} val
     * @param {?=} options
     * @return {?}
     */
    function (val, options) {
        /** @type {?} */
        var value = this.parseByValueColumnType(val);
        _super.prototype.setValue.call(this, value, options);
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OFormServiceComponent.prototype.setData = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        /** @type {?} */
        var value = this.parseByValueColumnType(val);
        _super.prototype.setData.call(this, value);
    };
    /**
     * @return {?}
     */
    OFormServiceComponent.prototype.getSelectedRecord = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var result = undefined;
        /** @type {?} */
        var selectedValue = this.getValue();
        if (Util.isDefined(selectedValue)) {
            result = this.getDataArray().find(function (item) { return item[_this.valueColumn] === selectedValue; });
        }
        return result;
    };
    /**
     * @return {?}
     */
    OFormServiceComponent.prototype.load = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var zone = this.injector.get(core.NgZone);
        /** @type {?} */
        var loadObservable = new Observable(function (observer) {
            /** @type {?} */
            var timer$$1 = window.setTimeout(function () {
                observer.next(true);
            }, self.delayLoad);
            return function () {
                window.clearTimeout(timer$$1);
                zone.run(function () {
                    observer.next(false);
                    self.loading = false;
                });
            };
        });
        /** @type {?} */
        var subscription = loadObservable.subscribe(function (val) {
            zone.run(function () {
                self.loading = /** @type {?} */ (val);
                self.loadingSubject.next(/** @type {?} */ (val));
            });
        });
        return subscription;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OFormServiceComponent.prototype.onFormControlChange = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.oldValue === value) {
            return;
        }
        _super.prototype.onFormControlChange.call(this, value);
    };
    OFormServiceComponent.DEFAULT_INPUTS_O_FORM_SERVICE_COMPONENT = DEFAULT_INPUTS_O_FORM_SERVICE_COMPONENT;
    OFormServiceComponent.DEFAULT_OUTPUTS_O_FORM_SERVICE_COMPONENT = DEFAULT_OUTPUTS_O_FORM_SERVICE_COMPONENT;
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormServiceComponent.prototype, "queryOnInit", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormServiceComponent.prototype, "queryOnBind", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFormServiceComponent.prototype, "queryWithNullParentKeys", void 0);
    return OFormServiceComponent;
}(OFormDataComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OComboSearchComponent = /** @class */ (function () {
    function OComboSearchComponent(matSelect, changeDetectorRef) {
        this.matSelect = matSelect;
        this.changeDetectorRef = changeDetectorRef;
        this.placeholder = 'SEARCH';
        /**
         * Event that emits when the current value changes
         */
        this.change = new core.EventEmitter();
        /**
         * Subject that emits when the component has been destroyed.
         */
        this._onDestroy = new Subject();
        this.onChange = function (_) {
            // do nothing
        };
        this.onTouched = function (_) {
            // do nothing
        };
    }
    Object.defineProperty(OComboSearchComponent.prototype, "value", {
        /** Current search value */
        get: /**
         * Current search value
         * @return {?}
         */
        function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OComboSearchComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // when the select dropdown panel is opened or closed, focus the search field when opening and clear it when closing
        this.matSelect.openedChange
            .pipe(takeUntil(this._onDestroy))
            .subscribe(function (opened) { return opened ? _this.focus() : _this.reset(); });
        // set the first item active after the options changed
        this.matSelect.openedChange
            .pipe(take(1))
            .pipe(takeUntil(this._onDestroy))
            .subscribe(function () {
            if (_this.matSelect.multiple) {
                _this.previousSelectedValues = _this.matSelect.value;
            }
            _this._options = _this.matSelect.options;
            _this._options.changes
                .pipe(takeUntil(_this._onDestroy))
                .subscribe(function () {
                /** @type {?} */
                var keyManager = _this.matSelect._keyManager;
                if (keyManager && _this.matSelect.panelOpen) {
                    // avoid "expression has been changed" error
                    setTimeout(function () { return keyManager.setFirstItemActive(); });
                }
            });
        });
        // detect changes when the input changes
        this.change
            .pipe(takeUntil(this._onDestroy))
            .subscribe(function () { return _this.changeDetectorRef.detectChanges(); });
        this.initMultipleHandling();
    };
    /**
     * @return {?}
     */
    OComboSearchComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    /**
     * Handles the key down event with MatSelect.
     * Allows e.g. selecting with enter key, navigation with arrow keys, etc.
     * @param {?} event
     * @return {?}
     */
    OComboSearchComponent.prototype.handleKeydown = /**
     * Handles the key down event with MatSelect.
     * Allows e.g. selecting with enter key, navigation with arrow keys, etc.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.keyCode === 32) {
            // do not propagate spaces to MatSelect, as this would select the currently active option
            event.stopPropagation();
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OComboSearchComponent.prototype.onInputChange = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var valueChanged = value !== this._value;
        if (valueChanged) {
            this._value = value;
            this.onChange(value);
            this.change.emit(value);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OComboSearchComponent.prototype.onBlur = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.writeValue(value);
        this.onTouched();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OComboSearchComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var valueChanged = value !== this._value;
        if (valueChanged) {
            this._value = value;
            this.change.emit(value);
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    OComboSearchComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    OComboSearchComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    /**
     * Focuses the search input field
     * @return {?}
     */
    OComboSearchComponent.prototype.focus = /**
     * Focuses the search input field
     * @return {?}
     */
    function () {
        if (!this.searchSelectInput) {
            return;
        }
        /** @type {?} */
        var panel = this.matSelect.panel.nativeElement;
        /** @type {?} */
        var scrollTop = panel.scrollTop;
        // focus
        this.searchSelectInput.nativeElement.focus();
        panel.scrollTop = scrollTop;
    };
    /**
     * Resets the current search value
     * @param {?=} focus whether to focus after resetting
     * @return {?}
     */
    OComboSearchComponent.prototype.reset = /**
     * Resets the current search value
     * @param {?=} focus whether to focus after resetting
     * @return {?}
     */
    function (focus) {
        if (!this.searchSelectInput) {
            return;
        }
        this.searchSelectInput.nativeElement.value = '';
        this.onInputChange('');
        if (focus) {
            this.focus();
        }
    };
    /**
     * Initializes handling <mat-select [multiple]="true">
     * Note: to improve this code, mat-select should be extended to allow disabling resetting the selection while filtering.
     */
    /**
     * Initializes handling <mat-select [multiple]="true">
     * Note: to improve this code, mat-select should be extended to allow disabling resetting the selection while filtering.
     * @return {?}
     */
    OComboSearchComponent.prototype.initMultipleHandling = /**
     * Initializes handling <mat-select [multiple]="true">
     * Note: to improve this code, mat-select should be extended to allow disabling resetting the selection while filtering.
     * @return {?}
     */
    function () {
        var _this = this;
        // if <mat-select [multiple]="true">
        // store previously selected values and restore them when they are deselected
        // because the option is not available while we are currently filtering
        this.matSelect.valueChange
            .pipe(takeUntil(this._onDestroy))
            .subscribe(function (values) {
            if (_this.matSelect.multiple) {
                /** @type {?} */
                var restoreSelectedValues_1 = false;
                if (_this._value && _this._value.length
                    && _this.previousSelectedValues && Array.isArray(_this.previousSelectedValues)) {
                    if (!values || !Array.isArray(values)) {
                        values = [];
                    }
                    /** @type {?} */
                    var optionValues_1 = _this.matSelect.options.map(function (option) { return option.value; });
                    _this.previousSelectedValues.forEach(function (previousValue) {
                        if (values.indexOf(previousValue) === -1 && optionValues_1.indexOf(previousValue) === -1) {
                            // if a value that was selected before is deselected and not found in the options, it was deselected
                            // due to the filtering, so we restore it.
                            values.push(previousValue);
                            restoreSelectedValues_1 = true;
                        }
                    });
                }
                if (restoreSelectedValues_1) {
                    _this.matSelect._onChange(values);
                }
                _this.previousSelectedValues = values;
            }
        });
    };
    OComboSearchComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'o-combo-search',
                    template: "\n    <input matInput class=\"o-combo-search-hidden\" />\n\n    <mat-form-field floatLabel=\"never\" class=\"o-combo-search-inner\">\n      <input matInput #searchSelectInput placeholder=\"{{ placeholder | oTranslate }}\" (keydown)=\"handleKeydown($event)\"\n        (input)=\"onInputChange($event.target.value)\" (blur)=\"onBlur($event.target.value)\" class=\"mat-select-search-input\" />\n      <button mat-icon-button matSuffix *ngIf=\"value\" (click)=\"reset(true)\" class=\"mat-select-search-clear\">\n        <mat-icon>close</mat-icon>\n      </button>\n    </mat-form-field>\n\n    <div *ngIf=\"value && _options?.length === 0\" fxLayoutAlign=\"center center\" class=\"o-combo-search-emmpty\">\n      <span>{{ 'INPUT.COMBO.EMPTY' | oTranslate }}</span>\n    </div>\n  ",
                    styles: ["\n    :host{display:flex;flex-direction:column;padding:0 16px}:host .o-combo-search-hidden{display:none}:host .o-combo-search-inner{height:3em;width:100%}:host .o-combo-search-emmpty{height:3em;line-height:3em}\n  "],
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: core.forwardRef(function () { return OComboSearchComponent; }),
                            multi: true
                        }
                    ],
                    host: {
                        '[class.o-combo-search]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OComboSearchComponent.ctorParameters = function () { return [
        { type: material.MatSelect, decorators: [{ type: core.Inject, args: [material.MatSelect,] }] },
        { type: core.ChangeDetectorRef }
    ]; };
    OComboSearchComponent.propDecorators = {
        searchSelectInput: [{ type: core.ViewChild, args: ['searchSelectInput', { read: core.ElementRef },] }]
    };
    return OComboSearchComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_COMBO = OFormServiceComponent.DEFAULT_INPUTS_O_FORM_SERVICE_COMPONENT.concat([
    'translate',
    'multiple',
    'nullSelection: null-selection',
    'multipleTriggerLabel: multiple-trigger-label',
    'searchable'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_COMBO = OFormServiceComponent.DEFAULT_OUTPUTS_O_FORM_SERVICE_COMPONENT.slice();
var 0$8 = dataServiceFactory;
var OComboComponent = /** @class */ (function (_super) {
    __extends(OComboComponent, _super);
    function OComboComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.searchControl = new forms.FormControl();
        _this.multipleTriggerLabel = false;
        _this.searchable = false;
        _this.translate = false;
        _this.nullSelection = true;
        _this.filteredDataArray = [];
        _this.subscription = new Subscription();
        _this.defaultValue = '';
        return _this;
    }
    /**
     * @return {?}
     */
    OComboComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.subscription.add(this.searchControl.valueChanges.subscribe(function () { return _this.searchFilter(); }));
    };
    /**
     * @return {?}
     */
    OComboComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngAfterViewInit.call(this);
        if (this.queryOnInit) {
            this.queryData();
        }
        else if (this.queryOnBind) {
            // TODO do it better. When changing tabs it is necessary to invoke new query
            this.syncDataIndex();
        }
    };
    /**
     * @return {?}
     */
    OComboComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
        this.destroy();
    };
    /**
     * @return {?}
     */
    OComboComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        _super.prototype.initialize.call(this);
        if (this.multiple) {
            this.nullSelection = false;
            this.defaultValue = [];
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OComboComponent.prototype.ensureOFormValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value instanceof OFormValue) {
            this.value = new OFormValue(value.value);
        }
        else if (Util.isDefined(value) && !(value instanceof OFormValue)) {
            this.value = new OFormValue(value);
        }
        else if (!Util.isDefined(value) && this.nullSelection) {
            this.value = new OFormValue(undefined);
        }
        else {
            this.value = new OFormValue(this.defaultValue);
        }
        // This call make the component querying its data multiple times
        // this.syncDataIndex();
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OComboComponent.prototype.setDataArray = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        _super.prototype.setDataArray.call(this, data);
        this.filteredDataArray = data;
    };
    /**
     * @return {?}
     */
    OComboComponent.prototype.getDataArray = /**
     * @return {?}
     */
    function () {
        return this.dataArray;
    };
    /**
     * @return {?}
     */
    OComboComponent.prototype.getFilteredDataArray = /**
     * @return {?}
     */
    function () {
        return this.filteredDataArray;
    };
    /**
     * @return {?}
     */
    OComboComponent.prototype.hasNullSelection = /**
     * @return {?}
     */
    function () {
        return this.nullSelection;
    };
    /**
     * @param {?=} queryIfNotFound
     * @return {?}
     */
    OComboComponent.prototype.syncDataIndex = /**
     * @param {?=} queryIfNotFound
     * @return {?}
     */
    function (queryIfNotFound) {
        if (queryIfNotFound === void 0) { queryIfNotFound = true; }
        _super.prototype.syncDataIndex.call(this, queryIfNotFound);
        if (this._currentIndex !== undefined && this.nullSelection) {
            // first position is for null selection that it is not included into dataArray
            this._currentIndex += 1;
        }
    };
    /**
     * @return {?}
     */
    OComboComponent.prototype.getValue = /**
     * @return {?}
     */
    function () {
        if (this.value instanceof OFormValue) {
            if (this.value.value !== undefined) {
                return this.value.value;
            }
            else if (this.value.value === undefined) {
                return this.getEmptyValue();
            }
        }
        return '';
    };
    /**
     * @return {?}
     */
    OComboComponent.prototype.getEmptyValue = /**
     * @return {?}
     */
    function () {
        if (this.multiple) {
            return [];
        }
        else {
            if (this.nullSelection) {
                return undefined;
            }
            else {
                return '';
            }
        }
    };
    /**
     * @return {?}
     */
    OComboComponent.prototype.clearValue = /**
     * @return {?}
     */
    function () {
        if (this.multiple) {
            this.setValue(this.defaultValue);
        }
        else {
            _super.prototype.clearValue.call(this);
        }
    };
    /**
     * @return {?}
     */
    OComboComponent.prototype.getMultiple = /**
     * @return {?}
     */
    function () {
        return this.multiple;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OComboComponent.prototype.onSelectionChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.selectModel.panelOpen) {
            return;
        }
        /** @type {?} */
        var newValue = event.value;
        this.setValue(newValue, {
            changeType: OValueChangeEvent.USER_CHANGE,
            emitEvent: false,
            emitModelToViewChange: false
        });
    };
    /**
     * @param {?=} item
     * @return {?}
     */
    OComboComponent.prototype.getOptionDescriptionValue = /**
     * @param {?=} item
     * @return {?}
     */
    function (item) {
        if (item === void 0) { item = {}; }
        /** @type {?} */
        var descTxt = '';
        if (this.descriptionColArray && this.descriptionColArray.length > 0) {
            /** @type {?} */
            var self_1 = this;
            this.descriptionColArray.forEach(function (col, index) {
                /** @type {?} */
                var txt = item[col];
                if (Util.isDefined(txt)) {
                    if (self_1.translate && self_1.translateService) {
                        txt = self_1.translateService.get(txt);
                    }
                    descTxt += txt;
                }
                if (index < self_1.descriptionColArray.length - 1) {
                    descTxt += self_1.separator;
                }
            });
        }
        return descTxt;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OComboComponent.prototype.getValueColumn = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item && item.hasOwnProperty(this.valueColumn)) {
            /** @type {?} */
            var option = item[this.valueColumn];
            if (option === 'undefined') {
                option = null;
            }
            return option;
        }
        return '';
    };
    /**
     * @param {?} item
     * @param {?} rowIndex
     * @return {?}
     */
    OComboComponent.prototype.isSelected = /**
     * @param {?} item
     * @param {?} rowIndex
     * @return {?}
     */
    function (item, rowIndex) {
        /** @type {?} */
        var selected = false;
        if (item && item.hasOwnProperty(this.valueColumn) && this.value) {
            /** @type {?} */
            var val = item[this.valueColumn];
            if (val === this.value.value) {
                selected = true;
                this._currentIndex = rowIndex;
            }
        }
        return selected;
    };
    /**
     * @param {?} val
     * @param {?=} options
     * @return {?}
     */
    OComboComponent.prototype.setValue = /**
     * @param {?} val
     * @param {?=} options
     * @return {?}
     */
    function (val, options) {
        var _this = this;
        if (!this.dataArray) {
            return;
        }
        /** @type {?} */
        var isDefinedVal = Util.isDefined(val);
        if (this.multiple && !isDefinedVal) {
            return;
        }
        if (!isDefinedVal && !this.nullSelection) {
            console.warn('`o-combo` with attr ' + this.oattr + ' cannot be set. `null-selection` attribute is false.');
            return;
        }
        if (isDefinedVal) {
            /** @type {?} */
            var record = this.dataArray.find(function (item) { return item[_this.valueColumn] === val; });
            if (!Util.isDefined(record)) {
                return;
            }
        }
        else {
            if (Util.isDefined(val)) {
                _super.prototype.setValue.call(this, val, options);
            }
        }
        _super.prototype.setValue.call(this, val, options);
    };
    /**
     * @return {?}
     */
    OComboComponent.prototype.getSelectedItems = /**
     * @return {?}
     */
    function () {
        return this.getValue();
    };
    /**
     * @param {?} values
     * @return {?}
     */
    OComboComponent.prototype.setSelectedItems = /**
     * @param {?} values
     * @return {?}
     */
    function (values) {
        this.setValue(values);
    };
    /**
     * @return {?}
     */
    OComboComponent.prototype.getFirstSelectedValue = /**
     * @return {?}
     */
    function () {
        return this.selectModel.selected[0].viewValue;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OComboComponent.prototype.setIsReadOnly = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        _super.prototype.setIsReadOnly.call(this, value);
        /** @type {?} */
        var readOnly = Util.isDefined(this.readOnly) ? this.readOnly : value;
        if (this.enabled) {
            if (this._fControl && readOnly) {
                this._fControl.disable();
            }
            else if (this._fControl) {
                this._fControl.enable();
            }
        }
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OComboComponent.prototype.parseByValueColumnType = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        if (!Util.isDefined(this.multiple)) {
            return val;
        }
        /** @type {?} */
        var valueArr = this.multiple ? val : [val];
        if (this.valueColumnType === Codes.TYPE_INT) {
            valueArr.forEach(function (item, index) {
                /** @type {?} */
                var parsed = parseInt(item);
                if (!isNaN(parsed)) {
                    valueArr[index] = parsed;
                }
            });
        }
        return this.multiple ? valueArr : valueArr[0];
    };
    /**
     * @return {?}
     */
    OComboComponent.prototype.searchFilter = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.dataArray || this.dataArray.length) {
            /** @type {?} */
            var search_1 = this.searchControl.value;
            if (!search_1) {
                this.filteredDataArray = this.dataArray.slice();
                return;
            }
            else {
                search_1 = search_1.toLowerCase();
            }
            // filter
            this.filteredDataArray = this.dataArray.filter(function (item) { return _this.getOptionDescriptionValue(item).toLowerCase().indexOf(search_1) > -1; });
        }
    };
    OComboComponent.DEFAULT_INPUTS_O_COMBO = DEFAULT_INPUTS_O_COMBO;
    OComboComponent.DEFAULT_OUTPUTS_O_COMBO = DEFAULT_OUTPUTS_O_COMBO;
    OComboComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-combo',
                    providers: [
                        { provide: OntimizeService$$1, useFactory: 0$8, deps: [core.Injector] },
                        { provide: OFormServiceComponent, useExisting: core.forwardRef(function () { return OComboComponent; }) }
                    ],
                    inputs: DEFAULT_INPUTS_O_COMBO,
                    outputs: DEFAULT_OUTPUTS_O_COMBO,
                    template: "\n    <div [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\" [matTooltipClass]=\"tooltipClass\" [matTooltipPosition]=\"tooltipPosition\"\n      [matTooltipShowDelay]=\"tooltipShowDelay\" [matTooltipHideDelay]=\"tooltipHideDelay\">\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [class.read-only]=\"isReadOnly\" [class.custom-width]=\"hasCustomWidth\"\n        [hideRequiredMarker]=\"hideRequiredMarker\" fxFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <mat-select [value]=\"getValue()\" #selectModel [id]=\"getAttribute()\" fxFill [formControlName]=\"getAttribute()\" [placeholder]=\"placeHolder\"\n          [multiple]=\"getMultiple()\" [required]=\"isRequired\" [panelClass]=\"{ 'o-combo-panel': true, 'o-combo-panel-search': searchable }\"\n          (selectionChange)=\"onSelectionChange($event)\">\n          <o-combo-search *ngIf=\"searchable\" [formControl]=\"searchControl\"></o-combo-search>\n\n          <mat-select-trigger *ngIf=\"multiple && multipleTriggerLabel\">\n            {{ selectModel.selected[0] ? getFirstSelectedValue(): '' }}\n            <span *ngIf=\"getFormControl().value.length > 1\">\n              {{ 'INPUT.COMBO.MESSAGE_TRIGGER' | oTranslate: { values: [getFormControl().value.length -1] } }}\n            </span>\n          </mat-select-trigger>\n\n          <div class=\"o-combo-options-container\">\n            <mat-option *ngIf=\"hasNullSelection()\" [value]=\"null\"></mat-option>\n            <mat-option *ngFor=\"let item of getFilteredDataArray()\" [value]=\"getValueColumn(item)\">\n              {{ getOptionDescriptionValue(item) }}\n            </mat-option>\n          </div>\n        </mat-select>\n\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ["\n    .o-combo .read-only .mat-select-arrow-wrapper{visibility:hidden}.o-combo .read-only .mat-form-field-underline{background-image:none}.o-combo .mat-select{line-height:normal}.o-combo-panel.o-combo-panel-search{overflow:hidden}.o-combo-panel.o-combo-panel-search .mat-select-content{height:100%}.o-combo-panel.o-combo-panel-search .mat-select-content .o-combo-options-container{height:calc(100% - 3em);overflow:auto}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-combo]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OComboComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    OComboComponent.propDecorators = {
        inputModel: [{ type: core.ViewChild, args: ['inputModel',] }],
        selectModel: [{ type: core.ViewChild, args: ['selectModel',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OComboComponent.prototype, "multiple", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OComboComponent.prototype, "multipleTriggerLabel", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OComboComponent.prototype, "searchable", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OComboComponent.prototype, "translate", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OComboComponent.prototype, "nullSelection", void 0);
    return OComboComponent;
}(OFormServiceComponent));
var OComboModule = /** @class */ (function () {
    function OComboModule() {
    }
    OComboModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OComboComponent, OComboSearchComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OComboComponent, OComboSearchComponent]
                },] },
    ];
    return OComboModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_INTEGER_INPUT = DEFAULT_INPUTS_O_TEXT_INPUT.concat([
    'min',
    'max',
    'step',
    'grouping',
    'thousandSeparator : thousand-separator',
    'olocale : locale'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_INTEGER_INPUT = DEFAULT_OUTPUTS_O_TEXT_INPUT.slice();
var OIntegerInputComponent = /** @class */ (function (_super) {
    __extends(OIntegerInputComponent, _super);
    function OIntegerInputComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.inputType = 'number';
        _this.step = 1;
        _this.grouping = false;
        _this._defaultSQLTypeKey = 'INTEGER';
        // Firefox workaround
        if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
            _this.inputType = 'text';
        }
        _this.setComponentPipe();
        return _this;
    }
    /**
     * @return {?}
     */
    OIntegerInputComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        _super.prototype.initialize.call(this);
        this.initializeStep();
    };
    /**
     * @return {?}
     */
    OIntegerInputComponent.prototype.setComponentPipe = /**
     * @return {?}
     */
    function () {
        this.componentPipe = new OIntegerPipe(this.injector);
    };
    /**
     * @return {?}
     */
    OIntegerInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        this.pipeArguments = {
            grouping: this.grouping,
            thousandSeparator: this.thousandSeparator,
            locale: this.olocale
        };
        if (this.step === undefined) {
            this.step = 1;
        }
    };
    /**
     * @return {?}
     */
    OIntegerInputComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngAfterViewInit.call(this);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OIntegerInputComponent.prototype.setData = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        _super.prototype.setData.call(this, value);
        setTimeout(function () {
            _this.setPipeValue();
        }, 0);
    };
    /**
     * @param {?} val
     * @param {?=} options
     * @return {?}
     */
    OIntegerInputComponent.prototype.setValue = /**
     * @param {?} val
     * @param {?=} options
     * @return {?}
     */
    function (val, options) {
        _super.prototype.setValue.call(this, val, options);
        this.setPipeValue();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OIntegerInputComponent.prototype.innerOnFocus = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.isReadOnly) {
            return;
        }
        this.setNumberDOMValue(this.getValue());
        _super.prototype.innerOnFocus.call(this, event);
    };
    /**
     * @param {?=} event
     * @return {?}
     */
    OIntegerInputComponent.prototype.innerOnBlur = /**
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        if (this.isReadOnly) {
            return;
        }
        this.setPipeValue();
        /** @type {?} */
        var formControl = this.getControl();
        if (formControl) {
            formControl.updateValueAndValidity();
        }
        _super.prototype.innerOnBlur.call(this, event);
    };
    /**
     * @return {?}
     */
    OIntegerInputComponent.prototype.setPipeValue = /**
     * @return {?}
     */
    function () {
        if (typeof this.pipeArguments !== 'undefined' && !this.isEmpty()) {
            /** @type {?} */
            var parsedValue = this.componentPipe.transform(this.getValue(), this.pipeArguments);
            this.setTextDOMValue(parsedValue);
        }
    };
    /**
     * @return {?}
     */
    OIntegerInputComponent.prototype.isEmpty = /**
     * @return {?}
     */
    function () {
        if (this.value instanceof OFormValue) {
            if (this.value.value !== undefined) {
                return false;
            }
        }
        return true;
    };
    /**
     * @return {?}
     */
    OIntegerInputComponent.prototype.getInputEl = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var inputElement;
        if (this.elRef.nativeElement.tagName === 'INPUT') {
            inputElement = this.elRef.nativeElement;
        }
        else {
            inputElement = this.elRef.nativeElement.getElementsByTagName('INPUT')[0];
        }
        return inputElement;
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OIntegerInputComponent.prototype.setNumberDOMValue = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        /** @type {?} */
        var inputElement = this.getInputEl();
        if (Util.isDefined(inputElement)) {
            // Firefox workaround
            if (navigator.userAgent.toLowerCase().indexOf('firefox') === -1) {
                inputElement.type = 'number';
            }
            inputElement.value = (val !== undefined) ? val : '';
        }
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OIntegerInputComponent.prototype.setTextDOMValue = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        /** @type {?} */
        var inputElement = this.getInputEl();
        if (Util.isDefined(inputElement)) {
            // Firefox workaround
            if (navigator.userAgent.toLowerCase().indexOf('firefox') === -1) {
                inputElement.type = 'text';
            }
            inputElement.value = (val !== undefined) ? val : '';
        }
    };
    /**
     * @return {?}
     */
    OIntegerInputComponent.prototype.resolveValidators = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validators = _super.prototype.resolveValidators.call(this);
        if (Util.isDefined(this.min)) {
            validators.push(this.minValidator.bind(this));
        }
        if (Util.isDefined(this.max)) {
            validators.push(this.maxValidator.bind(this));
        }
        return validators;
    };
    /**
     * @param {?} control
     * @return {?}
     */
    OIntegerInputComponent.prototype.minValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if ((typeof (control.value) === 'number') && (control.value < this.min)) {
            return {
                min: {
                    requiredMin: this.min
                }
            };
        }
        return {};
    };
    /**
     * @param {?} control
     * @return {?}
     */
    OIntegerInputComponent.prototype.maxValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if ((typeof (control.value) === 'number') && (this.max < control.value)) {
            return {
                max: {
                    requiredMax: this.max
                }
            };
        }
        return {};
    };
    /**
     * @return {?}
     */
    OIntegerInputComponent.prototype.initializeStep = /**
     * @return {?}
     */
    function () {
        if (this.step <= 0) {
            this.step = 1;
            console.warn('`step` attribute must be greater than zero');
        }
    };
    OIntegerInputComponent.DEFAULT_INPUTS_O_INTEGER_INPUT = DEFAULT_INPUTS_O_INTEGER_INPUT;
    OIntegerInputComponent.DEFAULT_OUTPUTS_O_INTEGER_INPUT = DEFAULT_OUTPUTS_O_INTEGER_INPUT;
    OIntegerInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-integer-input',
                    template: "\n    <div [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\" [matTooltipClass]=\"tooltipClass\" [matTooltipPosition]=\"tooltipPosition\"\n      [matTooltipShowDelay]=\"tooltipShowDelay\" [matTooltipHideDelay]=\"tooltipHideDelay\">\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\"  [hideRequiredMarker]=\"hideRequiredMarker\" [class.custom-width]=\"hasCustomWidth\"\n        [class.icon-field]=\"showClearButton\" fxFlexFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input matInput [type]=\"inputType\" [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\" [placeholder]=\"placeHolder\"\n          (focus)=\"innerOnFocus($event)\" (blur)=\"innerOnBlur($event)\" (change)=\"onChangeEvent($event)\" [readonly]=\"isReadOnly\"\n          [min]=\"min\" [max]=\"max\" [step]=\"step\" [required]=\"isRequired\">\n        <button type=\"button\" *ngIf=\"showClearButton\" matSuffix mat-icon-button (click)=\"onClickClearValue($event)\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('min')\" text=\"{{ 'FORM_VALIDATION.MIN_VALUE' | oTranslate }}: {{ getErrorValue('min', 'requiredMin') }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('max')\" text=\"{{ 'FORM_VALIDATION.MAX_VALUE' | oTranslate }}: {{ getErrorValue('max', 'requiredMax') }}\"></mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_INTEGER_INPUT,
                    outputs: DEFAULT_OUTPUTS_O_INTEGER_INPUT,
                    encapsulation: core.ViewEncapsulation.None
                },] },
    ];
    /** @nocollapse */
    OIntegerInputComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OIntegerInputComponent.prototype, "min", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OIntegerInputComponent.prototype, "max", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OIntegerInputComponent.prototype, "step", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OIntegerInputComponent.prototype, "grouping", void 0);
    return OIntegerInputComponent;
}(OTextInputComponent));
var OIntegerInputModule = /** @class */ (function () {
    function OIntegerInputModule() {
    }
    OIntegerInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OIntegerInputComponent],
                    imports: [common.CommonModule, OSharedModule, OTextInputModule],
                    exports: [OIntegerInputComponent, OTextInputModule]
                },] },
    ];
    return OIntegerInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_REAL_INPUT = DEFAULT_INPUTS_O_INTEGER_INPUT.concat([
    'minDecimalDigits: min-decimal-digits',
    'maxDecimalDigits: max-decimal-digits',
    'decimalSeparator : decimal-separator'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_REAL_INPUT = DEFAULT_OUTPUTS_O_INTEGER_INPUT.slice();
var ORealInputComponent = /** @class */ (function (_super) {
    __extends(ORealInputComponent, _super);
    function ORealInputComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.minDecimalDigits = 2;
        _this.maxDecimalDigits = 2;
        _this.step = 0.01;
        _this.grouping = true;
        _this._defaultSQLTypeKey = 'FLOAT';
        return _this;
    }
    /**
     * @return {?}
     */
    ORealInputComponent.prototype.setComponentPipe = /**
     * @return {?}
     */
    function () {
        this.componentPipe = new ORealPipe(this.injector);
    };
    /**
     * @return {?}
     */
    ORealInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        this.pipeArguments.decimalSeparator = this.decimalSeparator;
        this.pipeArguments.minDecimalDigits = this.minDecimalDigits;
        this.pipeArguments.maxDecimalDigits = this.maxDecimalDigits;
    };
    /**
     * @return {?}
     */
    ORealInputComponent.prototype.resolveValidators = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validators = _super.prototype.resolveValidators.call(this);
        if (Util.isDefined(this.minDecimalDigits)) {
            validators.push(this.minDecimalDigitsValidator.bind(this));
        }
        if (Util.isDefined(this.maxDecimalDigits)) {
            validators.push(this.maxDecimalDigitsValidator.bind(this));
        }
        return validators;
    };
    /**
     * @param {?} control
     * @return {?}
     */
    ORealInputComponent.prototype.minDecimalDigitsValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        /** @type {?} */
        var ctrlValue = control.value;
        if (typeof control.value === 'number') {
            ctrlValue = ctrlValue.toString();
        }
        if (ctrlValue && ctrlValue.length) {
            /** @type {?} */
            var valArray = ctrlValue.split(this.decimalSeparator ? this.decimalSeparator : '.');
            if (Util.isDefined(this.minDecimalDigits) && (this.minDecimalDigits > 0) && Util.isDefined(valArray[1]) && (valArray[1].length < this.minDecimalDigits)) {
                return {
                    minDecimaldigits: {
                        requiredMinDecimaldigits: this.minDecimalDigits
                    }
                };
            }
        }
        return {};
    };
    /**
     * @param {?} control
     * @return {?}
     */
    ORealInputComponent.prototype.maxDecimalDigitsValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        /** @type {?} */
        var ctrlValue = control.value;
        if (typeof control.value === 'number') {
            ctrlValue = ctrlValue.toString();
        }
        if (ctrlValue && ctrlValue.length) {
            /** @type {?} */
            var valArray = ctrlValue.split(this.decimalSeparator ? this.decimalSeparator : '.');
            if (Util.isDefined(this.maxDecimalDigits) && (this.maxDecimalDigits > 0) && Util.isDefined(valArray[1]) && (valArray[1].length > this.maxDecimalDigits)) {
                return {
                    maxDecimaldigits: {
                        requiredMaxDecimaldigits: this.maxDecimalDigits
                    }
                };
            }
        }
        return {};
    };
    /**
     * @return {?}
     */
    ORealInputComponent.prototype.initializeStep = /**
     * @return {?}
     */
    function () {
        if (this.step <= 0) {
            this.step = 1 / Math.pow(10, this.maxDecimalDigits);
            console.warn('`step` attribute must be greater than zero');
        }
    };
    ORealInputComponent.DEFAULT_INPUTS_O_REAL_INPUT = DEFAULT_INPUTS_O_REAL_INPUT;
    ORealInputComponent.DEFAULT_OUTPUTS_O_REAL_INPUT = DEFAULT_OUTPUTS_O_REAL_INPUT;
    ORealInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-real-input',
                    template: "\n    <div [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\" [matTooltipClass]=\"tooltipClass\"\n      [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\">\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [hideRequiredMarker]=\"hideRequiredMarker\"\n        [class.custom-width]=\"hasCustomWidth\" [class.icon-field]=\"showClearButton\" fxFlexFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input matInput [type]=\"inputType\" [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\"\n          [placeholder]=\"placeHolder\" (focus)=\"innerOnFocus($event)\" (blur)=\"innerOnBlur($event)\"\n          (change)=\"onChangeEvent($event)\" [readonly]=\"isReadOnly\" [min]=\"min\" [max]=\"max\" [step]=\"step\"\n          [required]=\"isRequired\">\n        <button type=\"button\" *ngIf=\"showClearButton\" matSuffix mat-icon-button (click)=\"onClickClearValue($event)\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('min')\"\n          text=\"{{ 'FORM_VALIDATION.MIN_VALUE' | oTranslate }}: {{ getErrorValue('min', 'requiredMin') }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('max')\"\n          text=\"{{ 'FORM_VALIDATION.MAX_VALUE' | oTranslate }}: {{ getErrorValue('max', 'requiredMax') }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('minDecimaldigits')\"\n          text=\"{{ 'FORM_VALIDATION.MIN_DECIMAL_DIGITS' | oTranslate }}: {{ getErrorValue('minDecimaldigits', 'requiredMinDecimaldigits') }}\">\n        </mat-error>\n        <mat-error *ngIf=\"hasError('maxDecimaldigits')\"\n          text=\"{{ 'FORM_VALIDATION.MAX_DECIMAL_DIGITS' | oTranslate }}: {{ getErrorValue('maxDecimaldigits', 'requiredMaxDecimaldigits') }}\">\n        </mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_REAL_INPUT,
                    outputs: DEFAULT_OUTPUTS_O_REAL_INPUT,
                    encapsulation: core.ViewEncapsulation.None
                },] },
    ];
    /** @nocollapse */
    ORealInputComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], ORealInputComponent.prototype, "minDecimalDigits", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], ORealInputComponent.prototype, "maxDecimalDigits", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], ORealInputComponent.prototype, "step", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], ORealInputComponent.prototype, "grouping", void 0);
    return ORealInputComponent;
}(OIntegerInputComponent));
var ORealInputModule = /** @class */ (function () {
    function ORealInputModule() {
    }
    ORealInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [ORealInputComponent],
                    imports: [common.CommonModule, OSharedModule, OIntegerInputModule],
                    exports: [OIntegerInputModule, ORealInputComponent]
                },] },
    ];
    return ORealInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_CURRENCY_INPUT = DEFAULT_INPUTS_O_REAL_INPUT.concat([
    'currencySymbol: currency-symbol',
    'currencySymbolPosition: currency-symbol-position'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_CURRENCY_INPUT = DEFAULT_OUTPUTS_O_REAL_INPUT.slice();
var OCurrencyInputComponent = /** @class */ (function (_super) {
    __extends(OCurrencyInputComponent, _super);
    function OCurrencyInputComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.currency_symbols = {
            'CRC': '',
            // Costa Rican Coln
            'NGN': '',
            // Nigerian Naira
            'PHP': '',
            // Philippine Peso
            'PLN': 'z',
            // Polish Zloty
            'PYG': '',
            // Paraguayan Guarani
            'THB': '',
            // Thai Baht
            'UAH': '',
            // Ukrainian Hryvnia
            'VND': '',
        };
        _this.currencySymbol = 'EUR';
        _this.currencySymbolPosition = 'right';
        return _this;
    }
    /**
     * @return {?}
     */
    OCurrencyInputComponent.prototype.existsOntimizeIcon = /**
     * @return {?}
     */
    function () {
        return OCurrencyInputComponent.currency_icons.indexOf(this.currencySymbol) !== -1;
    };
    /**
     * @param {?} position
     * @return {?}
     */
    OCurrencyInputComponent.prototype.useIcon = /**
     * @param {?} position
     * @return {?}
     */
    function (position) {
        return this.existsOntimizeIcon() && this.currencySymbolPosition === position;
    };
    /**
     * @param {?} position
     * @return {?}
     */
    OCurrencyInputComponent.prototype.useSymbol = /**
     * @param {?} position
     * @return {?}
     */
    function (position) {
        return this.currency_symbols.hasOwnProperty(this.currencySymbol) && this.currencySymbolPosition === position;
    };
    OCurrencyInputComponent.DEFAULT_INPUTS_O_CURRENCY_INPUT = DEFAULT_INPUTS_O_CURRENCY_INPUT;
    OCurrencyInputComponent.DEFAULT_OUTPUTS_O_CURRENCY_INPUT = DEFAULT_OUTPUTS_O_CURRENCY_INPUT;
    OCurrencyInputComponent.currency_icons = ['USD', 'EUR', 'GBP', 'ILS', 'INR', 'JPY', 'KRW', 'BTC'];
    OCurrencyInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-currency-input',
                    template: "\n    <div [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\" [matTooltipClass]=\"tooltipClass\"\n      [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n\n      <div *ngIf=\"useSymbol('left')\" matSuffix class=\"icon-btn\" [class.mat-disabled]=\"!enabled\">\n        {{ currency_symbols[currencySymbol] }}\n      </div>\n      <mat-icon *ngIf=\"useIcon('left')\" svgIcon=\"ontimize:{{currencySymbol}}\" matSuffix class=\"svg-icon\"\n        [class.mat-disabled]=\"!enabled\"></mat-icon>\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [hideRequiredMarker]=\"hideRequiredMarker\"\n        [class.custom-width]=\"hasCustomWidth\" class=\"icon-field\" fxFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input matInput [type]=\"inputType\" [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\"\n          [placeholder]=\"placeHolder\" (focus)=\"innerOnFocus($event)\" (blur)=\"innerOnBlur($event)\" [readonly]=\"isReadOnly\"\n          [min]=\"min\" [max]=\"max\" [step]=\"step\" [required]=\"isRequired\" (change)=\"onChangeEvent($event)\">\n\n        <button type=\"button\" *ngIf=\"showClearButton\" matSuffix mat-icon-button (click)=\"onClickClearValue($event)\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n        <div *ngIf=\"useSymbol('right')\" matSuffix class=\"icon-btn\" [class.mat-disabled]=\"!enabled\">\n          {{ currency_symbols[currencySymbol] }}\n        </div>\n        <mat-icon *ngIf=\"useIcon('right')\" svgIcon=\"ontimize:{{currencySymbol}}\" matSuffix class=\"svg-icon\"\n          [class.mat-disabled]=\"!enabled\">\n        </mat-icon>\n\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('min')\"\n          text=\"{{ 'FORM_VALIDATION.MIN_VALUE' | oTranslate }}: {{ getErrorValue('min', 'requiredMin') }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('max')\"\n          text=\"{{ 'FORM_VALIDATION.MAX_VALUE' | oTranslate }}: {{ getErrorValue('max', 'requiredMax') }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('minDecimaldigits')\"\n          text=\"{{ 'FORM_VALIDATION.MIN_DECIMAL_DIGITS' | oTranslate }}: {{ getErrorValue('minDecimaldigits', 'requiredMinDecimaldigits') }}\">\n        </mat-error>\n        <mat-error *ngIf=\"hasError('maxDecimaldigits')\"\n          text=\"{{ 'FORM_VALIDATION.MAX_DECIMAL_DIGITS' | oTranslate }}: {{ getErrorValue('maxDecimaldigits', 'requiredMaxDecimaldigits') }}\">\n        </mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ["\n    o-currency-input input{padding-right:8px}o-currency-input input .mat-form-field-wrapper .mat-input-table .mat-form-field-infix .mat-input-element{text-align:end}\n  "],
                    inputs: DEFAULT_INPUTS_O_CURRENCY_INPUT,
                    outputs: DEFAULT_OUTPUTS_O_CURRENCY_INPUT,
                    encapsulation: core.ViewEncapsulation.None
                },] },
    ];
    return OCurrencyInputComponent;
}(ORealInputComponent));
var OCurrencyInputModule = /** @class */ (function () {
    function OCurrencyInputModule() {
    }
    OCurrencyInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OCurrencyInputComponent],
                    imports: [common.CommonModule, OSharedModule, ORealInputModule],
                    exports: [OCurrencyInputComponent, ORealInputModule]
                },] },
    ];
    return OCurrencyInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var EMAIL_REGEXP = /[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?/;
/** @type {?} */
var DNI_PATTERN = '^(([0-9]{8})([-]?)([a-zA-Z]{1}))$';
/** @type {?} */
var NIE_PATTERN = '^(([x-zX-Z]{1})([-]?)([0-9]{7})([-]?)([a-zA-Z]{1}))$';
/** @type {?} */
var DNI_CHECK = 'TRWAGMYFPDXBNJZSQVHLCKET';
/** @type {?} */
var NUMBERS = '0123456789';
/** @type {?} */
var TWELVE_HOUR_FORMAT_PATTERN = '^(([0-9]|([01]?[0-9])):([0-9]|([0-5][0-9])) *([AaPp][Mm])*)$';
/** @type {?} */
var TWENTY_FOUR_HOUR_FORMAT_PATTERN = '^([0-9]|([01]?[0-9]|2[0-3])):[0-9]|([0-5][0-9])$';
var OValidators = /** @class */ (function () {
    function OValidators() {
    }
    /**
     * Hour validator hh:mm am/pm format
     * @param {?} control
     * @return {?}
     */
    OValidators.twelveHourFormatValidator = /**
     * Hour validator hh:mm am/pm format
     * @param {?} control
     * @return {?}
     */
    function (control) {
        /** @type {?} */
        var regExp = new RegExp(TWELVE_HOUR_FORMAT_PATTERN);
        if (control.value && typeof control.value === 'string' && !regExp.test(control.value)) {
            return { invalidFormatHour: true };
        }
        return {};
    };
    /**
     * Hour validator HH:mm format
     * @param {?} control
     * @return {?}
     */
    OValidators.twentyFourHourFormatValidator = /**
     * Hour validator HH:mm format
     * @param {?} control
     * @return {?}
     */
    function (control) {
        /** @type {?} */
        var regExp = new RegExp(TWENTY_FOUR_HOUR_FORMAT_PATTERN);
        if (control.value && typeof control.value === 'string' && !regExp.test(control.value)) {
            return { invalidFormatHour: true };
        }
        return {};
    };
    /**
     * Email validator
     * @param {?} control
     * @return {?}
     */
    OValidators.emailValidator = /**
     * Email validator
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (control.value && control.value.length > 0 && !EMAIL_REGEXP.test(control.value)) {
            return { invalidEmailAddress: true };
        }
        return {};
    };
    /**
     * NIF validator
     * @param {?} control
     * @return {?}
     */
    OValidators.nifValidator = /**
     * NIF validator
     * @param {?} control
     * @return {?}
     */
    function (control) {
        /** @type {?} */
        var newValue = control.value;
        /** @type {?} */
        var regExp = new RegExp(DNI_PATTERN + '|' + NIE_PATTERN);
        /** @type {?} */
        var valueWithoutDashes = '';
        for (var i in newValue) {
            if (newValue[i] !== '-') {
                valueWithoutDashes = valueWithoutDashes + newValue[i];
            }
        }
        if (valueWithoutDashes.length > 1) {
            /** @type {?} */
            var firstChar = valueWithoutDashes.charAt(0);
            if (NUMBERS.indexOf(firstChar) !== -1) {
                /** @type {?} */
                var number = valueWithoutDashes.substring(0, valueWithoutDashes.length - 1);
                /** @type {?} */
                var pos = parseInt(number, 10) % 23;
                /** @type {?} */
                var expectedLetter = DNI_CHECK.substring(pos, pos + 1);
                /** @type {?} */
                var letter = valueWithoutDashes.charAt(valueWithoutDashes.length - 1);
                /** @type {?} */
                var dniLetterError = (expectedLetter !== letter.toUpperCase());
                if (dniLetterError) {
                    return { invalidNIFLetter: true };
                }
                else {
                    if (!regExp.test(valueWithoutDashes)) {
                        return { invalidNIF: true };
                    }
                }
            }
            else {
                if (!regExp.test(valueWithoutDashes)) {
                    return { invalidNIF: true };
                }
            }
        }
        return undefined;
    };
    return OValidators;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_EMAIL_INPUT = DEFAULT_INPUTS_O_TEXT_INPUT.slice();
/** @type {?} */
var DEFAULT_OUTPUTS_O_EMAIL_INPUT = DEFAULT_OUTPUTS_O_TEXT_INPUT.slice();
var OEmailInputComponent = /** @class */ (function (_super) {
    __extends(OEmailInputComponent, _super);
    function OEmailInputComponent(form, elRef, injector) {
        return _super.call(this, form, elRef, injector) || this;
    }
    /**
     * @return {?}
     */
    OEmailInputComponent.prototype.resolveValidators = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validators = _super.prototype.resolveValidators.call(this);
        //Inject email validator
        validators.push(OValidators.emailValidator);
        return validators;
    };
    OEmailInputComponent.DEFAULT_INPUTS_O_EMAIL_INPUT = DEFAULT_INPUTS_O_EMAIL_INPUT;
    OEmailInputComponent.DEFAULT_OUTPUTS_O_EMAIL_INPUT = DEFAULT_OUTPUTS_O_EMAIL_INPUT;
    OEmailInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-email-input',
                    template: "\n    <div fxLayout=\"row\" fxLayoutAlign=\"space-between center\" [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\"\n      [matTooltipClass]=\"tooltipClass\" [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\">\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [hideRequiredMarker]=\"hideRequiredMarker\"\n        [class.custom-width]=\"hasCustomWidth\" class=\"icon-field\" fxFlexFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input matInput type=\"email\" [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\" [placeholder]=\"placeHolder\"\n          (focus)=\"innerOnFocus($event)\" (blur)=\"innerOnBlur($event)\" [readonly]=\"isReadOnly\" [required]=\"isRequired\"\n          (change)=\"onChangeEvent($event)\">\n        <button type=\"button\" *ngIf=\"showClearButton\" matSuffix mat-icon-button (click)=\"onClickClearValue($event)\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n        <mat-icon matSuffix [class.mat-disabled]=\"!enabled\" svgIcon=\"ontimize:mail_outline\"></mat-icon>\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('minlength')\"\n          text=\"{{ 'FORM_VALIDATION.MIN_LENGTH' | oTranslate }}: {{ getErrorValue('minlength', 'requiredLength') }}\">\n        </mat-error>\n        <mat-error *ngIf=\"hasError('maxlength')\"\n          text=\"{{ 'FORM_VALIDATION.MAX_LENGTH' | oTranslate }}: {{ getErrorValue('maxlength', 'requiredLength') }}\">\n        </mat-error>\n        <mat-error *ngIf=\"hasError('invalidEmailAddress')\" text=\"{{ 'FORM_VALIDATION.EMAIL_FORMAT' | oTranslate }}\">\n        </mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_EMAIL_INPUT,
                    outputs: DEFAULT_OUTPUTS_O_EMAIL_INPUT,
                    encapsulation: core.ViewEncapsulation.None
                },] },
    ];
    /** @nocollapse */
    OEmailInputComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    return OEmailInputComponent;
}(OTextInputComponent));
var OEmailInputModule = /** @class */ (function () {
    function OEmailInputModule() {
    }
    OEmailInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OEmailInputComponent],
                    imports: [OSharedModule, common.CommonModule, OTextInputModule],
                    exports: [OEmailInputComponent, OTextInputModule]
                },] },
    ];
    return OEmailInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OFileItem = /** @class */ (function () {
    function OFileItem(file, uploader) {
        this.index = void 0;
        this.isReady = false;
        this.isUploading = false;
        this.isUploaded = false;
        this.isSuccess = false;
        this.isCancel = false;
        this.isError = false;
        this.progress = 0;
        this._file = file;
        this.uploader = uploader;
    }
    /**
     * @return {?}
     */
    OFileItem.prototype.upload = /**
     * @return {?}
     */
    function () {
        this.uploader.uploadItem(this);
    };
    /**
     * @return {?}
     */
    OFileItem.prototype.cancel = /**
     * @return {?}
     */
    function () {
        this.uploader.cancelItem(this);
    };
    /**
     * @return {?}
     */
    OFileItem.prototype.remove = /**
     * @return {?}
     */
    function () {
        this.uploader.removeFile(this);
    };
    /**
     * @return {?}
     */
    OFileItem.prototype.prepareToUpload = /**
     * @return {?}
     */
    function () {
        this.index = this.index || ++this.uploader.nextIndex;
        this.isReady = true;
    };
    Object.defineProperty(OFileItem.prototype, "file", {
        get: /**
         * @return {?}
         */
        function () {
            return this._file;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFileItem.prototype, "name", {
        get: /**
         * @return {?}
         */
        function () {
            return this._file.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFileItem.prototype, "size", {
        get: /**
         * @return {?}
         */
        function () {
            return this._file.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFileItem.prototype, "type", {
        get: /**
         * @return {?}
         */
        function () {
            return this._file.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFileItem.prototype, "lastModifiedDate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._file.lastModifiedDate;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?=} notify
     * @return {?}
     */
    OFileItem.prototype._onBeforeUpload = /**
     * @param {?=} notify
     * @return {?}
     */
    function (notify) {
        if (notify === void 0) { notify = true; }
        this.isReady = true;
        this.isUploading = true;
        this.isUploaded = false;
        this.isSuccess = false;
        this.isCancel = false;
        this.isError = false;
        this.progress = 0;
        if (notify) {
            this.onBeforeUpload();
        }
    };
    /**
     * @param {?} progress
     * @return {?}
     */
    OFileItem.prototype._onProgress = /**
     * @param {?} progress
     * @return {?}
     */
    function (progress) {
        this.progress = progress;
        this.onProgress(progress);
    };
    /**
     * @param {?} data
     * @param {?=} notify
     * @return {?}
     */
    OFileItem.prototype._onSuccess = /**
     * @param {?} data
     * @param {?=} notify
     * @return {?}
     */
    function (data, notify) {
        if (notify === void 0) { notify = true; }
        this.index = void 0;
        this.isReady = false;
        this.isUploading = false;
        this.isUploaded = true;
        this.isSuccess = true;
        this.isCancel = false;
        this.isError = false;
        this.progress = 100;
        if (notify) {
            this.onSuccess(data);
        }
    };
    /**
     * @param {?} error
     * @param {?=} notify
     * @return {?}
     */
    OFileItem.prototype._onError = /**
     * @param {?} error
     * @param {?=} notify
     * @return {?}
     */
    function (error, notify) {
        if (notify === void 0) { notify = true; }
        this.index = void 0;
        this.isReady = false;
        this.isUploading = false;
        this.isUploaded = true;
        this.isSuccess = false;
        this.isCancel = false;
        this.isError = true;
        this.progress = 0;
        if (notify) {
            this.onError(error);
        }
    };
    /**
     * @param {?=} notify
     * @return {?}
     */
    OFileItem.prototype._onCancel = /**
     * @param {?=} notify
     * @return {?}
     */
    function (notify) {
        if (notify === void 0) { notify = true; }
        this.isReady = false;
        this.isUploading = false;
        this.isUploaded = false;
        this.isSuccess = false;
        this.isCancel = true;
        this.isError = false;
        this.progress = 0;
        this.index = void 0;
        if (notify) {
            this.onCancel();
        }
    };
    /**
     * @param {?=} notify
     * @return {?}
     */
    OFileItem.prototype._onComplete = /**
     * @param {?=} notify
     * @return {?}
     */
    function (notify) {
        if (notify === void 0) { notify = true; }
        if (notify) {
            this.onComplete();
        }
    };
    /**
     * @return {?}
     */
    OFileItem.prototype.onBeforeUpload = /**
     * @return {?}
     */
    function () {
        return {};
    };
    /**
     * @param {?} progress
     * @return {?}
     */
    OFileItem.prototype.onProgress = /**
     * @param {?} progress
     * @return {?}
     */
    function (progress) {
        return { progress: progress };
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OFileItem.prototype.onSuccess = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return { data: data };
    };
    /**
     * @param {?} error
     * @return {?}
     */
    OFileItem.prototype.onError = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        return { error: error };
    };
    /**
     * @return {?}
     */
    OFileItem.prototype.onCancel = /**
     * @return {?}
     */
    function () {
        return {};
    };
    /**
     * @return {?}
     */
    OFileItem.prototype.onComplete = /**
     * @return {?}
     */
    function () {
        return {};
    };
    Object.defineProperty(OFileItem.prototype, "pendingUpload", {
        get: /**
         * @return {?}
         */
        function () {
            return !this.isUploaded && !this.isUploading && !this.isCancel;
        },
        enumerable: true,
        configurable: true
    });
    return OFileItem;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OFileUploader = /** @class */ (function () {
    function OFileUploader(service, entity) {
        this.service = service;
        this.files = [];
        this.isUploading = false;
        this.progress = 0;
        this.nextIndex = 0;
        this.splitUpload = true;
        this.entity = entity;
    }
    /**
     * @param {?} fileItem
     * @return {?}
     */
    OFileUploader.prototype.addFile = /**
     * @param {?} fileItem
     * @return {?}
     */
    function (fileItem) {
        this.files.push(fileItem);
        this.progress = this._getTotalProgress();
    };
    /**
     * Cancels the upload of all files and remove them from the file list.
     */
    /**
     * Cancels the upload of all files and remove them from the file list.
     * @return {?}
     */
    OFileUploader.prototype.clear = /**
     * Cancels the upload of all files and remove them from the file list.
     * @return {?}
     */
    function () {
        this.cancel();
        while (this.files.length) {
            this.files[0].remove();
        }
        this.progress = 0;
    };
    /**
     * Removes a file from the file list, it cancels upload if needed.
     * @param value the file to remove
     */
    /**
     * Removes a file from the file list, it cancels upload if needed.
     * @param {?} value the file to remove
     * @return {?}
     */
    OFileUploader.prototype.removeFile = /**
     * Removes a file from the file list, it cancels upload if needed.
     * @param {?} value the file to remove
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var index = this.getIndexOfItem(value);
        /** @type {?} */
        var item = this.files[index];
        if (item) {
            if (item.isUploading) {
                item.cancel();
            }
            this.files.splice(index, 1);
            this.progress = this._getTotalProgress();
        }
    };
    /**
     * @return {?}
     */
    OFileUploader.prototype.upload = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.files.map(function (item) {
            if (item.pendingUpload) {
                item.prepareToUpload();
            }
        });
        if (this.splitUpload) {
            this.files.map(function (item) {
                if (item.pendingUpload) {
                    _this.uploadItem(item);
                }
            });
        }
        else {
            this.uploadItems(this.files);
        }
    };
    /**
     * Uploads a single file on a single request.
     * @param {?} item the file to upload
     * @return {?}
     */
    OFileUploader.prototype.uploadItem = /**
     * Uploads a single file on a single request.
     * @param {?} item the file to upload
     * @return {?}
     */
    function (item) {
        item.prepareToUpload();
        if (this.isUploading || item.isUploading) {
            return;
        }
        this.isUploading = true;
        item.isUploading = true;
        this._onBeforeUploadItem(item);
        if (this.service === undefined) {
            console.warn('No service configured! aborting upload');
            return;
        }
        if (this._uploadSuscription) {
            this._uploadSuscription.unsubscribe();
        }
        /** @type {?} */
        var self = this;
        this._uploadSuscription = item._uploadSuscription = this.service.upload([item], this.entity, this.data).subscribe(function (resp) {
            if (resp.loaded && resp.total) {
                /** @type {?} */
                var progress = Math.round(resp.loaded * 100 / resp.total);
                self._onProgressItem(item, progress);
            }
            else if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                self._onSuccessItem(item, resp);
            }
            else {
                console.error('uploadItem error');
                self._onErrorItem(item, 'Unknow error');
            }
        }, function (err) { return self._onErrorItem(item, err); }, function () { return self._onCompleteItem(item); });
    };
    /**
     * Upload a set of files on a single request.
     * @param {?} items the array of files to upload
     * @return {?}
     */
    OFileUploader.prototype.uploadItems = /**
     * Upload a set of files on a single request.
     * @param {?} items the array of files to upload
     * @return {?}
     */
    function (items) {
        if (this.isUploading || items.some(function (item) { return item.isUploading; })) {
            return;
        }
        this.isUploading = true;
        this._onBeforeUploadAll();
        if (this.service === undefined) {
            console.warn('No service configured! aborting upload');
            return;
        }
        if (this._uploadSuscription) {
            this._uploadSuscription.unsubscribe();
        }
        /** @type {?} */
        var self = this;
        this._uploadSuscription = this.service.upload(items, this.entity, this.data).subscribe(function (resp) {
            if (resp.loaded && resp.total) {
                /** @type {?} */
                var progress = Math.round(resp.loaded * 100 / resp.total);
                self._onProgressAll(progress);
            }
            else if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                self._onSuccessAll(resp);
            }
            else {
                console.error('uploadItems error');
            }
        }, function (err) { return self._onErrorAll(err); }, function () { return self._onCompleteAll(); });
    };
    /**
     * Cancels the upload of all files.
     * @return {?}
     */
    OFileUploader.prototype.cancel = /**
     * Cancels the upload of all files.
     * @return {?}
     */
    function () {
        if (this.splitUpload) {
            this.files.map(function (item) { return item.cancel(); });
        }
        else {
            if (this._uploadSuscription) {
                this._uploadSuscription.unsubscribe();
            }
            this._onCancelAll();
            this._onCompleteAll();
        }
    };
    /**
     * Cancels the the file upload.
     * @param {?} value the file to cancel its upload
     * @return {?}
     */
    OFileUploader.prototype.cancelItem = /**
     * Cancels the the file upload.
     * @param {?} value the file to cancel its upload
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var index = this.getIndexOfItem(value);
        /** @type {?} */
        var item = this.files[index];
        if (item && item.isUploading && this.splitUpload) {
            item._uploadSuscription.unsubscribe();
        }
        this._onCancelItem(item);
        this._onCompleteItem(item);
    };
    /**
     * @return {?}
     */
    OFileUploader.prototype.getNotUploadedItems = /**
     * @return {?}
     */
    function () {
        return this.files.filter(function (item) { return !item.isUploaded; });
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OFileUploader.prototype.getIndexOfItem = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return typeof value === 'number' ? value : this.files.indexOf(value);
    };
    /**
     * @param {?} fileItem
     * @return {?}
     */
    OFileUploader.prototype.onBeforeUploadItem = /**
     * @param {?} fileItem
     * @return {?}
     */
    function (fileItem) {
        return { fileItem: fileItem };
    };
    /**
     * @return {?}
     */
    OFileUploader.prototype.onBeforeUploadAll = /**
     * @return {?}
     */
    function () {
        return {};
    };
    /**
     * @param {?} fileItem
     * @param {?} progress
     * @return {?}
     */
    OFileUploader.prototype.onProgressItem = /**
     * @param {?} fileItem
     * @param {?} progress
     * @return {?}
     */
    function (fileItem, progress) {
        return { fileItem: fileItem, progress: progress };
    };
    /**
     * @param {?} progress
     * @return {?}
     */
    OFileUploader.prototype.onProgressAll = /**
     * @param {?} progress
     * @return {?}
     */
    function (progress) {
        return { progress: progress };
    };
    /**
     * @param {?} fileItem
     * @return {?}
     */
    OFileUploader.prototype.onCancelItem = /**
     * @param {?} fileItem
     * @return {?}
     */
    function (fileItem) {
        return { fileItem: fileItem };
    };
    /**
     * @return {?}
     */
    OFileUploader.prototype.onCancelAll = /**
     * @return {?}
     */
    function () {
        return {};
    };
    /**
     * @param {?} fileItem
     * @param {?} response
     * @return {?}
     */
    OFileUploader.prototype.onSuccessItem = /**
     * @param {?} fileItem
     * @param {?} response
     * @return {?}
     */
    function (fileItem, response) {
        return { fileItem: fileItem, response: response };
    };
    /**
     * @param {?} response
     * @return {?}
     */
    OFileUploader.prototype.onSuccessAll = /**
     * @param {?} response
     * @return {?}
     */
    function (response) {
        return { response: response };
    };
    /**
     * @param {?} fileItem
     * @param {?} error
     * @return {?}
     */
    OFileUploader.prototype.onErrorItem = /**
     * @param {?} fileItem
     * @param {?} error
     * @return {?}
     */
    function (fileItem, error) {
        return { fileItem: fileItem, error: error };
    };
    /**
     * @param {?} error
     * @return {?}
     */
    OFileUploader.prototype.onErrorAll = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        return { error: error };
    };
    /**
     * @param {?} fileItem
     * @return {?}
     */
    OFileUploader.prototype.onCompleteItem = /**
     * @param {?} fileItem
     * @return {?}
     */
    function (fileItem) {
        return { fileItem: fileItem };
    };
    /**
     * @return {?}
     */
    OFileUploader.prototype.onCompleteAll = /**
     * @return {?}
     */
    function () {
        return void 0;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OFileUploader.prototype._onBeforeUploadItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        item._onBeforeUpload();
        this.onBeforeUploadItem(item);
    };
    /**
     * @return {?}
     */
    OFileUploader.prototype._onBeforeUploadAll = /**
     * @return {?}
     */
    function () {
        this.files.map(function (item) { return item._onBeforeUpload(false); });
        this.onBeforeUploadAll();
    };
    /**
     * @param {?} item
     * @param {?} progress
     * @return {?}
     */
    OFileUploader.prototype._onProgressItem = /**
     * @param {?} item
     * @param {?} progress
     * @return {?}
     */
    function (item, progress) {
        /** @type {?} */
        var total = this._getTotalProgress(progress);
        this.progress = total;
        item._onProgress(progress);
        this.onProgressItem(item, progress);
        this.onProgressAll(total);
    };
    /**
     * @param {?} progress
     * @return {?}
     */
    OFileUploader.prototype._onProgressAll = /**
     * @param {?} progress
     * @return {?}
     */
    function (progress) {
        /** @type {?} */
        var total = this._getTotalProgress(progress);
        this.progress = total;
        this.onProgressAll(total);
    };
    /**
     * @param {?} item
     * @param {?} response
     * @return {?}
     */
    OFileUploader.prototype._onSuccessItem = /**
     * @param {?} item
     * @param {?} response
     * @return {?}
     */
    function (item, response) {
        item._onSuccess(response);
        this.onSuccessItem(item, response);
    };
    /**
     * @param {?} response
     * @return {?}
     */
    OFileUploader.prototype._onSuccessAll = /**
     * @param {?} response
     * @return {?}
     */
    function (response) {
        this.files.map(function (item) { return item._onSuccess(response, false); });
        this.onSuccessAll(response);
    };
    /**
     * @param {?} item
     * @param {?} error
     * @return {?}
     */
    OFileUploader.prototype._onErrorItem = /**
     * @param {?} item
     * @param {?} error
     * @return {?}
     */
    function (item, error) {
        item._onError(error);
        this.onErrorItem(item, error);
    };
    /**
     * @param {?} error
     * @return {?}
     */
    OFileUploader.prototype._onErrorAll = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        this.files.map(function (item) { return item._onError(error, false); });
        this.onErrorAll(error);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OFileUploader.prototype._onCancelItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        item._onCancel();
        this.onCancelItem(item);
    };
    /**
     * @return {?}
     */
    OFileUploader.prototype._onCancelAll = /**
     * @return {?}
     */
    function () {
        this.files.map(function (item) { return item._onCancel(false); });
        this.onCancelAll();
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OFileUploader.prototype._onCompleteItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        item._onComplete();
        this.onCompleteItem(item);
        /** @type {?} */
        var nextItem = this._getReadyItems()[0];
        this.isUploading = false;
        if (nextItem) {
            nextItem.upload();
            return;
        }
        this.onCompleteAll();
        this.progress = this._getTotalProgress();
    };
    /**
     * @return {?}
     */
    OFileUploader.prototype._onCompleteAll = /**
     * @return {?}
     */
    function () {
        this.files.map(function (item) { return item._onComplete(false); });
        this.isUploading = false;
        this.onCompleteAll();
        this.progress = this._getTotalProgress();
    };
    /**
     * @return {?}
     */
    OFileUploader.prototype._getReadyItems = /**
     * @return {?}
     */
    function () {
        return this.files
            .filter(function (item) { return (item.isReady && !item.isUploading); })
            .sort(function (item1, item2) { return item1.index - item2.index; });
    };
    /**
     * @param {?=} value
     * @return {?}
     */
    OFileUploader.prototype._getTotalProgress = /**
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (value === void 0) { value = 0; }
        /** @type {?} */
        var notUploaded = this.getNotUploadedItems().length;
        /** @type {?} */
        var uploaded = notUploaded ? this.files.length - notUploaded : this.files.length;
        /** @type {?} */
        var ratio = this.splitUpload ? 100 / this.files.length : 100;
        /** @type {?} */
        var current = value * ratio / 100;
        return Math.round(uploaded * ratio + current);
    };
    return OFileUploader;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_FILE_INPUT = [
    'oattr: attr',
    'olabel: label',
    'floatLabel: float-label',
    'oplaceholder: placeholder',
    'tooltip',
    'tooltipPosition: tooltip-position',
    'tooltipShowDelay: tooltip-show-delay',
    'tooltipHideDelay: tooltip-hide-delay',
    'enabled',
    'orequired: required',
    'service',
    'entity',
    'serviceType : service-type',
    'width',
    'readOnly: read-only',
    'clearButton: clear-button',
    'acceptFileType: accept-file-type',
    'maxFileSize: max-file-size',
    'multiple',
    'maxFiles: max-files',
    'showInfo: show-info',
    'splitUpload: split-upload',
    'additionalData: additional-data',
    'appearance',
    'hideRequiredMarker:hide-required-marker',
    'labelVisible:label-visible'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_FILE_INPUT = DEFAULT_OUTPUTS_O_FORM_DATA_COMPONENT.concat([
    'onBeforeUpload',
    'onBeforeUploadFile',
    'onProgress',
    'onProgressFile',
    'onCancel',
    'onCancelFile',
    'onUpload',
    'onUploadFile',
    'onComplete',
    'onCompleteFile',
    'onError',
    'onErrorFile'
]);
var OFileInputComponent = /** @class */ (function (_super) {
    __extends(OFileInputComponent, _super);
    function OFileInputComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.autoBinding = false;
        _this.autoRegistering = false;
        _this.showInfo = false;
        _this.multiple = false;
        _this.splitUpload = true;
        _this.maxFiles = -1;
        _this.onBeforeUpload = new core.EventEmitter();
        _this.onBeforeUploadFile = new core.EventEmitter();
        _this.onProgress = new core.EventEmitter();
        _this.onProgressFile = new core.EventEmitter();
        _this.onCancel = new core.EventEmitter();
        _this.onCancelFile = new core.EventEmitter();
        _this.onUpload = new core.EventEmitter();
        _this.onUploadFile = new core.EventEmitter();
        _this.onComplete = new core.EventEmitter();
        _this.onCompleteFile = new core.EventEmitter();
        _this.onError = new core.EventEmitter();
        _this.onErrorFile = new core.EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    OFileInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.initialize();
        this.uploader.onBeforeUploadAll = function () { return _this.onBeforeUpload.emit(); };
        this.uploader.onBeforeUploadItem = function (item) { return _this.onBeforeUploadFile.emit(item); };
        this.uploader.onProgressAll = function (progress) { return _this.onProgress.emit(progress); };
        this.uploader.onProgressItem = function (item, progress) { return _this.onProgressFile.emit({ item: item, progress: progress }); };
        this.uploader.onCancelAll = function () { return _this.onCancel.emit(); };
        this.uploader.onCancelItem = function (item) { return _this.onCancelFile.emit(); };
        this.uploader.onSuccessAll = function (response) { return _this.onUpload.emit({ response: response }); };
        this.uploader.onSuccessItem = function (item, response) { return _this.onUploadFile.emit({ item: item, response: response }); };
        this.uploader.onCompleteAll = function () { return _this.onComplete.emit(); };
        this.uploader.onCompleteItem = function (item) { return _this.onCompleteFile.emit(item); };
        this.uploader.onErrorAll = function (error) { return _this.onError.emit(error); };
        this.uploader.onErrorItem = function (item, error) { return _this.onErrorFile.emit({ item: item, error: error }); };
    };
    /**
     * @return {?}
     */
    OFileInputComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        _super.prototype.initialize.call(this);
        if (!this.service) {
            this.service = this.form.service;
        }
        if (!this.entity) {
            this.entity = this.form.entity;
        }
        this.configureService();
        this.uploader = new OFileUploader(this.fileService, this.entity);
        this.uploader.splitUpload = this.splitUpload;
    };
    /**
     * @return {?}
     */
    OFileInputComponent.prototype.configureService = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var loadingService = OntimizeFileService$$1;
        if (this.serviceType) {
            loadingService = this.serviceType;
        }
        try {
            this.fileService = this.injector.get(loadingService);
            if (this.fileService) {
                /** @type {?} */
                var serviceCfg = this.fileService.getDefaultServiceConfiguration(this.service);
                if (this.entity) {
                    serviceCfg.entity = this.entity;
                }
                this.fileService.configureService(serviceCfg);
            }
        }
        catch (e) {
            console.error(e);
        }
    };
    /**
     * @return {?}
     */
    OFileInputComponent.prototype.resolveValidators = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validators = _super.prototype.resolveValidators.call(this);
        if (this.acceptFileType) {
            validators.push(this.filetypeValidator.bind(this));
        }
        if (this.maxFileSize) {
            validators.push(this.maxFileSizeValidator.bind(this));
        }
        if (this.multiple && this.maxFiles !== -1) {
            validators.push(this.maxFilesValidator.bind(this));
        }
        return validators;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OFileInputComponent.prototype.fileSelected = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var value = '';
        if (event) {
            /** @type {?} */
            var target = event.target || event.srcElement;
            if (target.files.length > 0) {
                /** @type {?} */
                var files = target.files;
                if (!this.multiple) {
                    this.uploader.clear();
                }
                for (var i = 0, f = void 0; i < files.length; i++) {
                    f = files[i];
                    /** @type {?} */
                    var fileItem = new OFileItem(f, this.uploader);
                    this.uploader.addFile(fileItem);
                }
                value = this.uploader.files.map(function (file) { return file.name; }).join(', ');
                window.setTimeout(function () {
                    _this.setValue(value !== '' ? value : undefined, { changeType: OValueChangeEvent.USER_CHANGE });
                    if (_this._fControl) {
                        _this._fControl.markAsTouched();
                    }
                }, 0);
            }
        }
    };
    /**
     * Override super.onClickClearValue();
     * super.clearValue() vs super.onClickClearValue()
     *  * super.clearValue() emit OValueChangeEvent.PROGRAMMATIC_CHANGE
     *  * super.onClickClearValue() emit OValueChangeEvent.USER_CHANGE
     * @param {?} e
     * @return {?}
     */
    OFileInputComponent.prototype.onClickClearValue = /**
     * Override super.onClickClearValue();
     * super.clearValue() vs super.onClickClearValue()
     *  * super.clearValue() emit OValueChangeEvent.PROGRAMMATIC_CHANGE
     *  * super.onClickClearValue() emit OValueChangeEvent.USER_CHANGE
     * @param {?} e
     * @return {?}
     */
    function (e) {
        _super.prototype.onClickClearValue.call(this, e);
        this.uploader.clear();
    };
    /**
     * Override super.clearValue();
     * @return {?}
     */
    OFileInputComponent.prototype.clearValue = /**
     * Override super.clearValue();
     * @return {?}
     */
    function () {
        _super.prototype.clearValue.call(this);
        this.uploader.clear();
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OFileInputComponent.prototype.onClickUpload = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        e.stopPropagation();
        if (this.isValid) {
            this.upload();
        }
    };
    /**
     * @return {?}
     */
    OFileInputComponent.prototype.upload = /**
     * @return {?}
     */
    function () {
        this.uploader.upload();
    };
    Object.defineProperty(OFileInputComponent.prototype, "files", {
        get: /**
         * @return {?}
         */
        function () {
            return this.uploader.files;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OFileInputComponent.prototype, "additionalData", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.uploader) {
                return this.uploader.data;
            }
            return null;
        },
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (this.uploader) {
                this.uploader.data = data;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    OFileInputComponent.prototype.innerOnChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.ensureOFormValue(event);
        if (this._fControl && this._fControl.touched) {
            this._fControl.markAsDirty();
        }
        this.onChange.emit(event);
    };
    /**
     * @param {?} control
     * @return {?}
     */
    OFileInputComponent.prototype.filetypeValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (control.value && control.value.length > 0 && this.acceptFileType) {
            /** @type {?} */
            var regex_1 = new RegExp(this.acceptFileType.replace(';', '|'));
            if (!this.files.every(function (file) { return file.type.match(regex_1) !== null || file.name.substr(file.name.lastIndexOf('.')).match(regex_1) !== null; })) {
                return {
                    fileType: {
                        allowedFileTypes: this.acceptFileType.replace(';', ', ')
                    }
                };
            }
        }
        return {};
    };
    /**
     * @param {?} control
     * @return {?}
     */
    OFileInputComponent.prototype.maxFileSizeValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        var _this = this;
        if (control.value && control.value.length > 0 && this.maxFileSize) {
            if (!this.files.every(function (file) { return file.size < _this.maxFileSize; })) {
                return {
                    fileSize: {
                        maxFileSize: this.maxFileSize
                    }
                };
            }
        }
        return {};
    };
    /**
     * @param {?} control
     * @return {?}
     */
    OFileInputComponent.prototype.maxFilesValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (control.value && control.value.length > 0 && this.multiple && this.maxFiles !== -1) {
            if (this.maxFiles < this.files.length) {
                return {
                    numFile: {
                        maxFiles: this.maxFiles
                    }
                };
            }
        }
        return {};
    };
    OFileInputComponent.DEFAULT_INPUTS_O_FILE_INPUT = DEFAULT_INPUTS_O_FILE_INPUT;
    OFileInputComponent.DEFAULT_OUTPUTS_O_FILE_INPUT = DEFAULT_OUTPUTS_O_FILE_INPUT;
    OFileInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-file-input',
                    template: "\n    <div fxLayout=\"row\" fxLayoutAlign=\"space-between center\" [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\" [matTooltipClass]=\"tooltipClass\"\n      [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\" [matTooltipHideDelay]=\"tooltipHideDelay\">\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\"  [hideRequiredMarker]=\"hideRequiredMarker\" [class.custom-width]=\"hasCustomWidth\" class=\"icon-field\"\n        (click)=\"!enabled || isReadOnly ? null : inputFile.click()\" fxFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input #inputShowValue matInput type=\"text\" [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\" [placeholder]=\"placeHolder\"\n          [required]=\"isRequired\" readonly (change)=\"onChangeEvent($event)\">\n        <button type=\"button\" *ngIf=\"showClearButton\" matSuffix mat-icon-button (click)=\"onClickClearValue($event)\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n        <button type=\"button\" *ngIf=\"getValue()\" [disabled]=\"!isValid || uploader.isUploading\" matSuffix mat-icon-button (click)=\"onClickUpload($event)\">\n          <mat-icon>file_upload</mat-icon>\n        </button>\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('fileType')\" text=\"{{ 'FORM_VALIDATION.FILE_TYPE' | oTranslate}} ({{ getErrorValue('fileType','allowedFileTypes') }})\">\n        </mat-error>\n        <mat-error *ngIf=\"hasError('fileSize')\"\n          text=\"{{ 'FORM_VALIDATION.FILE_MAXSIZE' | oTranslate }}: {{ getErrorValue('fileSize', 'maxFileSize') }} bytes\"></mat-error>\n        <mat-error *ngIf=\"hasError('numFile')\" text=\"{{ 'FORM_VALIDATION.FILE_MAXNUM' | oTranslate }}: {{ getErrorValue('numFile', 'maxFiles') }}\">\n        </mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n      <input #inputFile type=\"file\" id=\"{{getAttribute()+'-file-input'}}\" [attr.accept]=\"acceptFileType ? acceptFileType.replace(';',',') : null\"\n        (change)=\"fileSelected($event)\" hidden=\"true\" [attr.multiple]=\"multiple ? '' : null\">\n      <div *ngIf=\"showInfo && files\">\n        <mat-progress-bar *ngIf=\"!splitUpload && uploader.isUploading\" color=\"accent\" mode=\"determinate\" [value]=\"uploader.progress\"></mat-progress-bar>\n        <mat-list>\n          <mat-list-item *ngFor=\"let file of files\">\n            <mat-icon mat-list-icon>insert_drive_file</mat-icon>\n            <span mat-line>{{ file.name }}</span>\n            <div fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n              <mat-progress-spinner *ngIf=\"splitUpload && file.isUploading\" color=\"accent\" mode=\"determinate\" [value]=\"file.progress\" class=\"uploading\"\n                diameter=\"3\" strokeWidth=\"3\"></mat-progress-spinner>\n              <mat-icon *ngIf=\"splitUpload && file.isUploaded && file.isSuccess\" class=\"uploaded\" svgIcon=\"ontimize:check_circle\"></mat-icon>\n              <mat-icon *ngIf=\"splitUpload && file.isUploaded && file.isError\" class=\"error\" svgIcon=\"ontimize:error_outline\"></mat-icon>\n            </div>\n          </mat-list-item>\n        </mat-list>\n      </div>\n    </div>\n  ",
                    styles: ["\n    .o-file-input-buttons{position:absolute;top:0;bottom:0;right:0;margin:auto}mat-icon.uploaded{color:#0f9d58}mat-icon.error{color:#D50000}\n  "],
                    inputs: DEFAULT_INPUTS_O_FILE_INPUT,
                    outputs: DEFAULT_OUTPUTS_O_FILE_INPUT
                },] },
    ];
    /** @nocollapse */
    OFileInputComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    OFileInputComponent.propDecorators = {
        inputFile: [{ type: core.ViewChild, args: ['inputFile',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFileInputComponent.prototype, "showInfo", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFileInputComponent.prototype, "multiple", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OFileInputComponent.prototype, "splitUpload", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OFileInputComponent.prototype, "maxFiles", void 0);
    return OFileInputComponent;
}(OFormDataComponent));
var OFileInputModule = /** @class */ (function () {
    function OFileInputModule() {
    }
    OFileInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OFileInputComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OFileInputComponent]
                },] },
    ];
    return OFileInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var defaults = {
    contentsCss: [''],
    customConfig: ''
};
var CKEditorComponent = /** @class */ (function () {
    function CKEditorComponent(ngZone) {
        this.ngZone = ngZone;
        this.innerValue = '';
        this._readonly = false;
        this.config = {};
        this.skin = 'moono-lisa';
        this.language = 'en';
        this.fullPage = false;
        this.inline = false;
        this.change = new core.EventEmitter();
        this.ready = new core.EventEmitter();
        this.blur = new core.EventEmitter();
        this.focus = new core.EventEmitter();
    }
    Object.defineProperty(CKEditorComponent.prototype, "instance", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ckIns;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CKEditorComponent.prototype, "readonly", {
        get: /**
         * @return {?}
         */
        function () {
            return this._readonly;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            this._readonly = value;
            setTimeout(function () {
                if (Util.isDefined(_this.ckIns) && Util.isDefined(_this.ckIns.editable())) {
                    _this.ckIns.setReadOnly(_this.readonly);
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?=} id
     * @return {?}
     */
    CKEditorComponent.getRandomIdentifier = /**
     * @param {?=} id
     * @return {?}
     */
    function (id) {
        if (id === void 0) { id = ''; }
        return 'editor-' + (id !== '' ? id : Math.round(Math.random() * 100000000));
    };
    /**
     * @return {?}
     */
    CKEditorComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroyCKEditor();
    };
    /**
     * @return {?}
     */
    CKEditorComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.destroyCKEditor();
        this.initCKEditor(CKEditorComponent.getRandomIdentifier(this.id));
    };
    /**
     * @param {?} identifier
     * @return {?}
     */
    CKEditorComponent.prototype.initCKEditor = /**
     * @param {?} identifier
     * @return {?}
     */
    function (identifier) {
        var _this = this;
        if (typeof CKEDITOR === 'undefined') {
            return console.warn('CKEditor 4.x is missing (http://ckeditor.com/)');
        }
        this.identifier = identifier;
        this.ck.nativeElement.setAttribute('name', this.identifier);
        /** @type {?} */
        var opt = Object.assign({}, defaults, this.config, {
            readOnly: this.readonly,
            skin: this.skin,
            language: this.language,
            fullPage: this.fullPage,
            inline: this.inline,
            width: '100%'
        });
        this.ckIns = this.inline
            ? CKEDITOR.inline(this.ck.nativeElement, opt)
            : CKEDITOR.replace(this.ck.nativeElement, opt);
        this.ckIns.setData(this.innerValue);
        this.ckIns.on('change', function () {
            /** @type {?} */
            var val = _this.ckIns.getData();
            _this.updateValue(val);
        });
        this.ckIns.on('instanceReady', function (evt) {
            _this.ngZone.run(function () {
                _this.ready.emit(evt);
            });
        });
        this.ckIns.on('blur', function (evt) {
            _this.ngZone.run(function () {
                _this.blur.emit(evt);
                _this.propagateTouch();
            });
        });
        this.ckIns.on('focus', function (evt) {
            _this.ngZone.run(function () {
                _this.focus.emit(evt);
            });
        });
    };
    /**
     * @return {?}
     */
    CKEditorComponent.prototype.destroyCKEditor = /**
     * @return {?}
     */
    function () {
        if (this.ckIns) {
            this.ckIns.removeAllListeners();
            if (CKEDITOR.instances.hasOwnProperty(this.ckIns.name)) {
                CKEDITOR.remove(CKEDITOR.instances[this.ckIns.name]);
            }
            this.ckIns.destroy();
            this.ckIns = null;
            /** @type {?} */
            var editorEl = document.querySelector('#cke_' + this.identifier);
            if (Util.isDefined(editorEl) && Util.isDefined(editorEl.parentElement)) {
                editorEl.parentElement.removeChild(editorEl);
            }
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    CKEditorComponent.prototype.updateValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        this.ngZone.run(function () {
            _this.innerValue = value;
            _this.propagateChange(value);
            _this.propagateTouch();
            _this.change.emit(value);
        });
    };
    /**
     * @param {?} value
     * @return {?}
     */
    CKEditorComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.innerValue = value || '';
        if (this.ckIns) {
            // Fix bug that can't emit change event when set non-html tag value twice in fullpage mode.
            this.ckIns.setData(this.innerValue);
            /** @type {?} */
            var val = this.ckIns.getData();
            this.ckIns.setData(val);
        }
    };
    /**
     * @param {?} _
     * @return {?}
     */
    CKEditorComponent.prototype.propagateChange = /**
     * @param {?} _
     * @return {?}
     */
    function (_) {
        // do nothing
    };
    /**
     * @return {?}
     */
    CKEditorComponent.prototype.propagateTouch = /**
     * @return {?}
     */
    function () {
        // do nothing
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    CKEditorComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.propagateChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    CKEditorComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.propagateTouch = fn;
    };
    CKEditorComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'ck-editor',
                    template: "<textarea #ck></textarea>",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: core.forwardRef(function () { return CKEditorComponent; }),
                            multi: true
                        }],
                    exportAs: 'ckEditor'
                },] },
    ];
    /** @nocollapse */
    CKEditorComponent.ctorParameters = function () { return [
        { type: core.NgZone }
    ]; };
    CKEditorComponent.propDecorators = {
        readonly: [{ type: core.Input }],
        config: [{ type: core.Input }],
        skin: [{ type: core.Input }],
        language: [{ type: core.Input }],
        fullPage: [{ type: core.Input }],
        inline: [{ type: core.Input }],
        id: [{ type: core.Input }],
        change: [{ type: core.Output }],
        ready: [{ type: core.Output }],
        blur: [{ type: core.Output }],
        focus: [{ type: core.Output }],
        ck: [{ type: core.ViewChild, args: ['ck',] }]
    };
    return CKEditorComponent;
}());
var CKEditorModule = /** @class */ (function () {
    function CKEditorModule() {
    }
    CKEditorModule.decorators = [
        { type: core.NgModule, args: [{
                    exports: [
                        forms.FormsModule,
                        CKEditorComponent
                    ],
                    declarations: [CKEditorComponent]
                },] },
    ];
    return CKEditorModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_HTML_INPUT = [
    'oattr: attr',
    'data',
    'autoBinding: automatic-binding',
    'autoRegistering: automatic-registering',
    'orequired: required',
    'minLength: min-length',
    'maxLength: max-length',
    'readOnly: read-only',
    'sqlType: sql-type'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_HTML_INPUT = DEFAULT_INPUTS_O_FORM_DATA_COMPONENT.concat([
    'onFocus',
    'onBlur'
]);
var OHTMLInputComponent = /** @class */ (function (_super) {
    __extends(OHTMLInputComponent, _super);
    function OHTMLInputComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this._minLength = -1;
        _this._maxLength = -1;
        /**
         * State of the mat-hint and mat-error animations.
         */
        _this._subscriptAnimationState = '';
        _this.form = form;
        _this.elRef = elRef;
        _this._changeDetectorRef = _this.injector.get(core.ChangeDetectorRef);
        try {
            _this.tabGroupContainer = _this.injector.get(material.MatTabGroup);
            _this.tabContainer = _this.injector.get(material.MatTab);
        }
        catch (error) {
            // Do nothing due to not always is contained on tab.
        }
        return _this;
    }
    /**
     * @return {?}
     */
    OHTMLInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        if (this.form) {
            /** @type {?} */
            var self = this;
            this.form.beforeCloseDetail.subscribe(function (evt) {
                self.destroyCKEditor();
            });
            this.form.beforeGoEditMode.subscribe(function (evt) {
                self.destroyCKEditor();
            });
        }
        if (this.tabGroupContainer) {
            this.tabGroupContainer.selectedTabChange.subscribe(function (evt) {
                self.destroyCKEditor();
                if (self.isInActiveTab()) {
                    self.ckEditor.initCKEditor(self.oattr);
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OHTMLInputComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngAfterViewInit.call(this);
        // Avoid animations on load.
        this._subscriptAnimationState = 'enter';
        this._changeDetectorRef.detectChanges();
    };
    /**
     * @param {?} error
     * @return {?}
     */
    OHTMLInputComponent.prototype.hasError = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        /** @type {?} */
        var result = _super.prototype.hasError.call(this, error);
        this._subscriptAnimationState = result ? 'enter' : 'void';
        return result;
    };
    /**
     * @return {?}
     */
    OHTMLInputComponent.prototype.isInActiveTab = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = !(this.tabGroupContainer && this.tabContainer);
        if (!result) {
            /** @type {?} */
            var self = this;
            this.tabGroupContainer._tabs.forEach(function (tab, index) {
                if (tab === self.tabContainer) {
                    result = (self.tabGroupContainer.selectedIndex === index);
                }
            });
        }
        return result;
    };
    /**
     * @return {?}
     */
    OHTMLInputComponent.prototype.resolveValidators = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validators = _super.prototype.resolveValidators.call(this);
        if (this.minLength >= 0) {
            validators.push(forms.Validators.minLength(this.minLength));
        }
        if (this.maxLength >= 0) {
            validators.push(forms.Validators.maxLength(this.maxLength));
        }
        return validators;
    };
    /**
     * @return {?}
     */
    OHTMLInputComponent.prototype.clearValue = /**
     * @return {?}
     */
    function () {
        _super.prototype.clearValue.call(this);
        this.ckEditor.instance.updateElement();
        this.ckEditor.instance.setData('');
    };
    /**
     * @return {?}
     */
    OHTMLInputComponent.prototype.destroyCKEditor = /**
     * @return {?}
     */
    function () {
        if (this.ckEditor) {
            this.ckEditor.destroyCKEditor();
        }
    };
    /**
     * @return {?}
     */
    OHTMLInputComponent.prototype.getCKEditor = /**
     * @return {?}
     */
    function () {
        return this.ckEditor.instance;
    };
    Object.defineProperty(OHTMLInputComponent.prototype, "minLength", {
        get: /**
         * @return {?}
         */
        function () {
            return this._minLength;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var old = this._minLength;
            this._minLength = NumberConverter(val);
            if (val !== old) {
                this.updateValidators();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OHTMLInputComponent.prototype, "maxLength", {
        get: /**
         * @return {?}
         */
        function () {
            return this._maxLength;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var old = this._maxLength;
            this._maxLength = NumberConverter(val);
            if (val !== old) {
                this.updateValidators();
            }
        },
        enumerable: true,
        configurable: true
    });
    OHTMLInputComponent.DEFAULT_INPUTS_O_HTML_INPUT = DEFAULT_INPUTS_O_HTML_INPUT;
    OHTMLInputComponent.DEFAULT_OUTPUTS_O_HTML_INPUT = DEFAULT_OUTPUTS_O_HTML_INPUT;
    OHTMLInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-html-input',
                    template: "\n    <div [formGroup]=\"getFormGroup()\" class=\"mat-form-field mat-form-field\" fxFill>\n      <div class=\"mat-form-field-wrapper mat-form-field-wrapper\">\n        <ck-editor #ckEditor [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\" (focus)=\"innerOnFocus($event)\" (blur)=\"innerOnBlur($event)\" \n        (change)=\"onChangeEvent($event)\"  [required]=\"isRequired\" [readonly]=\"isReadOnly\" class=\"mat-form-field-flex mat-form-field-flex\" fxFill></ck-editor>\n        <div class=\"mat-form-field-subscript-wrapper mat-form-field-subscript-wrapper\">\n          <div class=\"ng-trigger ng-trigger-transitionMessages\" [@transitionMessages]=\"_subscriptAnimationState\">\n            <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n            <mat-error *ngIf=\"hasError('minlength')\" text=\"{{ 'FORM_VALIDATION.MIN_LENGTH' | oTranslate }}: {{\n              getErrorValue('minlength', 'requiredLength') }}\"></mat-error>\n            <mat-error *ngIf=\"hasError('maxlength')\" text=\"{{ 'FORM_VALIDATION.MAX_LENGTH' | oTranslate }}: {{\n              getErrorValue('maxlength', 'requiredLength') }}\"></mat-error>\n            <mat-error *ngFor=\"let oError of getActiveOErrors()\"> {{ oError.text | oTranslate }} \"></mat-error>\n          </div>\n        </div>\n      </div>\n    </div>\n  ",
                    styles: ["\n    .mat-form-field-wrapper{position:relative}.mat-form-field-subscript-wrapper{position:absolute;width:100%;overflow:hidden}\n  "],
                    inputs: DEFAULT_INPUTS_O_HTML_INPUT,
                    outputs: DEFAULT_OUTPUTS_O_HTML_INPUT,
                    animations: [
                        animations$1.trigger('transitionMessages', [
                            animations$1.state('enter', animations$1.style({ opacity: 1, transform: 'translateY(0%)' })),
                            animations$1.transition('void => enter', [
                                animations$1.style({ opacity: 0, transform: 'translateY(-100%)' }),
                                animations$1.animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'),
                            ]),
                        ])
                    ]
                },] },
    ];
    /** @nocollapse */
    OHTMLInputComponent.ctorParameters = function () { return [
        { type: OFormComponent },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    OHTMLInputComponent.propDecorators = {
        ckEditor: [{ type: core.ViewChild, args: ['ckEditor',] }]
    };
    return OHTMLInputComponent;
}(OFormDataComponent));
var OHTMLInputModule = /** @class */ (function () {
    function OHTMLInputModule() {
    }
    OHTMLInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OHTMLInputComponent],
                    imports: [CKEditorModule, common.CommonModule, OSharedModule],
                    exports: [OHTMLInputComponent]
                },] },
    ];
    return OHTMLInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_LIST_PICKER = [
    'data',
    'visibleColumns: visible-columns',
    'filter'
];
var OListPickerDialogComponent = /** @class */ (function () {
    function OListPickerDialogComponent(dialogRef, injector, data) {
        this.dialogRef = dialogRef;
        this.injector = injector;
        this.filter = true;
        this.visibleData = [];
        this.data = [];
        this._startIndex = 0;
        this.recordsNumber = 100;
        this.scrollThreshold = 200;
        if (data.data && Util.isArray(data.data)) {
            this.data = data.data;
        }
        if (data.visibleColumns && Util.isArray(data.visibleColumns)) {
            this.visibleColsArray = data.visibleColumns;
        }
        if (data.queryRows !== undefined) {
            this.recordsNumber = data.queryRows;
        }
        if (data.filter !== undefined) {
            this.filter = data.filter;
        }
        if (data.menuColumns) {
            this.menuColumns = data.menuColumns;
        }
        this.searchVal = data.searchVal;
    }
    /**
     * @return {?}
     */
    OListPickerDialogComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (Util.isDefined(this.searchVal) && this.searchInput !== undefined && this.searchVal.length > 0) {
            this.searchInput.getFormControl().setValue(this.searchVal, {
                emitEvent: false
            });
            this.onFilterList(this.searchVal);
        }
        else {
            this.startIndex = 0;
        }
    };
    Object.defineProperty(OListPickerDialogComponent.prototype, "startIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this._startIndex;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._startIndex = val;
            this.visibleData = this.data.slice(this.startIndex, this.recordsNumber);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} e
     * @param {?} value
     * @return {?}
     */
    OListPickerDialogComponent.prototype.onClickListItem = /**
     * @param {?} e
     * @param {?} value
     * @return {?}
     */
    function (e, value) {
        this.dialogRef.close(value);
    };
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    OListPickerDialogComponent.prototype.trackByFn = /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    function (index, item) {
        return index;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OListPickerDialogComponent.prototype.onScroll = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event && event.target && this.visibleData.length < this.data.length) {
            /** @type {?} */
            var pendingScroll = event.target.scrollHeight - (event.target.scrollTop + event.target.clientHeight);
            if (!isNaN(pendingScroll) && pendingScroll <= this.scrollThreshold) {
                /** @type {?} */
                var index = this.visibleData.length;
                /** @type {?} */
                var searchVal = this.searchInput.getValue();
                if (Util.isDefined(searchVal) && searchVal.length > 0) {
                    index = this.visibleData[this.visibleData.length - 1]['_parsedIndex'];
                }
                /** @type {?} */
                var appendData = this.data.slice(index, this.visibleData.length + this.recordsNumber);
                if (appendData.length) {
                    appendData = this.transform(appendData, {
                        filtervalue: this.searchInput.getValue(),
                        filtercolumns: this.visibleColsArray
                    });
                    if (appendData.length) {
                        this.visibleData = this.visibleData.concat(appendData);
                    }
                }
            }
        }
    };
    /**
     * @param {?} searchVal
     * @return {?}
     */
    OListPickerDialogComponent.prototype.onFilterList = /**
     * @param {?} searchVal
     * @return {?}
     */
    function (searchVal) {
        this.visibleData = this.transform(this.data, {
            filtervalue: searchVal,
            filtercolumns: this.visibleColsArray
        });
        this._startIndex = 0;
        this.visibleData = this.visibleData.slice(this.startIndex, this.recordsNumber);
    };
    /**
     * @return {?}
     */
    OListPickerDialogComponent.prototype.isEmptyData = /**
     * @return {?}
     */
    function () {
        return Util.isDefined(this.visibleData) ? this.visibleData.length === 0 : true;
    };
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    OListPickerDialogComponent.prototype.transform = /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    function (value, args) {
        var _this = this;
        if (!args || args.length <= 1) {
            return value;
        }
        /** @type {?} */
        var filterValue = args['filtervalue'] ? args['filtervalue'] : '';
        /** @type {?} */
        var filterColumns = args['filtercolumns'];
        if (!filterColumns || !filterValue || filterValue.length === 0) {
            return value;
        }
        if (value === undefined || value === null) {
            return value;
        }
        return value.filter(function (item) {
            for (var i = 0; i < filterColumns.length; i++) {
                /** @type {?} */
                var colName = filterColumns[i];
                if (_this._isBlank(colName)) {
                    continue;
                }
                /** @type {?} */
                var origValue = item[colName];
                if (origValue) {
                    origValue = origValue.toString();
                    if (_this._isBlank(origValue)) {
                        continue;
                    }
                    if (origValue.toUpperCase().indexOf(filterValue.toUpperCase()) > -1) {
                        return item;
                    }
                }
            }
        });
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OListPickerDialogComponent.prototype._isBlank = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return !Util.isDefined(value) || value.length === 0;
    };
    OListPickerDialogComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-list-picker-dialog',
                    template: "\n    <div class=\"title-container\" *ngIf=\"filter\">\n      <o-search-input #searchInput [columns]=\"menuColumns\" show-menu=\"no\" float-label=\"never\" (onSearch)=\"onFilterList($event)\"\n        class=\"o-list-picker-search\"></o-search-input>\n    </div>\n    <div mat-dialog-content (scroll)=\"onScroll($event)\" [class.o-list-picker-has-filter]=\"filter\" fxFlex>\n      <mat-list>\n        <mat-list-item *ngIf=\"isEmptyData()\">\n          {{ 'LIST.EMPTY' | oTranslate }}\n          <ng-container *ngIf=\"filter && searchInput && searchInput.getValue() && searchInput.getValue().length > 0\">\n            {{ 'LIST.EMPTY_USING_FILTER' | oTranslate : { values: [searchInput.getValue()] } }}\n          </ng-container>\n        </mat-list-item>\n        <mat-list-item (click)=\"onClickListItem($event, item)\" *ngFor=\"let item of visibleData; trackBy: trackByFn\">\n          <span>{{ item['_parsedVisibleColumnText'] }}</span>\n          <mat-divider></mat-divider>\n        </mat-list-item>\n      </mat-list>\n    </div>\n    <mat-dialog-actions align=\"end\">\n      <button type=\"button\" mat-stroked-button mat-dialog-close>{{ 'CANCEL' | oTranslate | uppercase }}</button>\n    </mat-dialog-actions>\n  ",
                    styles: ["\n    .cdk-overlay-list-picker .mat-dialog-container{padding:0}.cdk-overlay-list-picker .mat-dialog-container .o-list-picker-dialog{display:flex;flex-direction:column;height:100%}.cdk-overlay-list-picker .mat-dialog-container .o-list-picker-dialog .title-container{padding:5px 20px}.cdk-overlay-list-picker .mat-dialog-container .o-list-picker-dialog .title-container .o-search-input mat-form-field .mat-form-field-wrapper{padding-bottom:0}.cdk-overlay-list-picker .mat-dialog-container .o-list-picker-dialog .title-container .o-search-input mat-form-field .mat-form-field-wrapper .mat-form-field-underline{display:none}.cdk-overlay-list-picker .mat-dialog-container .o-list-picker-dialog .mat-dialog-content{margin:0}.cdk-overlay-list-picker .mat-dialog-container .o-list-picker-dialog .mat-dialog-content mat-list mat-list-item{cursor:pointer}.cdk-overlay-list-picker .mat-dialog-container .o-list-picker-dialog .mat-dialog-actions{padding-top:12px;margin:0 12px}\n  "],
                    inputs: DEFAULT_INPUTS_O_LIST_PICKER,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-list-picker-dialog]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OListPickerDialogComponent.ctorParameters = function () { return [
        { type: material.MatDialogRef },
        { type: core.Injector },
        { type: undefined, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] }] }
    ]; };
    OListPickerDialogComponent.propDecorators = {
        searchInput: [{ type: core.ViewChild, args: ['searchInput',] }]
    };
    return OListPickerDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_LIST_PICKER$1 = OFormServiceComponent.DEFAULT_INPUTS_O_FORM_SERVICE_COMPONENT.concat([
    'filter',
    'dialogWidth : dialog-width',
    'dialogHeight : dialog-height',
    'queryRows: query-rows',
    'textInputEnabled: text-input-enabled',
    'dialogDisableClose: dialog-disable-close',
    'dialogClass: dialog-class'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_LIST_PICKER = OFormServiceComponent.DEFAULT_OUTPUTS_O_FORM_SERVICE_COMPONENT.concat([
    'onDialogAccept',
    'onDialogCancel'
]);
var 0$9 = dataServiceFactory;
var OListPickerComponent = /** @class */ (function (_super) {
    __extends(OListPickerComponent, _super);
    function OListPickerComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.onDialogAccept = new core.EventEmitter();
        _this.onDialogCancel = new core.EventEmitter();
        /* Inputs */
        _this.textInputEnabled = true;
        _this.dialogDisableClose = false;
        _this.filter = true;
        _this.dialogHeight = '55%';
        _this.blurDelay = 200;
        _this.blurPrevent = false;
        _this.matDialog = _this.injector.get(material.MatDialog);
        _this.stateCtrl = new forms.FormControl();
        /* overwritte clearButton to true */
        /* overwritte clearButton to true */
        _this.clearButton = true;
        return _this;
    }
    /**
     * @return {?}
     */
    OListPickerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.initialize();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    OListPickerComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
        if (typeof (changes['staticData']) !== 'undefined') {
            this.cacheQueried = true;
            this.setDataArray(changes['staticData'].currentValue);
        }
    };
    /**
     * @return {?}
     */
    OListPickerComponent.prototype.createFormControl = /**
     * @return {?}
     */
    function () {
        this._fControl = _super.prototype.createFormControl.call(this);
        this._fControl.fControlChildren = [this.stateCtrl];
        return this._fControl;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OListPickerComponent.prototype.ensureOFormValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        _super.prototype.ensureOFormValue.call(this, value);
        // This call make the component querying its data multiple times, but getting description value is needed
        this.syncDataIndex(false);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OListPickerComponent.prototype.setEnabled = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        _super.prototype.setEnabled.call(this, value);
        value ? this.stateCtrl.enable() : this.stateCtrl.disable();
    };
    /**
     * @return {?}
     */
    OListPickerComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngAfterViewInit.call(this);
        if (this.queryOnInit) {
            this.queryData();
        }
        else if (this.queryOnBind) {
            // TODO do it better. When changing tabs it is necessary to invoke new query
            this.syncDataIndex();
        }
    };
    /**
     * @return {?}
     */
    OListPickerComponent.prototype.getDescriptionValue = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var descTxt = '';
        if (this.descriptionColArray && this._currentIndex !== undefined) {
            /** @type {?} */
            var self_1 = this;
            this.descriptionColArray.forEach(function (descCol, index) {
                /** @type {?} */
                var txt = self_1.dataArray[self_1._currentIndex][descCol];
                if (txt) {
                    descTxt += txt;
                }
                if (index < self_1.descriptionColArray.length - 1) {
                    descTxt += self_1.separator;
                }
            });
        }
        return descTxt;
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OListPickerComponent.prototype.onClickClear = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        e.preventDefault();
        e.stopPropagation();
        if (!this.isReadOnly && this.enabled) {
            clearTimeout(this.blurTimer);
            this.blurPrevent = true;
            this.setValue(undefined);
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OListPickerComponent.prototype.onClickInput = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!this.textInputEnabled) {
            this.onClickListpicker(e);
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OListPickerComponent.prototype.onClickListpicker = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        e.preventDefault();
        e.stopPropagation();
        if (!this.isReadOnly && this.enabled) {
            clearTimeout(this.blurTimer);
            this.openDialog();
        }
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    OListPickerComponent.prototype.onDialogClose = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        this.dialogRef = null;
        this.visibleInputValue = undefined;
        if (evt instanceof Object && typeof evt[this.valueColumn] !== 'undefined') {
            /** @type {?} */
            var self_2 = this;
            window.setTimeout(function () {
                self_2.setValue(evt[self_2.valueColumn], { changeType: OValueChangeEvent.USER_CHANGE });
                if (self_2._fControl) {
                    self_2._fControl.markAsTouched();
                    self_2._fControl.markAsDirty();
                }
                self_2.onDialogAccept.emit();
            }, 0);
        }
        else {
            this.onDialogCancel.emit();
        }
    };
    /**
     * @param {?} evt
     * @return {?}
     */
    OListPickerComponent.prototype.innerOnBlur = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        if (!this.isReadOnly && this.enabled) {
            /** @type {?} */
            var self_3 = this;
            this.blurTimer = setTimeout(function () {
                if (!self_3.blurPrevent) {
                    self_3._fControl.markAsTouched();
                    self_3.onBlur.emit(evt);
                    if (self_3.visibleInputValue !== undefined && self_3.visibleInputValue.length > 0) {
                        self_3.openDialog();
                    }
                    else if (self_3.visibleInputValue !== undefined) {
                        self_3.setValue(undefined);
                        self_3.visibleInputValue = undefined;
                    }
                    else {
                        self_3._fControl.markAsTouched();
                    }
                }
                self_3.blurPrevent = false;
            }, this.blurDelay);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OListPickerComponent.prototype.onVisibleInputChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.visibleInputValue = event.target.value;
    };
    /**
     * @param {?} val
     * @return {?}
     */
    OListPickerComponent.prototype.onKeydownEnter = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        clearTimeout(this.blurTimer);
        this.blurPrevent = true;
        this.visibleInputValue = val;
        this.openDialog();
    };
    /**
     * @param {?} val
     * @param {?=} options
     * @param {?=} setDirty
     * @return {?}
     */
    OListPickerComponent.prototype.setFormValue = /**
     * @param {?} val
     * @param {?=} options
     * @param {?=} setDirty
     * @return {?}
     */
    function (val, options, setDirty) {
        if (setDirty === void 0) { setDirty = false; }
        _super.prototype.setFormValue.call(this, val, options, setDirty);
        this.stateCtrl.setValue(this.getDescriptionValue());
    };
    /**
     * @return {?}
     */
    OListPickerComponent.prototype.openDialog = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var cfg = {
            role: 'dialog',
            disableClose: this.dialogDisableClose,
            panelClass: ['cdk-overlay-list-picker', 'o-dialog-class', this.dialogClass],
            data: {
                data: this.getDialogDataArray(this.dataArray),
                filter: this.filter,
                searchVal: this.visibleInputValue,
                menuColumns: this.visibleColumns,
                // TODO: improve this, this is passed to `o-search-input` of the dialog
                visibleColumns: this.visibleColArray,
                queryRows: this.queryRows
            }
        };
        if (this.dialogWidth !== undefined) {
            cfg.width = this.dialogWidth;
        }
        if (this.dialogHeight !== undefined) {
            cfg.height = this.dialogHeight;
        }
        this.dialogRef = this.matDialog.open(OListPickerDialogComponent, cfg);
        this.dialogRef.afterClosed().subscribe(function (result) {
            _this.onDialogClose(result);
        });
    };
    /**
     * @param {?} dataArray
     * @return {?}
     */
    OListPickerComponent.prototype.getDialogDataArray = /**
     * @param {?} dataArray
     * @return {?}
     */
    function (dataArray) {
        /** @type {?} */
        var result = [];
        /** @type {?} */
        var self = this;
        dataArray.forEach(function (item, itemIndex) {
            /** @type {?} */
            var element = '';
            self.visibleColArray.forEach(function (visibleCol, index) {
                element += item[visibleCol];
                if ((index + 1) < self.visibleColArray.length) {
                    element += self.separator;
                }
            });
            /** @type {?} */
            var newItem = Object.assign({}, item);
            newItem['_parsedVisibleColumnText'] = element;
            newItem['_parsedIndex'] = itemIndex;
            result.push(newItem);
        });
        return result;
    };
    OListPickerComponent.DEFAULT_INPUTS_O_LIST_PICKER = DEFAULT_INPUTS_O_LIST_PICKER$1;
    OListPickerComponent.DEFAULT_OUTPUTS_O_LIST_PICKER = DEFAULT_OUTPUTS_O_LIST_PICKER;
    OListPickerComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-list-picker',
                    template: "\n    <div (click)=\"onClickInput($event)\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\" [formGroup]=\"getFormGroup()\"\n      [matTooltip]=\"tooltip\" [matTooltipClass]=\"tooltipClass\" [matTooltipPosition]=\"tooltipPosition\"\n      [matTooltipShowDelay]=\"tooltipShowDelay\" [matTooltipHideDelay]=\"tooltipHideDelay\"\n      class=\"custom-error o-list-picker-content\">\n      <input #inputModel class=\"input-model\" type=\"text\" [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\">\n\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [class.custom-width]=\"hasCustomWidth\"\n        [hideRequiredMarker]=\"hideRequiredMarker\" class=\"icon-field\" #innerInputContainer fxFlexFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input #visibleInput matInput type=\"text\" [attr.id]=\"'desc_' + getAttribute()\" [id]=\"'desc_' + getAttribute()\"\n          [formControl]=\"stateCtrl\" [placeholder]=\"placeHolder\" [value]=\"getDescriptionValue()\"\n          (input)=\"onVisibleInputChange($event)\" (focus)=\"innerOnFocus($event)\" (blur)=\"innerOnBlur($event)\"\n          [readonly]=\"isReadOnly || !textInputEnabled\" [required]=\"isRequired\"\n          (keydown.enter)=\"onKeydownEnter(visibleInput.value)\" (change)=\"onChangeEvent($event)\">\n\n        <button type=\"button\" [disabled]=\"isReadOnly || !enabled\" [class.read-only]=\"isReadOnly\" matSuffix mat-icon-button\n          (click)=\"onClickListpicker($event)\">\n          <mat-icon svgIcon=\"ontimize:search\"></mat-icon>\n        </button>\n\n        <button type=\"button\" [disabled]=\"isReadOnly || !enabled\" [class.read-only]=\"isReadOnly\" matSuffix mat-icon-button\n          (click)=\"onClickClearValue($event)\" *ngIf=\"showClearButton\">\n          <mat-icon svgIcon=\"ontimize:clear\"></mat-icon>\n        </button>\n\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ["\n    .o-list-picker-content .input-model{display:none !important}.o-list-picker-content .mat-button.mat-disabled{cursor:default}\n  "],
                    providers: [
                        { provide: OntimizeService$$1, useFactory: 0$9, deps: [core.Injector] },
                        { provide: OFormServiceComponent, useExisting: core.forwardRef(function () { return OListPickerComponent; }) }
                    ],
                    inputs: DEFAULT_INPUTS_O_LIST_PICKER$1,
                    outputs: DEFAULT_OUTPUTS_O_LIST_PICKER
                },] },
    ];
    /** @nocollapse */
    OListPickerComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    OListPickerComponent.propDecorators = {
        inputModel: [{ type: core.ViewChild, args: ['inputModel',] }],
        visibleInput: [{ type: core.ViewChild, args: ['visibleInput',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OListPickerComponent.prototype, "textInputEnabled", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OListPickerComponent.prototype, "dialogDisableClose", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OListPickerComponent.prototype, "filter", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OListPickerComponent.prototype, "queryRows", void 0);
    return OListPickerComponent;
}(OFormServiceComponent));
var OListPickerModule = /** @class */ (function () {
    function OListPickerModule() {
    }
    OListPickerModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OListPickerDialogComponent, OListPickerComponent],
                    imports: [common.CommonModule, ODialogModule, OSearchInputModule, OSharedModule],
                    exports: [OListPickerComponent],
                    entryComponents: [OListPickerDialogComponent]
                },] },
    ];
    return OListPickerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_NIF_INPUT = DEFAULT_INPUTS_O_TEXT_INPUT.slice();
/** @type {?} */
var DEFAULT_OUTPUTS_O_NIF_INPUT = DEFAULT_OUTPUTS_O_TEXT_INPUT.slice();
var ONIFInputComponent = /** @class */ (function (_super) {
    __extends(ONIFInputComponent, _super);
    function ONIFInputComponent(form, elRef, injector) {
        return _super.call(this, form, elRef, injector) || this;
    }
    /**
     * @return {?}
     */
    ONIFInputComponent.prototype.resolveValidators = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validators = _super.prototype.resolveValidators.call(this);
        //Inject NIF validator
        validators.push(OValidators.nifValidator);
        return validators;
    };
    ONIFInputComponent.DEFAULT_INPUTS_O_NIF_INPUT = DEFAULT_INPUTS_O_NIF_INPUT;
    ONIFInputComponent.DEFAULT_OUTPUTS_O_NIF_INPUT = DEFAULT_OUTPUTS_O_NIF_INPUT;
    ONIFInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-nif-input',
                    template: "\n    <div fxLayout=\"row\" fxLayoutAlign=\"space-between center\" [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\"\n      [matTooltipClass]=\"tooltipClass\" [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\">\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [hideRequiredMarker]=\"hideRequiredMarker\"\n        [class.custom-width]=\"hasCustomWidth\" class=\"icon-field\" fxFlexFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input matInput type=\"text\" [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\" [placeholder]=\"placeHolder\"\n          (focus)=\"innerOnFocus($event)\" (blur)=\"innerOnBlur($event)\" (change)=\"onChangeEvent($event)\"\n          [readonly]=\"isReadOnly\" [required]=\"isRequired\">\n        <button type=\"button\" *ngIf=\"showClearButton\" matSuffix mat-icon-button (click)=\"onClickClearValue($event)\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n        <mat-icon matSuffix [class.mat-disabled]=\"!enabled\" svgIcon=\"ontimize:perm_identity\"></mat-icon>\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('invalidNIF')\" text=\"{{ 'FORM_VALIDATION.NIF_FORMAT' | oTranslate}}\"></mat-error>\n        <mat-error *ngIf=\"hasError('invalidNIFLetter')\" text=\"{{ 'FORM_VALIDATION.DNI_LETTER' | oTranslate}}\"></mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_NIF_INPUT,
                    outputs: DEFAULT_OUTPUTS_O_NIF_INPUT,
                    encapsulation: core.ViewEncapsulation.None
                },] },
    ];
    /** @nocollapse */
    ONIFInputComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    return ONIFInputComponent;
}(OTextInputComponent));
var ONIFInputModule = /** @class */ (function () {
    function ONIFInputModule() {
    }
    ONIFInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [ONIFInputComponent],
                    imports: [OSharedModule, common.CommonModule, OTextInputModule],
                    exports: [ONIFInputComponent, OTextInputModule]
                },] },
    ];
    return ONIFInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_PASSWORD_INPUT = DEFAULT_INPUTS_O_TEXT_INPUT.slice();
/** @type {?} */
var DEFAULT_OUTPUTS_O_PASSWORD_INPUT = DEFAULT_OUTPUTS_O_TEXT_INPUT.slice();
var OPasswordInputComponent = /** @class */ (function (_super) {
    __extends(OPasswordInputComponent, _super);
    function OPasswordInputComponent(form, elRef, injector) {
        return _super.call(this, form, elRef, injector) || this;
    }
    OPasswordInputComponent.DEFAULT_INPUTS_O_PASSWORD_INPUT = DEFAULT_INPUTS_O_PASSWORD_INPUT;
    OPasswordInputComponent.DEFAULT_OUTPUTS_O_PASSWORD_INPUT = DEFAULT_OUTPUTS_O_PASSWORD_INPUT;
    OPasswordInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-password-input',
                    template: "\n    <div fxLayout=\"row\" fxLayoutAlign=\"space-between center\" [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\"\n      [matTooltipClass]=\"tooltipClass\" [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\">\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [hideRequiredMarker]=\"hideRequiredMarker\"\n        [class.custom-width]=\"hasCustomWidth\" class=\"icon-field\" fxFlexFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input matInput type=\"password\" [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\" [placeholder]=\"placeHolder\"\n          (focus)=\"innerOnFocus($event)\" (blur)=\"innerOnBlur($event)\" (change)=\"onChangeEvent($event)\"\n          [readonly]=\"isReadOnly\" [required]=\"isRequired\">\n        <button type=\"button\" *ngIf=\"showClearButton\" matSuffix mat-icon-button (click)=\"onClickClearValue($event)\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n        <mat-icon matSuffix [class.mat-disabled]=\"!enabled\" svgIcon=\"ontimize:vpn_key\"></mat-icon>\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('minlength')\"\n          text=\"{{ 'FORM_VALIDATION.MIN_LENGTH' | oTranslate }}: {{ getErrorValue('minlength', 'requiredLength') }}\">\n        </mat-error>\n        <mat-error *ngIf=\"hasError('maxlength')\"\n          text=\"{{ 'FORM_VALIDATION.MAX_LENGTH' | oTranslate }}: {{ getErrorValue('maxlength', 'requiredLength') }}\">\n        </mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_PASSWORD_INPUT,
                    outputs: DEFAULT_OUTPUTS_O_PASSWORD_INPUT,
                    encapsulation: core.ViewEncapsulation.None
                },] },
    ];
    /** @nocollapse */
    OPasswordInputComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    return OPasswordInputComponent;
}(OTextInputComponent));
var OPasswordInputModule = /** @class */ (function () {
    function OPasswordInputModule() {
    }
    OPasswordInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OPasswordInputComponent],
                    imports: [OSharedModule, common.CommonModule, OTextInputModule],
                    exports: [OPasswordInputComponent, OTextInputModule]
                },] },
    ];
    return OPasswordInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_PERCENT_INPUT = DEFAULT_INPUTS_O_REAL_INPUT.slice();
/** @type {?} */
var DEFAULT_OUTPUTS_O_PERCENT_INPUT = DEFAULT_OUTPUTS_O_REAL_INPUT.slice();
var OPercentInputComponent = /** @class */ (function (_super) {
    __extends(OPercentInputComponent, _super);
    function OPercentInputComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.grouping = true;
        return _this;
    }
    /**
     * @return {?}
     */
    OPercentInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (typeof (this.min) === 'undefined') {
            this.min = 0;
        }
        if (typeof (this.max) === 'undefined') {
            this.max = 100;
        }
        _super.prototype.ngOnInit.call(this);
    };
    OPercentInputComponent.DEFAULT_INPUTS_O_PERCENT_INPUT = DEFAULT_INPUTS_O_PERCENT_INPUT;
    OPercentInputComponent.DEFAULT_OUTPUTS_O_PERCENT_INPUT = DEFAULT_OUTPUTS_O_PERCENT_INPUT;
    OPercentInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-percent-input',
                    template: "\n    <div [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\" [matTooltipClass]=\"tooltipClass\"\n      [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [hideRequiredMarker]=\"hideRequiredMarker\"\n        [class.custom-width]=\"hasCustomWidth\" class=\"icon-field\" fxFlexFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input matInput [type]=\"inputType\" [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\"\n          [placeholder]=\"placeHolder\" (focus)=\"innerOnFocus($event)\" (blur)=\"innerOnBlur($event)\" [readonly]=\"isReadOnly\"\n          (change)=\"onChangeEvent($event)\" [min]=\"min\" [max]=\"max\" [step]=\"step\" [required]=\"isRequired\">\n        <button type=\"button\" *ngIf=\"showClearButton\" matSuffix mat-icon-button (click)=\"onClickClearValue($event)\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n        <mat-icon svgIcon=\"ontimize:PERCENT\" matSuffix class=\"svg-icon\" [class.mat-disabled]=\"!enabled\"></mat-icon>\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('min')\"\n          text=\"{{ 'FORM_VALIDATION.MIN_VALUE' | oTranslate }}: {{ getErrorValue('min', 'requiredMin') }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('max')\"\n          text=\"{{ 'FORM_VALIDATION.MAX_VALUE' | oTranslate }}: {{ getErrorValue('max', 'requiredMax') }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('minDecimaldigits')\"\n          text=\"{{ 'FORM_VALIDATION.MIN_DECIMAL_DIGITS' | oTranslate }}: {{ getErrorValue('minDecimaldigits', 'requiredMinDecimaldigits') }}\">\n        </mat-error>\n        <mat-error *ngIf=\"hasError('maxDecimaldigits')\"\n          text=\"{{ 'FORM_VALIDATION.MAX_DECIMAL_DIGITS' | oTranslate }}: {{ getErrorValue('maxDecimaldigits', 'requiredMaxDecimaldigits') }}\">\n        </mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ["\n\n  "],
                    inputs: DEFAULT_INPUTS_O_PERCENT_INPUT,
                    outputs: DEFAULT_OUTPUTS_O_PERCENT_INPUT,
                    encapsulation: core.ViewEncapsulation.None
                },] },
    ];
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OPercentInputComponent.prototype, "grouping", void 0);
    return OPercentInputComponent;
}(ORealInputComponent));
var OPercentInputModule = /** @class */ (function () {
    function OPercentInputModule() {
    }
    OPercentInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OPercentInputComponent],
                    imports: [common.CommonModule, OSharedModule, ORealInputModule],
                    exports: [OPercentInputComponent, ORealInputModule]
                },] },
    ];
    return OPercentInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TEXTAREA_INPUT = DEFAULT_INPUTS_O_TEXT_INPUT.concat([
    'columns',
    'rows'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_TEXTAREA_INPUT = DEFAULT_OUTPUTS_O_TEXT_INPUT.slice();
var OTextareaInputComponent = /** @class */ (function (_super) {
    __extends(OTextareaInputComponent, _super);
    function OTextareaInputComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.rows = 5;
        _this.columns = 3;
        return _this;
    }
    /**
     * @return {?}
     */
    OTextareaInputComponent.prototype.isResizable = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var resizable = true;
        if (!this.enabled || this.isReadOnly) {
            resizable = false;
        }
        return resizable;
    };
    OTextareaInputComponent.DEFAULT_INPUTS_O_TEXTAREA_INPUT = DEFAULT_INPUTS_O_TEXTAREA_INPUT;
    OTextareaInputComponent.DEFAULT_OUTPUTS_O_TEXTAREA_INPUT = DEFAULT_OUTPUTS_O_TEXTAREA_INPUT;
    OTextareaInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-textarea-input',
                    template: "\n    <div [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\" [matTooltipClass]=\"tooltipClass\"\n      [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\">\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [hideRequiredMarker]=\"hideRequiredMarker\"\n        [class.custom-width]=\"hasCustomWidth\" fxFlexFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <textarea matInput class=\"mat-textarea\" type=\"text\" [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\"\n          [placeholder]=\"placeHolder\" (focus)=\"innerOnFocus($event)\" (blur)=\"innerOnBlur($event)\" [readonly]=\"isReadOnly\"\n          [class.no-resize]=\"!isResizable()\" [rows]=\"rows\" [cols]=\"columns\" [required]=\"isRequired\"\n          (change)=\"onChangeEvent($event)\"></textarea>\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ["\n    .mat-textarea.no-resize{resize:none}.mat-textarea{resize:vertical}\n  "],
                    inputs: DEFAULT_INPUTS_O_TEXTAREA_INPUT,
                    outputs: DEFAULT_OUTPUTS_O_TEXTAREA_INPUT,
                    encapsulation: core.ViewEncapsulation.None
                },] },
    ];
    /** @nocollapse */
    OTextareaInputComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTextareaInputComponent.prototype, "rows", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OTextareaInputComponent.prototype, "columns", void 0);
    return OTextareaInputComponent;
}(OTextInputComponent));
var OTextareaInputModule = /** @class */ (function () {
    function OTextareaInputModule() {
    }
    OTextareaInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OTextareaInputComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OTextareaInputComponent]
                },] },
    ];
    return OTextareaInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_ERROR = [
    'name',
    'text'
];
var OErrorComponent = /** @class */ (function () {
    function OErrorComponent(oValidator, injector) {
        this.oValidator = oValidator;
        this.injector = injector;
    }
    /**
     * @return {?}
     */
    OErrorComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.registerValidatorError();
    };
    /**
     * @return {?}
     */
    OErrorComponent.prototype.registerValidatorError = /**
     * @return {?}
     */
    function () {
        if (this.oValidator) {
            this.oValidator.registerError(this);
        }
    };
    /**
     * @return {?}
     */
    OErrorComponent.prototype.getName = /**
     * @return {?}
     */
    function () {
        return this.name;
    };
    /**
     * @return {?}
     */
    OErrorComponent.prototype.getText = /**
     * @return {?}
     */
    function () {
        return this.text;
    };
    OErrorComponent.DEFAULT_INPUTS_O_ERROR = DEFAULT_INPUTS_O_ERROR;
    OErrorComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-error',
                    template: ' ',
                    inputs: DEFAULT_INPUTS_O_ERROR
                },] },
    ];
    /** @nocollapse */
    OErrorComponent.ctorParameters = function () { return [
        { type: OValidatorComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OValidatorComponent; }),] }] },
        { type: core.Injector }
    ]; };
    return OErrorComponent;
}());
var OErrorModule = /** @class */ (function () {
    function OErrorModule() {
    }
    OErrorModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OErrorComponent],
                    imports: [OSharedModule, common.CommonModule],
                    exports: [OErrorComponent]
                },] },
    ];
    return OErrorModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_HOUR_INPUT = [
    'format',
    'textInputEnabled: text-input-enabled',
    'min',
    'max',
    'valueType: value-type'
].concat(DEFAULT_INPUTS_O_FORM_DATA_COMPONENT);
/** @type {?} */
var DEFAULT_OUTPUTS_O_HOUR_INPUT = DEFAULT_OUTPUTS_O_FORM_DATA_COMPONENT.slice();
var OHourInputComponent = /** @class */ (function (_super) {
    __extends(OHourInputComponent, _super);
    function OHourInputComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.textInputEnabled = true;
        _this._format = Codes.TWENTY_FOUR_HOUR_FORMAT;
        _this.onKeyboardInputDone = false;
        _this._valueType = 'timestamp';
        _this._defaultSQLTypeKey = 'TIMESTAMP';
        return _this;
    }
    /**
     * @return {?}
     */
    OHourInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @return {?}
     */
    OHourInputComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.modifyPickerMethods();
    };
    /**
     * @return {?}
     */
    OHourInputComponent.prototype.getValue = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var value = _super.prototype.getValue.call(this);
        // Component value is always string internally, it must be converted to expected type
        if (!Util.isDefined(value) || this.valueType === 'string') {
            return value;
        }
        else if (this.valueType === 'timestamp') {
            return moment__default__default(value, this.formatString).valueOf();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OHourInputComponent.prototype.onKeyDown = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!Codes.isHourInputAllowed(e)) {
            e.preventDefault();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OHourInputComponent.prototype.innerOnBlur = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.onKeyboardInputDone) {
            this.updateValeOnInputChange(event);
        }
        _super.prototype.innerOnBlur.call(this, event);
    };
    /**
     * @return {?}
     */
    OHourInputComponent.prototype.registerOnFormControlChange = /**
     * @return {?}
     */
    function () {
        // This component does not need this subscription
    };
    Object.defineProperty(OHourInputComponent.prototype, "formatString", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.format === Codes.TWENTY_FOUR_HOUR_FORMAT ? Codes.HourFormat.TWENTY_FOUR : Codes.HourFormat.TWELVE);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?=} e
     * @return {?}
     */
    OHourInputComponent.prototype.open = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (Util.isDefined(e)) {
            e.stopPropagation();
        }
        if (this.picker) {
            this.picker.open();
        }
    };
    /**
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    OHourInputComponent.prototype.setTimestampValue = /**
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    function (value, options) {
        /** @type {?} */
        var parsedValue;
        /** @type {?} */
        var momentV = Util.isDefined(value) ? moment__default__default(value) : value;
        if (momentV && momentV.isValid()) {
            parsedValue = momentV.utcOffset(0).format(this.formatString);
        }
        this.setValue(parsedValue, options);
    };
    /**
     * @return {?}
     */
    OHourInputComponent.prototype.resolveValidators = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validators = _super.prototype.resolveValidators.call(this);
        if (this.format === Codes.TWENTY_FOUR_HOUR_FORMAT) {
            validators.push(OValidators.twentyFourHourFormatValidator);
        }
        else {
            validators.push(OValidators.twelveHourFormatValidator);
        }
        return validators;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OHourInputComponent.prototype.onFormControlChange = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.oldValue === value) {
            return;
        }
        _super.prototype.onFormControlChange.call(this, value);
    };
    Object.defineProperty(OHourInputComponent.prototype, "format", {
        get: /**
         * @return {?}
         */
        function () {
            return this._format;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var old = this._format;
            /** @type {?} */
            var parsedVal = NumberConverter(val);
            if (parsedVal !== Codes.TWELVE_FOUR_HOUR_FORMAT && parsedVal !== Codes.TWENTY_FOUR_HOUR_FORMAT) {
                parsedVal = Codes.TWENTY_FOUR_HOUR_FORMAT;
            }
            this._format = parsedVal;
            if (parsedVal !== old) {
                this.updateValidators();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OHourInputComponent.prototype, "valueType", {
        get: /**
         * @return {?}
         */
        function () {
            return this._valueType;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._valueType = this.convertToOHourValueType(val);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} val
     * @return {?}
     */
    OHourInputComponent.prototype.convertToOHourValueType = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        /** @type {?} */
        var result = 'string';
        /** @type {?} */
        var lowerVal = (val || '').toLowerCase();
        if (lowerVal === 'string' || lowerVal === 'timestamp') {
            return lowerVal;
        }
        return result;
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    OHourInputComponent.prototype.onChangeEvent = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        this.onTimepickerChange(arg.target.value);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OHourInputComponent.prototype.onTimepickerChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var value = event;
        if (this.valueType === 'timestamp') {
            value = moment__default__default(event, this.formatString).valueOf();
        }
        else {
            value = this.convertToFormatString(event);
        }
        /** emitModelToViewChange: false  because onChange event is trigger in ngModelChange */
        this.setValue(value, {
            changeType: OValueChangeEvent.USER_CHANGE,
            emitEvent: false,
            emitModelToViewChange: false
        });
    };
    /**
     * @return {?}
     */
    OHourInputComponent.prototype.modifyPickerMethods = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.picker) {
            /** @type {?} */
            var ngxTimepicker = this.picker.timepickerInput;
            if (ngxTimepicker && ngxTimepicker.onInput) {
                ngxTimepicker.onInput = function (value) { return _this.onKeyboardInputDone = true; };
            }
        }
    };
    /**
     * @param {?} blurEvent
     * @return {?}
     */
    OHourInputComponent.prototype.updateValeOnInputChange = /**
     * @param {?} blurEvent
     * @return {?}
     */
    function (blurEvent) {
        if (this.onKeyboardInputDone) {
            /** @type {?} */
            var value = blurEvent.currentTarget.value;
            // ngx-material-timepicker does not allow writing characters on input, so we add 'AM/PM' in order to make validation work properly
            value = this.parseHour(value);
            this.setValue(value);
        }
        this.onKeyboardInputDone = false;
    };
    /**
     * Receives an hour input introduced by the user and returns the hour formated acording current format
     * @param value
     */
    /**
     * Receives an hour input introduced by the user and returns the hour formated acording current format
     * @param {?} value
     * @return {?}
     */
    OHourInputComponent.prototype.parseHour = /**
     * Receives an hour input introduced by the user and returns the hour formated acording current format
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var strArray = value.split(':');
        /** @type {?} */
        var hour = strArray[0];
        if (Codes.TWELVE_FOUR_HOUR_FORMAT === this.format) {
            if (hour) {
                hour = parseInt(hour);
                /** @type {?} */
                var period = hour <= 12 ? ' AM' : ' PM';
                if (hour > 12) {
                    hour = hour - 12;
                }
                strArray[0] = hour;
                value = strArray.join(':') + period;
            }
        }
        else if (Codes.TWELVE_FOUR_HOUR_FORMAT === this.format) {
            // do nothing
        }
        return value;
    };
    /**
     * @param {?} type
     * @param {?} newValue
     * @param {?} oldValue
     * @return {?}
     */
    OHourInputComponent.prototype.emitOnValueChange = /**
     * @param {?} type
     * @param {?} newValue
     * @param {?} oldValue
     * @return {?}
     */
    function (type, newValue, oldValue) {
        this.onChange.emit(newValue);
        _super.prototype.emitOnValueChange.call(this, type, newValue, oldValue);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OHourInputComponent.prototype.convertToFormatString = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value === '00:00' || !Util.isDefined(value)) {
            return value;
        }
        /** @type {?} */
        var formatStr = this.format === Codes.TWENTY_FOUR_HOUR_FORMAT ? 'HH:mm' : 'hh:mm a';
        /** @type {?} */
        var result = value;
        if (typeof value === 'number') {
            result = moment__default__default(value).format(formatStr);
        }
        else {
            result = value ? moment__default__default(value, 'h:mm A').format(formatStr) : value;
        }
        return result;
    };
    OHourInputComponent.DEFAULT_INPUTS_O_HOUR_INPUT = DEFAULT_INPUTS_O_HOUR_INPUT;
    OHourInputComponent.DEFAULT_OUTPUTS_O_HOUR_INPUT = DEFAULT_OUTPUTS_O_HOUR_INPUT;
    OHourInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-hour-input',
                    template: "\n    <div fxLayout=\"row\" fxLayoutAlign=\"space-between center\" [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\"\n      [matTooltipClass]=\"tooltipClass\" [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\">\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" fxFill [hideRequiredMarker]=\"hideRequiredMarker\">\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input matInput [ngxTimepicker]=\"picker\" [id]=\"getAttribute()\" [placeholder]=\"placeHolder\"\n          [formControlName]=\"getAttribute()\" [readonly]=\"isReadOnly || !textInputEnabled\" (focus)=\"innerOnFocus($event)\"\n          (blur)=\"innerOnBlur($event)\" [required]=\"isRequired\" (change)=\"onChangeEvent($event)\" [min]=\"min\" [max]=\"max\"\n          (keydown)=\"onKeyDown($event)\" [format]=\"format\" [disableClick]=\"true\">\n\n        <button type=\"button\" *ngIf=\"showClearButton\" matSuffix mat-icon-button (click)=\"onClickClearValue($event)\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n        <button type=\"button\" matSuffix mat-icon-button [disabled]=\"isReadOnly || !enabled\" (click)=\"open($event)\">\n          <mat-icon ngxMaterialTimepickerToggleIcon svgIcon=\"ontimize:clock\"></mat-icon>\n        </button>\n\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }} \"></mat-error>\n        <mat-error *ngIf=\"hasError('invalidFormatHour')\"\n          text=\"{{ 'FORM_VALIDATION.HOUR_FORMAT' | oTranslate }} {{ formatString }}\"></mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n\n    <ngx-material-timepicker #picker (timeSet)=\"onTimepickerChange($event)\" [confirmBtnTmpl]=\"confirmBtn\"\n      [cancelBtnTmpl]=\"cancelBtn\"></ngx-material-timepicker>\n  \n    <ng-template #confirmBtn>\n      <button mat-stroked-button type=\"button\" (click)=\"setTime($event)\"><span>{{'OK' | oTranslate}}</span></button>\n    </ng-template>\n    <ng-template #cancelBtn>\n      <button mat-stroked-button type=\"button\" (click)=\"picker.close()\"><span>{{'CANCEL' | oTranslate}}</span></button>\n    </ng-template>\n  ",
                    styles: ["\n    button.mat-stroked-button{margin:0 6px}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    outputs: DEFAULT_OUTPUTS_O_HOUR_INPUT,
                    inputs: DEFAULT_INPUTS_O_HOUR_INPUT,
                    host: {
                        '[class.o-hour-input]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OHourInputComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    OHourInputComponent.propDecorators = {
        picker: [{ type: core.ViewChild, args: ['picker',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OHourInputComponent.prototype, "textInputEnabled", void 0);
    return OHourInputComponent;
}(OFormDataComponent));
var OHourInputModule = /** @class */ (function () {
    function OHourInputModule() {
    }
    OHourInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OHourInputComponent],
                    imports: [OSharedModule, common.CommonModule, NgxMaterialTimepickerModule],
                    exports: [OHourInputComponent]
                },] },
    ];
    return OHourInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TIME_INPUT = DEFAULT_INPUTS_O_FORM_DATA_COMPONENT.concat([
    'oDateFormat: date-format',
    'oDateLocale: date-locale',
    'oDateStartView: date-start-view',
    'oDateMinDate: date-min',
    'oDateMaxDate: date-max',
    'oDateTouchUi: date-touch-ui',
    'oDateStartAt: date-start-at',
    'oDateFilterDate: date-filter-date',
    'oDateTextInputEnabled: date-text-input-enabled',
    'oHourFormat: hour-format',
    'oHourMin: hour-min',
    'oHourMax: hour-max',
    'oHourTextInputEnabled: hour-text-input-enabled',
    'oHourPlaceholder: hour-placeholder',
    'oDatePlaceholder: date-placeholder'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_TIME_INPUT = DEFAULT_OUTPUTS_O_FORM_DATA_COMPONENT.slice();
var OTimeInputComponent = /** @class */ (function (_super) {
    __extends(OTimeInputComponent, _super);
    function OTimeInputComponent(form, elRef, injector, cd) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.cd = cd;
        _this.oDateFormat = 'L';
        _this.oDateStartView = 'month';
        _this.oDateTextInputEnabled = true;
        _this.oHourFormat = 24;
        _this.oHourTextInputEnabled = true;
        _this.oHourPlaceholder = '';
        _this.oDatePlaceholder = '';
        _this.formGroup = new forms.FormGroup({});
        _this.subscription = new Subscription();
        _this._defaultSQLTypeKey = 'DATE';
        return _this;
    }
    /**
     * @return {?}
     */
    OTimeInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        /** @type {?} */
        var self = this;
        /** @type {?} */
        var mergeSubscription = merge(this.dateInput.onValueChange, this.hourInput.onValueChange).subscribe(function (event) {
            if (event.isUserChange()) {
                self.updateComponentValue();
                /** @type {?} */
                var newValue = self._fControl.value;
                self.emitOnValueChange(OValueChangeEvent.USER_CHANGE, newValue, self.oldValue);
                self.oldValue = newValue;
            }
        });
        this.subscription.add(mergeSubscription);
    };
    /**
     * @return {?}
     */
    OTimeInputComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.modifyFormControls();
        _super.prototype.ngAfterViewInit.call(this);
        this.registerFormControls();
        this.setInnerComponentsData();
    };
    /**
     * @return {?}
     */
    OTimeInputComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    /**
     * @param {?} cfg
     * @param {?} validators
     * @return {?}
     */
    OTimeInputComponent.prototype.createFormControl = /**
     * @param {?} cfg
     * @param {?} validators
     * @return {?}
     */
    function (cfg, validators) {
        this._fControl = _super.prototype.createFormControl.call(this, cfg, validators);
        this._fControl.fControlChildren = [this.dateInput, this.hourInput];
        return this._fControl;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OTimeInputComponent.prototype.onFormControlChange = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        _super.prototype.onFormControlChange.call(this, value);
        this.setInnerComponentsData();
    };
    /**
     * @param {?} newValue
     * @param {?=} options
     * @return {?}
     */
    OTimeInputComponent.prototype.setValue = /**
     * @param {?} newValue
     * @param {?=} options
     * @return {?}
     */
    function (newValue, options) {
        /** @type {?} */
        var changed = this.oldValue !== newValue;
        _super.prototype.setValue.call(this, newValue, options);
        if (changed) {
            this.setInnerComponentsData();
        }
    };
    /**
     * @return {?}
     */
    OTimeInputComponent.prototype.onClickClearValue = /**
     * @return {?}
     */
    function () {
        this.blockGroupValueChanges = true;
        if (this.dateInput) {
            this.dateInput.clearValue();
        }
        if (this.hourInput) {
            this.hourInput.clearValue();
        }
        this.clearValue();
        this.blockGroupValueChanges = false;
    };
    /**
     * @return {?}
     */
    OTimeInputComponent.prototype.setInnerComponentsData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var dateValue;
        /** @type {?} */
        var hourValue;
        if (Util.isDefined(this.value) && Util.isDefined(this.value.value)) {
            /** @type {?} */
            var momentD = moment__default__default(this.value.value);
            if (momentD.isValid()) {
                dateValue = momentD.clone().startOf('day').valueOf();
                hourValue = momentD.clone().valueOf() - dateValue;
            }
        }
        if (this.dateInput) {
            this.dateInput.setValue(dateValue);
        }
        if (this.hourInput) {
            this.hourInput.setTimestampValue(hourValue);
        }
        this.cd.detectChanges();
    };
    /**
     * @return {?}
     */
    OTimeInputComponent.prototype.updateComponentValue = /**
     * @return {?}
     */
    function () {
        if (!this.value) {
            this.value = new OFormValue();
        }
        /** @type {?} */
        var timeValue;
        /** @type {?} */
        var values = this.formGroup.getRawValue();
        /** @type {?} */
        var mDate = (values['dateInput'] ? moment__default__default(values['dateInput']) : moment__default__default()).startOf('day');
        /** @type {?} */
        var mHour = this.hourInput.valueType === 'timestamp' ? moment__default__default(values['hourInput']) : moment__default__default(values['hourInput'], this.hourInput.formatString);
        timeValue = mDate.clone()
            .set('hour', mHour.get('hour'))
            .set('minute', mHour.get('minutes'))
            .valueOf();
        if (this._fControl) {
            this._fControl.setValue(timeValue);
            this._fControl.markAsDirty();
        }
        this.ensureOFormValue(timeValue);
    };
    /**
     * @return {?}
     */
    OTimeInputComponent.prototype.modifyFormControls = /**
     * @return {?}
     */
    function () {
        if (this.dateInput) {
            /** @type {?} */
            var self_1 = this;
            this.dateInput.getFormGroup = function () {
                return self_1.formGroup;
            };
        }
        if (this.hourInput) {
            /** @type {?} */
            var self_2 = this;
            this.hourInput.getFormGroup = function () {
                return self_2.formGroup;
            };
        }
        if (this.form) {
            this.form.formGroup.removeControl('dateInput');
            this.form.formGroup.removeControl('hourInput');
        }
    };
    /**
     * @return {?}
     */
    OTimeInputComponent.prototype.registerFormControls = /**
     * @return {?}
     */
    function () {
        if (this.dateInput && this.dateInput.getFormControl()) {
            this.formGroup.registerControl('dateInput', this.dateInput.getFormControl());
        }
        if (this.hourInput) {
            if (this.hourInput.getFormControl()) {
                this.formGroup.registerControl('hourInput', this.hourInput.getFormControl());
            }
        }
    };
    OTimeInputComponent.DEFAULT_INPUTS_O_TIME_INPUT = DEFAULT_INPUTS_O_TIME_INPUT;
    OTimeInputComponent.DEFAULT_OUTPUTS_O_TIME_INPUT = DEFAULT_OUTPUTS_O_TIME_INPUT;
    OTimeInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-time-input',
                    template: "\n    <div [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\" [matTooltipClass]=\"tooltipClass\"\n      [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\">\n      <div class=\"mat-form-field mat-form-field-appearance-legacy\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\"\n        fxLayoutGap=\"8px\">\n        <o-date-input #dateInput fxFlex attr=\"dateInput\" [read-only]=\"readOnly\" [enabled]=\"enabled\" [required]=\"isRequired\"\n          [label]=\"olabel\" clear-button=\"no\" automatic-registering=\"no\" automatic-binding=\"no\"\n          (onFocus)=\"innerOnFocus($event)\" (onBlur)=\"innerOnBlur($event)\" [format]=\"oDateFormat\" [locale]=\"oDateLocale\"\n          [start-view]=\"oDateStartView\" [min]=\"oDateMinDate\" [max]=\"oDateMaxDate\" [touch-ui]=\"oDateTouchUi\"\n          [start-at]=\"oDateStartAt\" [filter-date]=\"oDateFilterDate\" [text-input-enabled]=\"oDateTextInputEnabled\"\n          [placeholder]=\"oDatePlaceholder\" [label-visible]=\"labelVisible\" [hide-required-marker]=\"hideRequiredMarker\">\n        </o-date-input>\n\n        <span class=\"separator\">&ndash;</span>\n\n        <o-hour-input #hourInput fxFlex attr=\"hourInput\" [read-only]=\"readOnly\" [enabled]=\"enabled\" [required]=\"isRequired\"\n          clear-button=\"no\" automatic-registering=\"no\" automatic-binding=\"no\" (onFocus)=\"innerOnFocus($event)\"\n          (onBlur)=\"innerOnBlur($event)\" [format]=\"oHourFormat\" [text-input-enabled]=\"oHourTextInputEnabled\"\n          [min]=\"oHourMin\" [max]=\"oHourMax\" hide-required-marker=\"yes\" label-visible=\"no\" [placeholder]=\"oHourPlaceholder\">\n        </o-hour-input>\n\n        <button class=\"mat-form-field-suffix\" type=\"button\" *ngIf=\"showClearButton\" matSuffix mat-icon-button\n          (click)=\"onClickClearValue()\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n      </div>\n\n      <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n    </div>\n  ",
                    styles: ["\n    .o-time-input .separator{cursor:default}.o-time-input .mat-form-field.icon-field:not(.custom-width).icon-field-1-suffix .mat-form-field-infix{width:auto}\n  "],
                    inputs: DEFAULT_INPUTS_O_TIME_INPUT,
                    outputs: DEFAULT_OUTPUTS_O_TIME_INPUT,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-time-input]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OTimeInputComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector },
        { type: core.ChangeDetectorRef }
    ]; };
    OTimeInputComponent.propDecorators = {
        dateInput: [{ type: core.ViewChild, args: ['dateInput',] }],
        hourInput: [{ type: core.ViewChild, args: ['hourInput',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTimeInputComponent.prototype, "oDateTouchUi", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTimeInputComponent.prototype, "oDateTextInputEnabled", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OTimeInputComponent.prototype, "oHourTextInputEnabled", void 0);
    return OTimeInputComponent;
}(OFormDataComponent));
var OTimeInputModule = /** @class */ (function () {
    function OTimeInputModule() {
    }
    OTimeInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OTimeInputComponent],
                    imports: [common.CommonModule, ODateInputModule, OHourInputModule, OSharedModule],
                    exports: [OTimeInputComponent]
                },] },
    ];
    return OTimeInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_RADIO = OFormServiceComponent.DEFAULT_INPUTS_O_FORM_SERVICE_COMPONENT.concat([
    'translate',
    'layout',
    'labelPosition: label-position'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_RADIO = OFormServiceComponent.DEFAULT_OUTPUTS_O_FORM_SERVICE_COMPONENT.slice();
var 0$10 = dataServiceFactory;
var ORadioComponent = /** @class */ (function (_super) {
    __extends(ORadioComponent, _super);
    function ORadioComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        /* Inputs */
        _this.translate = false;
        _this.layout = 'column';
        _this.labelPosition = 'after';
        return _this;
    }
    /**
     * @return {?}
     */
    ORadioComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngAfterViewInit.call(this);
        if (this.queryOnInit) {
            this.queryData();
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ORadioComponent.prototype.onMatRadioGroupChange = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        /** @type {?} */
        var newValue = e.value;
        this.setValue(newValue, {
            changeType: OValueChangeEvent.USER_CHANGE,
            emitEvent: false,
            emitModelToViewChange: false
        });
    };
    /**
     * @param {?=} item
     * @return {?}
     */
    ORadioComponent.prototype.getOptionDescriptionValue = /**
     * @param {?=} item
     * @return {?}
     */
    function (item) {
        if (item === void 0) { item = {}; }
        /** @type {?} */
        var descTxt = '';
        if (this.descriptionColArray && this.descriptionColArray.length > 0) {
            /** @type {?} */
            var self = this;
            this.descriptionColArray.forEach(function (col, index) {
                /** @type {?} */
                var txt = item[col];
                if (txt) {
                    if (self.translate && self.translateService) {
                        txt = self.translateService.get(txt);
                    }
                    descTxt += txt;
                }
                if (index < self.descriptionColArray.length - 1) {
                    descTxt += self.separator;
                }
            });
        }
        return descTxt;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    ORadioComponent.prototype.getValueColumn = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item && item.hasOwnProperty(this.valueColumn)) {
            /** @type {?} */
            var option = item[this.valueColumn];
            if (option === 'undefined') {
                option = null;
            }
            return option;
        }
        return void 0;
    };
    /**
     * @return {?}
     */
    ORadioComponent.prototype.getDescriptionValue = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (Util.isDefined(this.descriptionColArray) && this.descriptionColArray.length) {
            /** @type {?} */
            var currItem_1 = this.dataArray.find(function (e) { return e[_this.valueColumn] === _this.getValue(); });
            if (Util.isDefined(currItem_1)) {
                return this.descriptionColArray.map(function (col) { return (_this.translate && _this.translateService) ? _this.translateService.get(currItem_1[col]) : currItem_1[col]; }).join(this.separator);
            }
        }
        return '';
    };
    ORadioComponent.DEFAULT_INPUTS_O_RADIO = DEFAULT_INPUTS_O_RADIO;
    ORadioComponent.DEFAULT_OUTPUTS_O_RADIO = DEFAULT_OUTPUTS_O_RADIO;
    ORadioComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'o-radio',
                    template: "\n    <div [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\" [matTooltipClass]=\"tooltipClass\"\n      [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\" class=\"relative\">\n      <!-- mat-form-field and hidden input are used only for displaying component label and errors as mat-radio is not supported inside form-field -->\n      <!-- https://github.com/angular/material2/issues/7891 -->\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [hideRequiredMarker]=\"hideRequiredMarker\"\n        [class.read-only]=\"isReadOnly\" [class.custom-width]=\"hasCustomWidth\" [class.o-radio-from-field-row]=\"layout==='row'\"\n        floatLabel=\"always\" class=\"mat-form-field--no-underline\" fxFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input matInput [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\" [placeholder]=\"placeHolder\"\n          [required]=\"isRequired\" style=\"display: none\" />\n        <mat-radio-group [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\" [name]=\"getAttribute()\"\n          [value]=\"getValue()\" [required]=\"isRequired\" [labelPosition]=\"labelPosition\"\n          (change)=\"onMatRadioGroupChange($event)\" [fxLayout]=\"layout\" fxLayoutGap=\"8px\">\n          <mat-radio-button *ngFor=\"let item of getDataArray()\" [value]=\"getValueColumn(item)\" [disabled]=\"!enabled\">\n            {{ getOptionDescriptionValue(item) }}\n          </mat-radio-button>\n        </mat-radio-group>\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n      <div *ngIf=\"isReadOnly\" (click)=\"$event.stopPropagation()\" class=\"read-only-blocker\" fxFill></div>\n    </div>\n  ",
                    styles: ["\n    .o-radio .mat-form-field--no-underline .mat-form-field-underline,.o-radio .mat-form-field--no-underline .mat-form-field-underline .mat-form-field-ripple{background-image:none;background-color:transparent}.o-radio .mat-form-field:not(.custom-width).o-radio-from-field-row .mat-form-field-infix{width:auto}.o-radio .read-only-blocker{z-index:2;position:absolute;top:0;left:0;right:0}\n  "],
                    inputs: DEFAULT_INPUTS_O_RADIO,
                    outputs: DEFAULT_OUTPUTS_O_RADIO,
                    providers: [
                        { provide: OntimizeService$$1, useFactory: 0$10, deps: [core.Injector] }
                    ],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-radio]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    ORadioComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], ORadioComponent.prototype, "translate", void 0);
    return ORadioComponent;
}(OFormServiceComponent));
var ORadioModule = /** @class */ (function () {
    function ORadioModule() {
    }
    ORadioModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [ORadioComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [ORadioComponent]
                },] },
    ];
    return ORadioModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_SLIDETOGGLE = [
    'trueValue: true-value',
    'falseValue: false-value',
    'booleanType: boolean-type',
    'color',
    'labelPosition: label-position'
].concat(DEFAULT_INPUTS_O_FORM_DATA_COMPONENT);
/** @type {?} */
var DEFAULT_OUTPUTS_O_SLIDETOGGLE = DEFAULT_OUTPUTS_O_FORM_DATA_COMPONENT.slice();
var OSlideToggleComponent = /** @class */ (function (_super) {
    __extends(OSlideToggleComponent, _super);
    function OSlideToggleComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.trueValue = true;
        _this.falseValue = false;
        _this.booleanType = 'boolean';
        _this.labelPosition = 'after';
        _this._defaultSQLTypeKey = 'BOOLEAN';
        _this.defaultValue = false;
        return _this;
    }
    /**
     * @return {?}
     */
    OSlideToggleComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        _super.prototype.initialize.call(this);
        if (!Util.isDefined(this.sqlType)) {
            switch (this.booleanType) {
                case 'number':
                    this.sqlType = 'INTEGER';
                    break;
                case 'string':
                    this.sqlType = 'VARCHAR';
                    break;
                case 'boolean':
                default:
                    this.sqlType = 'BOOLEAN';
            }
        }
        this.defaultValue = this.falseValue;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    OSlideToggleComponent.prototype.ensureOFormValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value instanceof OFormValue) {
            if (!Util.isDefined(value.value)) {
                value.value = this.falseValue;
            }
            this.value = new OFormValue(value.value);
        }
        else {
            this.value = new OFormValue(value === this.trueValue ? this.trueValue : this.falseValue);
        }
    };
    /**
     * @return {?}
     */
    OSlideToggleComponent.prototype.isChecked = /**
     * @return {?}
     */
    function () {
        if (this.value instanceof OFormValue) {
            return this.value.value === this.trueValue;
        }
        return false;
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OSlideToggleComponent.prototype.onClickBlocker = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        e.stopPropagation();
    };
    OSlideToggleComponent.DEFAULT_INPUTS_O_CHECKBOX = DEFAULT_INPUTS_O_SLIDETOGGLE;
    OSlideToggleComponent.DEFAULT_OUTPUTS_O_CHECKBOX = DEFAULT_OUTPUTS_O_SLIDETOGGLE;
    OSlideToggleComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-slide-toggle',
                    inputs: DEFAULT_INPUTS_O_SLIDETOGGLE,
                    outputs: DEFAULT_OUTPUTS_O_SLIDETOGGLE,
                    template: "\n    <div [class.custom-width]=\"hasCustomWidth\" [formGroup]=\"getFormGroup()\" class=\"relative\" [matTooltip]=\"tooltip\"\n      [matTooltipClass]=\"tooltipClass\" [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\" fxLayout=\"row\" fxLayoutAlign=\"start center\" fxFill>\n      <mat-slide-toggle [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\" [checked]=\"isChecked()\"\n        [required]=\"isRequired\" [labelPosition]=\"labelPosition\" [color]=\"color\" (change)=\"onChangeEvent($event)\">\n        <ng-container *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</ng-container>\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-slide-toggle>\n      <div *ngIf=\"isReadOnly\" (click)=\"onClickBlocker($event)\" class=\"read-only-blocker\" fxFill></div>\n    </div>\n  ",
                    styles: ["\n    .o-slide-toggle .read-only-blocker{z-index:2;position:absolute;top:0;left:0;right:0}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-slide-toggle]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OSlideToggleComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    return OSlideToggleComponent;
}(OFormDataComponent));
var OSlideToggleModule = /** @class */ (function () {
    function OSlideToggleModule() {
    }
    OSlideToggleModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OSlideToggleComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OSlideToggleComponent]
                },] },
    ];
    return OSlideToggleModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_SLIDER_INPUT$$1 = DEFAULT_INPUTS_O_FORM_DATA_COMPONENT.concat([
    'color',
    'invert',
    'max',
    'min',
    'step',
    'thumbLabel:thumb-label',
    'tickInterval:tick-interval',
    'layout',
    'oDisplayWith:display-with'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_SLIDER_INPUT$$1 = DEFAULT_OUTPUTS_O_FORM_DATA_COMPONENT.slice();
var OSliderComponent$$1 = /** @class */ (function (_super) {
    __extends(OSliderComponent$$1, _super);
    function OSliderComponent$$1(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.layout = 'row';
        _this.vertical = false;
        _this.invert = false;
        _this.thumbLabel = false;
        _this.step = 1;
        _this._tickInterval = 0;
        return _this;
    }
    Object.defineProperty(OSliderComponent$$1.prototype, "tickInterval", {
        get: /**
         * @return {?}
         */
        function () {
            return this._tickInterval;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._tickInterval = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} evt
     * @return {?}
     */
    OSliderComponent$$1.prototype.onClickBlocker = /**
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        evt.stopPropagation();
    };
    OSliderComponent$$1.DEFAULT_INPUTS_O_SLIDER_INPUT = DEFAULT_INPUTS_O_SLIDER_INPUT$$1;
    OSliderComponent$$1.DEFAULT_OUTPUTS_O_SLIDER_INPUT = DEFAULT_OUTPUTS_O_SLIDER_INPUT$$1;
    OSliderComponent$$1.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-slider',
                    host: {
                        'class': 'o-slider'
                    },
                    template: "\n    <div [formGroup]=\"getFormGroup()\" class=\"relative\" [matTooltip]=\"tooltip\" [matTooltipClass]=\"tooltipClass\"\n      [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\" [matTooltipHideDelay]=\"tooltipHideDelay\">\n      <mat-slider [color]=\"color\" [invert]=\"invert\" [max]=\"max\" [min]=\"min\" [step]=\"step\" [thumbLabel]=\"thumbLabel\"\n        [tickInterval]=\"tickInterval\" [vertical]=\"layout==='column'\" [id]=\"getAttribute()\"\n        [formControlName]=\"getAttribute()\" (change)=\"onChangeEvent($event)\" [displayWith]=\"oDisplayWith\"></mat-slider>\n      <div *ngIf=\"isReadOnly\" (click)=\"onClickBlocker($event)\" class=\"read-only-blocker\" fxFill></div>\n    </div>\n  ",
                    styles: ["\n    .o-slider mat-slider{width:100%}.o-slider .read-only-blocker{z-index:2;position:absolute;top:0;left:0;right:0}\n  "],
                    inputs: DEFAULT_INPUTS_O_SLIDER_INPUT$$1,
                    outputs: DEFAULT_OUTPUTS_O_SLIDER_INPUT$$1,
                    encapsulation: core.ViewEncapsulation.None
                },] },
    ];
    /** @nocollapse */
    OSliderComponent$$1.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OSliderComponent$$1.prototype, "vertical", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OSliderComponent$$1.prototype, "invert", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OSliderComponent$$1.prototype, "thumbLabel", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OSliderComponent$$1.prototype, "min", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OSliderComponent$$1.prototype, "max", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OSliderComponent$$1.prototype, "step", void 0);
    return OSliderComponent$$1;
}(OFormDataComponent));
var OSliderModule$$1 = /** @class */ (function () {
    function OSliderModule$$1() {
    }
    OSliderModule$$1.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OSliderComponent$$1],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OSliderComponent$$1]
                },] },
    ];
    return OSliderModule$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var moment$1$1 = moment__default;
/** @enum {string} */
var SideEnum = {
    left: 'left',
    right: 'right',
};
var DaterangepickerComponent = /** @class */ (function () {
    function DaterangepickerComponent(_ref) {
        this._ref = _ref;
        this._old = { start: null, end: null };
        this.calendarVariables = { left: {}, right: {} };
        this.timepickerVariables = { left: {}, right: {} };
        this.daterangepicker = { start: new forms.FormControl(), end: new forms.FormControl() };
        this.applyBtn = { disabled: false };
        this.startDate = moment$1$1().startOf('day');
        this.endDate = moment$1$1().endOf('day');
        this.dateLimit = null;
        // used in template for compile time support of enum values.
        this.sideEnum = SideEnum;
        this.minDate = null;
        this.maxDate = null;
        this.autoApply = false;
        this.singleDatePicker = false;
        this.showDropdowns = false;
        this.showWeekNumbers = false;
        this.showISOWeekNumbers = false;
        this.linkedCalendars = false;
        this.autoUpdateInput = true;
        this.alwaysShowCalendars = false;
        this.maxSpan = false;
        // timepicker variables
        this.timePicker = false;
        this.timePicker24Hour = false;
        this.timePickerIncrement = 1;
        this.timePickerSeconds = false;
        // end of timepicker variables
        this.showClearButton = false;
        this.firstMonthDayClass = null;
        this.lastMonthDayClass = null;
        this.emptyWeekRowClass = null;
        this.firstDayOfNextMonthClass = null;
        this.lastDayOfPreviousMonthClass = null;
        // custom ranges
        this._ranges = {};
        this.showCancel = false;
        this.keepCalendarOpeningWithRange = false;
        this.showRangeLabelOnInput = false;
        this.rangesArray = [];
        // some state information
        this.isShown = false;
        this.inline = true;
        this.leftCalendar = {};
        this.rightCalendar = {};
        this.showCalInRanges = false;
        this.options = {};
        this.choosedDate = new core.EventEmitter();
        this.rangeClicked = new core.EventEmitter();
        this.datesUpdated = new core.EventEmitter();
    }
    Object.defineProperty(DaterangepickerComponent.prototype, "ranges", {
        get: /**
         * @return {?}
         */
        function () {
            return this._ranges;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._ranges = value;
            this.renderRanges();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    DaterangepickerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._buildLocale();
        /** @type {?} */
        var daysOfWeek = this.locale.daysOfWeek.slice();
        if (this.locale.firstDay !== 0) {
            /** @type {?} */
            var iterator = this.locale.firstDay;
            while (iterator > 0) {
                daysOfWeek.push(daysOfWeek.shift());
                iterator--;
            }
        }
        this.locale.daysOfWeek = daysOfWeek;
        if (this.inline) {
            this._old.start = this.startDate.clone();
            this._old.end = this.endDate.clone();
        }
        this.updateMonthsInView();
        this.renderCalendar(SideEnum.left);
        this.renderCalendar(SideEnum.right);
        this.renderRanges();
    };
    /**
     * @return {?}
     */
    DaterangepickerComponent.prototype.renderRanges = /**
     * @return {?}
     */
    function () {
        this.rangesArray = [];
        /** @type {?} */
        var start;
        /** @type {?} */
        var end;
        if (typeof this.ranges === 'object') {
            for (var range$$1 in this.ranges) {
                if (typeof this.ranges[range$$1][0] === 'string') {
                    start = moment$1$1(this.ranges[range$$1][0], this.locale.format);
                }
                else {
                    start = moment$1$1(this.ranges[range$$1][0]);
                }
                if (typeof this.ranges[range$$1][1] === 'string') {
                    end = moment$1$1(this.ranges[range$$1][1], this.locale.format);
                }
                else {
                    end = moment$1$1(this.ranges[range$$1][1]);
                }
                // If the start or end date exceed those allowed by the minDate or maxSpan
                // options, shorten the range to the allowable period.
                if (this.minDate && start.isBefore(this.minDate)) {
                    start = this.minDate.clone();
                }
                /** @type {?} */
                var maxDate = this.maxDate;
                if (this.maxSpan && maxDate && start.clone().add(this.maxSpan).isAfter(maxDate)) {
                    maxDate = start.clone().add(this.maxSpan);
                }
                if (maxDate && end.isAfter(maxDate)) {
                    end = maxDate.clone();
                }
                // If the end of the range is before the minimum or the start of the range is
                // after the maximum, don't display this range option at all.
                if ((this.minDate && end.isBefore(this.minDate, this.timePicker ? 'minute' : 'day'))
                    || (maxDate && start.isAfter(maxDate, this.timePicker ? 'minute' : 'day'))) {
                    continue;
                }
                /** @type {?} */
                var elem = document.createElement('textarea');
                elem.innerHTML = range$$1;
                /** @type {?} */
                var rangeHtml = elem.value;
                this.ranges[rangeHtml] = [start, end];
            }
            for (var range$$1 in this.ranges) {
                this.rangesArray.push(range$$1);
            }
            if (this.showCustomRangeLabel) {
                this.rangesArray.push(this.locale.customRangeLabel);
            }
            this.showCalInRanges = (!this.rangesArray.length) || this.alwaysShowCalendars;
            if (!this.timePicker) {
                this.startDate = this.startDate.startOf('day');
                this.endDate = this.endDate.endOf('day');
            }
            // can't be used together for now
            if (this.timePicker && this.autoApply) {
                this.autoApply = false;
            }
        }
    };
    /**
     * @param {?} side
     * @return {?}
     */
    DaterangepickerComponent.prototype.renderTimePicker = /**
     * @param {?} side
     * @return {?}
     */
    function (side) {
        if (side === SideEnum.right && !this.endDate) {
            return;
        }
        /** @type {?} */
        var selected;
        /** @type {?} */
        var minDate;
        /** @type {?} */
        var maxDate = this.maxDate;
        if (side === SideEnum.left) {
            selected = this.startDate.clone(), minDate = this.minDate;
        }
        else if (side === SideEnum.right) {
            selected = this.endDate.clone(), minDate = this.startDate;
        }
        /** @type {?} */
        var start = this.timePicker24Hour ? 0 : 1;
        /** @type {?} */
        var end = this.timePicker24Hour ? 23 : 12;
        this.timepickerVariables[side] = {
            hours: [],
            minutes: [],
            minutesLabel: [],
            seconds: [],
            secondsLabel: [],
            disabledHours: [],
            disabledMinutes: [],
            disabledSeconds: [],
            selectedHour: 0,
            selectedMinute: 0,
            selectedSecond: 0,
        };
        // generate hours
        for (var i_1 = start; i_1 <= end; i_1++) {
            /** @type {?} */
            var i_in_24 = i_1;
            if (!this.timePicker24Hour) {
                i_in_24 = selected.hour() >= 12 ? (i_1 === 12 ? 12 : i_1 + 12) : (i_1 === 12 ? 0 : i_1);
            }
            /** @type {?} */
            var time = selected.clone().hour(i_in_24);
            /** @type {?} */
            var disabled = false;
            if (minDate && time.minute(59).isBefore(minDate)) {
                disabled = true;
            }
            if (maxDate && time.minute(0).isAfter(maxDate)) {
                disabled = true;
            }
            this.timepickerVariables[side].hours.push(i_1);
            if (i_in_24 === selected.hour() && !disabled) {
                this.timepickerVariables[side].selectedHour = i_1;
            }
            else if (disabled) {
                this.timepickerVariables[side].disabledHours.push(i_1);
            }
        }
        // generate minutes
        for (var i = 0; i < 60; i += this.timePickerIncrement) {
            /** @type {?} */
            var padded = i < 10 ? '0' + i : i;
            /** @type {?} */
            var time = selected.clone().minute(i);
            /** @type {?} */
            var disabled = false;
            if (minDate && time.second(59).isBefore(minDate)) {
                disabled = true;
            }
            if (maxDate && time.second(0).isAfter(maxDate)) {
                disabled = true;
            }
            this.timepickerVariables[side].minutes.push(i);
            this.timepickerVariables[side].minutesLabel.push(padded);
            if (selected.minute() === i && !disabled) {
                this.timepickerVariables[side].selectedMinute = i;
            }
            else if (disabled) {
                this.timepickerVariables[side].disabledMinutes.push(i);
            }
        }
        // generate seconds
        if (this.timePickerSeconds) {
            for (var i_2 = 0; i_2 < 60; i_2++) {
                /** @type {?} */
                var padded = i_2 < 10 ? '0' + i_2 : i_2;
                /** @type {?} */
                var time = selected.clone().second(i_2);
                /** @type {?} */
                var disabled = false;
                if (minDate && time.isBefore(minDate)) {
                    disabled = true;
                }
                if (maxDate && time.isAfter(maxDate)) {
                    disabled = true;
                }
                this.timepickerVariables[side].seconds.push(i_2);
                this.timepickerVariables[side].secondsLabel.push(padded);
                if (selected.second() === i_2 && !disabled) {
                    this.timepickerVariables[side].selectedSecond = i_2;
                }
                else if (disabled) {
                    this.timepickerVariables[side].disabledSeconds.push(i_2);
                }
            }
        }
        // generate AM/PM
        if (!this.timePicker24Hour) {
            if (minDate && selected.clone().hour(12).minute(0).second(0).isBefore(minDate)) {
                this.timepickerVariables[side].amDisabled = true;
            }
            if (maxDate && selected.clone().hour(0).minute(0).second(0).isAfter(maxDate)) {
                this.timepickerVariables[side].pmDisabled = true;
            }
            if (selected.hour() >= 12) {
                this.timepickerVariables[side].ampmModel = 'PM';
            }
            else {
                this.timepickerVariables[side].ampmModel = 'AM';
            }
        }
        this.timepickerVariables[side].selected = selected;
    };
    /**
     * @param {?} side
     * @return {?}
     */
    DaterangepickerComponent.prototype.renderCalendar = /**
     * @param {?} side
     * @return {?}
     */
    function (side) {
        /** @type {?} */
        var mainCalendar = (side === SideEnum.left) ? this.leftCalendar : this.rightCalendar;
        /** @type {?} */
        var month = mainCalendar.month.month();
        /** @type {?} */
        var year = mainCalendar.month.year();
        /** @type {?} */
        var hour = mainCalendar.month.hour();
        /** @type {?} */
        var minute = mainCalendar.month.minute();
        /** @type {?} */
        var second = mainCalendar.month.second();
        /** @type {?} */
        var daysInMonth = moment$1$1([year, month]).daysInMonth();
        /** @type {?} */
        var firstDay = moment$1$1([year, month, 1]);
        /** @type {?} */
        var lastDay = moment$1$1([year, month, daysInMonth]);
        /** @type {?} */
        var lastMonth = moment$1$1(firstDay).subtract(1, 'month').month();
        /** @type {?} */
        var lastYear = moment$1$1(firstDay).subtract(1, 'month').year();
        /** @type {?} */
        var daysInLastMonth = moment$1$1([lastYear, lastMonth]).daysInMonth();
        /** @type {?} */
        var dayOfWeek = firstDay.day();
        /** @type {?} */
        var calendar = [];
        calendar.firstDay = firstDay;
        calendar.lastDay = lastDay;
        for (var i = 0; i < 6; i++) {
            calendar[i] = [];
        }
        /** @type {?} */
        var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay + 1;
        if (startDay > daysInLastMonth) {
            startDay -= 7;
        }
        if (dayOfWeek === this.locale.firstDay) {
            startDay = daysInLastMonth - 6;
        }
        /** @type {?} */
        var curDate = moment$1$1([lastYear, lastMonth, startDay, 12, minute, second]);
        for (var i = 0, col = 0, row = 0; i < 42; i++, col++, curDate = moment$1$1(curDate).add(24, 'hour')) {
            if (i > 0 && col % 7 === 0) {
                col = 0;
                row++;
            }
            calendar[row][col] = curDate.clone().hour(hour).minute(minute).second(second);
            curDate.hour(12);
            if (this.minDate && calendar[row][col].format('YYYY-MM-DD') === this.minDate.format('YYYY-MM-DD') &&
                calendar[row][col].isBefore(this.minDate) && side === 'left') {
                calendar[row][col] = this.minDate.clone();
            }
            if (this.maxDate && calendar[row][col].format('YYYY-MM-DD') === this.maxDate.format('YYYY-MM-DD') &&
                calendar[row][col].isAfter(this.maxDate) && side === 'right') {
                calendar[row][col] = this.maxDate.clone();
            }
        }
        // make the calendar object available to hoverDate/clickDate
        if (side === SideEnum.left) {
            this.leftCalendar.calendar = calendar;
        }
        else {
            this.rightCalendar.calendar = calendar;
        }
        /** @type {?} */
        var minDate = side === 'left' ? this.minDate : this.startDate;
        /** @type {?} */
        var maxDate = this.maxDate;
        // adjust maxDate to reflect the dateLimit setting in order to
        // grey out end dates beyond the dateLimit
        if (this.endDate === null && this.dateLimit) {
            /** @type {?} */
            var maxLimit = this.startDate.clone().add(this.dateLimit, 'day').endOf('day');
            if (!maxDate || maxLimit.isBefore(maxDate)) {
                maxDate = maxLimit;
            }
        }
        this.calendarVariables[side] = {
            month: month,
            year: year,
            hour: hour,
            minute: minute,
            second: second,
            daysInMonth: daysInMonth,
            firstDay: firstDay,
            lastDay: lastDay,
            lastMonth: lastMonth,
            lastYear: lastYear,
            daysInLastMonth: daysInLastMonth,
            dayOfWeek: dayOfWeek,
            // other vars
            calRows: Array.from(Array(6).keys()),
            calCols: Array.from(Array(7).keys()),
            classes: {},
            minDate: minDate,
            maxDate: maxDate,
            calendar: calendar
        };
        if (this.showDropdowns) {
            /** @type {?} */
            var currentMonth = calendar[1][1].month();
            /** @type {?} */
            var currentYear = calendar[1][1].year();
            /** @type {?} */
            var maxYear = (maxDate && maxDate.year()) || (currentYear + 5);
            /** @type {?} */
            var minYear = (minDate && minDate.year()) || (currentYear - 50);
            /** @type {?} */
            var inMinYear = currentYear === minYear;
            /** @type {?} */
            var inMaxYear = currentYear === maxYear;
            /** @type {?} */
            var years = [];
            for (var y = minYear; y <= maxYear; y++) {
                years.push(y);
            }
            this.calendarVariables[side].dropdowns = {
                currentMonth: currentMonth,
                currentYear: currentYear,
                maxYear: maxYear,
                minYear: minYear,
                inMinYear: inMinYear,
                inMaxYear: inMaxYear,
                monthArrays: Array.from(Array(12).keys()),
                yearArrays: years
            };
        }
        this._buildCells(calendar, side);
    };
    /**
     * @param {?} startDate
     * @return {?}
     */
    DaterangepickerComponent.prototype.setStartDate = /**
     * @param {?} startDate
     * @return {?}
     */
    function (startDate) {
        if (typeof startDate === 'string') {
            this.startDate = moment$1$1(startDate, this.locale.format);
        }
        if (typeof startDate === 'object') {
            this.startDate = moment$1$1(startDate);
        }
        if (!this.timePicker) {
            this.startDate = this.startDate.startOf('day');
        }
        if (this.timePicker && this.timePickerIncrement) {
            this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
        }
        if (this.minDate && this.startDate.isBefore(this.minDate)) {
            this.startDate = this.minDate.clone();
            if (this.timePicker && this.timePickerIncrement) {
                this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
            }
        }
        if (this.maxDate && this.startDate.isAfter(this.maxDate)) {
            this.startDate = this.maxDate.clone();
            if (this.timePicker && this.timePickerIncrement) {
                this.startDate.minute(Math.floor(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
            }
        }
        if (!this.isShown) {
            this.updateElement();
        }
        this.updateMonthsInView();
    };
    /**
     * @param {?} endDate
     * @return {?}
     */
    DaterangepickerComponent.prototype.setEndDate = /**
     * @param {?} endDate
     * @return {?}
     */
    function (endDate) {
        if (typeof endDate === 'string') {
            this.endDate = moment$1$1(endDate, this.locale.format);
        }
        if (typeof endDate === 'object') {
            this.endDate = moment$1$1(endDate);
        }
        if (!this.timePicker) {
            this.endDate = this.endDate.add(1, 'd').startOf('day').subtract(1, 'second');
        }
        if (this.timePicker && this.timePickerIncrement) {
            this.endDate.minute(Math.round(this.endDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
        }
        if (this.endDate.isBefore(this.startDate)) {
            this.endDate = this.startDate.clone();
        }
        if (this.maxDate && this.endDate.isAfter(this.maxDate)) {
            this.endDate = this.maxDate.clone();
        }
        if (this.dateLimit && this.startDate.clone().add(this.dateLimit, 'day').isBefore(this.endDate)) {
            this.endDate = this.startDate.clone().add(this.dateLimit, 'day');
        }
        if (!this.isShown) {
            // this.updateElement();
        }
        this.updateMonthsInView();
    };
    /**
     * @param {?} date
     * @return {?}
     */
    DaterangepickerComponent.prototype.isInvalidDate = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return false;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    DaterangepickerComponent.prototype.isCustomDate = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return false;
    };
    /**
     * @return {?}
     */
    DaterangepickerComponent.prototype.updateView = /**
     * @return {?}
     */
    function () {
        if (this.timePicker) {
            this.renderTimePicker(SideEnum.left);
            this.renderTimePicker(SideEnum.right);
        }
        this.updateMonthsInView();
        this.updateCalendars();
    };
    /**
     * @return {?}
     */
    DaterangepickerComponent.prototype.updateMonthsInView = /**
     * @return {?}
     */
    function () {
        if (this.endDate) {
            // if both dates are visible already, do nothing
            if (!this.singleDatePicker && this.leftCalendar.month && this.rightCalendar.month &&
                ((this.startDate && this.leftCalendar && this.startDate.format('YYYY-MM') === this.leftCalendar.month.format('YYYY-MM')) ||
                    (this.startDate && this.rightCalendar && this.startDate.format('YYYY-MM') === this.rightCalendar.month.format('YYYY-MM')))
                &&
                    (this.endDate.format('YYYY-MM') === this.leftCalendar.month.format('YYYY-MM') ||
                        this.endDate.format('YYYY-MM') === this.rightCalendar.month.format('YYYY-MM'))) {
                return;
            }
            if (this.startDate) {
                this.leftCalendar.month = this.startDate.clone().date(2);
                if (!this.linkedCalendars && (this.endDate.month() !== this.startDate.month() ||
                    this.endDate.year() !== this.startDate.year())) {
                    this.rightCalendar.month = this.endDate.clone().date(2);
                }
                else {
                    this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
                }
            }
        }
        else {
            if (this.leftCalendar.month.format('YYYY-MM') !== this.startDate.format('YYYY-MM') &&
                this.rightCalendar.month.format('YYYY-MM') !== this.startDate.format('YYYY-MM')) {
                this.leftCalendar.month = this.startDate.clone().date(2);
                this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
            }
        }
        if (this.maxDate && this.linkedCalendars && !this.singleDatePicker && this.rightCalendar.month > this.maxDate) {
            this.rightCalendar.month = this.maxDate.clone().date(2);
            this.leftCalendar.month = this.maxDate.clone().date(2).subtract(1, 'month');
        }
    };
    /**
     *  This is responsible for updating the calendars
     */
    /**
     *  This is responsible for updating the calendars
     * @return {?}
     */
    DaterangepickerComponent.prototype.updateCalendars = /**
     *  This is responsible for updating the calendars
     * @return {?}
     */
    function () {
        this.renderCalendar(SideEnum.left);
        this.renderCalendar(SideEnum.right);
        if (this.endDate === null) {
            return;
        }
        this.calculateChosenLabel();
    };
    /**
     * @return {?}
     */
    DaterangepickerComponent.prototype.updateElement = /**
     * @return {?}
     */
    function () {
        if (!this.singleDatePicker && this.autoUpdateInput) {
            if (this.startDate && this.endDate) {
                // if we use ranges and should show range label on inpu
                if (this.rangesArray.length && this.showRangeLabelOnInput === true && this.chosenRange &&
                    this.locale.customRangeLabel !== this.chosenRange) {
                    this.chosenLabel = this.chosenRange;
                }
                else {
                    this.chosenLabel = this.startDate.format(this.locale.format) +
                        this.locale.separator + this.endDate.format(this.locale.format);
                }
            }
        }
        else if (this.autoUpdateInput) {
            this.chosenLabel = this.startDate.format(this.locale.format);
        }
    };
    /**
     * @return {?}
     */
    DaterangepickerComponent.prototype.remove = /**
     * @return {?}
     */
    function () {
        this.isShown = false;
    };
    /**
     * this should calculate the label
     */
    /**
     * this should calculate the label
     * @return {?}
     */
    DaterangepickerComponent.prototype.calculateChosenLabel = /**
     * this should calculate the label
     * @return {?}
     */
    function () {
        if (!this.locale || !this.locale.separator) {
            this._buildLocale();
        }
        /** @type {?} */
        var customRange = true;
        /** @type {?} */
        var i = 0;
        if (this.rangesArray.length > 0) {
            for (var range$$1 in this.ranges) {
                if (this.timePicker) {
                    /** @type {?} */
                    var format = this.timePickerSeconds ? 'YYYY-MM-DD HH:mm:ss' : 'YYYY-MM-DD HH:mm';
                    //ignore times when comparing dates if time picker seconds is not enabled
                    if (this.startDate.format(format) === this.ranges[range$$1][0].format(format) && this.endDate.format(format) === this.ranges[range$$1][1].format(format)) {
                        customRange = false;
                        this.chosenRange = this.rangesArray[i];
                        break;
                    }
                }
                else {
                    //ignore times when comparing dates if time picker is not enabled
                    if (this.startDate.format('YYYY-MM-DD') === this.ranges[range$$1][0].format('YYYY-MM-DD') && this.endDate.format('YYYY-MM-DD') === this.ranges[range$$1][1].format('YYYY-MM-DD')) {
                        customRange = false;
                        this.chosenRange = this.rangesArray[i];
                        break;
                    }
                }
                i++;
            }
            if (customRange) {
                if (this.showCustomRangeLabel) {
                    this.chosenRange = this.locale.customRangeLabel;
                }
                else {
                    this.chosenRange = null;
                }
                // if custom label: show calenar
                this.showCalInRanges = true;
            }
        }
        this.updateElement();
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    DaterangepickerComponent.prototype.clickApply = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (!this.singleDatePicker && this.startDate && !this.endDate) {
            this.endDate = this.startDate.clone();
            this.calculateChosenLabel();
        }
        if (this.isInvalidDate && this.startDate && this.endDate) {
            /** @type {?} */
            var d = this.startDate.clone();
            while (d.isBefore(this.endDate)) {
                if (this.isInvalidDate(d)) {
                    this.endDate = d.subtract(1, 'days');
                    this.calculateChosenLabel();
                    break;
                }
                d.add(1, 'days');
            }
        }
        if (this.chosenLabel) {
            this.choosedDate.emit({ chosenLabel: this.chosenLabel, startDate: this.startDate, endDate: this.endDate });
        }
        this.datesUpdated.emit({ startDate: this.startDate, endDate: this.endDate });
        this.hide();
    };
    /**
     * @param {?} e
     * @return {?}
     */
    DaterangepickerComponent.prototype.clickCancel = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.startDate = this._old.start;
        this.endDate = this._old.end;
        if (this.inline) {
            this.updateView();
        }
        this.hide();
    };
    /**
     * called when month is changed
     * @param monthEvent get value in event.target.value
     * @param side left or right
     */
    /**
     * called when month is changed
     * @param {?} monthEvent get value in event.target.value
     * @param {?} side left or right
     * @return {?}
     */
    DaterangepickerComponent.prototype.monthChanged = /**
     * called when month is changed
     * @param {?} monthEvent get value in event.target.value
     * @param {?} side left or right
     * @return {?}
     */
    function (monthEvent, side) {
        /** @type {?} */
        var year = this.calendarVariables[side].dropdowns.currentYear;
        /** @type {?} */
        var month = parseInt(monthEvent.target.value, 10);
        this.monthOrYearChanged(month, year, side);
    };
    /**
     * called when year is changed
     * @param yearEvent get value in event.target.value
     * @param side left or right
     */
    /**
     * called when year is changed
     * @param {?} yearEvent get value in event.target.value
     * @param {?} side left or right
     * @return {?}
     */
    DaterangepickerComponent.prototype.yearChanged = /**
     * called when year is changed
     * @param {?} yearEvent get value in event.target.value
     * @param {?} side left or right
     * @return {?}
     */
    function (yearEvent, side) {
        /** @type {?} */
        var month = this.calendarVariables[side].dropdowns.currentMonth;
        /** @type {?} */
        var year = parseInt(yearEvent.target.value, 10);
        this.monthOrYearChanged(month, year, side);
    };
    /**
     * called when time is changed
     * @param timeEvent  an event
     * @param side left or right
     */
    /**
     * called when time is changed
     * @param {?} timeEvent  an event
     * @param {?} side left or right
     * @return {?}
     */
    DaterangepickerComponent.prototype.timeChanged = /**
     * called when time is changed
     * @param {?} timeEvent  an event
     * @param {?} side left or right
     * @return {?}
     */
    function (timeEvent, side) {
        /** @type {?} */
        var hour = parseInt(this.timepickerVariables[side].selectedHour, 10);
        /** @type {?} */
        var minute = parseInt(this.timepickerVariables[side].selectedMinute, 10);
        /** @type {?} */
        var second = this.timePickerSeconds ? parseInt(this.timepickerVariables[side].selectedSecond, 10) : 0;
        if (!this.timePicker24Hour) {
            /** @type {?} */
            var ampm = this.timepickerVariables[side].ampmModel;
            if (ampm === 'PM' && hour < 12) {
                hour += 12;
            }
            if (ampm === 'AM' && hour === 12) {
                hour = 0;
            }
        }
        if (side === SideEnum.left) {
            /** @type {?} */
            var start = this.startDate.clone();
            start.hour(hour);
            start.minute(minute);
            start.second(second);
            this.setStartDate(start);
            if (this.singleDatePicker) {
                this.endDate = this.startDate.clone();
            }
            else if (this.endDate && this.endDate.format('YYYY-MM-DD') === start.format('YYYY-MM-DD') && this.endDate.isBefore(start)) {
                this.setEndDate(start.clone());
            }
        }
        else if (this.endDate) {
            /** @type {?} */
            var end = this.endDate.clone();
            end.hour(hour);
            end.minute(minute);
            end.second(second);
            this.setEndDate(end);
        }
        //update the calendars so all clickable dates reflect the new time component
        this.updateCalendars();
        //re-render the time pickers because changing one selection can affect what's enabled in another
        this.renderTimePicker(SideEnum.left);
        this.renderTimePicker(SideEnum.right);
    };
    /**
     *  call when month or year changed
     * @param month month number 0 -11
     * @param year year eg: 1995
     * @param side left or right
     */
    /**
     *  call when month or year changed
     * @param {?} month month number 0 -11
     * @param {?} year year eg: 1995
     * @param {?} side left or right
     * @return {?}
     */
    DaterangepickerComponent.prototype.monthOrYearChanged = /**
     *  call when month or year changed
     * @param {?} month month number 0 -11
     * @param {?} year year eg: 1995
     * @param {?} side left or right
     * @return {?}
     */
    function (month, year, side) {
        /** @type {?} */
        var isLeft = side === SideEnum.left;
        if (!isLeft) {
            if (year < this.startDate.year() || (year === this.startDate.year() && month < this.startDate.month())) {
                month = this.startDate.month();
                year = this.startDate.year();
            }
        }
        if (this.minDate) {
            if (year < this.minDate.year() || (year === this.minDate.year() && month < this.minDate.month())) {
                month = this.minDate.month();
                year = this.minDate.year();
            }
        }
        if (this.maxDate) {
            if (year > this.maxDate.year() || (year === this.maxDate.year() && month > this.maxDate.month())) {
                month = this.maxDate.month();
                year = this.maxDate.year();
            }
        }
        this.calendarVariables[side].dropdowns.currentYear = year;
        this.calendarVariables[side].dropdowns.currentMonth = month;
        if (isLeft) {
            this.leftCalendar.month.month(month).year(year);
            if (this.linkedCalendars) {
                this.rightCalendar.month = this.leftCalendar.month.clone().add(1, 'month');
            }
        }
        else {
            this.rightCalendar.month.month(month).year(year);
            if (this.linkedCalendars) {
                this.leftCalendar.month = this.rightCalendar.month.clone().subtract(1, 'month');
            }
        }
        this.updateCalendars();
    };
    /**
     * Click on previous month
     * @param side left or right calendar
     */
    /**
     * Click on previous month
     * @param {?} side left or right calendar
     * @return {?}
     */
    DaterangepickerComponent.prototype.clickPrev = /**
     * Click on previous month
     * @param {?} side left or right calendar
     * @return {?}
     */
    function (side) {
        if (side === SideEnum.left) {
            this.leftCalendar.month.subtract(1, 'month');
            if (this.linkedCalendars) {
                this.rightCalendar.month.subtract(1, 'month');
            }
        }
        else {
            this.rightCalendar.month.subtract(1, 'month');
        }
        this.updateCalendars();
    };
    /**
     * Click on next month
     * @param side left or right calendar
     */
    /**
     * Click on next month
     * @param {?} side left or right calendar
     * @return {?}
     */
    DaterangepickerComponent.prototype.clickNext = /**
     * Click on next month
     * @param {?} side left or right calendar
     * @return {?}
     */
    function (side) {
        if (side === SideEnum.left) {
            this.leftCalendar.month.add(1, 'month');
        }
        else {
            this.rightCalendar.month.add(1, 'month');
            if (this.linkedCalendars) {
                this.leftCalendar.month.add(1, 'month');
            }
        }
        this.updateCalendars();
    };
    /**
     * When selecting a date
     * @param e event: get value by e.target.value
     * @param side left or right
     * @param row row position of the current date clicked
     * @param col col position of the current date clicked
     */
    /**
     * When selecting a date
     * @param {?} e event: get value by e.target.value
     * @param {?} side left or right
     * @param {?} row row position of the current date clicked
     * @param {?} col col position of the current date clicked
     * @return {?}
     */
    DaterangepickerComponent.prototype.clickDate = /**
     * When selecting a date
     * @param {?} e event: get value by e.target.value
     * @param {?} side left or right
     * @param {?} row row position of the current date clicked
     * @param {?} col col position of the current date clicked
     * @return {?}
     */
    function (e, side, row, col) {
        if (e.target.tagName === 'TD') {
            if (!e.target.classList.contains('available')) {
                return;
            }
        }
        else if (e.target.tagName === 'SPAN') {
            if (!e.target.parentElement.classList.contains('available')) {
                return;
            }
        }
        if (this.rangesArray.length) {
            this.chosenRange = this.locale.customRangeLabel;
        }
        /** @type {?} */
        var date = side === SideEnum.left ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];
        if (this.endDate || date.isBefore(this.startDate, 'day')) { // picking start
            // picking start
            if (this.timePicker) {
                date = this._getDateWithTime(date, SideEnum.left);
            }
            this.endDate = null;
            this.setStartDate(date.clone());
        }
        else if (!this.endDate && date.isBefore(this.startDate)) {
            // special case: clicking the same date for start/end,
            // but the time of the end date is before the start date
            this.setEndDate(this.startDate.clone());
        }
        else { // picking end
            // picking end
            if (this.timePicker) {
                date = this._getDateWithTime(date, SideEnum.right);
            }
            this.setEndDate(date.clone());
            if (this.autoApply) {
                this.calculateChosenLabel();
                this.clickApply();
            }
        }
        if (this.singleDatePicker) {
            this.setEndDate(this.startDate);
            this.updateElement();
            if (this.autoApply) {
                this.clickApply();
            }
        }
        this.updateView();
        // This is to cancel the blur event handler if the mouse was in one of the inputs
        e.stopPropagation();
    };
    /**
     *  Click on the custom range
     * @param e: Event
     * @param label
     */
    /**
     *  Click on the custom range
     * @param {?} e
     * @param {?} label
     * @return {?}
     */
    DaterangepickerComponent.prototype.clickRange = /**
     *  Click on the custom range
     * @param {?} e
     * @param {?} label
     * @return {?}
     */
    function (e, label) {
        this.chosenRange = label;
        if (label === this.locale.customRangeLabel) {
            this.isShown = true; // show calendars
            this.showCalInRanges = true;
        }
        else {
            /** @type {?} */
            var dates = this.ranges[label];
            this.startDate = dates[0].clone();
            this.endDate = dates[1].clone();
            if (this.showRangeLabelOnInput && label !== this.locale.customRangeLabel) {
                this.chosenLabel = label;
            }
            else {
                this.calculateChosenLabel();
            }
            this.showCalInRanges = (!this.rangesArray.length) || this.alwaysShowCalendars;
            if (!this.timePicker) {
                this.startDate.startOf('day');
                this.endDate.endOf('day');
            }
            if (!this.alwaysShowCalendars) {
                this.isShown = false; // hide calendars
            }
            this.rangeClicked.emit({ label: label, dates: dates });
            if (!this.keepCalendarOpeningWithRange) {
                this.clickApply();
            }
            else {
                this.leftCalendar.month.month(dates[0].month());
                this.leftCalendar.month.year(dates[0].year());
                this.rightCalendar.month.month(dates[1].month());
                this.rightCalendar.month.year(dates[1].year());
                this.updateCalendars();
                if (this.timePicker) {
                    this.renderTimePicker(SideEnum.left);
                    this.renderTimePicker(SideEnum.right);
                }
            }
        }
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    DaterangepickerComponent.prototype.show = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (this.isShown) {
            return;
        }
        this._old.start = this.startDate.clone();
        this._old.end = this.endDate.clone();
        this.isShown = true;
        this.updateView();
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    DaterangepickerComponent.prototype.hide = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (!this.isShown) {
            return;
        }
        // incomplete date selection, revert to last values
        if (!this.endDate) {
            if (this._old.start) {
                this.startDate = this._old.start.clone();
            }
            if (this._old.end) {
                this.endDate = this._old.end.clone();
            }
        }
        // if a new date range was selected, invoke the user callback function
        if (!this.startDate.isSame(this._old.start) || !this.endDate.isSame(this._old.end)) {
            // this.callback(this.startDate, this.endDate, this.chosenLabel);
        }
        // if picker is attached to a text input, update it
        this.updateElement();
        this.isShown = false;
        this._ref.detectChanges();
    };
    /**
     * handle click on all element in the component, usefull for outside of click
     * @param e event
     */
    /**
     * handle click on all element in the component, usefull for outside of click
     * @param {?} e event
     * @return {?}
     */
    DaterangepickerComponent.prototype.handleInternalClick = /**
     * handle click on all element in the component, usefull for outside of click
     * @param {?} e event
     * @return {?}
     */
    function (e) {
        e.stopPropagation();
    };
    /**
     * update the locale options
     * @param locale
     */
    /**
     * update the locale options
     * @param {?} locale
     * @return {?}
     */
    DaterangepickerComponent.prototype.updateLocale = /**
     * update the locale options
     * @param {?} locale
     * @return {?}
     */
    function (locale) {
        for (var key in locale) {
            if (locale.hasOwnProperty(key)) {
                this.locale[key] = locale[key];
            }
        }
    };
    /**
     *  clear the daterange picker
     */
    /**
     *  clear the daterange picker
     * @return {?}
     */
    DaterangepickerComponent.prototype.clear = /**
     *  clear the daterange picker
     * @return {?}
     */
    function () {
        this.startDate = moment$1$1().startOf('day');
        this.endDate = moment$1$1().endOf('day');
        this.choosedDate.emit({ chosenLabel: '', startDate: null, endDate: null });
        this.datesUpdated.emit({ startDate: null, endDate: null });
        this.hide();
    };
    /**
     * Find out if the selected range should be disabled if it doesn't
     * fit into minDate and maxDate limitations.
     */
    /**
     * Find out if the selected range should be disabled if it doesn't
     * fit into minDate and maxDate limitations.
     * @param {?} range
     * @return {?}
     */
    DaterangepickerComponent.prototype.disableRange = /**
     * Find out if the selected range should be disabled if it doesn't
     * fit into minDate and maxDate limitations.
     * @param {?} range
     * @return {?}
     */
    function (range$$1) {
        var _this = this;
        if (range$$1 === this.locale.customRangeLabel) {
            return false;
        }
        /** @type {?} */
        var rangeMarkers = this.ranges[range$$1];
        /** @type {?} */
        var areBothBefore = rangeMarkers.every(function (date) {
            if (!_this.minDate) {
                return false;
            }
            return date.isBefore(_this.minDate);
        });
        /** @type {?} */
        var areBothAfter = rangeMarkers.every(function (date) {
            if (!_this.maxDate) {
                return false;
            }
            return date.isAfter(_this.maxDate);
        });
        return (areBothBefore || areBothAfter);
    };
    /**
     *
     * @param {?} date the date to add time
     * @param {?} side left or right
     * @return {?}
     */
    DaterangepickerComponent.prototype._getDateWithTime = /**
     *
     * @param {?} date the date to add time
     * @param {?} side left or right
     * @return {?}
     */
    function (date, side) {
        /** @type {?} */
        var hour = parseInt(this.timepickerVariables[side].selectedHour, 10);
        if (!this.timePicker24Hour) {
            /** @type {?} */
            var ampm = this.timepickerVariables[side].ampmModel;
            if (ampm === 'PM' && hour < 12) {
                hour += 12;
            }
            if (ampm === 'AM' && hour === 12) {
                hour = 0;
            }
        }
        /** @type {?} */
        var minute = parseInt(this.timepickerVariables[side].selectedMinute, 10);
        /** @type {?} */
        var second = this.timePickerSeconds ? parseInt(this.timepickerVariables[side].selectedSecond, 10) : 0;
        return date.clone().hour(hour).minute(minute).second(second);
    };
    /**
     *  build the locale config
     * @return {?}
     */
    DaterangepickerComponent.prototype._buildLocale = /**
     *  build the locale config
     * @return {?}
     */
    function () {
        if (!this.locale.format) {
            if (this.timePicker) {
                this.locale.format = moment$1$1.localeData().longDateFormat('lll');
            }
            else {
                this.locale.format = moment$1$1.localeData().longDateFormat('L');
            }
        }
    };
    /**
     * @param {?} calendar
     * @param {?} side
     * @return {?}
     */
    DaterangepickerComponent.prototype._buildCells = /**
     * @param {?} calendar
     * @param {?} side
     * @return {?}
     */
    function (calendar, side) {
        for (var row = 0; row < 6; row++) {
            this.calendarVariables[side].classes[row] = {};
            /** @type {?} */
            var rowClasses = [];
            if (this.emptyWeekRowClass && !this.hasCurrentMonthDays(this.calendarVariables[side].month, calendar[row])) {
                rowClasses.push(this.emptyWeekRowClass);
            }
            for (var col = 0; col < 7; col++) {
                /** @type {?} */
                var classes = [];
                // highlight today's date
                if (calendar[row][col].isSame(new Date(), 'day')) {
                    classes.push('today');
                }
                // highlight weekends
                if (calendar[row][col].isoWeekday() > 5) {
                    classes.push('weekend');
                }
                // grey out the dates in other months displayed at beginning and end of this calendar
                if (calendar[row][col].month() !== calendar[1][1].month()) {
                    classes.push('off');
                    // mark the last day of the previous month in this calendar
                    if (this.lastDayOfPreviousMonthClass && (calendar[row][col].month() < calendar[1][1].month() || calendar[1][1].month() === 0) && calendar[row][col].date() === this.calendarVariables[side].daysInLastMonth) {
                        classes.push(this.lastDayOfPreviousMonthClass);
                    }
                    // mark the first day of the next month in this calendar
                    if (this.firstDayOfNextMonthClass && (calendar[row][col].month() > calendar[1][1].month() || calendar[row][col].month() === 0) && calendar[row][col].date() === 1) {
                        classes.push(this.firstDayOfNextMonthClass);
                    }
                }
                // mark the first day of the current month with a custom class
                if (this.firstMonthDayClass && calendar[row][col].month() === calendar[1][1].month() && calendar[row][col].date() === calendar.firstDay.date()) {
                    classes.push(this.firstMonthDayClass);
                }
                // mark the last day of the current month with a custom class
                if (this.lastMonthDayClass && calendar[row][col].month() === calendar[1][1].month() && calendar[row][col].date() === calendar.lastDay.date()) {
                    classes.push(this.lastMonthDayClass);
                }
                // don't allow selection of dates before the minimum date
                if (this.minDate && calendar[row][col].isBefore(this.minDate, 'day')) {
                    classes.push('off', 'disabled');
                }
                // don't allow selection of dates after the maximum date
                if (this.calendarVariables[side].maxDate && calendar[row][col].isAfter(this.calendarVariables[side].maxDate, 'day')) {
                    classes.push('off', 'disabled');
                }
                // don't allow selection of date if a custom function decides it's invalid
                if (this.isInvalidDate(calendar[row][col])) {
                    classes.push('off', 'disabled');
                }
                // highlight the currently selected start date
                if (this.startDate && calendar[row][col].format('YYYY-MM-DD') === this.startDate.format('YYYY-MM-DD')) {
                    classes.push('active', 'start-date');
                }
                // highlight the currently selected end date
                if (this.endDate !== null && calendar[row][col].format('YYYY-MM-DD') === this.endDate.format('YYYY-MM-DD')) {
                    classes.push('active', 'end-date');
                }
                // highlight dates in-between the selected dates
                if (this.endDate !== null && calendar[row][col] > this.startDate && calendar[row][col] < this.endDate) {
                    classes.push('in-range');
                }
                /** @type {?} */
                var isCustom = this.isCustomDate(calendar[row][col]);
                if (isCustom !== false) {
                    if (typeof isCustom === 'string') {
                        classes.push(isCustom);
                    }
                    else {
                        Array.prototype.push.apply(classes, isCustom);
                    }
                }
                /** @type {?} */
                var cname = '';
                /** @type {?} */
                var disabled = false;
                for (var i = 0; i < classes.length; i++) {
                    cname += classes[i] + ' ';
                    if (classes[i] === 'disabled') {
                        disabled = true;
                    }
                }
                if (!disabled) {
                    cname += 'available';
                }
                this.calendarVariables[side].classes[row][col] = cname.replace(/^\s+|\s+$/g, '');
            }
            this.calendarVariables[side].classes[row].classList = rowClasses.join(' ');
        }
    };
    /**
     * Find out if the current calendar row has current month days
     * (as opposed to consisting of only previous/next month days)
     */
    /**
     * Find out if the current calendar row has current month days
     * (as opposed to consisting of only previous/next month days)
     * @param {?} currentMonth
     * @param {?} row
     * @return {?}
     */
    DaterangepickerComponent.prototype.hasCurrentMonthDays = /**
     * Find out if the current calendar row has current month days
     * (as opposed to consisting of only previous/next month days)
     * @param {?} currentMonth
     * @param {?} row
     * @return {?}
     */
    function (currentMonth, row) {
        for (var day = 0; day < 7; day++) {
            if (row[day].month() === currentMonth) {
                return true;
            }
        }
        return false;
    };
    DaterangepickerComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'o-daterange-picker',
                    styles: ["\n      .md-drppicker{position:absolute;border-radius:4px;width:278px;padding:4px;margin-top:-10px;overflow:hidden;z-index:1000;font-size:13px;box-shadow:0 2px 4px 0 rgba(0,0,0,0.16),0 2px 8px 0 rgba(0,0,0,0.12)}.md-drppicker.double{width:auto}.md-drppicker.inline{position:relative;display:inline-block}.md-drppicker:after,.md-drppicker:before{position:absolute;display:inline-block;content:''}.md-drppicker.openscenter:before{left:0;right:0;width:0;margin-left:auto;margin-right:auto}.md-drppicker.openscenter:after{left:0;right:0;width:0;margin-left:auto;margin-right:auto}.md-drppicker.single .calendar,.md-drppicker.single .ranges{float:none}.md-drppicker.shown{transform:scale(1);transition:all .1s ease-in-out;transform-origin:0 0;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.md-drppicker.shown.drops-up-left{transform-origin:100% 100%}.md-drppicker.shown.drops-up-right{transform-origin:0 100%}.md-drppicker.shown.drops-down-left{transform-origin:100% 0}.md-drppicker.shown.drops-down-right{transform-origin:0 0}.md-drppicker.shown.drops-down-center{transform-origin:NaN}.md-drppicker.shown.drops-up-center{transform-origin:50%}.md-drppicker.shown .calendar{display:block}.md-drppicker.hidden{transition:all .1s ease;transform:scale(0);transform-origin:0 0;cursor:default;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.md-drppicker.hidden.drops-up-left{transform-origin:100% 100%}.md-drppicker.hidden.drops-up-right{transform-origin:0 100%}.md-drppicker.hidden.drops-down-left{transform-origin:100% 0}.md-drppicker.hidden.drops-down-right{transform-origin:0 0}.md-drppicker.hidden.drops-down-center{transform-origin:NaN}.md-drppicker.hidden.drops-up-center{transform-origin:50%}.md-drppicker.hidden .calendar{display:none}.md-drppicker .calendar{max-width:270px;margin:4px}.md-drppicker .calendar.single .calendar-table{border:none}.md-drppicker .calendar td,.md-drppicker .calendar th{padding:0;white-space:nowrap;text-align:center;height:36px;width:36px}.md-drppicker .calendar td span,.md-drppicker .calendar th span{pointer-events:none}.md-drppicker .calendar-table{border-style:1px solid;padding:4px;border-radius:4px}.md-drppicker table{width:100%;margin:0}.md-drppicker td,.md-drppicker th{text-align:center;width:20px;height:20px;border-radius:4px;border-style:1px solid;white-space:nowrap;cursor:pointer;height:2em;width:2em}.md-drppicker td.available.prev,.md-drppicker th.available.prev{display:block;background-image:url(\"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMy43IDYiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDMuNyA2IiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxnPg0KCTxwYXRoIGQ9Ik0zLjcsMC43TDEuNCwzbDIuMywyLjNMMyw2TDAsM2wzLTNMMy43LDAuN3oiLz4NCjwvZz4NCjwvc3ZnPg0K\");background-repeat:no-repeat;background-size:.5em;background-position:center;opacity:.8;transition:background-color .2s ease;border-radius:2em}.md-drppicker td.available.prev:hover,.md-drppicker th.available.prev:hover{margin:0}.md-drppicker td.available.next,.md-drppicker th.available.next{transform:rotate(180deg);display:block;background-image:url(\"data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMy43IDYiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDMuNyA2IiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxnPg0KCTxwYXRoIGQ9Ik0zLjcsMC43TDEuNCwzbDIuMywyLjNMMyw2TDAsM2wzLTNMMy43LDAuN3oiLz4NCjwvZz4NCjwvc3ZnPg0K\");background-repeat:no-repeat;background-size:.5em;background-position:center;opacity:.8;transition:background-color .2s ease;border-radius:2em}.md-drppicker td.available.next:hover,.md-drppicker th.available.next:hover{margin:0;transform:rotate(180deg)}.md-drppicker td.available:hover,.md-drppicker th.available:hover{background-repeat:no-repeat;background-size:.5em;background-position:center;margin:.25em 0;opacity:.8;border-radius:2em;transform:scale(1);transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0}.md-drppicker td.week,.md-drppicker th.week{font-size:80%}.md-drppicker td{margin:.25em 0;opacity:.8;transition:background-color .2s ease;border-radius:2em;transform:scale(1);transition:all 450ms cubic-bezier(0.23, 1, 0.32, 1) 0}.md-drppicker td.in-range{border-radius:0}.md-drppicker td.start-date{border-radius:2em 0 0 2em}.md-drppicker td.end-date{border-radius:0 2em 2em 0}.md-drppicker td.start-date.end-date{border-radius:4px}.md-drppicker th.month{width:auto}.md-drppicker option.disabled,.md-drppicker td.disabled{cursor:not-allowed;text-decoration:line-through}.md-drppicker .dropdowns{background-repeat:no-repeat;background-size:10px;background-position-y:center;background-position-x:right;width:50px;background-image:url(\"data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDI1NSAyNTUiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDI1NSAyNTU7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8ZyBpZD0iYXJyb3ctZHJvcC1kb3duIj4KCQk8cG9seWdvbiBwb2ludHM9IjAsNjMuNzUgMTI3LjUsMTkxLjI1IDI1NSw2My43NSAgICIgZmlsbD0iIzk4OGM4YyIvPgoJPC9nPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+Cjwvc3ZnPgo=\")}.md-drppicker .dropdowns select{display:inline-block;width:100%;padding:5px;border:1px solid;border-radius:2px;height:3rem}.md-drppicker .dropdowns select.monthselect,.md-drppicker .dropdowns select.yearselect{font-size:12px;padding:1px;height:auto;margin:0;cursor:default}.md-drppicker .dropdowns select.ampmselect,.md-drppicker .dropdowns select.hourselect,.md-drppicker .dropdowns select.minuteselect,.md-drppicker .dropdowns select.secondselect{width:50px;margin:0 auto;border-style:1px solid;padding:2px;outline:0;font-size:12px}.md-drppicker .dropdowns select.monthselect,.md-drppicker .dropdowns select.yearselect{cursor:pointer;opacity:0;position:absolute;top:0;left:0;margin:0;padding:0}.md-drppicker th.month>div{position:relative;display:inline-block}.md-drppicker .calendar-time{text-align:center;margin:4px auto 0;line-height:30px;position:relative}.md-drppicker .calendar-time .select{display:inline}.md-drppicker .calendar-time .select .select-item{display:inline-block;width:auto;position:relative;font-family:inherit;background-color:transparent;padding:10px 10px 10px 0;font-size:18px;border-radius:0;border:none;border-bottom-style:1px solid}.md-drppicker .calendar-time .select .select-item:after{position:absolute;top:18px;right:10px;width:0;height:0;padding:0;content:'';border-left:6px solid transparent;border-right:6px solid transparent;border-top:6px solid rgba(0,0,0,0.12);pointer-events:none}.md-drppicker .calendar-time .select .select-item:focus{outline:none}.md-drppicker .calendar-time .select .select-item .select-label{font-size:16px;font-weight:normal;position:absolute;pointer-events:none;left:0;top:10px;transition:.2s ease all}.md-drppicker .calendar-time select.disabled{cursor:not-allowed}.md-drppicker .label-input{border-style:1px solid;border-radius:4px;height:30px;line-height:30px;display:block;vertical-align:middle;margin:0 auto 5px;padding:0 0 0 28px;width:100%}.md-drppicker .label-input.active{border-style:1px solid;border-radius:4px}.md-drppicker .md-drppicker_input{position:relative;padding:0 30px 0 0}.md-drppicker .md-drppicker_input i,.md-drppicker .md-drppicker_input svg{position:absolute;left:8px;top:8px}.md-drppicker.rtl .label-input{padding-right:28px;padding-left:6px}.md-drppicker.rtl .md-drppicker_input i,.md-drppicker.rtl .md-drppicker_input svg{left:auto;right:8px}.md-drppicker .show-ranges .drp-calendar.left{border-left-style:1px solid}.md-drppicker .ranges{float:none;text-align:left;margin:0}.md-drppicker .ranges ul{list-style:none;margin:0 auto;padding:0;width:100%}.md-drppicker .ranges ul li{font-size:12px}.md-drppicker .ranges ul li button{padding:8px 12px;width:100%;background:none;border:none;text-align:left;cursor:pointer}.md-drppicker .ranges ul li button[disabled]{opacity:.3}.md-drppicker .ranges ul li button:active{background:transparent}.md-drppicker .show-calendar .ranges{margin-top:8px}.md-drppicker [hidden]{display:none}.md-drppicker .buttons{text-align:right;margin:0 5px 5px 0}.md-drppicker .btn{position:relative;overflow:hidden;border-width:0;outline:none;padding:0 6px;cursor:pointer;border-radius:2px;box-shadow:0 1px 4px rgba(0,0,0,0.6);color:#ecf0f1;transition:background-color .4s;height:auto;text-transform:uppercase;line-height:36px;border:none}.md-drppicker .btn>*{position:relative}.md-drppicker .btn span{display:block;padding:12px 24px}.md-drppicker .btn:before{content:\"\";position:absolute;top:50%;left:50%;display:block;width:0;padding-top:0;border-radius:100%;-webkit-transform:translate(-50%, -50%);-moz-transform:translate(-50%, -50%);-ms-transform:translate(-50%, -50%);-o-transform:translate(-50%, -50%);transform:translate(-50%, -50%)}.md-drppicker .btn:active:before{width:120%;padding-top:120%;transition:width .2s ease-out, padding-top .2s ease-out}.md-drppicker .btn:disabled{opacity:.5}.md-drppicker .clear{box-shadow:none}.md-drppicker .clear svg{fill:currentColor}@media (min-width: 564px){.md-drppicker{width:auto}.md-drppicker.single .calendar.left{clear:none}.md-drppicker.ltr{direction:ltr;text-align:left}.md-drppicker.ltr .calendar.left{clear:left}.md-drppicker.ltr .calendar.left .calendar-table{border-right:none;border-top-right-radius:0;border-bottom-right-radius:0}.md-drppicker.ltr .calendar.right{margin-left:0}.md-drppicker.ltr .calendar.right .calendar-table{border-left:none;border-top-left-radius:0;border-bottom-left-radius:0}.md-drppicker.ltr .left .md-drppicker_input{padding-right:35px}.md-drppicker.ltr .right .md-drppicker_input{padding-right:35px}.md-drppicker.ltr .calendar.left .calendar-table{padding-right:12px}.md-drppicker.ltr .calendar,.md-drppicker.ltr .ranges{float:left}.md-drppicker.rtl{direction:rtl;text-align:right}.md-drppicker.rtl .calendar.left{clear:right;margin-left:0}.md-drppicker.rtl .calendar.left .calendar-table{border-left:none;border-top-left-radius:0;border-bottom-left-radius:0}.md-drppicker.rtl .calendar.right{margin-right:0}.md-drppicker.rtl .calendar.right .calendar-table{border-right:none;border-top-right-radius:0;border-bottom-right-radius:0}.md-drppicker.rtl .left .md-drppicker_input{padding-left:12px}.md-drppicker.rtl .calendar.left .calendar-table{padding-left:12px}.md-drppicker.rtl .calendar,.md-drppicker.rtl .ranges{text-align:right;float:right}.drp-animate{transform:translate(0);transition:transform .2s ease, opacity .2s ease}.drp-animate.drp-picker-site-this{transition-timing-function:linear}.drp-animate.drp-animate-right{transform:translateX(10%);opacity:0}.drp-animate.drp-animate-left{transform:translateX(-10%);opacity:0}}@media (min-width: 730px){.md-drppicker .ranges{width:auto}.md-drppicker.ltr .ranges{float:left}.md-drppicker.rtl .ranges{float:right}.md-drppicker .calendar.left{clear:none !important}}\n    "],
                    template: "\n      <div class=\"md-drppicker\" #pickerContainer\n      [ngClass]=\"{\n          ltr: locale.direction === 'ltr',\n          rtl: this.locale.direction === 'rtl',\n          'shown': isShown || inline,\n          'hidden': !isShown && !inline,\n          'inline': inline,\n          'double': !singleDatePicker && showCalInRanges,\n          'show-ranges': rangesArray.length\n      }\" [class]=\"'drops-' + drops + '-' + opens\">\n          <div class=\"ranges\">\n              <ul>\n                <li *ngFor=\"let range of rangesArray\">\n                  <button type=\"button\"\n                          (click)=\"clickRange($event, range)\"\n                          [disabled]=\"disableRange(range)\"\n                          [ngClass]=\"{'active': range === chosenRange}\">{{range | oTranslate}}</button>\n                </li>\n              </ul>\n          </div>\n          <div class=\"calendar\" [ngClass]=\"{right: singleDatePicker, left: !singleDatePicker}\"\n              *ngIf=\"showCalInRanges\">\n              <div class=\"calendar-table\">\n                  <table class=\"table-condensed\" *ngIf=\"calendarVariables\">\n                      <thead>\n                          <tr>\n                              <th *ngIf=\"showWeekNumbers || showISOWeekNumbers\"></th>\n                              <ng-container *ngIf=\"!calendarVariables.left.minDate || calendarVariables.left.minDate.isBefore(calendarVariables.left.calendar.firstDay) && (!this.linkedCalendars || true)\">\n                                  <th (click)=\"clickPrev(sideEnum.left)\" class=\"prev available\" >\n                                  </th>\n                              </ng-container>\n                              <ng-container *ngIf=\"!(!calendarVariables.left.minDate || calendarVariables.left.minDate.isBefore(calendarVariables.left.calendar.firstDay) && (!this.linkedCalendars || true))\">\n                                  <th></th>\n                              </ng-container>\n                              <th colspan=\"5\" class=\"month drp-animate\">\n                                  <ng-container *ngIf=\"showDropdowns && calendarVariables.left.dropdowns\">\n                                      <div class=\"dropdowns\">\n                                              {{this.locale.monthNames[calendarVariables?.left?.calendar[1][1].month()]}}\n                                              <select class=\"monthselect\" (change)=\"monthChanged($event, sideEnum.left)\">\n                                                      <option\n                                                      [disabled]=\"(calendarVariables.left.dropdowns.inMinYear && m < calendarVariables.left.minDate.month()) || (calendarVariables.left.dropdowns.inMaxYear && m > calendarVariables.left.maxDate.month())\"\n                                                      *ngFor=\"let m of calendarVariables.left.dropdowns.monthArrays\" [value]=\"m\" [selected]=\"calendarVariables.left.dropdowns.currentMonth == m\">\n                                                          {{locale.monthNames[m]}}\n                                                      </option>\n                                              </select>\n                                      </div>\n                                      <div class=\"dropdowns\">\n                                          {{ calendarVariables?.left?.calendar[1][1].format(\" YYYY\")}}\n                                          <select class=\"yearselect\"  (change)=\"yearChanged($event, sideEnum.left)\">\n                                              <option *ngFor=\"let y of calendarVariables.left.dropdowns.yearArrays\" [selected]=\"y === calendarVariables.left.dropdowns.currentYear\">\n                                                  {{y}}\n                                              </option>\n                                          </select>\n                                      </div>\n                                  </ng-container>\n                                  <ng-container *ngIf=\"!showDropdowns || !calendarVariables.left.dropdowns\">\n                                          {{this.locale.monthNames[calendarVariables?.left?.calendar[1][1].month()]}}  {{ calendarVariables?.left?.calendar[1][1].format(\" YYYY\")}}\n                                  </ng-container>\n                              </th>\n                              <ng-container *ngIf=\"(!calendarVariables.left.maxDate || calendarVariables.left.maxDate.isAfter(calendarVariables.left.calendar.lastDay)) && (!linkedCalendars || singleDatePicker )\">\n                                  <th class=\"next available\" (click)=\"clickNext(sideEnum.left)\">\n                                  </th>\n                              </ng-container>\n                              <ng-container *ngIf=\"!((!calendarVariables.left.maxDate || calendarVariables.left.maxDate.isAfter(calendarVariables.left.calendar.lastDay)) && (!linkedCalendars || singleDatePicker ))\">\n                                  <th></th>\n                              </ng-container>\n                          </tr>\n                          <tr class='week-days'>\n                              <th *ngIf=\"showWeekNumbers || showISOWeekNumbers\" class=\"week\"><span>{{this.locale.weekLabel}}</span></th>\n                              <th *ngFor=\"let dayofweek of locale.daysOfWeek\"><span>{{dayofweek}}</span></th>\n                          </tr>\n                      </thead>\n                      <tbody class=\"drp-animate\">\n                          <tr *ngFor=\"let row of calendarVariables.left.calRows\" [class]=\"calendarVariables.left.classes[row].classList\">\n                              <!-- add week number -->\n                              <td  class=\"week\" *ngIf=\"showWeekNumbers\">\n                                  <span>{{calendarVariables.left.calendar[row][0].week()}}</span>\n                              </td>\n                              <td class=\"week\" *ngIf=\"showISOWeekNumbers\">\n                                  <span>{{calendarVariables.left.calendar[row][0].isoWeek()}}</span>\n                              </td>\n                              <!-- cal -->\n                              <td *ngFor=\"let col of calendarVariables.left.calCols\" [class]=\"calendarVariables.left.classes[row][col]\" (click)=\"clickDate($event, sideEnum.left, row, col)\">\n                                  <span>{{calendarVariables.left.calendar[row][col].date()}}</span>\n                              </td>\n                          </tr>\n                      </tbody>\n                  </table>\n              </div>\n              <div class=\"calendar-time\" *ngIf=\"timePicker\">\n                  <div class=\"select\">\n                      <select class=\"hourselect select-item\" [disabled]=\"!endDate\" [(ngModel)]=\"timepickerVariables.left.selectedHour\" (ngModelChange)=\"timeChanged($event, sideEnum.left)\">\n                          <option *ngFor=\"let i of timepickerVariables.left.hours\"\n                          [value]=\"i\"\n                          [disabled]=\"timepickerVariables.left.disabledHours.indexOf(i) > -1\">{{i}}</option>\n                      </select>\n                  </div>\n                  <div class=\"select\">\n                      <select class=\"select-item minuteselect\" [disabled]=\"!endDate\" [(ngModel)]=\"timepickerVariables.left.selectedMinute\" (ngModelChange)=\"timeChanged($event, sideEnum.left)\">\n                          <option *ngFor=\"let i of timepickerVariables.left.minutes; let index = index;\"\n                          [value]=\"i\"\n                          [disabled]=\"timepickerVariables.left.disabledMinutes.indexOf(i) > -1\">{{timepickerVariables.left.minutesLabel[index]}}</option>\n                      </select>\n                      <span class=\"select-highlight\"></span>\n                      <span class=\"select-bar\"></span>\n                  </div>\n                  <div class=\"select\">\n                      <select class=\"select-item secondselect\" *ngIf=\"timePickerSeconds\" [disabled]=\"!endDate\" [(ngModel)]=\"timepickerVariables.left.selectedSecond\" (ngModelChange)=\"timeChanged($event, sideEnum.left)\">\n                          <option *ngFor=\"let i of timepickerVariables.left.seconds; let index = index;\"\n                          [value]=\"i\"\n                          [disabled]=\"timepickerVariables.left.disabledSeconds.indexOf(i) > -1\">{{timepickerVariables.left.secondsLabel[index]}}</option>\n                      </select>\n                      <span class=\"select-highlight\"></span>\n                      <span class=\"select-bar\"></span>\n                  </div>\n                  <div class=\"select\">\n                      <select class=\"select-item ampmselect\" *ngIf=\"!timePicker24Hour\" [(ngModel)]=\"timepickerVariables.left.ampmModel\" (ngModelChange)=\"timeChanged($event, sideEnum.left)\">\n                          <option value=\"AM\" [disabled]=\"timepickerVariables.left.amDisabled\">AM</option>\n                          <option value=\"PM\"  [disabled]=\"timepickerVariables.left.pmDisabled\">PM</option>\n                      </select>\n                      <span class=\"select-highlight\"></span>\n                      <span class=\"select-bar\"></span>\n                  </div>\n              </div>\n          </div>\n          <div class=\"calendar right\"\n              *ngIf=\"showCalInRanges && !singleDatePicker\"\n              >\n              <div class=\"calendar-table\">\n                  <table class=\"table-condensed\" *ngIf=\"calendarVariables\">\n                      <thead>\n                          <tr>\n                              <th *ngIf=\"showWeekNumbers || showISOWeekNumbers\"></th>\n                              <ng-container *ngIf=\"(!calendarVariables.right.minDate || calendarVariables.right.minDate.isBefore(calendarVariables.right.calendar.firstDay)) && (!this.linkedCalendars)\">\n                                  <th (click)=\"clickPrev(sideEnum.right)\" class=\"prev available\" >\n                                  </th>\n                              </ng-container>\n                              <ng-container *ngIf=\"!((!calendarVariables.right.minDate || calendarVariables.right.minDate.isBefore(calendarVariables.right.calendar.firstDay)) && (!this.linkedCalendars))\">\n                                  <th></th>\n                              </ng-container>\n                              <th colspan=\"5\" class=\"month\">\n                                  <ng-container *ngIf=\"showDropdowns && calendarVariables.right.dropdowns\">\n                                      <div class=\"dropdowns\">\n                                          {{this.locale.monthNames[calendarVariables?.right?.calendar[1][1].month()]}}\n                                          <select class=\"monthselect\" (change)=\"monthChanged($event, sideEnum.right)\">\n                                                  <option\n                                                  [disabled]=\"(calendarVariables.right.dropdowns.inMinYear && m < calendarVariables.right.minDate.month()) || (calendarVariables.right.dropdowns.inMaxYear && m > calendarVariables.right.maxDate.month())\"\n                                                  *ngFor=\"let m of calendarVariables.right.dropdowns.monthArrays\" [value]=\"m\" [selected]=\"calendarVariables.right.dropdowns.currentMonth == m\">\n                                                      {{locale.monthNames[m]}}\n                                                  </option>\n                                          </select>\n                                      </div>\n                                      <div class=\"dropdowns\">\n                                              {{ calendarVariables?.right?.calendar[1][1].format(\" YYYY\")}}\n                                              <select class=\"yearselect\" (change)=\"yearChanged($event, sideEnum.right)\">\n                                              <option *ngFor=\"let y of calendarVariables.right.dropdowns.yearArrays\" [selected]=\"y === calendarVariables.right.dropdowns.currentYear\">\n                                                  {{y}}\n                                              </option>\n                                          </select>\n                                      </div>\n                                  </ng-container>\n                                  <ng-container *ngIf=\"!showDropdowns || !calendarVariables.right.dropdowns\">\n                                          {{this.locale.monthNames[calendarVariables?.right?.calendar[1][1].month()]}}  {{ calendarVariables?.right?.calendar[1][1].format(\" YYYY\")}}\n                                  </ng-container>\n                              </th>\n                                  <ng-container *ngIf=\"!calendarVariables.right.maxDate || calendarVariables.right.maxDate.isAfter(calendarVariables.right.calendar.lastDay) && (!linkedCalendars || singleDatePicker || true)\">\n                                      <th class=\"next available\" (click)=\"clickNext(sideEnum.right)\">\n                                      </th>\n                                  </ng-container>\n                                  <ng-container *ngIf=\"!(!calendarVariables.right.maxDate || calendarVariables.right.maxDate.isAfter(calendarVariables.right.calendar.lastDay) && (!linkedCalendars || singleDatePicker || true))\">\n                                      <th></th>\n                                  </ng-container>\n                          </tr>\n\n                          <tr>\n                              <th *ngIf=\"showWeekNumbers || showISOWeekNumbers\" class=\"week\"><span>{{this.locale.weekLabel}}</span></th>\n                              <th *ngFor=\"let dayofweek of locale.daysOfWeek\"><span>{{dayofweek}}</span></th>\n                          </tr>\n                      </thead>\n                      <tbody>\n                          <tr *ngFor=\"let row of calendarVariables.right.calRows\" [class]=\"calendarVariables.right.classes[row].classList\">\n                              <td class=\"week\" *ngIf=\"showWeekNumbers\">\n                                  <span>{{calendarVariables.right.calendar[row][0].week()}}</span>\n                              </td>\n                              <td class=\"week\" *ngIf=\"showISOWeekNumbers\">\n                                  <span>{{calendarVariables.right.calendar[row][0].isoWeek()}}</span>\n                              </td>\n                              <td *ngFor=\"let col of calendarVariables.right.calCols\" [class]=\"calendarVariables.right.classes[row][col]\" (click)=\"clickDate($event, sideEnum.right, row, col)\">\n                                  <span>{{calendarVariables.right.calendar[row][col].date()}}</span>\n                              </td>\n                          </tr>\n                      </tbody>\n                  </table>\n              </div>\n              <div class=\"calendar-time\" *ngIf=\"timePicker\">\n                  <div class=\"select\">\n                      <select class=\"select-item hourselect\" [disabled]=\"!endDate\" [(ngModel)]=\"timepickerVariables.right.selectedHour\" (ngModelChange)=\"timeChanged($event, sideEnum.right)\">\n                          <option *ngFor=\"let i of timepickerVariables.right.hours\"\n                          [value]=\"i\"\n                          [disabled]=\"timepickerVariables.right.disabledHours.indexOf(i) > -1\">{{i}}</option>\n                      </select>\n                      <span class=\"select-highlight\"></span>\n                      <span class=\"select-bar\"></span>\n                  </div>\n                  <div class=\"select\">\n                      <select class=\"select-item minuteselect\" [disabled]=\"!endDate\" [(ngModel)]=\"timepickerVariables.right.selectedMinute\" (ngModelChange)=\"timeChanged($event, sideEnum.right)\">\n                          <option *ngFor=\"let i of timepickerVariables.right.minutes; let index = index;\"\n                          [value]=\"i\"\n                          [disabled]=\"timepickerVariables.right.disabledMinutes.indexOf(i) > -1\">{{timepickerVariables.right.minutesLabel[index]}}</option>\n                      </select>\n                      <span class=\"select-highlight\"></span>\n                      <span class=\"select-bar\"></span>\n                  </div>\n                  <div class=\"select\">\n                      <select *ngIf=\"timePickerSeconds\" class=\"select-item secondselect\" [disabled]=\"!endDate\" [(ngModel)]=\"timepickerVariables.right.selectedSecond\" (ngModelChange)=\"timeChanged($event, sideEnum.right)\">\n                          <option *ngFor=\"let i of timepickerVariables.right.seconds; let index = index;\"\n                          [value]=\"i\"\n                          [disabled]=\"timepickerVariables.right.disabledSeconds.indexOf(i) > -1\">{{timepickerVariables.right.secondsLabel[index]}}</option>\n                      </select>\n                      <span class=\"select-highlight\"></span>\n                      <span class=\"select-bar\"></span>\n                  </div>\n                  <div class=\"select\">\n                      <select *ngIf=\"!timePicker24Hour\" class=\"select-item ampmselect\" [(ngModel)]=\"timepickerVariables.right.ampmModel\" (ngModelChange)=\"timeChanged($event, sideEnum.right)\">\n                          <option value=\"AM\" [disabled]=\"timepickerVariables.right.amDisabled\">AM</option>\n                          <option value=\"PM\"  [disabled]=\"timepickerVariables.right.pmDisabled\">PM</option>\n                      </select>\n                      <span class=\"select-highlight\"></span>\n                      <span class=\"select-bar\"></span>\n                  </div>\n              </div>\n          </div>\n          <div class=\"buttons\" *ngIf=\"!autoApply && ( !rangesArray.length || (showCalInRanges && !singleDatePicker))\">\n              <div class=\"buttons_input\">\n                  <button  *ngIf=\"showClearButton\" class=\"mat-primary mat-stroked-button clear\" type=\"button\" (click)=\"clear()\" title=\"clear the date\">\n                      <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"30\" height=\"30\" viewBox=\"0 -5 24 24\"><path d=\"M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z\"/></svg>\n                  </button>\n                  <button class=\"mat-primary mat-stroked-button\" *ngIf=\"showCancel\" type=\"button\" (click)=\"clickCancel($event)\">{{locale.cancelLabel}}</button>\n                  <button class=\"mat-primary mat-stroked-button\"  [disabled]=\"applyBtn.disabled\" type=\"button\" (click)=\"clickApply($event)\">{{locale.applyLabel}}</button>\n              </div>\n          </div>\n      </div>\n    ",
                    host: {
                        '(click)': 'handleInternalClick($event)',
                    },
                    encapsulation: core.ViewEncapsulation.None,
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: core.forwardRef(function () { return DaterangepickerComponent; }),
                            multi: true
                        }]
                },] },
    ];
    /** @nocollapse */
    DaterangepickerComponent.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef }
    ]; };
    DaterangepickerComponent.propDecorators = {
        dateLimit: [{ type: core.Input }],
        minDate: [{ type: core.Input }],
        maxDate: [{ type: core.Input }],
        autoApply: [{ type: core.Input }],
        singleDatePicker: [{ type: core.Input }],
        showDropdowns: [{ type: core.Input }],
        showISOWeekNumbers: [{ type: core.Input }],
        linkedCalendars: [{ type: core.Input }],
        autoUpdateInput: [{ type: core.Input }],
        alwaysShowCalendars: [{ type: core.Input }],
        maxSpan: [{ type: core.Input }],
        timePicker: [{ type: core.Input }],
        timePicker24Hour: [{ type: core.Input }],
        timePickerIncrement: [{ type: core.Input }],
        timePickerSeconds: [{ type: core.Input }],
        showClearButton: [{ type: core.Input }],
        firstMonthDayClass: [{ type: core.Input }],
        lastMonthDayClass: [{ type: core.Input }],
        emptyWeekRowClass: [{ type: core.Input }],
        firstDayOfNextMonthClass: [{ type: core.Input }],
        lastDayOfPreviousMonthClass: [{ type: core.Input }],
        locale: [{ type: core.Input }],
        ranges: [{ type: core.Input }],
        showCustomRangeLabel: [{ type: core.Input }],
        showCancel: [{ type: core.Input }],
        keepCalendarOpeningWithRange: [{ type: core.Input }],
        showRangeLabelOnInput: [{ type: core.Input }],
        drops: [{ type: core.Input }],
        opens: [{ type: core.Input }],
        choosedDate: [{ type: core.Output, args: ['choosedDate',] }],
        rangeClicked: [{ type: core.Output, args: ['rangeClicked',] }],
        datesUpdated: [{ type: core.Output, args: ['datesUpdated',] }],
        pickerContainer: [{ type: core.ViewChild, args: ['pickerContainer',] }],
        isInvalidDate: [{ type: core.Input }],
        isCustomDate: [{ type: core.Input }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], DaterangepickerComponent.prototype, "showWeekNumbers", void 0);
    return DaterangepickerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var moment$2$1 = moment__default;
var ODaterangepickerDirective = /** @class */ (function () {
    function ODaterangepickerDirective(_dialog, _ngZone, _overlay, _viewContainerRef, _changeDetectorRef, _el, differs, scrollStrategy) {
        this._dialog = _dialog;
        this._ngZone = _ngZone;
        this._overlay = _overlay;
        this._viewContainerRef = _viewContainerRef;
        this._changeDetectorRef = _changeDetectorRef;
        this._el = _el;
        this.differs = differs;
        this.scrollStrategy = scrollStrategy;
        this._onChange = Function.prototype;
        this._onTouched = Function.prototype;
        this._validatorChange = Function.prototype;
        this.minDate = null;
        this.maxDate = null;
        this.dateLimit = null;
        this.showCancel = false;
        // timepicker variables
        this.timePicker = false;
        this.showRanges = false;
        this.timePicker24Hour = false;
        this.timePickerIncrement = 1;
        this.timePickerSeconds = false;
        this._endKey = 'endDate';
        this._startKey = 'startDate';
        this.ranges = {
            'DATERANGE.today': [moment$2$1(), moment$2$1()],
            'DATERANGE.yesterday': [moment$2$1().subtract(1, 'days'), moment$2$1().subtract(1, 'days')],
            'DATERANGE.last_7days': [moment$2$1().subtract(6, 'days'), moment$2$1()],
            'DATERANGE.last_30days': [moment$2$1().subtract(29, 'days'), moment$2$1()],
            'DATERANGE.this_month': [moment$2$1().startOf('month'), moment$2$1().endOf('month')],
            'DATERANGE.last_month': [moment$2$1().subtract(1, 'month').startOf('month'), moment$2$1().subtract(1, 'month').endOf('month')],
            'DATERANGE.this_year': [moment$2$1().startOf('year'), moment$2$1().endOf('year')]
        };
        this.oTouchUi = false;
        this.notForChangesProperty = [
            'locale',
            'endKey',
            'startKey'
        ];
        this.onChange = new core.EventEmitter();
        this.rangeClicked = new core.EventEmitter();
        this.datesUpdated = new core.EventEmitter();
        this.drops = 'down';
        this.opens = 'right';
    }
    Object.defineProperty(ODaterangepickerDirective.prototype, "separator", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== null) {
                this._separator = value;
                if (this._locale) {
                    this._locale.separator = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODaterangepickerDirective.prototype, "locale", {
        get: /**
         * @return {?}
         */
        function () {
            return this._locale;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== null) {
                this._locale = value;
                if (this._separator) {
                    this._locale.separator = this._separator;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODaterangepickerDirective.prototype, "startKey", {
        get: /**
         * @return {?}
         */
        function () {
            return this._startKey;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value && value !== null) {
                this._startKey = value;
            }
            else {
                this._startKey = 'startDate';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODaterangepickerDirective.prototype, "endKey", {
        get: /**
         * @return {?}
         */
        function () {
            return this._endKey;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value && value !== null) {
                this._endKey = value;
            }
            else {
                this._endKey = 'endDate';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODaterangepickerDirective.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._value || null;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._value = val;
            this._onChange(val);
            this._changeDetectorRef.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} instance
     * @return {?}
     */
    ODaterangepickerDirective.prototype.initializeListeners = /**
     * @param {?} instance
     * @return {?}
     */
    function (instance) {
        var _this = this;
        instance.rangeClicked.asObservable().subscribe(function (range$$1) {
            _this.rangeClicked.emit(range$$1);
        });
        instance.datesUpdated.asObservable().subscribe(function (range$$1) {
            _this.datesUpdated.emit(range$$1);
        });
        instance.choosedDate.asObservable().subscribe(function (change) {
            if (change) {
                /** @type {?} */
                var value = {};
                value[_this._startKey] = change.startDate;
                value[_this._endKey] = change.endDate;
                _this.value = value;
                _this.onChange.emit(value);
                if (typeof change.chosenLabel === 'string') {
                    _this._el.nativeElement.value = change.chosenLabel;
                }
            }
        });
        instance.firstMonthDayClass = this.firstMonthDayClass;
        instance.lastMonthDayClass = this.lastMonthDayClass;
        instance.emptyWeekRowClass = this.emptyWeekRowClass;
        instance.firstDayOfNextMonthClass = this.firstDayOfNextMonthClass;
        instance.lastDayOfPreviousMonthClass = this.lastDayOfPreviousMonthClass;
        instance.drops = this.drops;
        instance.opens = this.opens;
        instance.minDate = this.minDate;
        instance.maxDate = this.maxDate;
        instance.locale = this.locale;
        instance.showWeekNumbers = this.showWeekNumbers;
        if (this.showRanges) {
            instance.ranges = this.ranges;
            instance.keepCalendarOpeningWithRange = true;
            instance.alwaysShowCalendars = true;
        }
        this.localeDiffer = this.differs.find(this.locale).create();
    };
    // ngOnChanges(changes: SimpleChanges): void  {
    //   for (let change in changes) {
    //     if (changes.hasOwnProperty(change)) {
    //       if (this.notForChangesProperty.indexOf(change) === -1) {
    //         this.picker[change] = changes[change].currentValue;
    //       }
    //     }
    //   }
    // }
    // ngDoCheck() {
    //   if (this.localeDiffer) {
    //     const changes = this.localeDiffer.diff(this.locale);
    //     if (changes) {
    //       this.picker.updateLocale(this.locale);
    //     }
    //   }
    // }
    /**
     * @return {?}
     */
    ODaterangepickerDirective.prototype.onBlur = /**
     * @return {?}
     */
    function () {
        this._onTouched();
    };
    /**
     * @return {?}
     */
    ODaterangepickerDirective.prototype.open = /**
     * @return {?}
     */
    function () {
        if (!this.oTouchUi) {
            this.openAsPopup();
        }
        else {
            this.openAsDialog();
        }
    };
    /**
     * @return {?}
     */
    ODaterangepickerDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.close();
        if (this._popupRef) {
            this._popupRef.dispose();
            this._popupComponentRef = null;
        }
    };
    /**
     * @return {?}
     */
    ODaterangepickerDirective.prototype.clear = /**
     * @return {?}
     */
    function () {
        this._popupComponentRef.instance.clear();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ODaterangepickerDirective.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.setValue(value);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ODaterangepickerDirective.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ODaterangepickerDirective.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouched = fn;
    };
    /**
     * @param {?} instance
     * @param {?} val
     * @return {?}
     */
    ODaterangepickerDirective.prototype.setValueInDateComponent = /**
     * @param {?} instance
     * @param {?} val
     * @return {?}
     */
    function (instance, val) {
        if (val) {
            if (val[this._startKey]) {
                instance.setStartDate(val[this._startKey]);
            }
            if (val[this._endKey]) {
                instance.setEndDate(val[this._endKey]);
            }
            instance.calculateChosenLabel();
            if (instance.chosenLabel) {
                this._el.nativeElement.value = instance.chosenLabel;
            }
        }
        else {
            instance.clear();
        }
    };
    /**
     * @param {?} val
     * @return {?}
     */
    ODaterangepickerDirective.prototype.setValue = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        if (val) {
            this.value = val;
        }
    };
    /**
     *
     * @return {?}
     */
    ODaterangepickerDirective.prototype.openAsPopup = /**
     *
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._calendarPortal) {
            this._calendarPortal = new ComponentPortal(DaterangepickerComponent, this._viewContainerRef);
        }
        if (!this._popupRef) {
            this._createPopup();
        }
        if (!this._popupRef.hasAttached()) {
            this._popupComponentRef = this._popupRef.attach(this._calendarPortal);
            this.initializeListeners(this._popupComponentRef.instance);
            if (this.value) {
                this.setValueInDateComponent(this._popupComponentRef.instance, this.value);
            }
            // Update the position once the calendar has rendered.
            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {
                _this._popupRef.updatePosition();
            });
        }
    };
    /**
     * Create the popup.
     * @return {?}
     */
    ODaterangepickerDirective.prototype._createPopup = /**
     * Create the popup.
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var overlayConfig = new OverlayConfig({
            positionStrategy: this._createPopupPositionStrategy(),
            hasBackdrop: true,
            backdropClass: 'mat-overlay-transparent-backdrop',
            direction: 'ltr',
            panelClass: 'o-daterangepicker-popup',
            scrollStrategy: this.scrollStrategy.close()
        });
        this._popupRef = this._overlay.create(overlayConfig);
        this._popupRef.overlayElement.setAttribute('role', 'dialog');
        merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(filter(function (event) {
            // Closing on alt + up is only valid when there's an input associated with the datepicker.
            return event.keyCode === ESCAPE ||
                (_this._el && event.altKey && event.keyCode === UP_ARROW);
        }))).subscribe(function () { return _this.close(); });
    };
    /**
     * @return {?}
     */
    ODaterangepickerDirective.prototype._createPopupPositionStrategy = /**
     * @return {?}
     */
    function () {
        return this._overlay.position()
            .flexibleConnectedTo(this._el)
            // .withTransformOriginOn('.mat-datepicker-content')
            // .withFlexibleDimensions(false)
            .withViewportMargin(8)
            // .withLockedPosition()
            .withPositions([
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'top'
            },
            {
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'bottom'
            },
            {
                originX: 'end',
                originY: 'bottom',
                overlayX: 'end',
                overlayY: 'top'
            },
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'end',
                overlayY: 'bottom'
            }
        ]);
    };
    /**
     * Open the calendar as a dialog.
     * @return {?}
     */
    ODaterangepickerDirective.prototype.openAsDialog = /**
     * Open the calendar as a dialog.
     * @return {?}
     */
    function () {
        var _this = this;
        // Usually this would be handled by `open` which ensures that we can only have one overlay
        // open at a time, however since we reset the variables in async handlers some overlays
        // may slip through if the user opens and closes multiple times in quick succession (e.g.
        // by holding down the enter key).
        if (this._dialogRef) {
            this._dialogRef.close();
        }
        this._dialogRef = this._dialog.open(DaterangepickerComponent, {
            direction: 'ltr',
            viewContainerRef: this._viewContainerRef,
            panelClass: 'mat-datepicker-dialog',
        });
        this.initializeListeners(this._dialogRef.componentInstance);
        if (this.value) {
            this.setValueInDateComponent(this._dialogRef.componentInstance, this.value);
        }
        this._dialogRef.afterClosed().subscribe(function () { return _this.close(); });
        //this._dialogRef.componentInstance. = this;
    };
    /**
     * @return {?}
     */
    ODaterangepickerDirective.prototype.close = /**
     * @return {?}
     */
    function () {
        if (this._popupRef && this._popupRef.hasAttached()) {
            this._popupRef.detach();
        }
        if (this._dialogRef) {
            this._dialogRef.close();
        }
        if (this._calendarPortal && this._calendarPortal.isAttached) {
            this._calendarPortal.detach();
        }
    };
    ODaterangepickerDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: 'input[o-daterange-input]',
                    host: {
                        '(keyup.esc)': 'hide()',
                        '(blur)': 'onBlur()'
                    },
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: core.forwardRef(function () { return ODaterangepickerDirective; }), multi: true
                        }
                    ]
                },] },
    ];
    /** @nocollapse */
    ODaterangepickerDirective.ctorParameters = function () { return [
        { type: material.MatDialog },
        { type: core.NgZone },
        { type: Overlay },
        { type: core.ViewContainerRef },
        { type: core.ChangeDetectorRef },
        { type: core.ElementRef },
        { type: core.KeyValueDiffers },
        { type: ScrollStrategyOptions }
    ]; };
    ODaterangepickerDirective.propDecorators = {
        minDate: [{ type: core.Input }],
        maxDate: [{ type: core.Input }],
        showCustomRangeLabel: [{ type: core.Input }],
        linkedCalendars: [{ type: core.Input }],
        dateLimit: [{ type: core.Input }],
        singleDatePicker: [{ type: core.Input }],
        showWeekNumbers: [{ type: core.Input }],
        showISOWeekNumbers: [{ type: core.Input }],
        showDropdowns: [{ type: core.Input }],
        isInvalidDate: [{ type: core.Input }],
        isCustomDate: [{ type: core.Input }],
        opens: [{ type: core.Input }],
        drops: [{ type: core.Input }],
        lastMonthDayClass: [{ type: core.Input }],
        emptyWeekRowClass: [{ type: core.Input }],
        firstDayOfNextMonthClass: [{ type: core.Input }],
        lastDayOfPreviousMonthClass: [{ type: core.Input }],
        keepCalendarOpeningWithRange: [{ type: core.Input }],
        showRangeLabelOnInput: [{ type: core.Input }],
        showCancel: [{ type: core.Input }],
        timePicker: [{ type: core.Input }],
        showRanges: [{ type: core.Input }],
        timePicker24Hour: [{ type: core.Input }],
        timePickerIncrement: [{ type: core.Input }],
        timePickerSeconds: [{ type: core.Input }],
        separator: [{ type: core.Input }],
        locale: [{ type: core.Input }],
        _endKey: [{ type: core.Input }],
        oTouchUi: [{ type: core.Input }],
        startKey: [{ type: core.Input }],
        endKey: [{ type: core.Input }],
        onChange: [{ type: core.Output, args: ['change',] }],
        rangeClicked: [{ type: core.Output, args: ['rangeClicked',] }],
        datesUpdated: [{ type: core.Output, args: ['datesUpdated',] }]
    };
    return ODaterangepickerDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_OUTPUTS_O_DATERANGE_INPUT = DEFAULT_OUTPUTS_O_TEXT_INPUT.slice();
/** @type {?} */
var DEFAULT_INPUTS_O_DATERANGE_INPUT = [
    'separator',
    'showWeekNumbers:show-week-numbers',
    'showRanges:show-ranges',
    'olocale:locale',
    'startKey',
    'endKey'
].concat(DEFAULT_INPUTS_O_DATE_INPUT);
/** @type {?} */
var moment$3$1 = moment__default;
var ODateRangeInputComponent = /** @class */ (function (_super) {
    __extends(ODateRangeInputComponent, _super);
    function ODateRangeInputComponent(form, elRef, injector) {
        var _this = _super.call(this, form, elRef, injector) || this;
        _this.textInputEnabled = true;
        _this.showWeekNumbers = false;
        _this.oTouchUi = false;
        _this.showRanges = false;
        _this._startKey = 'startDate';
        _this._endKey = 'endDate';
        _this._separator = ' - ';
        _this.oformat = 'L';
        _this.oTranslate = _this.injector.get(OTranslateService$$1);
        _this.momentSrv = _this.injector.get(MomentService);
        _this._localeOptions = {
            direction: 'ltr',
            separator: ' - ',
            weekLabel: _this.oTranslate.get('DATERANGE.W'),
            applyLabel: _this.oTranslate.get('DATERANGE.APPLYLABEL'),
            cancelLabel: _this.oTranslate.get('CANCEL'),
            customRangeLabel: 'Custom range',
            daysOfWeek: moment$3$1.weekdaysMin(),
            monthNames: moment$3$1.monthsShort(),
            firstDay: moment$3$1.localeData().firstDayOfWeek(),
            format: 'L'
        };
        return _this;
    }
    Object.defineProperty(ODateRangeInputComponent.prototype, "oMinDate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._oMinDate;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._oMinDate = moment$3$1(value, this.oformat);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODateRangeInputComponent.prototype, "oMaxDate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._oMaxDate;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._oMaxDate = moment$3$1(value, this.oformat);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODateRangeInputComponent.prototype, "startKey", {
        get: /**
         * @return {?}
         */
        function () {
            return this._startKey;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._startKey = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODateRangeInputComponent.prototype, "endKey", {
        get: /**
         * @return {?}
         */
        function () {
            return this._endKey;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._endKey = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODateRangeInputComponent.prototype, "separator", {
        get: /**
         * @return {?}
         */
        function () {
            return this._separator;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._separator = value;
            if (this.getFormControl() && this.getFormControl().value) {
                this.updateElement();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODateRangeInputComponent.prototype, "showClearButton", {
        get: /**
         * @return {?}
         */
        function () {
            return this.clearButton && !this.isReadOnly && this.enabled && this.matInputRef.nativeElement.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ODateRangeInputComponent.prototype, "localeOptions", {
        get: /**
         * @return {?}
         */
        function () {
            return this._localeOptions;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ODateRangeInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        if (!this.olocale) {
            this.olocale = this.momentSrv.getLocale();
            moment$3$1.locale(this.olocale);
        }
        if (this.oformat) {
            this._localeOptions.format = this.oformat;
        }
    };
    /**
     * @return {?}
     */
    ODateRangeInputComponent.prototype.openPicker = /**
     * @return {?}
     */
    function () {
        this.pickerDirective.open();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ODateRangeInputComponent.prototype.onChangeEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var objectValue;
        if (event instanceof Event) {
            /** @type {?} */
            var value = (/** @type {?} */ (event.target)).value;
            if (value !== '') {
                objectValue = this.getDateRangeToString(value);
            }
        }
        else {
            objectValue = event;
        }
        this.setValue(objectValue, {
            changeType: OValueChangeEvent.USER_CHANGE,
            emitEvent: false,
            emitModelToViewChange: false
        });
    };
    /**
     * @param {?} val
     * @param {?=} options
     * @param {?=} setDirty
     * @return {?}
     */
    ODateRangeInputComponent.prototype.setValue = /**
     * @param {?} val
     * @param {?=} options
     * @param {?=} setDirty
     * @return {?}
     */
    function (val, options, setDirty) {
        if (options === void 0) { options = {}; }
        if (setDirty === void 0) { setDirty = false; }
        _super.prototype.setValue.call(this, val, options, setDirty);
        this.updateElement();
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ODateRangeInputComponent.prototype.onClickClearValue = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        _super.prototype.onClickClearValue.call(this, e);
        this.pickerDirective.value = undefined;
        this.pickerDirective.datesUpdated.emit(undefined);
    };
    /**
     * @param {?} range
     * @return {?}
     */
    ODateRangeInputComponent.prototype.datesUpdated = /**
     * @param {?} range
     * @return {?}
     */
    function (range$$1) {
        this.pickerDirective.close();
        this.setValue(range$$1, {
            changeType: OValueChangeEvent.USER_CHANGE,
            emitEvent: false,
            emitModelToViewChange: false
        });
    };
    /**
     * @param {?} newValue
     * @return {?}
     */
    ODateRangeInputComponent.prototype.setData = /**
     * @param {?} newValue
     * @return {?}
     */
    function (newValue) {
        _super.prototype.setData.call(this, newValue);
        this.pickerDirective.datesUpdated.emit(newValue);
        this.updateElement();
    };
    /**
     * @return {?}
     */
    ODateRangeInputComponent.prototype.updateElement = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var chosenLabel = (!this.isObjectDataRangeNull(this.value)) ? this.value.value[this.pickerDirective.startKey].format(this.oformat) +
            this.separator + this.value.value[this.pickerDirective.endKey].format(this.oformat) : null;
        this.pickerDirective._el.nativeElement.value = chosenLabel;
    };
    /**
     * @param {?} valueToString
     * @return {?}
     */
    ODateRangeInputComponent.prototype.getDateRangeToString = /**
     * @param {?} valueToString
     * @return {?}
     */
    function (valueToString) {
        /** @type {?} */
        var value = {};
        /** @type {?} */
        var range$$1 = valueToString.split(this.separator);
        value[this._startKey] = moment$3$1(range$$1[0].trim(), this.oformat);
        value[this._endKey] = moment$3$1(range$$1[1].trim(), this.oformat);
        return value;
    };
    /**
     * @return {?}
     */
    ODateRangeInputComponent.prototype.resolveValidators = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validators = _super.prototype.resolveValidators.call(this);
        validators.push(this.rangeDateValidator.bind(this));
        if (Util.isDefined(this._oMinDate)) {
            validators.push(this.minDateValidator.bind(this));
        }
        if (Util.isDefined(this._oMaxDate)) {
            validators.push(this.maxDateValidator.bind(this));
        }
        validators.push(this.parseDateValidator.bind(this));
        return validators;
    };
    /**
     * @param {?} objectValue
     * @return {?}
     */
    ODateRangeInputComponent.prototype.isObjectDataRangeNull = /**
     * @param {?} objectValue
     * @return {?}
     */
    function (objectValue) {
        return objectValue !== null && objectValue.value !== null &&
            !Util.isDefined(objectValue.value[this.pickerDirective.startKey]) &&
            !Util.isDefined(objectValue.value[this.pickerDirective.endKey]);
    };
    /**
     * @param {?} control
     * @return {?}
     */
    ODateRangeInputComponent.prototype.rangeDateValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if ((control.value instanceof Object)
            && !this.isObjectDataRangeNull(control) && control.value[this._endKey].isSameOrBefore(control.value[this._startKey])) {
            return {
                dateRange: true
            };
        }
        return {};
    };
    /**
     * @param {?} control
     * @return {?}
     */
    ODateRangeInputComponent.prototype.minDateValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        /** @type {?} */
        var mindate = moment$3$1(this._oMinDate);
        if ((control.value instanceof Object)
            && !this.isObjectDataRangeNull(control) && control.value[this._startKey].isBefore(mindate)) {
            return {
                dateRangeMin: {
                    dateMin: mindate.format(this.oformat)
                }
            };
        }
        return {};
    };
    /**
     * @param {?} control
     * @return {?}
     */
    ODateRangeInputComponent.prototype.maxDateValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        /** @type {?} */
        var maxdate = moment$3$1(this._oMaxDate);
        if ((control.value instanceof Object)
            && !this.isObjectDataRangeNull(control) && control.value[this._endKey].isAfter(maxdate)) {
            return {
                dateRangeMax: {
                    dateMax: maxdate.format(this.oformat)
                }
            };
        }
        return {};
    };
    /**
     * @param {?} control
     * @return {?}
     */
    ODateRangeInputComponent.prototype.parseDateValidator = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if ((control.value instanceof Object)
            && !this.isObjectDataRangeNull(control)
            && ((control.value[this._startKey] && !control.value[this._startKey].isValid())
                || (control.value[this._endKey] && !control.value[this._endKey].isValid()))) {
            return {
                dateRangeParse: {
                    format: this.oformat + this._localeOptions.separator + this.oformat
                }
            };
        }
        return {};
    };
    ODateRangeInputComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-daterange-input',
                    template: "\n    <div fxLayout=\"row\" fxLayoutAlign=\"space-between center\" [formGroup]=\"getFormGroup()\" [matTooltip]=\"tooltip\"\n      [matTooltipClass]=\"tooltipClass\" [matTooltipPosition]=\"tooltipPosition\" [matTooltipShowDelay]=\"tooltipShowDelay\"\n      [matTooltipHideDelay]=\"tooltipHideDelay\">\n\n      <mat-form-field [appearance]=\"appearance\" [floatLabel]=\"floatLabel\" [hideRequiredMarker]=\"hideRequiredMarker\"\n        [class.custom-width]=\"hasCustomWidth\" class=\"icon-field\" fxFlexFill>\n        <mat-label *ngIf=\"labelVisible\">{{ olabel | oTranslate }}</mat-label>\n        <input #matInputRef matInput type=\"text\" o-daterange-input [id]=\"getAttribute()\" [formControlName]=\"getAttribute()\"\n          [required]=\"isRequired\" [placeholder]=\"placeHolder\" [readonly]=\"isReadOnly || !textInputEnabled\"\n          showDropdowns=\"true\" showCancel=\"true\" [showRanges]=\"showRanges\" \n          (datesUpdated)=\"datesUpdated($event)\" [oTouchUi]=\"oTouchUi\" [minDate]=\"oMinDate\" [maxDate]=\"oMaxDate\"\n          (focus)=\"innerOnFocus($event)\" (blur)=\"innerOnBlur($event)\" (change)=\"onChangeEvent($event)\" [locale]=\"localeOptions\"   [separator]=\"separator\"\n          [startKey]=\"startKey\" [endKey]=\"endKey\" [showWeekNumbers]=\"showWeekNumbers\">\n        <button type=\"button\" matSuffix mat-icon-button (click)=\"openPicker()\" [disabled]=\"isReadOnly || !enabled\">\n          <mat-icon>today</mat-icon>\n        </button>\n\n        <button type=\"button\" *ngIf=\"showClearButton\" matSuffix mat-icon-button (click)=\"onClickClearValue($event)\"\n          [disabled]=\"isReadOnly || !enabled\">\n          <mat-icon svgIcon=\"ontimize:close\"></mat-icon>\n        </button>\n\n        <mat-error *ngIf=\"hasError('required')\" text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('dateRange')\" text=\"{{ 'FORM_VALIDATION.DATERANGE_INVALID' | oTranslate }}\"></mat-error>\n        <mat-error *ngIf=\"hasError('dateRangeParse')\"\n          text=\"{{ 'FORM_VALIDATION.DATE_PARSE' | oTranslate }} : {{ getErrorValue('dateRangeParse', 'format') }}\">\n        </mat-error>\n        <mat-error *ngIf=\"hasError('dateRangeMin')\"\n          text=\"{{ 'FORM_VALIDATION.DATERANGE_MIN' | oTranslate }} : {{ getErrorValue('dateRangeMin', 'dateMin') }}\">\n        </mat-error>\n        <mat-error *ngIf=\"hasError('dateRangeMax')\"\n          text=\"{{ 'FORM_VALIDATION.DATERANGE_MAX' | oTranslate }} : {{ getErrorValue('dateRangeMax', 'dateMax') }}\">\n        </mat-error>\n        <mat-error *ngFor=\"let oError of getActiveOErrors()\" text=\"{{ oError.text | oTranslate }}\"></mat-error>\n      </mat-form-field>\n    </div>\n  ",
                    styles: ['./o-daterange-input.component.scss'],
                    outputs: DEFAULT_OUTPUTS_O_DATERANGE_INPUT,
                    inputs: DEFAULT_INPUTS_O_DATERANGE_INPUT
                },] },
    ];
    /** @nocollapse */
    ODateRangeInputComponent.ctorParameters = function () { return [
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] },
        { type: core.ElementRef },
        { type: core.Injector }
    ]; };
    ODateRangeInputComponent.propDecorators = {
        pickerDirective: [{ type: core.ViewChild, args: [ODaterangepickerDirective,] }],
        matInputRef: [{ type: core.ViewChild, args: ['matInputRef',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], ODateRangeInputComponent.prototype, "textInputEnabled", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], ODateRangeInputComponent.prototype, "showWeekNumbers", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], ODateRangeInputComponent.prototype, "oTouchUi", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], ODateRangeInputComponent.prototype, "showRanges", void 0);
    return ODateRangeInputComponent;
}(OFormDataComponent));
var ODateRangeInputModule = /** @class */ (function () {
    function ODateRangeInputModule() {
    }
    ODateRangeInputModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [DaterangepickerComponent, ODateRangeInputComponent, ODaterangepickerDirective],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [ODateRangeInputComponent],
                    entryComponents: [
                        DaterangepickerComponent
                    ],
                    providers: []
                },] },
    ];
    return ODateRangeInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_TEXT_RENDERER = [
    'title',
    'primaryText : primary-text',
    'secondaryText : secondary-text',
    'icon'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_TEXT_RENDERER = [
    'onIconClick : icon-action'
];
var OListItemTextRenderer = /** @class */ (function () {
    function OListItemTextRenderer(elRef, _renderer, _injector, _listItem) {
        this.elRef = elRef;
        this._renderer = _renderer;
        this._injector = _injector;
        this._listItem = _listItem;
        this.onIconClick = new core.EventEmitter();
    }
    /**
     * @return {?}
     */
    OListItemTextRenderer.prototype.modifyMatListItemElement = /**
     * @return {?}
     */
    function () {
        if (this.elRef.nativeElement && this.elRef.nativeElement.parentElement) {
            /** @type {?} */
            var listItem = this.elRef.nativeElement.parentElement.parentElement;
            if (listItem && listItem.nodeName === 'MAT-LIST-ITEM') {
                /** @type {?} */
                var linesNo = 3;
                if (this.title === undefined) {
                    linesNo--;
                }
                if (this.primaryText === undefined) {
                    linesNo--;
                }
                if (this.secondaryText === undefined) {
                    linesNo--;
                }
                listItem.classList.add('mat-' + linesNo + '-line');
                listItem.querySelector('.mat-list-text').remove();
            }
        }
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OListItemTextRenderer.prototype.onActionIconClick = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (Util.isDefined(e)) {
            e.stopPropagation();
        }
        this.onIconClick.emit(event);
    };
    Object.defineProperty(OListItemTextRenderer.prototype, "title", {
        get: /**
         * @return {?}
         */
        function () {
            return this._title;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._title = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OListItemTextRenderer.prototype, "primaryText", {
        get: /**
         * @return {?}
         */
        function () {
            return this._primaryText;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._primaryText = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OListItemTextRenderer.prototype, "secondaryText", {
        get: /**
         * @return {?}
         */
        function () {
            return this._secondaryText;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._secondaryText = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OListItemTextRenderer.prototype, "icon", {
        get: /**
         * @return {?}
         */
        function () {
            return this._icon;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._icon = val;
        },
        enumerable: true,
        configurable: true
    });
    OListItemTextRenderer.DEFAULT_INPUTS_O_TEXT_RENDERER = DEFAULT_INPUTS_O_TEXT_RENDERER;
    OListItemTextRenderer.DEFAULT_OUTPUTS_O_TEXT_RENDERER = DEFAULT_OUTPUTS_O_TEXT_RENDERER;
    return OListItemTextRenderer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_LIST_ITEM_AVATAR = OListItemTextRenderer.DEFAULT_INPUTS_O_TEXT_RENDERER.concat([
    'avatar',
    'emptyAvatar: empty-avatar',
    'avatarType: avatar-type'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_LIST_ITEM_AVATAR = OListItemTextRenderer.DEFAULT_OUTPUTS_O_TEXT_RENDERER.slice();
var OListItemAvatarComponent = /** @class */ (function (_super) {
    __extends(OListItemAvatarComponent, _super);
    function OListItemAvatarComponent(elRef, _renderer, _injector, _listItem, sanitizer) {
        var _this = _super.call(this, elRef, _renderer, _injector, _listItem) || this;
        _this._listItem = _listItem;
        _this.sanitizer = sanitizer;
        return _this;
    }
    /**
     * @return {?}
     */
    OListItemAvatarComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.modifyMatListItemElement();
    };
    /**
     * @return {?}
     */
    OListItemAvatarComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var avatarValue = this.avatar;
        if (!this.avatar) {
            avatarValue = this.emptyAvatar;
        }
        else {
            switch (this.avatarType) {
                case 'base64':
                    avatarValue = ('data:image/png;base64,' + ((typeof (avatarValue.bytes) !== 'undefined') ? avatarValue.bytes : avatarValue));
                    break;
                case 'url':
                default:
                    avatarValue = this.avatar;
                    break;
            }
        }
        this.avatarSrc = this.sanitizer.bypassSecurityTrustResourceUrl(avatarValue);
    };
    Object.defineProperty(OListItemAvatarComponent.prototype, "avatarSrc", {
        get: /**
         * @return {?}
         */
        function () {
            return this._avatarSrc;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._avatarSrc = val;
        },
        enumerable: true,
        configurable: true
    });
    OListItemAvatarComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-list-item-avatar',
                    template: "\n    <div fxLayout=\"row\" fxLayoutAlign=\"center center\">\n      <img matListAvatar class=\"avatar\" [src]=\"avatarSrc\" [alt]=\"title\">\n      <div class=\"mat-list-text\">\n        <h3 matLine class=\"primary-text\"> {{ title }} </h3>\n        <h4 *ngIf=\"primaryText !== undefined\" matLine class=\"primary-text\">{{ primaryText }}</h4>\n        <p *ngIf=\"secondaryText !== undefined\" matLine class=\"secondary-text\">{{ secondaryText }}</p>\n      </div>\n      <mat-icon *ngIf=\"icon !== undefined\" class=\"material-icons o-list-item-icon\" (click)=\"onActionIconClick($event)\">{{ icon\n        }}\n      </mat-icon>\n    </div>\n  ",
                    styles: ["\n    .o-list-row-action+.o-list-item-avatar{padding:0px 0px 0px 10px}.mat-list.selectable .o-list-item-avatar .mat-list-text{padding-right:0px}.mat-list .mat-list-item .mat-list-item-content .o-list-item-avatar.o-custom-list-item .mat-list-text,.mat-nav-list .mat-list-item .mat-list-item-content .o-list-item-avatar.o-custom-list-item .mat-list-text{padding:0 16px}\n  "],
                    inputs: DEFAULT_INPUTS_O_LIST_ITEM_AVATAR,
                    outputs: DEFAULT_OUTPUTS_O_LIST_ITEM_AVATAR,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-custom-list-item]': 'true',
                        '[class.o-list-item-avatar]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OListItemAvatarComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: core.Injector },
        { type: OListItemComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OListItemComponent; }),] }] },
        { type: platformBrowser.DomSanitizer }
    ]; };
    return OListItemAvatarComponent;
}(OListItemTextRenderer));
var OListItemAvatarModule = /** @class */ (function () {
    function OListItemAvatarModule() {
    }
    OListItemAvatarModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OListItemAvatarComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OListItemAvatarComponent]
                },] },
    ];
    return OListItemAvatarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_LIST_ITEM_TEXT = OListItemTextRenderer.DEFAULT_INPUTS_O_TEXT_RENDERER.concat([
    'iconPosition : icon-position'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_LIST_ITEM_TEXT = OListItemTextRenderer.DEFAULT_OUTPUTS_O_TEXT_RENDERER.slice();
var OListItemTextComponent = /** @class */ (function (_super) {
    __extends(OListItemTextComponent, _super);
    function OListItemTextComponent(elRef, _renderer, _injector, _listItem) {
        var _this = _super.call(this, elRef, _renderer, _injector, _listItem) || this;
        _this._listItem = _listItem;
        _this.ICON_POSITION_LEFT = 'left';
        _this.ICON_POSITION_RIGHT = 'right';
        _this.elRef.nativeElement.classList.add('o-list-item-text');
        return _this;
    }
    /**
     * @return {?}
     */
    OListItemTextComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.iconPosition || [this.ICON_POSITION_LEFT, this.ICON_POSITION_RIGHT].indexOf(this.iconPosition.toLowerCase()) === -1) {
            this.iconPosition = this.ICON_POSITION_RIGHT;
        }
    };
    /**
     * @return {?}
     */
    OListItemTextComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.modifyMatListItemElement();
    };
    Object.defineProperty(OListItemTextComponent.prototype, "iconPosition", {
        get: /**
         * @return {?}
         */
        function () {
            return this._iconPosition;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._iconPosition = val;
        },
        enumerable: true,
        configurable: true
    });
    OListItemTextComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-list-item-text',
                    template: "\n    <div fxLayout=\"row\" fxLayoutAlign=\"center center\">\n      <mat-icon *ngIf=\"icon !== undefined && iconPosition === ICON_POSITION_LEFT\" class=\"material-icons o-list-item-icon\" (click)=\"onActionIconClick($event)\">{{\n        icon }}</mat-icon>\n      <div class=\"mat-list-text\">\n        <h3 matLine class=\"primary-text\"> {{ title }} </h3>\n        <h4 *ngIf=\"primaryText !== undefined\" matLine class=\"primary-text\">{{ primaryText }}</h4>\n        <p *ngIf=\"secondaryText !== undefined\" matLine class=\"secondary-text\">{{ secondaryText }}</p>\n      </div>\n      <mat-icon *ngIf=\"icon !== undefined && iconPosition === ICON_POSITION_RIGHT\" class=\"material-icons o-list-item-icon\" (click)=\"onActionIconClick($event)\">{{\n        icon }}\n      </mat-icon>\n    </div>\n  ",
                    styles: ["\n    .mat-list.selectable[dense] .mat-list-item-content{padding-right:32px}.mat-list.selectable:not([dense]) .mat-list-item-content{padding-right:36px}\n  "],
                    inputs: DEFAULT_INPUTS_O_LIST_ITEM_TEXT,
                    outputs: DEFAULT_OUTPUTS_O_LIST_ITEM_TEXT,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-custom-list-item]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OListItemTextComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: core.Injector },
        { type: OListItemComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OListItemComponent; }),] }] }
    ]; };
    return OListItemTextComponent;
}(OListItemTextRenderer));
var OListItemTextModule = /** @class */ (function () {
    function OListItemTextModule() {
    }
    OListItemTextModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OListItemTextComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OListItemTextComponent]
                },] },
    ];
    return OListItemTextModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_CARD_RENDERER = [
    'title',
    'subtitle',
    'image',
    'showImage: show-image',
    'action1Text: action-1-text',
    'action2Text: action-2-text'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_CARD_RENDERER = [
    'onAction1Click: action-1',
    'onAction2Click: action-2'
];
var OListItemCardRenderer = /** @class */ (function () {
    /* end of inputs variables */
    function OListItemCardRenderer(elRef, _renderer, _injector, _listItem) {
        this.elRef = elRef;
        this._renderer = _renderer;
        this._injector = _injector;
        this._listItem = _listItem;
        this._showImage = true;
        this.onAction1Click = new core.EventEmitter();
        this.onAction2Click = new core.EventEmitter();
    }
    /**
     * @return {?}
     */
    OListItemCardRenderer.prototype.modifyMatListItemElement = /**
     * @return {?}
     */
    function () {
        if (this.elRef.nativeElement && this.elRef.nativeElement.parentElement) {
            /** @type {?} */
            var matListItem = this.elRef.nativeElement.parentElement.parentElement;
            matListItem.querySelector('.mat-list-text').remove();
            matListItem.classList.add('o-card-item');
        }
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OListItemCardRenderer.prototype.onAction1ButtonClick = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (Util.isDefined(e)) {
            e.stopPropagation();
        }
        this.onAction1Click.emit(event);
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OListItemCardRenderer.prototype.onAction2ButtonClick = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (Util.isDefined(e)) {
            e.stopPropagation();
        }
        this.onAction2Click.emit(event);
    };
    /**
     * @param {?} height
     * @return {?}
     */
    OListItemCardRenderer.prototype.compareListHeight = /**
     * @param {?} height
     * @return {?}
     */
    function (height) {
        return (height === this._listItem._list.rowHeight) || undefined;
    };
    Object.defineProperty(OListItemCardRenderer.prototype, "title", {
        get: /**
         * @return {?}
         */
        function () {
            return this._title;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._title = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OListItemCardRenderer.prototype, "subtitle", {
        get: /**
         * @return {?}
         */
        function () {
            return this._subtitle;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._subtitle = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OListItemCardRenderer.prototype, "image", {
        get: /**
         * @return {?}
         */
        function () {
            return this._image;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._image = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OListItemCardRenderer.prototype, "showImage", {
        get: /**
         * @return {?}
         */
        function () {
            return this._showImage;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._showImage = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OListItemCardRenderer.prototype, "action1Text", {
        get: /**
         * @return {?}
         */
        function () {
            return this._action1Text;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._action1Text = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OListItemCardRenderer.prototype, "action2Text", {
        get: /**
         * @return {?}
         */
        function () {
            return this._action2Text;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._action2Text = val;
        },
        enumerable: true,
        configurable: true
    });
    OListItemCardRenderer.DEFAULT_INPUTS_O_CARD_RENDERER = DEFAULT_INPUTS_O_CARD_RENDERER;
    OListItemCardRenderer.DEFAULT_OUTPUTS_O_CARD_RENDERER = DEFAULT_OUTPUTS_O_CARD_RENDERER;
    return OListItemCardRenderer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_LIST_ITEM_CARD = OListItemCardRenderer.DEFAULT_INPUTS_O_CARD_RENDERER.slice();
/** @type {?} */
var DEFAULT_OUTPUTS_O_LIST_ITEM_CARD = OListItemCardRenderer.DEFAULT_OUTPUTS_O_CARD_RENDERER.slice();
var OListItemCardComponent = /** @class */ (function (_super) {
    __extends(OListItemCardComponent, _super);
    function OListItemCardComponent(elRef, _renderer, _injector, _listItem) {
        return _super.call(this, elRef, _renderer, _injector, _listItem) || this;
    }
    /**
     * @return {?}
     */
    OListItemCardComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.modifyMatListItemElement();
    };
    OListItemCardComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-list-item-card',
                    template: "\n    <mat-card fxLayout=\"column\" fxLayoutAlign=\"center center\">\n      <mat-card-title-group>\n        <img *ngIf=\"showImage\" src=\"{{ image }}\" [class.mat-card-sm-image]=\"compareListHeight('small')\" [class.mat-card-md-image]=\"compareListHeight('medium')\"\n          [class.mat-card-lg-image]=\"compareListHeight('large')\">\n        <mat-card-title *ngIf=\"title !== undefined\"> {{ title }}</mat-card-title>\n        <mat-card-subtitle *ngIf=\"subtitle !== undefined\"> {{ subtitle }}</mat-card-subtitle>\n      </mat-card-title-group>\n      <mat-card-actions>\n        <button type=\"button\" mat-button *ngIf=\"action1Text !== undefined\" (click)=\"onAction1ButtonClick($event)\">{{ action1Text }}</button>\n        <button type=\"button\" mat-button *ngIf=\"action2Text !== undefined\" (click)=\"onAction2ButtonClick($event)\">{{ action2Text }}</button>\n      </mat-card-actions>\n    </mat-card>\n  ",
                    styles: ["\n    .mat-list .mat-list-item.o-card-item,.mat-list .mat-list-item.o-card-item .mat-list-item-content{height:auto}.o-list-item-card{padding:8px 0}.o-list-item-card mat-card,.o-list-item-card mat-card-actions,.o-list-item-card mat-card-title-group{width:100%}\n  "],
                    inputs: DEFAULT_INPUTS_O_LIST_ITEM_CARD,
                    outputs: DEFAULT_OUTPUTS_O_LIST_ITEM_CARD,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-custom-list-item]': 'true',
                        '[class.o-list-item-card]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OListItemCardComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: core.Injector },
        { type: OListItemComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OListItemComponent; }),] }] }
    ]; };
    return OListItemCardComponent;
}(OListItemCardRenderer));
var OListItemCardModule = /** @class */ (function () {
    function OListItemCardModule() {
    }
    OListItemCardModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OListItemCardComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OListItemCardComponent]
                },] },
    ];
    return OListItemCardModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_LIST_ITEM_CARD_IMAGE = OListItemCardRenderer.DEFAULT_INPUTS_O_CARD_RENDERER.concat([
    'avatar'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_LIST_ITEM_CARD_IMAGE = OListItemCardRenderer.DEFAULT_OUTPUTS_O_CARD_RENDERER.slice();
var OListItemCardImageComponent = /** @class */ (function (_super) {
    __extends(OListItemCardImageComponent, _super);
    function OListItemCardImageComponent(elRef, _renderer, _injector, _listItem) {
        var _this = _super.call(this, elRef, _renderer, _injector, _listItem) || this;
        _this._collapsible = false;
        _this._collapsed = true;
        _this.onIconClick = new core.EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    OListItemCardImageComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.modifyMatListItemElement();
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OListItemCardImageComponent.prototype.onActionIconClick = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        if (Util.isDefined(e)) {
            e.stopPropagation();
        }
        this.onIconClick.emit(event);
    };
    Object.defineProperty(OListItemCardImageComponent.prototype, "content", {
        get: /**
         * @return {?}
         */
        function () {
            return this._content;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._content = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OListItemCardImageComponent.prototype, "avatar", {
        get: /**
         * @return {?}
         */
        function () {
            return this._avatar;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._avatar = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OListItemCardImageComponent.prototype, "icon", {
        get: /**
         * @return {?}
         */
        function () {
            return this._icon;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._icon = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OListItemCardImageComponent.prototype, "collapsible", {
        get: /**
         * @return {?}
         */
        function () {
            return this._collapsible;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._collapsible = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OListItemCardImageComponent.prototype, "collapsed", {
        get: /**
         * @return {?}
         */
        function () {
            return this._collapsed;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._collapsed = val;
        },
        enumerable: true,
        configurable: true
    });
    OListItemCardImageComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-list-item-card-image',
                    template: "\n    <mat-card fxLayout=\"column\" fxLayoutAlign=\"center center\" class=\"o-item-card\" [class.small]=\"compareListHeight('small')\"\n      [class.medium]=\"compareListHeight('medium')\" [class.large]=\"compareListHeight('large')\">\n\n      <mat-card-header *ngIf=\"avatar !== undefined\">\n        <img matCardAvatar src=\"{{ avatar }}\">\n        <mat-card-title *ngIf=\"title !== undefined\"> {{ title }}</mat-card-title>\n        <mat-card-subtitle *ngIf=\"subtitle !== undefined\"> {{ subtitle }}</mat-card-subtitle>\n      </mat-card-header>\n\n      <img *ngIf=\"image !== undefined\" matCardImage src=\"{{ image }}\" [class.exists-action-button]=\"icon !== undefined\">\n\n      <button type=\"button\" *ngIf=\"icon !== undefined && compareListHeight('small')\" mat-mini-fab (click)=\"onActionIconClick($event)\" class=\"action-button\">\n        <mat-icon>{{ icon }}</mat-icon>\n      </button>\n\n      <button type=\"button\" *ngIf=\"icon !== undefined && (compareListHeight('medium') || compareListHeight('large'))\" mat-fab (click)=\"onActionIconClick($event)\"\n        class=\"action-button\">\n        <mat-icon>{{ icon }}</mat-icon>\n      </button>\n\n      <mat-card-title *ngIf=\"avatar === undefined && title !== undefined\"> {{ title }}</mat-card-title>\n      <mat-card-subtitle *ngIf=\"avatar === undefined && subtitle !== undefined\"> {{ subtitle }}</mat-card-subtitle>\n\n      <mat-card-content *ngIf=\"!collapsible\">\n        <p>\n          {{ content }}\n        </p>\n      </mat-card-content>\n\n      <mat-card-actions>\n        <button type=\"button\" mat-button *ngIf=\"action1Text !== undefined\" (click)=\"onAction1ButtonClick($event)\">{{ action1Text }}</button>\n        <button type=\"button\" mat-button *ngIf=\"action2Text !== undefined\" (click)=\"onAction2ButtonClick($event)\">{{ action2Text }}</button>\n\n        <div class=\"collapse-button-container\">\n          <button type=\"button\" mat-icon-button *ngIf=\"collapsible\" (click)=\"collapsed = !collapsed\" class=\"collapse-button\">\n            <mat-icon *ngIf=\"collapsed\" svgIcon=\"ontimize:keyboard_arrow_down\"></mat-icon>\n            <mat-icon *ngIf=\"!collapsed\" svgIcon=\"ontimize:keyboard_arrow_up\"></mat-icon>\n          </button>\n        </div>\n      </mat-card-actions>\n\n      <mat-card-content *ngIf=\"collapsible && !collapsed\">\n        <p>\n          {{ content }}\n        </p>\n      </mat-card-content>\n\n    </mat-card>\n  ",
                    styles: ["\n    .mat-list .mat-list-item.o-card-item,.mat-list .mat-list-item.o-card-item .mat-list-item-content{height:auto}.o-list-item-card-image{padding:8px 0}.o-list-item-card-image .mat-card mat-card-actions,.o-list-item-card-image .mat-card mat-card-header,.o-list-item-card-image .mat-card mat-card-subtitle,.o-list-item-card-image .mat-card mat-card-title{width:100%}.o-list-item-card-image .mat-card.large{width:100%}.o-list-item-card-image .mat-card.medium{width:80%;margin-left:auto;margin-right:auto}.o-list-item-card-image .mat-card.small{width:60%;margin-left:auto;margin-right:auto}.o-list-item-card-image .mat-card.small img.exists-action-button{margin-bottom:-20px}.o-list-item-card-image .mat-card:not(.small):not(.medium):not(.large){width:100%}.o-list-item-card-image .mat-card .action-button{margin-left:auto}.o-list-item-card-image .mat-card img.exists-action-button{margin-bottom:-28px}.o-list-item-card-image .mat-card .collapse-button-container{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;position:relative}.o-list-item-card-image .mat-card .collapse-button-container .collapse-button{margin-left:calc(100% - 40px)}\n  "],
                    inputs: DEFAULT_INPUTS_O_LIST_ITEM_CARD_IMAGE.concat([
                        'content',
                        'avatar',
                        'icon',
                        'collapsible',
                        'collapsed'
                    ]),
                    outputs: DEFAULT_OUTPUTS_O_LIST_ITEM_CARD_IMAGE.concat([
                        'onIconClick : icon-action'
                    ]),
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-custom-list-item]': 'true',
                        '[class.o-list-item-card-image]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OListItemCardImageComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: core.Injector },
        { type: OListItemComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OListItemComponent; }),] }] }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OListItemCardImageComponent.prototype, "_collapsible", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OListItemCardImageComponent.prototype, "_collapsed", void 0);
    return OListItemCardImageComponent;
}(OListItemCardRenderer));
var OListItemCardImageModule = /** @class */ (function () {
    function OListItemCardImageModule() {
    }
    OListItemCardImageModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OListItemCardImageComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OListItemCardImageComponent]
                },] },
    ];
    return OListItemCardImageModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_USER_INFO = [];
/** @type {?} */
var DEFAULT_OUTPUTS_O_USER_INFO = [];
var OUserInfoComponent = /** @class */ (function () {
    function OUserInfoComponent(elRef, injector, router$$1) {
        var _this = this;
        this.elRef = elRef;
        this.injector = injector;
        this.router = router$$1;
        this.dialogService = this.injector.get(DialogService);
        this.loginService = this.injector.get(LoginService$$1);
        this.oUserInfoService = this.injector.get(OUserInfoService);
        this.userInfo = this.oUserInfoService.getUserInfo();
        this.userInfoSubscription = this.oUserInfoService.getUserInfoObservable().subscribe(function (res) {
            _this.userInfo = res;
        });
    }
    /**
     * @return {?}
     */
    OUserInfoComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.userInfoSubscription.unsubscribe();
    };
    /**
     * @return {?}
     */
    OUserInfoComponent.prototype.onLogoutClick = /**
     * @return {?}
     */
    function () {
        this.loginService.logoutWithConfirmationAndRedirect();
    };
    /**
     * @return {?}
     */
    OUserInfoComponent.prototype.onSettingsClick = /**
     * @return {?}
     */
    function () {
        this.router.navigate(['main/settings']);
    };
    Object.defineProperty(OUserInfoComponent.prototype, "existsUserInfo", {
        get: /**
         * @return {?}
         */
        function () {
            return this.userInfo !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OUserInfoComponent.prototype, "avatar", {
        get: /**
         * @return {?}
         */
        function () {
            return this.userInfo ? this.userInfo.avatar : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OUserInfoComponent.prototype, "username", {
        get: /**
         * @return {?}
         */
        function () {
            return this.userInfo ? this.userInfo.username : undefined;
        },
        enumerable: true,
        configurable: true
    });
    OUserInfoComponent.DEFAULT_INPUTS_O_USER_INFO = DEFAULT_INPUTS_O_USER_INFO;
    OUserInfoComponent.DEFAULT_OUTPUTS_O_USER_INFO = DEFAULT_OUTPUTS_O_USER_INFO;
    OUserInfoComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-user-info',
                    inputs: DEFAULT_INPUTS_O_USER_INFO,
                    outputs: DEFAULT_OUTPUTS_O_USER_INFO,
                    template: "\n    <div class=\"o-user-info-container\" fxLayout=\"row\" fxLayoutAlign=\"center\">\n      <ng-container *ngIf=\"existsUserInfo\">\n        <div class=\"o-user-info-wrapper\" fxLayout=\"row\" fxLayoutAlign=\"center center\">\n          <div fxLayout=\"row\" fxLayoutAlign=\"center center\" class=\"o-user-info-avatar-wrapper\">\n            <img [src]=\"avatar\" *ngIf=\"avatar\" />\n          </div>\n          <span class=\"o-user-info-username\" *ngIf=\"username\"> {{ username }}</span>\n          <mat-icon [matMenuTriggerFor]=\"menu\" svgIcon=\"ontimize:keyboard_arrow_down\"></mat-icon>\n        </div>\n        <mat-menu #menu=\"matMenu\" yPosition=\"below\">\n          <button type=\"button\" mat-menu-item (click)=\"onSettingsClick()\">\n            <mat-icon svgIcon=\"ontimize:settings\"></mat-icon>\n            <span>{{ 'SETTINGS' | oTranslate }}</span>\n          </button>\n          <button type=\"button\" mat-menu-item (click)=\"onLogoutClick()\">\n            <mat-icon svgIcon=\"ontimize:power_settings_new\"></mat-icon>\n            <span>{{ 'LOGOUT' | oTranslate }}</span>\n          </button>\n        </mat-menu>\n      </ng-container>\n    </div>\n  ",
                    styles: ["\n    .o-user-info .o-user-info-container{cursor:pointer;height:100%}.o-user-info .o-user-info-avatar-wrapper{width:30px;height:30px;overflow:hidden;border-radius:100%}.o-user-info .o-user-info-avatar-wrapper img{max-width:100%;height:auto}.o-user-info .o-user-info-username{padding-left:6px}.o-user-info mat-icon{padding-left:4px;font-size:16px;line-height:26px}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-user-info]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OUserInfoComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Injector },
        { type: router.Router }
    ]; };
    return OUserInfoComponent;
}());
var OUserInfoModule = /** @class */ (function () {
    function OUserInfoModule() {
    }
    OUserInfoModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OUserInfoComponent],
                    imports: [common.CommonModule, OSharedModule, router.RouterModule],
                    exports: [OUserInfoComponent]
                },] },
    ];
    return OUserInfoModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var REG_LANGUAGE = /^([a-z]{2})[-|_]([A-Z]{2})$/;
var LocaleCode = /** @class */ (function () {
    function LocaleCode() {
    }
    /**
     * @param {?} code
     * @return {?}
     */
    LocaleCode.getLanguageCode = /**
     * @param {?} code
     * @return {?}
     */
    function (code) {
        /** @type {?} */
        var match = code.match(REG_LANGUAGE);
        /** @type {?} */
        var result = code.toLowerCase();
        if (match && match.length > 1) {
            result = match[1].toLowerCase();
        }
        return result;
    };
    /**
     * @param {?} code
     * @return {?}
     */
    LocaleCode.getCountryCode = /**
     * @param {?} code
     * @return {?}
     */
    function (code) {
        /** @type {?} */
        var match = code.match(REG_LANGUAGE);
        /** @type {?} */
        var result = code.toLowerCase();
        if (match && match.length > 2) {
            result = match[2].toLowerCase();
        }
        else {
            /*Exception pt is locale id of Portuguese Brazil
                  and pt-PT is Portuguese Portugal */
            if (result === 'pt') {
                result = 'br';
            }
        }
        return result;
    };
    return LocaleCode;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_LANGUAGE_SELECTOR = [
    'useFlagIcons: use-flag-icons'
];
/** @type {?} */
var DEFAULT_OUTPUTS_LANGUAGE_SELECTOR = [
    'onChange'
];
var OLanguageSelectorComponent = /** @class */ (function () {
    function OLanguageSelectorComponent(injector) {
        this.injector = injector;
        this.useFlagIcons = false;
        this.onChange = new core.EventEmitter();
        this.translateService = this.injector.get(OTranslateService$$1);
        this.appConfig = this.injector.get(AppConfig);
        this.availableLangs = this.appConfig.getConfiguration().applicationLocales;
    }
    /**
     * @param {?} lang
     * @return {?}
     */
    OLanguageSelectorComponent.prototype.getFlagClass = /**
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        /** @type {?} */
        var flagName = LocaleCode.getCountryCode(lang);
        flagName = (flagName !== 'en') ? flagName : 'gb';
        return 'flag-icon-' + flagName;
    };
    /**
     * @return {?}
     */
    OLanguageSelectorComponent.prototype.getAvailableLangs = /**
     * @return {?}
     */
    function () {
        return this.availableLangs;
    };
    /**
     * @param {?} lang
     * @return {?}
     */
    OLanguageSelectorComponent.prototype.configureI18n = /**
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        if (this.translateService && this.translateService.getCurrentLang() !== lang) {
            this.translateService.use(lang);
        }
    };
    /**
     * @return {?}
     */
    OLanguageSelectorComponent.prototype.getCurrentLang = /**
     * @return {?}
     */
    function () {
        return this.translateService.getCurrentLang();
    };
    /**
     * @return {?}
     */
    OLanguageSelectorComponent.prototype.getCurrentCountry = /**
     * @return {?}
     */
    function () {
        return LocaleCode.getCountryCode(this.getCurrentLang());
    };
    OLanguageSelectorComponent.DEFAULT_INPUTS_O_LANGUAGE_SELECTOR = DEFAULT_INPUTS_O_LANGUAGE_SELECTOR;
    OLanguageSelectorComponent.DEFAULT_OUTPUTS_LANGUAGE_SELECTOR = DEFAULT_OUTPUTS_LANGUAGE_SELECTOR;
    OLanguageSelectorComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-language-selector',
                    inputs: DEFAULT_INPUTS_O_LANGUAGE_SELECTOR,
                    outputs: DEFAULT_OUTPUTS_LANGUAGE_SELECTOR,
                    template: "\n    <div fxLayout fxLayoutAlign=\"center center\" fxFill>\n      <button type=\"button\" *ngIf=\"useFlagIcons\" class=\"menu-button\" mat-icon-button [matMenuTriggerFor]=\"langMenu\">\n        <span class=\"flag-icon {{ getFlagClass(getCurrentCountry()) }}\"></span>\n      </button>\n\n      <button type=\"button\" *ngIf=\"!useFlagIcons\" class=\"menu-button o-language-selector-text\" mat-button [matMenuTriggerFor]=\"langMenu\">\n        <span>{{ 'LOCALE_' + getCurrentLang() | oTranslate }}</span>\n      </button>\n    </div>\n\n    <mat-menu #langMenu=\"matMenu\" yPosition=\"below\">\n      <button type=\"button\" mat-menu-item *ngFor=\"let lang of getAvailableLangs()\" (click)=\"configureI18n(lang)\">\n        <span *ngIf=\"useFlagIcons\" class=\"flag-icon {{ getFlagClass(lang) }}\"></span>\n        <span>{{ 'LOCALE_' + lang | oTranslate }}</span>\n      </button>\n    </mat-menu>\n  ",
                    styles: ["\n    .o-language-selector .menu-button{margin-left:6px}.o-language-selector .menu-button.o-language-selector-text{padding:0;min-width:40px}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-language-selector]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OLanguageSelectorComponent.ctorParameters = function () { return [
        { type: core.Injector }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OLanguageSelectorComponent.prototype, "useFlagIcons", void 0);
    return OLanguageSelectorComponent;
}());
var OLanguageSelectorModule = /** @class */ (function () {
    function OLanguageSelectorModule() {
    }
    OLanguageSelectorModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OLanguageSelectorComponent],
                    imports: [OSharedModule, common.CommonModule],
                    exports: [OLanguageSelectorComponent]
                },] },
    ];
    return OLanguageSelectorModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_MENU_CARD = [
    'title',
    'image',
    'icon',
    'tooltip',
    'buttonText : button-text',
    'disabledButton : disabled-button',
    'mainContainerLayout : main-container-layout',
    'secondaryContainerLayout : secondary-container-layout',
    'route',
    'detailComponent : detail-component',
    'detailComponentInputs : detail-component-inputs',
    'action'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_MENU_CARD = [];
var OCardMenuItemComponent = /** @class */ (function () {
    function OCardMenuItemComponent(injector, router$$1, actRoute, resolver, cd, elRef) {
        var _this = this;
        this.injector = injector;
        this.router = router$$1;
        this.actRoute = actRoute;
        this.resolver = resolver;
        this.cd = cd;
        this.elRef = elRef;
        this.disabledButton = false;
        this.mainContainerLayout = 'column';
        this.secondaryContainerLayout = 'column';
        this._showSecondaryContainer = true;
        this.translateService = this.injector.get(OTranslateService$$1);
        this.translateServiceSubscription = this.translateService.onLanguageChanged.subscribe(function () {
            _this.cd.detectChanges();
        });
    }
    Object.defineProperty(OCardMenuItemComponent.prototype, "detailComponentContainer", {
        get: /**
         * @return {?}
         */
        function () {
            return this._detailComponentContainer;
        },
        set: /**
         * @param {?} content
         * @return {?}
         */
        function (content) {
            this._detailComponentContainer = content;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OCardMenuItemComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.detailComponentContainer && this.detailComponent) {
            /** @type {?} */
            var factory = this.resolver.resolveComponentFactory(this.detailComponent);
            /** @type {?} */
            var ref = this.detailComponentContainer.createComponent(factory);
            if (this.detailComponentInputs && ref.instance) {
                /** @type {?} */
                var keys = Object.keys(this.detailComponentInputs);
                for (var i = 0, len = keys.length; i < len; i++) {
                    ref.instance[keys[i]] = this.detailComponentInputs[keys[i]];
                }
            }
        }
        this.showSecondaryContainer = (this.detailComponentContainer && this.detailComponent) || this.secondaryContent.length > 0;
        this.cd.detectChanges();
    };
    /**
     * @return {?}
     */
    OCardMenuItemComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.translateServiceSubscription) {
            this.translateServiceSubscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OCardMenuItemComponent.prototype.useImage = /**
     * @return {?}
     */
    function () {
        return this.image !== undefined;
    };
    /**
     * @return {?}
     */
    OCardMenuItemComponent.prototype.useIcon = /**
     * @return {?}
     */
    function () {
        return this.icon !== undefined && this.image === undefined;
    };
    /**
     * @return {?}
     */
    OCardMenuItemComponent.prototype.onButtonClick = /**
     * @return {?}
     */
    function () {
        if (this.route) {
            this.router.navigate([this.route], {
                relativeTo: this.actRoute
            });
        }
        else if (this.action) {
            this.action();
        }
    };
    /**
     * @return {?}
     */
    OCardMenuItemComponent.prototype.onClick = /**
     * @return {?}
     */
    function () {
        if (this.buttonText === undefined) {
            this.onButtonClick();
        }
    };
    Object.defineProperty(OCardMenuItemComponent.prototype, "showSecondaryContainer", {
        get: /**
         * @return {?}
         */
        function () {
            return this._showSecondaryContainer;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._showSecondaryContainer = val;
            if (val) {
                this.elRef.nativeElement.classList.remove('compact');
            }
            else {
                this.elRef.nativeElement.classList.add('compact');
            }
        },
        enumerable: true,
        configurable: true
    });
    OCardMenuItemComponent.DEFAULT_INPUTS_O_MENU_CARD = DEFAULT_INPUTS_O_MENU_CARD;
    OCardMenuItemComponent.DEFAULT_OUTPUTS_O_MENU_CARD = DEFAULT_OUTPUTS_O_MENU_CARD;
    OCardMenuItemComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-card-menu-item',
                    template: "\n    <div class=\"o-card-menu-item-content\" (click)=\"onClick()\" fxLayout=\"column\" fxFill fxLayoutAlign=\"space-between center\"\n      layout-padding>\n\n      <div class=\"o-card-menu-item-main\" fxFlex=\"{{ showSecondaryContainer ? '40' : '80' }}\" [fxLayout]=\"mainContainerLayout\"\n        fxLayoutAlign=\"space-between center\">\n        <div *ngIf=\"useImage() || useIcon()\" fxFlex=\"80\" fxLayout=\"column\" fxLayoutAlign=\"center center\" class=\"o-card-menu-item-image-container\">\n          <img *ngIf=\"useImage()\" [src]=\"image\" />\n          <mat-icon *ngIf=\"useIcon()\" class=\"o-card-menu-item-icon\" fxLayoutAlign=\"center center\">{{ icon }}</mat-icon>\n        </div>\n\n        <div class=\"o-card-menu-item-title\" fxFlex=\"20\" fxLayout=\"column\" fxLayoutAlign=\"center center\" *ngIf=\"title !== undefined\">{{\n          title | oTranslate }}</div>\n\n        <mat-icon class=\"o-card-menu-item-info\" matTooltip=\"{{ tooltip | oTranslate }}\" *ngIf=\"tooltip\" svgIcon=\"ontimize:info_outline\"></mat-icon>\n\n        <ng-content select=\".main-container\"></ng-content>\n      </div>\n\n      <button type=\"button\" *ngIf=\"buttonText !== undefined\" [disabled]=\"disabledButton\" (click)=\"onButtonClick()\"\n        mat-button>{{ buttonText | oTranslate }}</button>\n\n      <div *ngIf=\"showSecondaryContainer\" class=\"o-card-menu-item-secondary\" fxFlex=\"50\" [fxLayout]=\"secondaryContainerLayout\"\n        fxLayoutAlign=\"space-around center\">\n        <ng-content select=\".secondary-container\"></ng-content>\n        <ng-container #menuCardContent *ngIf=\"detailComponent\">\n        </ng-container>\n      </div>\n    </div>\n  ",
                    styles: ["\n    .o-card-menu-item{border-radius:3px}.o-card-menu-item .o-card-menu-item-main,.o-card-menu-item .o-card-menu-item-secondary{width:100%;padding:12px 0}.o-card-menu-item .o-card-menu-item-image-container{width:100%}.o-card-menu-item .o-card-menu-item-image-container .o-card-menu-item-icon{width:100%;height:100%;font-size:5em}.o-card-menu-item .o-card-menu-item-image-container img{max-width:100%;max-height:100%}.o-card-menu-item .mat-button,.o-card-menu-item .o-card-menu-item-title{font-weight:600}.o-card-menu-item .mat-button{width:100%;border-radius:5px;text-decoration:none}.o-card-menu-item .o-card-menu-item-main{position:relative}.o-card-menu-item .o-card-menu-item-icon,.o-card-menu-item .o-card-menu-item-title{cursor:default}.o-card-menu-item .o-card-menu-item-info{cursor:default;position:absolute;top:0;right:0}\n  "],
                    inputs: DEFAULT_INPUTS_O_MENU_CARD,
                    outputs: DEFAULT_OUTPUTS_O_MENU_CARD,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-card-menu-item]': 'true',
                        '[class.mat-elevation-z1]': 'true',
                        '[class.compact]': '!showSecondaryContainer'
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    OCardMenuItemComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: router.Router },
        { type: router.ActivatedRoute },
        { type: core.ComponentFactoryResolver },
        { type: core.ChangeDetectorRef },
        { type: core.ElementRef }
    ]; };
    OCardMenuItemComponent.propDecorators = {
        detailComponentContainer: [{ type: core.ViewChild, args: ['menuCardContent', { read: core.ViewContainerRef },] }],
        secondaryContent: [{ type: core.ContentChildren, args: ['.secondary-container',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OCardMenuItemComponent.prototype, "disabledButton", void 0);
    return OCardMenuItemComponent;
}());
var OCardMenuItemModule = /** @class */ (function () {
    function OCardMenuItemModule() {
    }
    OCardMenuItemModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OCardMenuItemComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OCardMenuItemComponent]
                },] },
    ];
    return OCardMenuItemModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_GRID_ITEM = [
    'colspan',
    'rowspan'
];
var OGridItemComponent = /** @class */ (function () {
    function OGridItemComponent(_el, renderer, _grid) {
        this._el = _el;
        this.renderer = renderer;
        this._grid = _grid;
        this.mdClick = new core.EventEmitter();
        this.mdDoubleClick = new core.EventEmitter();
        this.colspan = 1;
        this.rowspan = 1;
    }
    /**
     * @return {?}
     */
    OGridItemComponent.prototype.onMouseEnter = /**
     * @return {?}
     */
    function () {
        if (this._grid.detailMode !== Codes.DETAIL_MODE_NONE) {
            this.renderer.setElementStyle(this._el.nativeElement, 'cursor', 'pointer');
        }
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OGridItemComponent.prototype.onItemClicked = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        ObservableWrapper.callEmit(this.mdClick, this);
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OGridItemComponent.prototype.onItemDoubleClicked = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        ObservableWrapper.callEmit(this.mdDoubleClick, this);
    };
    /**
     * @param {?} onNext
     * @return {?}
     */
    OGridItemComponent.prototype.onClick = /**
     * @param {?} onNext
     * @return {?}
     */
    function (onNext) {
        return ObservableWrapper.subscribe(this.mdClick, onNext);
    };
    /**
     * @param {?} onNext
     * @return {?}
     */
    OGridItemComponent.prototype.onDoubleClick = /**
     * @param {?} onNext
     * @return {?}
     */
    function (onNext) {
        return ObservableWrapper.subscribe(this.mdDoubleClick, onNext);
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OGridItemComponent.prototype.setItemData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (!this.modelData) {
            this.modelData = data;
        }
    };
    /**
     * @return {?}
     */
    OGridItemComponent.prototype.getItemData = /**
     * @return {?}
     */
    function () {
        return this.modelData;
    };
    OGridItemComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-grid-item',
                    template: "\n    <ng-template #templateref>\n      <ng-content></ng-content>\n    </ng-template>\n  ",
                    inputs: DEFAULT_INPUTS_O_GRID_ITEM,
                    host: {
                        '[class.o-grid-item]': 'true',
                        '(click)': 'onItemClicked($event)',
                        '(dblclick)': 'onItemDoubleClicked($event)'
                    },
                },] },
    ];
    /** @nocollapse */
    OGridItemComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer },
        { type: OGridComponent$$1, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OGridComponent$$1; }),] }] }
    ]; };
    OGridItemComponent.propDecorators = {
        template: [{ type: core.ViewChild, args: [core.TemplateRef,] }],
        onMouseEnter: [{ type: core.HostListener, args: ['mouseenter',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OGridItemComponent.prototype, "colspan", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OGridItemComponent.prototype, "rowspan", void 0);
    return OGridItemComponent;
}());
var OGridItemModule = /** @class */ (function () {
    function OGridItemModule() {
    }
    OGridItemModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OGridItemComponent],
                    imports: [common.CommonModule, OSharedModule],
                    exports: [OGridItemComponent]
                },] },
    ];
    return OGridItemModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OGridItemDirective = /** @class */ (function () {
    function OGridItemDirective(_el, renderer) {
        this._el = _el;
        this.renderer = renderer;
        this.mdClick = new core.EventEmitter();
        this.mdDoubleClick = new core.EventEmitter();
    }
    /**
     * @return {?}
     */
    OGridItemDirective.prototype.onMouseEnter = /**
     * @return {?}
     */
    function () {
        if (Util.isDefined(this.grid) && this.grid.detailMode !== Codes.DETAIL_MODE_NONE) {
            this.renderer.setElementStyle(this._el.nativeElement, 'cursor', 'pointer');
        }
    };
    /**
     * @param {?} onNext
     * @return {?}
     */
    OGridItemDirective.prototype.onClick = /**
     * @param {?} onNext
     * @return {?}
     */
    function (onNext) {
        return ObservableWrapper.subscribe(this.mdClick, onNext);
    };
    /**
     * @param {?} onNext
     * @return {?}
     */
    OGridItemDirective.prototype.onDoubleClick = /**
     * @param {?} onNext
     * @return {?}
     */
    function (onNext) {
        return ObservableWrapper.subscribe(this.mdDoubleClick, onNext);
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OGridItemDirective.prototype.onItemClicked = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        ObservableWrapper.callEmit(this.mdClick, this);
    };
    /**
     * @param {?=} e
     * @return {?}
     */
    OGridItemDirective.prototype.onItemDoubleClicked = /**
     * @param {?=} e
     * @return {?}
     */
    function (e) {
        ObservableWrapper.callEmit(this.mdDoubleClick, this);
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OGridItemDirective.prototype.setItemData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (!this.modelData) {
            this.modelData = data;
        }
    };
    /**
     * @return {?}
     */
    OGridItemDirective.prototype.getItemData = /**
     * @return {?}
     */
    function () {
        return this.modelData;
    };
    /**
     * @param {?} grid
     * @return {?}
     */
    OGridItemDirective.prototype.setGridComponent = /**
     * @param {?} grid
     * @return {?}
     */
    function (grid) {
        this.grid = grid;
    };
    OGridItemDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: 'mat-grid-tile[o-grid-item]',
                    host: {
                        '(click)': 'onItemClicked($event)',
                        '(dblclick)': 'onItemDoubleClicked($event)'
                    }
                },] },
    ];
    /** @nocollapse */
    OGridItemDirective.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer }
    ]; };
    OGridItemDirective.propDecorators = {
        onMouseEnter: [{ type: core.HostListener, args: ['mouseenter',] }]
    };
    return OGridItemDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_GRID$$1 = OServiceComponent$$1.DEFAULT_INPUTS_O_SERVICE_COMPONENT.concat([
    'cols',
    'pageSizeOptions: page-size-options',
    'showPageSize: show-page-size',
    'showSort: orderable',
    'sortableColumns: sortable-columns',
    'sortColumn: sort-column',
    'quickFilterColumns: quick-filter-columns',
    'gridItemHeight: grid-item-height',
    'refreshButton: refresh-button',
    'paginationControls: pagination-controls',
    'gutterSize:gutter-size',
    'fixedHeader:fixed-header',
    'showFooter:show-footer'
]);
/** @type {?} */
var DEFAULT_OUTPUTS_O_GRID$$1 = [
    'onClick',
    'onDoubleClick',
    'onDataLoaded',
    'onPaginatedDataLoaded'
];
/** @type {?} */
var PAGE_SIZE_OPTIONS = [8, 16, 24, 32, 64];
var 0$11 = dataServiceFactory;
var OGridComponent$$1 = /** @class */ (function (_super) {
    __extends(OGridComponent$$1, _super);
    function OGridComponent$$1(injector, elRef, form) {
        var _this = _super.call(this, injector, elRef, form) || this;
        /* Inputs */
        _this.queryRows = 32;
        _this.fixedHeader = false;
        _this.showPageSize = false;
        _this.showSort = false;
        _this.showFooter = true;
        _this.gridItemHeight = '1:1';
        _this.refreshButton = true;
        _this.paginationControls = false;
        _this.gutterSize = '1px';
        _this.onClick = new core.EventEmitter();
        _this.onDoubleClick = new core.EventEmitter();
        _this.onDataLoaded = new core.EventEmitter();
        _this.onPaginatedDataLoaded = new core.EventEmitter();
        /* Parsed Inputs */
        _this._sortableColumns = [];
        _this._colsDefault = 1;
        _this._pageSizeOptions = PAGE_SIZE_OPTIONS;
        _this.dataResponseArray = [];
        _this.storePaginationState = false;
        _this._currentPage = 0;
        _this.subscription = new Subscription();
        _this.media = _this.injector.get(flexLayout.ObservableMedia);
        return _this;
    }
    Object.defineProperty(OGridComponent$$1.prototype, "cols", {
        get: /**
         * @return {?}
         */
        function () {
            return this._cols || this._colsDefault;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._cols = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OGridComponent$$1.prototype, "pageSizeOptions", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pageSizeOptions;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (!(val instanceof Array)) {
                val = Util.parseArray(String(val)).map(function (a) { return parseInt(a); });
            }
            this._pageSizeOptions = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OGridComponent$$1.prototype, "sortableColumns", {
        get: /**
         * @return {?}
         */
        function () {
            return this._sortableColumns;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var parsed = [];
            if (!Util.isArray(val)) {
                parsed = ServiceUtils$$1.parseSortColumns(String(val));
            }
            this._sortableColumns = parsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OGridComponent$$1.prototype, "gridItems", {
        get: /**
         * @return {?}
         */
        function () {
            return this._gridItems;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._gridItems = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OGridComponent$$1.prototype, "currentPage", {
        get: /**
         * @return {?}
         */
        function () {
            return this._currentPage;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._currentPage = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.initialize();
    };
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.initialize = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.initialize.call(this);
        if (this.state.hasOwnProperty('sort-column')) {
            this.sortColumn = this.state['sort-column'];
        }
        this.parseSortColumn();
        /** @type {?} */
        var existingOption = this.pageSizeOptions.find(function (option) { return option === _this.queryRows; });
        if (!Util.isDefined(existingOption)) {
            this._pageSizeOptions.push(this.queryRows);
            this._pageSizeOptions.sort(function (i, j) { return i - j; });
        }
        if (!Util.isDefined(this.quickFilterColumns)) {
            this.quickFilterColumns = this.columns;
        }
        this.quickFilterColArray = Util.parseArray(this.quickFilterColumns, true);
        if (this.state.hasOwnProperty('currentPage')) {
            this.currentPage = this.state['currentPage'];
        }
        if (this.queryOnInit) {
            this.queryData();
        }
    };
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.gridItems = this.inputGridItems.toArray();
        this.subscription.add(this.inputGridItems.changes.subscribe(function (queryChanges) {
            _this.gridItems = queryChanges._results;
        }));
    };
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.afterViewInit.call(this);
        this.setGridItemDirectivesData();
        if (this.searchInputComponent) {
            this.registerQuickFilter(this.searchInputComponent);
        }
    };
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subscription.add(this.media.subscribe(function (change) {
            switch (change.mqAlias) {
                case 'xs':
                case 'sm':
                    _this._colsDefault = 1;
                    break;
                case 'md':
                    _this._colsDefault = 2;
                    break;
                case 'lg':
                case 'xl':
                    _this._colsDefault = 4;
            }
        }));
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    OGridComponent$$1.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
    };
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.reloadData = /**
     * @return {?}
     */
    function () {
        if (!this.pageable) {
            this.filterData();
        }
        else {
            /** @type {?} */
            var queryArgs = {};
            queryArgs = {
                offset: this.paginationControls ? (this.currentPage * this.queryRows) : 0,
                length: Math.max(this.queryRows, this.dataResponseArray.length),
                replace: true
            };
            this.queryData(void 0, queryArgs);
        }
    };
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.reloadPaginatedDataFromStart = /**
     * @return {?}
     */
    function () {
        this.currentPage = 0;
        this.dataResponseArray = [];
        this.reloadData();
    };
    /**
     * @param {?} data
     * @return {?}
     */
    OGridComponent$$1.prototype.setDataArray = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (Util.isArray(data)) {
            this.dataResponseArray = data;
        }
        else if (Util.isObject(data)) {
            this.dataResponseArray = [data];
        }
        else {
            console.warn('Component has received not supported service data. Supported data are Array or Object');
            this.dataResponseArray = [];
        }
        this.filterData();
    };
    /**
     * Filters data locally
     * @param {?=} value the filtering value
     * @param {?=} loadMore
     * @return {?}
     */
    OGridComponent$$1.prototype.filterData = /**
     * Filters data locally
     * @param {?=} value the filtering value
     * @param {?=} loadMore
     * @return {?}
     */
    function (value, loadMore) {
        value = Util.isDefined(value) ? value : Util.isDefined(this.quickFilterComponent) ? this.quickFilterComponent.getValue() : void 0;
        if (this.state && Util.isDefined(value)) {
            this.state.filterValue = value;
        }
        if (this.pageable) {
            /** @type {?} */
            var queryArgs = {
                offset: 0,
                length: this.queryRows,
                replace: true
            };
            this.queryData(void 0, queryArgs);
            return;
        }
        if (this.dataResponseArray && this.dataResponseArray.length > 0) {
            /** @type {?} */
            var filteredData = this.dataResponseArray.slice(0);
            if (value && value.length > 0) {
                /** @type {?} */
                var caseSensitive_1 = this.isFilterCaseSensitive();
                /** @type {?} */
                var self_1 = this;
                filteredData = filteredData.filter(function (item) {
                    return self_1.getQuickFilterColumns().some(function (col) {
                        /** @type {?} */
                        var regExpStr = Util.escapeSpecialCharacter(Util.normalizeString(value, !caseSensitive_1));
                        return new RegExp(regExpStr).test(Util.normalizeString(item[col] + '', !caseSensitive_1));
                    });
                });
            }
            if (Util.isDefined(this.sortColumnOrder)) {
                /** @type {?} */
                var sort_1 = this.sortColumnOrder;
                /** @type {?} */
                var factor_1 = (sort_1.ascendent ? 1 : -1);
                // filteredData = filteredData.sort((a, b) => (Util.normalizeString(a[sort.columnName]) > Util.normalizeString(b[sort.columnName])) ? (1 * factor) : (Util.normalizeString(b[sort.columnName]) > Util.normalizeString(a[sort.columnName])) ? (-1 * factor) : 0);
                filteredData.sort(function (a, b) {
                    /** @type {?} */
                    var aOp = isNaN(a[sort_1.columnName]) ? Util.normalizeString(a[sort_1.columnName]) : a[sort_1.columnName];
                    /** @type {?} */
                    var bOp = isNaN(b[sort_1.columnName]) ? Util.normalizeString(b[sort_1.columnName]) : b[sort_1.columnName];
                    return (aOp > bOp) ? (1 * factor_1) : (bOp > aOp) ? (-1 * factor_1) : 0;
                });
            }
            if (this.paginationControls) {
                this.dataArray = filteredData.splice(this.currentPage * this.queryRows, this.queryRows);
            }
            else {
                this.dataArray = filteredData.splice(0, this.queryRows * (this.currentPage + 1));
            }
        }
        else {
            this.dataArray = this.dataResponseArray;
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OGridComponent$$1.prototype.registerGridItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item) {
            /** @type {?} */
            var self_2 = this;
            if (self_2.detailMode === Codes.DETAIL_MODE_CLICK) {
                item.onClick(function (gridItem) { return self_2.onItemDetailClick(gridItem); });
            }
            if (Codes.isDoubleClickMode(self_2.detailMode)) {
                item.onDoubleClick(function (gridItem) { return self_2.onItemDetailDblClick(gridItem); });
            }
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OGridComponent$$1.prototype.onItemDetailClick = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this.oenabled && this.detailMode === Codes.DETAIL_MODE_CLICK) {
            this.saveDataNavigationInLocalStorage();
            this.viewDetail(item.getItemData());
            ObservableWrapper.callEmit(this.onClick, item);
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OGridComponent$$1.prototype.onItemDetailDblClick = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this.oenabled && Codes.isDoubleClickMode(this.detailMode)) {
            this.saveDataNavigationInLocalStorage();
            this.viewDetail(item.getItemData());
            ObservableWrapper.callEmit(this.onDoubleClick, item);
        }
    };
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy();
    };
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.destroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.destroy.call(this);
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.loadMore = /**
     * @return {?}
     */
    function () {
        this.currentPage += 1;
        if (this.pageable) {
            /** @type {?} */
            var queryArgs = {
                offset: this.state.queryRecordOffset,
                length: this.queryRows
            };
            this.queryData(void 0, queryArgs);
        }
        else {
            this.filterData(void 0, true);
        }
    };
    Object.defineProperty(OGridComponent$$1.prototype, "totalRecords", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.pageable) {
                return this.getTotalRecordsNumber();
            }
            return this.dataResponseArray.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} filter
     * @param {?=} ovrrArgs
     * @return {?}
     */
    OGridComponent$$1.prototype.getQueryArguments = /**
     * @param {?} filter
     * @param {?=} ovrrArgs
     * @return {?}
     */
    function (filter$$1, ovrrArgs) {
        /** @type {?} */
        var queryArguments = _super.prototype.getQueryArguments.call(this, filter$$1, ovrrArgs);
        // queryArguments[3] = this.getSqlTypesForFilter(queryArguments[1]);
        if (this.pageable && Util.isDefined(this.sortColumn)) {
            queryArguments[6] = this.sortColumnOrder ? [this.sortColumnOrder] : this.sortColumnOrder;
        }
        return queryArguments;
    };
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.parseSortColumn = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var parsed = (ServiceUtils$$1.parseSortColumns(this.sortColumn) || [])[0];
        /** @type {?} */
        var exists = parsed ? this.sortableColumns.find(function (item) { return (item.columnName === parsed.columnName) && (item.ascendent === parsed.ascendent); }) : false;
        if (exists) {
            this.sortColumnOrder = parsed;
        }
    };
    Object.defineProperty(OGridComponent$$1.prototype, "currentOrderColumn", {
        get: /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (!Util.isDefined(this.sortColumnOrder)) {
                return undefined;
            }
            /** @type {?} */
            var index;
            this.sortableColumns.forEach(function (item, i) {
                if ((item.columnName === _this.sortColumnOrder.columnName) &&
                    (item.ascendent === _this.sortColumnOrder.ascendent)) {
                    index = i;
                }
            });
            return index;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.sortColumnOrder = this.sortableColumns[val];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} e
     * @return {?}
     */
    OGridComponent$$1.prototype.onChangePage = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!this.pageable) {
            this.currentPage = e.pageIndex;
            this.queryRows = e.pageSize;
            this.filterData();
            return;
        }
        /** @type {?} */
        var tableState = this.state;
        /** @type {?} */
        var goingBack = e.pageIndex < this.currentPage;
        this.currentPage = e.pageIndex;
        /** @type {?} */
        var pageSize = e.pageSize;
        /** @type {?} */
        var oldQueryRows = this.queryRows;
        /** @type {?} */
        var changingPageSize = (oldQueryRows !== pageSize);
        this.queryRows = pageSize;
        /** @type {?} */
        var newStartRecord;
        /** @type {?} */
        var queryLength;
        if (goingBack || changingPageSize) {
            newStartRecord = (this.currentPage * this.queryRows);
            queryLength = this.queryRows;
        }
        else {
            newStartRecord = Math.max(tableState.queryRecordOffset, (this.currentPage * this.queryRows));
            /** @type {?} */
            var newEndRecord = Math.min(newStartRecord + this.queryRows, tableState.totalQueryRecordsNumber);
            queryLength = Math.min(this.queryRows, newEndRecord - newStartRecord);
        }
        /** @type {?} */
        var queryArgs = {
            offset: newStartRecord,
            length: queryLength
        };
        this.queryData(void 0, queryArgs);
    };
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.getDataToStore = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var dataToStore = _super.prototype.getDataToStore.call(this);
        dataToStore['currentPage'] = this.currentPage;
        if (this.storePaginationState) {
            dataToStore['queryRecordOffset'] = Math.max((this.state.queryRecordOffset - this.dataArray.length), (this.state.queryRecordOffset - this.queryRows));
        }
        else {
            delete dataToStore['queryRecordOffset'];
        }
        if (Util.isDefined(this.sortColumnOrder)) {
            dataToStore['sort-column'] = this.sortColumnOrder.columnName + Codes.COLUMNS_ALIAS_SEPARATOR +
                (this.sortColumnOrder.ascendent ? Codes.ASC_SORT : Codes.DESC_SORT);
        }
        return dataToStore;
    };
    /**
     * @param {?} col
     * @return {?}
     */
    OGridComponent$$1.prototype.getSortOptionText = /**
     * @param {?} col
     * @return {?}
     */
    function (col) {
        /** @type {?} */
        var result;
        /** @type {?} */
        var colTextKey = "GRID.SORT_BY_" + col.columnName.toUpperCase() + "_" + (col.ascendent ? 'ASC' : 'DESC');
        result = this.translateService.get(colTextKey);
        if (result !== colTextKey) {
            return result;
        }
        colTextKey = 'GRID.SORT_BY_' + (col.ascendent ? 'ASC' : 'DESC');
        result = this.translateService.get(colTextKey, [(this.translateService.get(col.columnName) || '')]);
        return result;
    };
    /**
     * @param {?} data
     * @param {?=} sqlTypes
     * @param {?=} replace
     * @return {?}
     */
    OGridComponent$$1.prototype.setData = /**
     * @param {?} data
     * @param {?=} sqlTypes
     * @param {?=} replace
     * @return {?}
     */
    function (data, sqlTypes, replace) {
        if (Util.isArray(data)) {
            /** @type {?} */
            var dataArray = data;
            /** @type {?} */
            var respDataArray = data;
            if (!replace) {
                if (this.pageable) {
                    dataArray = this.paginationControls ? data : (this.dataArray || []).concat(data);
                    respDataArray = this.paginationControls ? data : (this.dataResponseArray || []).concat(data);
                }
                else {
                    dataArray = data.slice(this.paginationControls ? ((this.queryRows * (this.currentPage + 1)) - this.queryRows) : 0, this.queryRows * (this.currentPage + 1));
                    respDataArray = data;
                }
            }
            this.dataArray = dataArray;
            this.dataResponseArray = respDataArray;
            if (!this.pageable) {
                this.filterData();
            }
        }
        else {
            this.dataArray = [];
            this.dataResponseArray = [];
        }
        if (this.loaderSubscription) {
            this.loaderSubscription.unsubscribe();
        }
        if (this.pageable) {
            ObservableWrapper.callEmit(this.onPaginatedDataLoaded, data);
        }
        ObservableWrapper.callEmit(this.onDataLoaded, this.dataResponseArray);
    };
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.saveDataNavigationInLocalStorage = /**
     * @return {?}
     */
    function () {
        _super.prototype.saveDataNavigationInLocalStorage.call(this);
        this.storePaginationState = true;
    };
    /**
     * @return {?}
     */
    OGridComponent$$1.prototype.setGridItemDirectivesData = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var self = this;
        this.gridItemDirectives.changes.subscribe(function () {
            _this.gridItemDirectives.toArray().forEach(function (element, index) {
                element.setItemData(self.dataArray[index]);
                element.setGridComponent(self);
                self.registerGridItem(element);
            });
        });
    };
    OGridComponent$$1.DEFAULT_INPUTS_O_GRID = DEFAULT_INPUTS_O_GRID$$1;
    OGridComponent$$1.DEFAULT_OUTPUTS_O_GRID = DEFAULT_OUTPUTS_O_GRID$$1;
    OGridComponent$$1.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-grid',
                    providers: [
                        { provide: OntimizeService$$1, useFactory: 0$11, deps: [core.Injector] }
                    ],
                    inputs: DEFAULT_INPUTS_O_GRID$$1,
                    outputs: DEFAULT_OUTPUTS_O_GRID$$1,
                    template: "\n    <div [style.display]=\"isVisible()? '' : 'none'\" class=\"o-grid-container\" fxLayout=\"column\" fxLayoutAlign=\"start stretch\">\n      <!--TOOLBAR-->\n      <mat-toolbar *ngIf=\"hasControls()\" class=\"o-grid-toolbar\">\n        <div class=\"mat-toolbar-tools\" fxLayout=\"row\" fxLayoutAlign=\"start center\" fxLayoutGap=\"8px\" fxFill>\n          <!--button refresh-->\n          <button type=\"button\" mat-icon-button aria-label=\"Refresh\" (click)=\"reloadData()\" *ngIf=\"refreshButton\">\n            <mat-icon svgIcon=\"ontimize:autorenew\"></mat-icon>\n          </button>\n\n          <!--O-GRID-PAGINATOR-->\n          <div class=\"o-grid-paginator\" *ngIf=\"showPageSize\">\n            <div class=\"o-grid-page-size-label\">{{ 'GRID.ITEMS_PER_PAGE' | oTranslate }}:</div>\n            <mat-form-field class=\"o-grid-select-page\" floatLabel=\"never\">\n              <mat-select placeholder=\"\" #pageSizeSelect [(value)]=\"queryRows\" (selectionChange)=\"reloadData()\">\n                <mat-option *ngFor=\"let page of pageSizeOptions\" [value]=\"page\">\n                  {{ page }}\n                </mat-option>\n              </mat-select>\n            </mat-form-field>\n          </div>\n\n          <!--O-GRID-SORT-->\n          <div class=\"o-grid-sort\" *ngIf=\"showSort && sortableColumns.length > 0\">\n            <mat-form-field class=\"o-grid-select-sort\" floatLabel=\"never\">\n              <mat-icon matPrefix>sort</mat-icon>\n              <mat-select #sortSelect [(value)]=\"currentOrderColumn\" (selectionChange)=\"reloadData()\" placeholder=\" {{ 'GRID.SORT_BY' | oTranslate }}\">\n                <mat-option *ngFor=\"let column of sortableColumns; let i = index\" [value]=\"i\">\n                  {{ getSortOptionText(column) }}\n                </mat-option>\n              </mat-select>\n            </mat-form-field>\n          </div>\n\n          <div fxLayoutAlign=\"center center\" fxFlex>\n            <span *ngIf=\"hasTitle()\" fxLayoutAlign=\"center center\">{{ title | oTranslate }}</span>\n          </div>\n          <o-search-input *ngIf=\"quickFilter\" [columns]=\"quickFilterColumns\" [filter-case-sensitive]=\"filterCaseSensitive\" \n            [show-case-sensitive-checkbox]=\"showCaseSensitiveCheckbox()\" placeholder=\"\" ></o-search-input>\n        </div>\n      </mat-toolbar>\n\n      <!--not results-->\n      <div class=\"o-grid-no-results fill-remaining\" *ngIf=\"gridItems.length === 0\" fxLayoutAlign=\"center start\" layout-padding>\n        {{'GRID.EMPTY' | oTranslate}}\n        <ng-container *ngIf=\"quickFilter && searchInputComponent && searchInputComponent.getValue() && searchInputComponent.getValue().length > 0\">\n          {{ 'GRID.EMPTY_USING_FILTER' | oTranslate : { values: [ searchInputComponent.getValue()] } }}\n        </ng-container>\n      </div>\n\n      <!--MAT-GRID-LIST-->\n      <mat-grid-list [cols]=\"cols\" [gutterSize]=\"gutterSize\" [rowHeight]=\"gridItemHeight\" class=\"o-mat-grid-list fill-remaining\"\n        *ngIf=\"gridItems.length > 0\">\n        <mat-grid-tile o-grid-item *ngFor=\"let item of gridItems\" [colspan]=\"item.colspan\" [rowspan]=\"item.rowspan\">\n          <ng-container *ngTemplateOutlet=\"item.template\"></ng-container>\n        </mat-grid-tile>\n      </mat-grid-list>\n\n      <!-- GRID FOOTER -->\n      <div *ngIf=\"!paginationControls && showFooter\" fxLayout=\"row\" fxLayoutAlign=\"center center\" class=\"o-grid-footer\">\n        <button type=\"button\" mat-button *ngIf=\"dataArray.length < totalRecords\" (click)=\"loadMore()\" class=\"mat-raised-button\">\n          {{ 'GRID.BUTTON_NEXT' | oTranslate }}\n        </button>\n        <span fxFlex></span>\n        <span class=\"o-grid-totals\">{{ 'GRID.TEXT_SHOWN_ITEMS' | oTranslate :{values: [dataArray.length, totalRecords]} }}</span>\n      </div>\n\n      <mat-paginator class=\"o-mat-paginator\" #paginator *ngIf=\"paginationControls && showFooter\" [length]=\"totalRecords\" [pageSize]=\"queryRows\"\n        [pageSizeOptions]=\"pageSizeOptions\" [pageIndex]=\"currentPage\" [showFirstLastButtons]=\"true\" (page)=\"onChangePage($event)\"></mat-paginator>\n\n      <div *ngIf=\"loading | async\" fxLayout=\"row\" fxLayoutAlign=\"center end\" class=\"o-loading-blocker\">\n        <div fxLayoutAlign=\"center center\" [class.o-spinner-container-controls]=\"hasControls()\" class=\"o-spinner-container\">\n          <mat-progress-spinner mode=\"indeterminate\" strokeWidth=\"3\"></mat-progress-spinner>\n        </div>\n      </div>\n\n    </div>\n  ",
                    styles: ["\n    :host.o-grid{height:100%}:host.o-grid .o-grid-container{position:relative;height:100%;display:flex}:host.o-grid .o-grid-container .o-grid-toolbar{flex:0 0 auto}:host.o-grid .o-grid-container .o-grid-no-results{padding:16px}:host.o-grid .o-grid-container .o-grid-paginator,:host.o-grid .o-grid-container .o-grid-sort{font-size:.8em;margin-right:1em}:host.o-grid .o-grid-container .o-grid-paginator{display:flex}:host.o-grid .o-grid-container .o-grid-paginator .o-grid-select-page{width:60px}:host.o-grid .o-grid-container .o-grid-paginator .o-grid-page-size-label{margin:0 4px 0 8px;align-self:center}:host.o-grid .o-grid-container .o-grid-footer .o-grid-totals{margin-right:8px;font-size:14px}:host.o-grid .o-grid-container .o-grid-footer,:host.o-grid .o-grid-container .o-mat-paginator{flex-shrink:0}:host.o-grid .o-grid-container .o-loading-blocker{position:absolute;top:0;left:0;right:0;bottom:0;z-index:500;visibility:visible;opacity:1;-moz-transition:opacity .25s linear;-webkit-transition:opacity .25s linear;transition:opacity .25s linear}:host.o-grid .o-grid-container .o-loading-blocker .o-spinner-container{width:100%;height:100%}:host.o-grid .o-grid-container .o-loading-blocker .o-spinner-container.o-spinner-container-controls{height:calc(100% - 64px)}:host.o-grid.o-grid-fixed{max-height:100%;height:100%}:host.o-grid.o-grid-fixed .o-grid-container{max-height:100%;height:100%}:host.o-grid.o-grid-fixed .o-mat-grid-list{overflow:auto;padding-bottom:0 !important}:host.o-grid.o-grid-fixed .o-grid-footer,:host.o-grid.o-grid-fixed .o-mat-paginator{flex:0 0 auto}\n  "],
                    host: {
                        '[class.o-grid]': 'true',
                        '[class.o-grid-fixed]': 'fixedHeader',
                    }
                },] },
    ];
    /** @nocollapse */
    OGridComponent$$1.ctorParameters = function () { return [
        { type: core.Injector },
        { type: core.ElementRef },
        { type: OFormComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OFormComponent; }),] }] }
    ]; };
    OGridComponent$$1.propDecorators = {
        inputGridItems: [{ type: core.ContentChildren, args: [OGridItemComponent,] }],
        gridItemDirectives: [{ type: core.ViewChildren, args: [OGridItemDirective,] }],
        matpaginator: [{ type: core.ViewChild, args: [material.MatPaginator,] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Number)
    ], OGridComponent$$1.prototype, "queryRows", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OGridComponent$$1.prototype, "fixedHeader", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OGridComponent$$1.prototype, "showPageSize", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OGridComponent$$1.prototype, "showSort", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OGridComponent$$1.prototype, "showFooter", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OGridComponent$$1.prototype, "refreshButton", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OGridComponent$$1.prototype, "paginationControls", void 0);
    return OGridComponent$$1;
}(OServiceComponent$$1));
var OGridModule$$1 = /** @class */ (function () {
    function OGridModule$$1() {
    }
    OGridModule$$1.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OGridComponent$$1, OGridItemDirective],
                    imports: [common.CommonModule, OGridItemModule, OSearchInputModule, OSharedModule, router.RouterModule],
                    exports: [OGridComponent$$1, OGridItemComponent, OGridItemDirective],
                    entryComponents: [OGridItemComponent]
                },] },
    ];
    return OGridModule$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_APP_HEADER = [
    'showUserInfo: show-user-info',
    'showLanguageSelector: show-language-selector',
    'useFlagIcons: use-flag-icons'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_APP_HEADER = [
    'onSidenavToggle'
];
var OAppHeaderComponent = /** @class */ (function () {
    function OAppHeaderComponent(router$$1, injector, elRef) {
        var _this = this;
        this.router = router$$1;
        this.injector = injector;
        this.elRef = elRef;
        this._headerTitle = '';
        this.showUserInfo = true;
        this.showLanguageSelector = true;
        this.useFlagIcons = false;
        this.onSidenavToggle = new core.EventEmitter();
        this.dialogService = this.injector.get(DialogService);
        this.modulesInfoService = this.injector.get(OModulesInfoService$$1);
        this.modulesInfoSubscription = this.modulesInfoService.getModuleChangeObservable().subscribe(function (res) {
            _this.headerTitle = res.name;
        });
    }
    /**
     * @return {?}
     */
    OAppHeaderComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.modulesInfoSubscription.unsubscribe();
    };
    /**
     * @return {?}
     */
    OAppHeaderComponent.prototype.onLogoutClick = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.dialogService.confirm('CONFIRM', 'MESSAGES.CONFIRM_LOGOUT').then(function (res) {
            if (res) {
                ServiceUtils$$1.redirectLogin(_this.router, false);
            }
        });
    };
    Object.defineProperty(OAppHeaderComponent.prototype, "headerTitle", {
        get: /**
         * @return {?}
         */
        function () {
            return this._headerTitle;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._headerTitle = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OAppHeaderComponent.prototype, "showHeaderTitle", {
        get: /**
         * @return {?}
         */
        function () {
            return this._headerTitle.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    OAppHeaderComponent.DEFAULT_INPUTS_O_APP_HEADER = DEFAULT_INPUTS_O_APP_HEADER;
    OAppHeaderComponent.DEFAULT_OUTPUTS_O_APP_HEADER = DEFAULT_OUTPUTS_O_APP_HEADER;
    OAppHeaderComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-app-header',
                    inputs: DEFAULT_INPUTS_O_APP_HEADER,
                    outputs: DEFAULT_OUTPUTS_O_APP_HEADER,
                    template: "\n    <nav fxFlex fxLayout=\"row\" fxLayoutAlign=\"space-between stretch\">\n      <mat-icon class=\"sidenav-toggle\" (click)=\"onSidenavToggle.emit()\" svgIcon=\"ontimize:menu\"></mat-icon>\n      <div fxFlex fxLayout=\"row\" fxLayoutAlign=\"space-between stretch\">\n        <ng-content></ng-content>\n        <span *ngIf=\"showHeaderTitle\" class=\"o-app-header-title\" fxLayout=\"row\" fxLayoutAlign=\"center center\">\n          {{ headerTitle | oTranslate }}\n        </span>\n        <div fxLayout=\"row\" fxLayoutAlign=\"end stretch\" class=\"o-app-header-default-actions\"> \n          <o-user-info *ngIf=\"showUserInfo\"></o-user-info>\n          <o-language-selector *ngIf=\"showLanguageSelector\" [use-flag-icons]=\"useFlagIcons\"></o-language-selector>\n        </div>\n      </div>\n    </nav>\n  ",
                    styles: ["\n    .o-app-header{z-index:2;box-shadow:0 2px 6px rgba(0,0,0,0.24);height:56px}.o-app-header nav{padding-right:16px}.o-app-header nav .sidenav-toggle{text-align:center;padding:16px;cursor:pointer}.o-app-header nav .o-app-header-title{padding:0 16px;cursor:default}.o-app-header nav .o-app-header-default-actions{margin-left:auto}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-app-header]': 'true'
                    }
                },] },
    ];
    /** @nocollapse */
    OAppHeaderComponent.ctorParameters = function () { return [
        { type: router.Router },
        { type: core.Injector },
        { type: core.ElementRef }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OAppHeaderComponent.prototype, "showUserInfo", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OAppHeaderComponent.prototype, "showLanguageSelector", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OAppHeaderComponent.prototype, "useFlagIcons", void 0);
    return OAppHeaderComponent;
}());
var OAppHeaderModule = /** @class */ (function () {
    function OAppHeaderModule() {
    }
    OAppHeaderModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule, OLanguageSelectorModule, OUserInfoModule, OSharedModule],
                    declarations: [OAppHeaderComponent],
                    exports: [OAppHeaderComponent]
                },] },
    ];
    return OAppHeaderModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_APP_SIDENAV_IMAGE = [
    'openedSrc: opened-src',
    'closedSrc: closed-src'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_APP_SIDENAV_IMAGE = [];
var OAppSidenavImageComponent = /** @class */ (function () {
    function OAppSidenavImageComponent(injector, cd) {
        this.injector = injector;
        this.cd = cd;
        this.sidenav = this.injector.get(OAppSidenavComponent);
    }
    /**
     * @return {?}
     */
    OAppSidenavImageComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.sidenav) {
            /** @type {?} */
            var self_1 = this;
            this.sidenavOpenSubs = this.sidenav.sidenav.openedStart.subscribe(function (opened) {
                self_1.updateImage();
            });
            this.sidenavCloseSubs = this.sidenav.sidenav.closedStart.subscribe(function (opened) {
                self_1.updateImage();
            });
        }
        this.updateImage();
    };
    /**
     * @return {?}
     */
    OAppSidenavImageComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.sidenavOpenSubs) {
            this.sidenavOpenSubs.unsubscribe();
        }
        if (this.sidenavCloseSubs) {
            this.sidenavCloseSubs.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OAppSidenavImageComponent.prototype.updateImage = /**
     * @return {?}
     */
    function () {
        if (this.sidenav && this.sidenav.sidenav.opened) {
            this.setOpenedImg();
        }
        else {
            this.setClosedImg();
        }
        this.cd.detectChanges();
    };
    Object.defineProperty(OAppSidenavImageComponent.prototype, "src", {
        get: /**
         * @return {?}
         */
        function () {
            return this._src;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._src = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OAppSidenavImageComponent.prototype.setOpenedImg = /**
     * @return {?}
     */
    function () {
        this.src = this.openedSrc;
    };
    /**
     * @return {?}
     */
    OAppSidenavImageComponent.prototype.setClosedImg = /**
     * @return {?}
     */
    function () {
        this.src = this.closedSrc;
    };
    Object.defineProperty(OAppSidenavImageComponent.prototype, "showImage", {
        get: /**
         * @return {?}
         */
        function () {
            return (this._src !== undefined && this._src.length > 0);
        },
        enumerable: true,
        configurable: true
    });
    OAppSidenavImageComponent.DEFAULT_INPUTS_O_APP_SIDENAV_IMAGE = DEFAULT_INPUTS_O_APP_SIDENAV_IMAGE;
    OAppSidenavImageComponent.DEFAULT_OUTPUTS_O_APP_SIDENAV_IMAGE = DEFAULT_OUTPUTS_O_APP_SIDENAV_IMAGE;
    OAppSidenavImageComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-app-sidenav-image',
                    inputs: DEFAULT_INPUTS_O_APP_SIDENAV_IMAGE,
                    outputs: DEFAULT_OUTPUTS_O_APP_SIDENAV_IMAGE,
                    template: "\n    <div class=\"o-app-sidenav-image-container\" *ngIf=\"showImage\">\n      <img class=\"o-app-sidenav-image\" [src]=\"src\" />\n    </div>\n  ",
                    styles: ["\n    .sidenav-toggle-container+.o-app-sidenav-image .o-app-sidenav-image-container{padding-top:0;text-align:center}.mat-drawer-opened .o-app-sidenav-image .o-app-sidenav-image-container{text-align:center}.o-app-sidenav-image .o-app-sidenav-image-container{max-height:75px;padding:8px 16px 16px}.o-app-sidenav-image .o-app-sidenav-image-container .o-app-sidenav-image{max-width:100%;max-height:100%}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-app-sidenav-image]': 'true'
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    OAppSidenavImageComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: core.ChangeDetectorRef }
    ]; };
    return OAppSidenavImageComponent;
}());
var OAppSidenavImageModule = /** @class */ (function () {
    function OAppSidenavImageModule() {
    }
    OAppSidenavImageModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule, OSharedModule],
                    declarations: [OAppSidenavImageComponent],
                    exports: [OAppSidenavImageComponent]
                },] },
    ];
    return OAppSidenavImageModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_APP_SIDENAV_MENU_ITEM = [
    'menuItem : menu-item',
    'menuItemType : menu-item-type',
    'sidenavOpened : sidenav-opened',
    'disabled'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_APP_SIDENAV_MENU_ITEM = [
    'onClick'
];
var OAppSidenavMenuItemComponent = /** @class */ (function () {
    function OAppSidenavMenuItemComponent(injector, elRef, cd) {
        var _this = this;
        this.injector = injector;
        this.elRef = elRef;
        this.cd = cd;
        this.onClick = new core.EventEmitter();
        this.sidenavOpened = true;
        this.disabled = false;
        this.translateService = this.injector.get(OTranslateService$$1);
        this.loginService = this.injector.get(LoginService$$1);
        this.dialogService = this.injector.get(DialogService);
        this.permissionsService = this.injector.get(PermissionsService);
        this.oUserInfoService = this.injector.get(OUserInfoService);
        this.sidenav = this.injector.get(OAppSidenavComponent);
        this.oAppLayoutComponent = this.injector.get(OAppLayoutComponent);
        this.router = this.injector.get(router.Router);
        this.routerSubscription = this.router.events.subscribe(function () {
            _this.cd.detectChanges();
        });
    }
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.parsePermissions();
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isUserInfoItem()) {
            this.setUserInfoImage();
            this.appSidenavToggleSubscription = this.sidenav.sidenav.openedChange.subscribe(function (opened) {
                if (opened) {
                    _this.setUserInfoImage();
                }
            });
            this.userInfoSubscription = this.oUserInfoService.getUserInfoObservable().subscribe(function (res) {
                if (Util.isDefined(res.avatar) && _this.sidenav.sidenav.opened) {
                    (/** @type {?} */ (_this.menuItem)).avatar = res.avatar;
                    _this.setUserInfoImage();
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.appSidenavToggleSubscription) {
            this.appSidenavToggleSubscription.unsubscribe();
        }
        if (this.routerSubscription) {
            this.routerSubscription.unsubscribe();
        }
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
        }
        if (this.userInfoSubscription) {
            this.userInfoSubscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.parsePermissions = /**
     * @return {?}
     */
    function () {
        // if oattr in form, it can have permissions
        this.permissions = this.permissionsService.getMenuPermissions(this.menuItem.id);
        if (!Util.isDefined(this.permissions)) {
            return;
        }
        this.hidden = this.permissions.visible === false;
        if (!this.disabled) {
            // if the disabled input is true it means that its parent is disabled using permissions
            this.disabled = this.permissions.enabled === false;
        }
        if (this.disabled) {
            this.mutationObserver = PermissionsUtils.registerDisabledChangesInDom(this.elRef.nativeElement, {
                checkStringValue: true
            });
        }
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.setUserInfoImage = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var imgEl = this.elRef.nativeElement.getElementsByClassName('o-user-info-image')[0];
        if (imgEl !== undefined) {
            /** @type {?} */
            var item = /** @type {?} */ (this.menuItem);
            imgEl.setAttribute('style', 'background-image: url(\'' + item.avatar + '\')');
        }
        this.cd.detectChanges();
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.executeItemAction = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var actionItem = (/** @type {?} */ (this.menuItem));
        if (Util.parseBoolean(actionItem.confirm, false)) {
            this.dialogService.confirm('CONFIRM', actionItem.confirmText || 'MESSAGES.CONFIRM_ACTION').then(function (result) { return result ? actionItem.action() : null; });
        }
        else {
            actionItem.action();
        }
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.configureI18n = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var localeItem = (/** @type {?} */ (this.menuItem));
        if (this.isConfiguredLang()) {
            return;
        }
        if (this.translateService) {
            this.translateService.use(localeItem.locale);
        }
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.isConfiguredLang = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var localeItem = (/** @type {?} */ (this.menuItem));
        if (this.translateService) {
            return (this.translateService.getCurrentLang() === localeItem.locale);
        }
        return false;
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.logout = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var menuItem = (/** @type {?} */ (this.menuItem));
        if (Util.parseBoolean(menuItem.confirm, true)) {
            this.loginService.logoutWithConfirmationAndRedirect();
        }
        else {
            this.loginService.logoutAndRedirect();
        }
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.navigate = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var route = (/** @type {?} */ (this.menuItem)).route;
        if (this.router.url !== route) {
            this.router.navigate([route]);
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.triggerClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (this.disabled) {
            return;
        }
        switch (this.menuItemType) {
            case 'action':
                this.executeItemAction();
                break;
            case 'locale':
                this.configureI18n();
                break;
            case 'logout':
                this.logout();
                break;
            case 'route':
                this.navigate();
                break;
            default:
                break;
        }
        this.onClick.emit(e);
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.isRouteItem = /**
     * @return {?}
     */
    function () {
        return this.menuItemType === 'route';
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.isActionItem = /**
     * @return {?}
     */
    function () {
        return this.menuItemType === 'action';
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.isLocaleItem = /**
     * @return {?}
     */
    function () {
        return this.menuItemType === 'locale';
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.isLogoutItem = /**
     * @return {?}
     */
    function () {
        return this.menuItemType === 'logout';
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.isUserInfoItem = /**
     * @return {?}
     */
    function () {
        return this.menuItemType === 'user-info';
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.isDefaultItem = /**
     * @return {?}
     */
    function () {
        return this.menuItemType === 'default';
    };
    Object.defineProperty(OAppSidenavMenuItemComponent.prototype, "useFlagIcons", {
        get: /**
         * @return {?}
         */
        function () {
            return this.oAppLayoutComponent && this.oAppLayoutComponent.useFlagIcons;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.isActiveItem = /**
     * @return {?}
     */
    function () {
        if (!this.isRouteItem()) {
            return false;
        }
        /** @type {?} */
        var route = (/** @type {?} */ (this.menuItem)).route;
        return this.router.url === route || this.router.url.startsWith(route + '/');
    };
    Object.defineProperty(OAppSidenavMenuItemComponent.prototype, "tooltip", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var result = this.translateService.get(this.menuItem.name);
            if (Util.isDefined(this.menuItem.tooltip)) {
                result += ': ' + this.translateService.get(this.menuItem.tooltip);
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OAppSidenavMenuItemComponent.prototype.getClass = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var className = 'o-app-sidenav-menu-item';
        if (this.menuItem.class) {
            className += ' ' + this.menuItem.class;
        }
        return className;
    };
    OAppSidenavMenuItemComponent.DEFAULT_INPUTS_O_APP_SIDENAV_MENU_ITEM = DEFAULT_INPUTS_O_APP_SIDENAV_MENU_ITEM;
    OAppSidenavMenuItemComponent.DEFAULT_OUTPUTS_O_APP_SIDENAV_MENU_ITEM = DEFAULT_OUTPUTS_O_APP_SIDENAV_MENU_ITEM;
    OAppSidenavMenuItemComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-app-sidenav-menu-item',
                    inputs: DEFAULT_INPUTS_O_APP_SIDENAV_MENU_ITEM,
                    outputs: DEFAULT_OUTPUTS_O_APP_SIDENAV_MENU_ITEM,
                    template: "\n    <ng-container *ngIf=\"sidenavOpened\">\n      <li *ngIf=\"!hidden\" class=\"o-app-sidenav-menuitem o-app-sidenav-item\" [class.o-user-info]=\"isUserInfoItem()\">\n\n        <a mat-button *ngIf=\"!isUserInfoItem() && !isLocaleItem()\" (click)=\"triggerClick($event)\"\n          [class.o-app-sidenav-viewer-sidenav-item-selected]=\"isActiveItem()\">\n          <div fxLayout=\"row\" fxLayoutAlign=\"start center\">\n            <mat-icon *ngIf=\"menuItem.icon\">{{ menuItem.icon }}</mat-icon>\n            {{ menuItem.name | oTranslate }}\n          </div>\n        </a>\n\n        <a mat-button *ngIf=\"isLocaleItem()\" (click)=\"triggerClick($event)\">\n          <div fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n            <mat-icon *ngIf=\"menuItem.icon\">{{ menuItem.icon }}</mat-icon>\n            {{ menuItem.name | oTranslate }}\n            <mat-icon *ngIf=\"isConfiguredLang()\" class=\"configured-lang\">check_circle</mat-icon>\n          </div>\n        </a>\n\n        <div *ngIf=\"isUserInfoItem()\" fxLayout=\"column\" fxLayoutAlign=\"center center\" class=\"o-user-info-menu-item\">\n          <div class=\"o-user-info-image\" fxFlexFill></div>\n          <div class=\"o-user-info-item\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\" fxFlexFill>\n            <div class=\"o-user-info-name\">{{ menuItem.user }} </div>\n            <o-language-selector [use-flag-icons]=\"useFlagIcons\"></o-language-selector>\n          </div>\n        </div>\n      </li>\n    </ng-container>\n\n    <ng-container *ngIf=\"!sidenavOpened\">\n      <li *ngIf=\"!hidden\" class=\"o-app-sidenav-menuitem o-app-sidenav-item\">\n        <a [matTooltip]=\"tooltip\" matTooltipClass=\"menuitem-tooltip\" matTooltipPosition=\"right\" mat-button (click)=\"triggerClick($event)\"\n          [class.o-app-sidenav-viewer-sidenav-item-selected]=\"isActiveItem()\">\n          <mat-icon *ngIf=\"menuItem.icon\">{{ menuItem.icon }}</mat-icon>\n        </a>\n      </li>\n    </ng-container>\n  ",
                    styles: ["\n    .o-app-sidenav-menu-item .o-user-info-menu-item{cursor:default}.o-app-sidenav-menu-item .o-user-info-menu-item .o-user-info-image{background-repeat:no-repeat;background-position:center;background-size:cover;width:100%;height:200px !important}.o-app-sidenav-menu-item .o-user-info-menu-item .o-user-info-item{padding:0 8px 0 16px}.o-app-sidenav-menu-item .o-user-info-menu-item .o-user-info-name{text-transform:uppercase;font-weight:600}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class]': 'getClass()',
                        '[attr.disabled]': 'disabled'
                    }
                },] },
    ];
    /** @nocollapse */
    OAppSidenavMenuItemComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: core.ElementRef },
        { type: core.ChangeDetectorRef }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OAppSidenavMenuItemComponent.prototype, "sidenavOpened", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OAppSidenavMenuItemComponent.prototype, "disabled", void 0);
    return OAppSidenavMenuItemComponent;
}());
var OAppSidenavMenuItemModule = /** @class */ (function () {
    function OAppSidenavMenuItemModule() {
    }
    OAppSidenavMenuItemModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule, OLanguageSelectorModule, OSharedModule, router.RouterModule],
                    declarations: [OAppSidenavMenuItemComponent],
                    exports: [OAppSidenavMenuItemComponent]
                },] },
    ];
    return OAppSidenavMenuItemModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_APP_SIDENAV_MENU_GROUP = [
    'menuGroup : menu-group',
    'sidenavOpened : sidenav-opened'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_APP_SIDENAV_MENU_GROUP = [
    'onItemClick'
];
var OAppSidenavMenuGroupComponent = /** @class */ (function () {
    function OAppSidenavMenuGroupComponent(injector, elRef, cd) {
        this.injector = injector;
        this.elRef = elRef;
        this.cd = cd;
        this.onItemClick = new core.EventEmitter();
        this.sidenavOpened = true;
        this.translateService = this.injector.get(OTranslateService$$1);
        this.appMenuService = this.injector.get(AppMenuService);
        this.permissionsService = this.injector.get(PermissionsService);
        this.sidenav = this.injector.get(OAppSidenavComponent);
    }
    /**
     * @return {?}
     */
    OAppSidenavMenuGroupComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.parsePermissions();
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuGroupComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.menuGroup.id === 'user-info') {
            /** @type {?} */
            var self_1 = this;
            this.sidenavSubscription = this.sidenav.sidenav.openedChange.subscribe(function (opened) {
                self_1.disabled = !!(!opened || (self_1.permissions && self_1.permissions.enabled === false));
                self_1.updateContentExpansion();
                self_1.cd.markForCheck();
            });
        }
        this.updateContentExpansion();
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuGroupComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.sidenavSubscription) {
            this.sidenavSubscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuGroupComponent.prototype.parsePermissions = /**
     * @return {?}
     */
    function () {
        // if oattr in form, it can have permissions
        this.permissions = this.permissionsService.getMenuPermissions(this.menuGroup.id);
        if (!Util.isDefined(this.permissions)) {
            return;
        }
        this.hidden = this.permissions.visible === false;
        this.disabled = this.permissions.enabled === false;
        if (this.disabled) {
            this.mutationObserver = PermissionsUtils.registerDisabledChangesInDom(this.elRef.nativeElement, {
                checkStringValue: true
            });
        }
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuGroupComponent.prototype.onClick = /**
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        this.menuGroup.opened = !this.menuGroup.opened;
        this.updateContentExpansion();
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuGroupComponent.prototype.updateContentExpansion = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isOpened = this.menuGroup && this.menuGroup.opened;
        if (this.menuGroup.id === 'user-info') {
            isOpened = (this.sidenav && this.sidenav.sidenav.opened) && isOpened;
        }
        this.contentExpansion = isOpened ? 'expanded' : 'collapsed';
    };
    Object.defineProperty(OAppSidenavMenuGroupComponent.prototype, "contentExpansion", {
        get: /**
         * @return {?}
         */
        function () {
            return this._contentExpansion;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._contentExpansion = val;
            this.cd.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OAppSidenavMenuGroupComponent.prototype, "tooltip", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var result = this.translateService.get(this.menuGroup.name);
            if (Util.isDefined(this.menuGroup.tooltip)) {
                result += ': ' + this.translateService.get(this.menuGroup.tooltip);
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} e
     * @return {?}
     */
    OAppSidenavMenuGroupComponent.prototype.onMenuItemClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.onItemClick.emit(e);
    };
    /**
     * @return {?}
     */
    OAppSidenavMenuGroupComponent.prototype.getClass = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var className = 'o-app-sidenav-menu-group';
        if (this.menuGroup.class) {
            className += ' ' + this.menuGroup.class;
        }
        return className;
    };
    OAppSidenavMenuGroupComponent.DEFAULT_INPUTS_O_APP_SIDENAV_MENU_GROUP = DEFAULT_INPUTS_O_APP_SIDENAV_MENU_GROUP;
    OAppSidenavMenuGroupComponent.DEFAULT_OUTPUTS_O_APP_SIDENAV_MENU_GROUP = DEFAULT_OUTPUTS_O_APP_SIDENAV_MENU_GROUP;
    OAppSidenavMenuGroupComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-app-sidenav-menu-group',
                    inputs: DEFAULT_INPUTS_O_APP_SIDENAV_MENU_GROUP,
                    outputs: DEFAULT_OUTPUTS_O_APP_SIDENAV_MENU_GROUP,
                    template: "\n    <ng-container *ngIf=\"!hidden\">\n      <button type=\"button\" mat-button class=\"o-app-sidenav-item o-app-sidenav-menugroup\" [class.active]=\"menuGroup.opened\"\n        fxLayout=\"column\" (click)=\"onClick()\">\n        <div fxLayout=\"row\" fxLayoutAlign=\"start center\" fxFill>\n          <ng-container *ngIf=\"sidenavOpened\">\n            <mat-icon *ngIf=\"menuGroup.icon\">{{ menuGroup.icon }}</mat-icon>\n            <h3>{{ menuGroup.name | oTranslate }}</h3>\n            <span class=\"fill-remaining\"></span>\n            <mat-icon class=\"o-app-sidenav-menugroup-arrow\" svgIcon=\"ontimize:keyboard_arrow_right\"></mat-icon>\n          </ng-container>\n          <ng-container *ngIf=\"!sidenavOpened\">\n            <mat-icon [matTooltip]=\"tooltip\" matTooltipClass=\"menugroup-tooltip\" matTooltipPosition=\"right\" *ngIf=\"menuGroup.icon\">{{\n              menuGroup.icon }}</mat-icon>\n          </ng-container>\n        </div>\n      </button>\n\n      <div class=\"o-app-sidenav-menugroup-items-container\">\n        <ul [@contentExpansion]=\"contentExpansion\" class=\"o-app-sidenav-menugroup-ul\">\n          <ng-container *ngFor=\"let menuItem of menuGroup.items\">\n            <o-app-sidenav-menu-item [sidenav-opened]=\"sidenavOpened\" [disabled]=\"disabled\" [menu-item]=\"menuItem\"\n              [menu-item-type]=\"appMenuService.getMenuItemType(menuItem)\" (onClick)=\"onMenuItemClick($event)\">\n            </o-app-sidenav-menu-item>\n          </ng-container>\n        </ul>\n      </div>\n    </ng-container>\n  ",
                    styles: ["\n    .o-app-sidenav-menu-group .o-app-sidenav-menugroup{width:100%}.o-app-sidenav-menu-group[disabled=true] .o-app-sidenav-menugroup{cursor:default}.o-app-sidenav-menu-group .mat-tooltip.menugroup-tooltip{margin-left:28px}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    animations: [
                        animations$1.trigger('contentExpansion', [
                            animations$1.state('collapsed', animations$1.style({ height: '0px' })),
                            animations$1.state('expanded', animations$1.style({ height: '*' })),
                            animations$1.transition('collapsed => expanded', animations$1.animate('200ms ease-in')),
                            animations$1.transition('expanded => collapsed', animations$1.animate('200ms ease-out'))
                        ])
                    ],
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    host: {
                        '[class]': 'getClass()',
                        '[attr.disabled]': 'disabled'
                    }
                },] },
    ];
    /** @nocollapse */
    OAppSidenavMenuGroupComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: core.ElementRef },
        { type: core.ChangeDetectorRef }
    ]; };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OAppSidenavMenuGroupComponent.prototype, "sidenavOpened", void 0);
    return OAppSidenavMenuGroupComponent;
}());
var OAppSidenavMenuGroupModule = /** @class */ (function () {
    function OAppSidenavMenuGroupModule() {
    }
    OAppSidenavMenuGroupModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule, OAppSidenavMenuItemModule, OSharedModule],
                    declarations: [OAppSidenavMenuGroupComponent],
                    exports: [OAppSidenavMenuGroupComponent]
                },] },
    ];
    return OAppSidenavMenuGroupModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_APP_SIDENAV = [
    'opened',
    'showUserInfo: show-user-info',
    'showToggleButton: show-toggle-button',
    'openedSidenavImg: opened-sidenav-image',
    'closedSidenavImg: closed-sidenav-image',
    'layoutMode: layout-mode',
    'sidenavMode: sidenav-mode'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_APP_SIDENAV = [
    'onSidenavToggle',
    'afterSidenavToggle'
];
var OAppSidenavComponent = /** @class */ (function () {
    function OAppSidenavComponent(injector, router$$1, elRef, cd, media) {
        this.injector = injector;
        this.router = router$$1;
        this.elRef = elRef;
        this.cd = cd;
        this.media = media;
        this._menuRootArray = [];
        this.opened = true;
        this._showUserInfo = true;
        this._showToggleButton = true;
        this.onSidenavToggle = new core.EventEmitter();
        this.afterSidenavToggle = new core.EventEmitter();
        this.manuallyClosed = false;
        this.appMenuService = this.injector.get(AppMenuService);
        this.menuRootArray = this.appMenuService.getMenuRoots();
        this.oUserInfoService = this.injector.get(OUserInfoService);
        /** @type {?} */
        var self = this;
        this.mediaWatch = this.media.subscribe(function (change) {
            if (self.isScreenSmall() && self.sidenav) {
                self.sidenav.close();
            }
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    OAppSidenavComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.manuallyClosed && !this.isScreenSmall() && !this.isMobileMode()) {
            this.sidenav.open();
        }
    };
    /**
     * @return {?}
     */
    OAppSidenavComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.routerSubscription = this.router.events.subscribe(function () {
            if (_this.isScreenSmall()) {
                _this.sidenav.close();
            }
        });
    };
    /**
     * @return {?}
     */
    OAppSidenavComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.showUserInfo && this.showToggleButton) {
            this.userInfo = this.oUserInfoService.getUserInfo();
            this.userInfoSubscription = this.oUserInfoService.getUserInfoObservable().subscribe(function (res) {
                _this.userInfo = res;
                _this.refreshMenuRoots();
            });
        }
        this.refreshMenuRoots();
    };
    Object.defineProperty(OAppSidenavComponent.prototype, "layoutMode", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layoutMode;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var m = OAppLayoutComponent.OAppLayoutModes.find(function (e) { return e === val; });
            if (Util.isDefined(m)) {
                this._layoutMode = m;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OAppSidenavComponent.prototype, "sidenavMode", {
        get: /**
         * @return {?}
         */
        function () {
            return this._sidenavMode;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var m = OAppLayoutComponent.OSidenavModes.find(function (e) { return e === val; });
            if (Util.isDefined(m)) {
                this._sidenavMode = m;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OAppSidenavComponent.prototype.refreshMenuRoots = /**
     * @return {?}
     */
    function () {
        if (this.showUserInfo && this.userInfo && this._showToggleButton) {
            /** @type {?} */
            var firstRoot = this.menuRootArray[0];
            /** @type {?} */
            var alreadyExistsUserInfo = firstRoot ? firstRoot.id === 'user-info' : false;
            if (alreadyExistsUserInfo) {
                /** @type {?} */
                var userInfoItem = /** @type {?} */ ((/** @type {?} */ (this.menuRootArray[0])).items[0]);
                userInfoItem.id = this.userInfo.username;
                userInfoItem.name = this.userInfo.username;
                userInfoItem.user = this.userInfo.username;
                userInfoItem.avatar = this.userInfo.avatar;
            }
            else {
                /** @type {?} */
                var userInfoItem = {
                    id: this.userInfo.username,
                    name: this.userInfo.username,
                    user: this.userInfo.username,
                    avatar: this.userInfo.avatar
                };
                /** @type {?} */
                var menuGroupUserInfo = {
                    id: 'user-info',
                    name: 'APP_LAYOUT.USER_PROFILE',
                    items: [userInfoItem],
                    opened: true,
                    icon: 'person_pin'
                };
                this.menuRootArray.unshift(menuGroupUserInfo);
            }
        }
    };
    /**
     * @return {?}
     */
    OAppSidenavComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.routerSubscription) {
            this.routerSubscription.unsubscribe();
        }
        if (this.userInfoSubscription) {
            this.userInfoSubscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OAppSidenavComponent.prototype.isScreenSmall = /**
     * @return {?}
     */
    function () {
        return !this.manuallyClosed && this.media.isActive('lt-sm');
    };
    /**
     * @return {?}
     */
    OAppSidenavComponent.prototype.isMobileMode = /**
     * @return {?}
     */
    function () {
        return this._layoutMode === 'mobile';
    };
    /**
     * @return {?}
     */
    OAppSidenavComponent.prototype.isSidenavOpened = /**
     * @return {?}
     */
    function () {
        return this.opened && !this.isMobileMode() && !this.isScreenSmall();
    };
    Object.defineProperty(OAppSidenavComponent.prototype, "menuRootArray", {
        get: /**
         * @return {?}
         */
        function () {
            return this._menuRootArray;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._menuRootArray = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    OAppSidenavComponent.prototype.toggleSidenav = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var promise = this.sidenav.opened ? this.sidenav.close() : this.sidenav.open();
        /** @type {?} */
        var self = this;
        promise.then(function () {
            self.afterSidenavToggle.emit(self.sidenav.opened);
        });
        this.cd.detectChanges();
        this.opened = this.sidenav.opened;
        this.manuallyClosed = !this.opened;
        this.onSidenavToggle.emit(this.sidenav.opened);
    };
    Object.defineProperty(OAppSidenavComponent.prototype, "showUserInfo", {
        get: /**
         * @return {?}
         */
        function () {
            return this._showUserInfo;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._showUserInfo = arg;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OAppSidenavComponent.prototype, "showToggleButton", {
        get: /**
         * @return {?}
         */
        function () {
            return this._showToggleButton;
        },
        set: /**
         * @param {?} arg
         * @return {?}
         */
        function (arg) {
            this._showToggleButton = arg;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} e
     * @return {?}
     */
    OAppSidenavComponent.prototype.onMenuItemClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (this.isMobileMode()) {
            this.sidenav.close();
        }
    };
    OAppSidenavComponent.DEFAULT_INPUTS_O_APP_LAYOUT = DEFAULT_INPUTS_O_APP_SIDENAV;
    OAppSidenavComponent.DEFAULT_OUTPUTS_O_APP_LAYOUT = DEFAULT_OUTPUTS_O_APP_SIDENAV;
    OAppSidenavComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-app-sidenav',
                    inputs: DEFAULT_INPUTS_O_APP_SIDENAV,
                    outputs: DEFAULT_OUTPUTS_O_APP_SIDENAV,
                    template: "\n    <mat-sidenav-container class=\"o-app-sidenav-container\" [class.opened]=\"sidenav.opened\"\n      [class.o-app-sidenav-mode-desktop]=\"(layoutMode || 'desktop') === 'desktop'\" [class.o-app-sidenav-mode-mobile]=\"(layoutMode || 'desktop') !== 'desktop'\">\n\n      <mat-sidenav #sidenav class=\"o-app-sidenav-sidenav o-scroll\" [opened]=\"isSidenavOpened()\" [mode]=\"(sidenavMode || ((layoutMode || 'desktop') === 'desktop' ? 'side' : 'over'))\"\n        [class.mat-drawer-opened]=\"sidenav.opened\" [class.mat-drawer-closed]=\"!sidenav.opened\" fxLayout=\"column\"\n        fxLayoutAlign=\"start stretch\">\n\n        <div fxLayout=\"row\" fxLayoutAlign=\"end\" *ngIf=\"showToggleButton\" class=\"sidenav-toggle-container\">\n          <mat-icon class=\"sidenav-toggle\" (click)=\"toggleSidenav()\" svgIcon=\"ontimize:menu\">menu</mat-icon>\n        </div>\n\n        <o-app-sidenav-image [opened-src]=\"openedSidenavImg\" [closed-src]=\"closedSidenavImg\"> </o-app-sidenav-image>\n\n        <ng-content select=\"o-app-layout-sidenav-projection-start\"></ng-content>\n\n        <nav *ngFor=\"let menuRootItem of menuRootArray\">\n\n          <ul *ngIf=\"appMenuService.getMenuItemType(menuRootItem) !== 'group'\">\n            <o-app-sidenav-menu-item [menu-item]=\"menuRootItem\" [menu-item-type]=\"appMenuService.getMenuItemType(menuRootItem)\"\n              [sidenav-opened]=\"sidenav.opened\" (onClick)=\"onMenuItemClick($event)\">\n            </o-app-sidenav-menu-item>\n          </ul>\n\n          <o-app-sidenav-menu-group [menu-group]=\"menuRootItem\" [sidenav-opened]=\"sidenav.opened\" *ngIf=\"appMenuService.getMenuItemType(menuRootItem) === 'group'\"\n            (onItemClick)=\"onMenuItemClick($event)\">\n          </o-app-sidenav-menu-group>\n        </nav>\n\n        <ng-content select=\"o-app-layout-sidenav-projection-end\"></ng-content>\n\n      </mat-sidenav>\n\n      <mat-sidenav-content class=\"o-app-sidenav-content\">\n        <ng-content></ng-content>\n      </mat-sidenav-content>\n    </mat-sidenav-container>\n  ",
                    styles: ["\n    .o-app-sidenav.header-layout .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav{box-shadow:3px 56px 6px rgba(0,0,0,0.24)}.o-app-sidenav .o-app-sidenav-menu-group[disabled=true] .mat-button-focus-overlay,.o-app-sidenav .o-app-sidenav-menu-group[disabled=true] .mat-ripple,.o-app-sidenav .o-app-sidenav-menu-item[disabled=true] .mat-button-focus-overlay,.o-app-sidenav .o-app-sidenav-menu-item[disabled=true] .mat-ripple{display:none}.o-app-sidenav .o-app-sidenav-menu-group[disabled=true] .o-app-sidenav-item,.o-app-sidenav .o-app-sidenav-menu-item[disabled=true] .o-app-sidenav-item{opacity:.5}.o-app-sidenav .o-app-sidenav-menu-group[disabled=true] a,.o-app-sidenav .o-app-sidenav-menu-item[disabled=true] a{cursor:initial}.o-app-sidenav .o-app-sidenav-container{width:100%;height:100%}.o-app-sidenav .o-app-sidenav-container.o-app-sidenav-mode-desktop:not(.opened) .o-app-sidenav-sidenav.mat-drawer-closed{visibility:visible !important;transform:translate3d(-191px, 0, 0)}.o-app-sidenav .o-app-sidenav-container.o-app-sidenav-mode-desktop:not(.opened) .o-app-sidenav-content.mat-drawer-content{margin-right:48px !important;transform:translate3d(48px, 0, 0) !important}.o-app-sidenav .o-app-sidenav-container .o-app-sidenav-content{position:absolute;right:0;left:0}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav{box-shadow:3px 0 6px rgba(0,0,0,0.24);padding-bottom:36px;padding-top:5px;width:240px;bottom:0;overflow:auto;height:100%}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav h3{border:none;font-size:16px;font-weight:700;line-height:24px;text-transform:capitalize;margin:0;padding-left:16px}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav ul{list-style-type:none;margin:0;padding:0}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav li{margin:0;padding:0}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav li>a{box-sizing:border-box;display:block;font-size:14px;font-weight:400;line-height:47px;text-decoration:none;padding:0 16px;position:relative}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav .sidenav-toggle{padding:4px 12px 8px;cursor:pointer}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav .o-app-sidenav-menugroup{transition:background-color 500ms}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav .o-app-sidenav-menugroup.active+.o-app-sidenav-menugroup-items-container .o-app-sidenav-menu-item:last-child li{border-color:transparent}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav .o-app-sidenav-menugroup-items-container{overflow:hidden}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav.mat-drawer-closing{transform:translate3d(-191px, 0, 0)}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav.mat-drawer-closed{text-align:center}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav.mat-drawer-closed .o-app-sidenav-item:not(.o-user-info){cursor:pointer}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav.mat-drawer-closed .o-app-sidenav-item.o-user-info:focus,.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav.mat-drawer-closed .o-app-sidenav-item.o-user-info:hover{color:inherit}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav.mat-drawer-closed .o-app-sidenav-item.o-app-sidenav-menuitem a{width:48px;max-width:48px;min-width:48px;line-height:48px;padding:0 8px;height:48px}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav.mat-drawer-closed .o-app-sidenav-item.o-app-sidenav-menugroup{padding:8px 8px 8px 12px;height:48px;-webkit-box-pack:center !important;-ms-flex-pack:center !important;justify-content:center !important}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav.mat-drawer-closed>nav{width:48px;min-width:48px;margin-left:auto}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav.mat-drawer-closed .o-app-sidenav-image .o-app-sidenav-image-container{padding:0;text-align:end;max-height:48px}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav.mat-drawer-closed .o-app-sidenav-image .o-app-sidenav-image-container .o-app-sidenav-image{max-height:48px;margin:8px 8px 0 0}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav:not(.mat-drawer-closed) .o-app-sidenav-item{border-bottom-width:0;border-bottom-style:solid}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav:not(.mat-drawer-closed) .o-app-sidenav-menugroup{padding:16px;transition:padding 500ms 0s}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav:not(.mat-drawer-closed) .o-app-sidenav-menugroup .o-app-sidenav-menugroup-arrow{position:absolute;right:16px;transition:500ms transform cubic-bezier(0.25, 0.8, 0.25, 1)}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav:not(.mat-drawer-closed) .o-app-sidenav-menugroup.active .o-app-sidenav-menugroup-arrow{transform:rotate(90deg)}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav:not(.mat-drawer-closed) .o-app-sidenav-menugroup.active+.o-app-sidenav-menugroup-items-container ul li>a{padding-left:32px}.o-app-sidenav .o-app-sidenav-container .mat-drawer.o-app-sidenav-sidenav:not(.mat-drawer-closed) .o-app-sidenav-menuitem mat-icon{margin-right:16px}.o-app-sidenav .o-app-sidenav-container .o-app-sidenav-content{min-height:100%;display:flex;flex-direction:column}.o-app-sidenav .o-app-sidenav-container .o-app-sidenav-content router-outlet+*{flex-grow:1}\n  "],
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-app-sidenav]': 'true'
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    OAppSidenavComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: router.Router },
        { type: core.ElementRef },
        { type: core.ChangeDetectorRef },
        { type: flexLayout.ObservableMedia }
    ]; };
    OAppSidenavComponent.propDecorators = {
        sidenav: [{ type: core.ViewChild, args: [material.MatSidenav,] }],
        onResize: [{ type: core.HostListener, args: ['window:resize', ['$event'],] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OAppSidenavComponent.prototype, "opened", void 0);
    return OAppSidenavComponent;
}());
var OAppSidenavModule = /** @class */ (function () {
    function OAppSidenavModule() {
    }
    OAppSidenavModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule, OAppSidenavMenuGroupModule, OAppSidenavImageModule, OAppSidenavMenuItemModule, OSharedModule, router.RouterModule],
                    declarations: [OAppSidenavComponent],
                    exports: [OAppSidenavComponent]
                },] },
    ];
    return OAppSidenavModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OAppLayoutHeaderComponent = /** @class */ (function () {
    function OAppLayoutHeaderComponent() {
    }
    OAppLayoutHeaderComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-app-layout-header',
                    template: "\n    <ng-content></ng-content>\n  ",
                },] },
    ];
    return OAppLayoutHeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_APP_LAYOUT_SIDENAV = [
    'position'
];
var OAppLayoutSidenavComponent = /** @class */ (function () {
    function OAppLayoutSidenavComponent() {
        this.position = 'end';
    }
    OAppLayoutSidenavComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-app-layout-sidenav',
                    template: "\n    <ng-content></ng-content>\n  ",
                    inputs: DEFAULT_INPUTS_O_APP_LAYOUT_SIDENAV
                },] },
    ];
    return OAppLayoutSidenavComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_APP_LAYOUT = [
    'mode',
    'sidenavMode: sidenav-mode',
    'sidenavOpened: sidenav-opened',
    '_showHeader: show-header',
    'showUserInfo: show-user-info',
    'showLanguageSelector: show-language-selector',
    'useFlagIcons: use-flag-icons',
    'openedSidenavImg: opened-sidenav-image',
    'closedSidenavImg: closed-sidenav-image'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_APP_LAYOUT = [
    'beforeOpenSidenav',
    'afterOpenSidenav',
    'beforeCloseSidenav',
    'afterCloseSidenav'
];
var OAppLayoutComponent = /** @class */ (function () {
    function OAppLayoutComponent() {
        this.sidenavOpened = true;
        this.showUserInfo = true;
        this.showLanguageSelector = true;
        this.useFlagIcons = false;
        this.beforeOpenSidenav = new core.EventEmitter();
        this.afterOpenSidenav = new core.EventEmitter();
        this.beforeCloseSidenav = new core.EventEmitter();
        this.afterCloseSidenav = new core.EventEmitter();
    }
    Object.defineProperty(OAppLayoutComponent.prototype, "showHeader", {
        get: /**
         * @return {?}
         */
        function () {
            return this._showHeader;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._showHeader = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OAppLayoutComponent.prototype, "mode", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mode;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var m = OAppLayoutComponent.OAppLayoutModes.find(function (e) { return e === val; });
            if (Util.isDefined(m)) {
                this._mode = m;
                if (this._mode === 'mobile' && !Util.isDefined(this.showHeader)) {
                    this.showHeader = true;
                }
            }
            else {
                console.error('Invalid `o-app-layout` mode (' + val + ')');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OAppLayoutComponent.prototype, "sidenavMode", {
        get: /**
         * @return {?}
         */
        function () {
            return this._sidenavMode;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var m = OAppLayoutComponent.OSidenavModes.find(function (e) { return e === val; });
            if (Util.isDefined(m)) {
                this._sidenavMode = m;
            }
            else {
                console.error('Invalid `o-app-layout` sidenav-mode (' + val + ')');
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} opened
     * @return {?}
     */
    OAppLayoutComponent.prototype.sidenavToggle = /**
     * @param {?} opened
     * @return {?}
     */
    function (opened) {
        opened ? this.beforeOpenSidenav.emit() : this.beforeCloseSidenav.emit();
    };
    /**
     * @param {?} opened
     * @return {?}
     */
    OAppLayoutComponent.prototype.afterToggle = /**
     * @param {?} opened
     * @return {?}
     */
    function (opened) {
        opened ? this.afterOpenSidenav.emit() : this.afterCloseSidenav.emit();
    };
    OAppLayoutComponent.DEFAULT_INPUTS_O_APP_LAYOUT = DEFAULT_INPUTS_O_APP_LAYOUT;
    OAppLayoutComponent.DEFAULT_OUTPUTS_O_APP_LAYOUT = DEFAULT_OUTPUTS_O_APP_LAYOUT;
    OAppLayoutComponent.OAppLayoutModes = ['mobile', 'desktop'];
    OAppLayoutComponent.OSidenavModes = ['over', 'push', 'side'];
    OAppLayoutComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-app-layout',
                    inputs: DEFAULT_INPUTS_O_APP_LAYOUT,
                    outputs: DEFAULT_OUTPUTS_O_APP_LAYOUT,
                    template: "\n    <o-app-sidenav #appSidenav [sidenav-mode]=\"sidenavMode\" [opened]=\"sidenavOpened\" [show-user-info]=\"showUserInfo\"\n      [show-toggle-button]=\"!showHeader\" [opened-sidenav-image]=\"openedSidenavImg\" [closed-sidenav-image]=\"closedSidenavImg\"\n      [layout-mode]=\"mode\" [class.header-layout]=\"showHeader\" (onSidenavToggle)=\"sidenavToggle($event)\"\n      (afterSidenavToggle)=\"afterToggle($event)\">\n\n      <ng-content select=\"o-app-layout-sidenav[position=start]\" ngProjectAs=\"o-app-layout-sidenav-projection-start\">\n      </ng-content>\n      <ng-content select=\"o-app-layout-sidenav[position=end]\" ngProjectAs=\"o-app-layout-sidenav-projection-end\">\n      </ng-content>\n      <ng-content select=\"o-app-layout-sidenav\" ngProjectAs=\"o-app-layout-sidenav-projection-end\"></ng-content>\n\n      <o-app-header #appHeader *ngIf=\"showHeader\" [show-user-info]=\"showUserInfo\"\n        [show-language-selector]=\"showLanguageSelector\" [use-flag-icons]=\"useFlagIcons\"\n        (onSidenavToggle)=\"appSidenav.toggleSidenav()\">\n\n        <ng-content select=\"o-app-layout-header\"></ng-content>\n\n      </o-app-header>\n\n      <div class=\"application-layout-content-wrapper\" [class.header-layout]=\"showHeader\">\n        <ng-content></ng-content>\n      </div>\n    </o-app-sidenav>\n  ",
                    styles: ["\n    .application-layout-content-wrapper{z-index:1;position:absolute;top:0px;bottom:0px;left:0px;right:0px;overflow:auto;padding:8px}.application-layout-content-wrapper.header-layout{top:56px}\n  "],
                    encapsulation: core.ViewEncapsulation.None
                },] },
    ];
    OAppLayoutComponent.propDecorators = {
        appSidenav: [{ type: core.ViewChild, args: ['appSidenav',] }]
    };
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OAppLayoutComponent.prototype, "sidenavOpened", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OAppLayoutComponent.prototype, "showUserInfo", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OAppLayoutComponent.prototype, "showLanguageSelector", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OAppLayoutComponent.prototype, "useFlagIcons", void 0);
    __decorate([
        InputConverter(),
        __metadata("design:type", Boolean)
    ], OAppLayoutComponent.prototype, "_showHeader", void 0);
    return OAppLayoutComponent;
}());
var OAppLayoutModule = /** @class */ (function () {
    function OAppLayoutModule() {
    }
    OAppLayoutModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule, OSharedModule, router.RouterModule, OAppSidenavModule, OAppHeaderModule],
                    declarations: [OAppLayoutComponent, OAppLayoutHeaderComponent, OAppLayoutSidenavComponent],
                    exports: [OAppLayoutComponent, OAppLayoutHeaderComponent, OAppLayoutSidenavComponent]
                },] },
    ];
    return OAppLayoutModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_INPUTS_O_MENU_LAYOUT = [
    'parentMenuId : parent-menu-id'
];
/** @type {?} */
var DEFAULT_OUTPUTS_O_MENU_LAYOUT = [];
var OCardMenuLayoutComponent = /** @class */ (function () {
    function OCardMenuLayoutComponent(injector, cd) {
        var _this = this;
        this.injector = injector;
        this.cd = cd;
        this.translateService = this.injector.get(OTranslateService$$1);
        this.appMenuService = this.injector.get(AppMenuService);
        this.menuRoots = this.appMenuService.getMenuRoots();
        this.translateServiceSubscription = this.translateService.onLanguageChanged.subscribe(function () {
            _this.cd.detectChanges();
        });
    }
    /**
     * @return {?}
     */
    OCardMenuLayoutComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.setCardMenuItems();
    };
    /**
     * @return {?}
     */
    OCardMenuLayoutComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.translateServiceSubscription) {
            this.translateServiceSubscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    OCardMenuLayoutComponent.prototype.setCardMenuItems = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var cardItemsAux = [];
        if (!this.parentMenuId) {
            cardItemsAux = this.menuRoots.filter(function (item) { return !_this.appMenuService.isMenuGroup(item); });
        }
        else {
            cardItemsAux = this.getItemsFilteredByParentId(this.menuRoots);
        }
        this.cardItems = cardItemsAux;
    };
    Object.defineProperty(OCardMenuLayoutComponent.prototype, "cardItems", {
        get: /**
         * @return {?}
         */
        function () {
            return this.cardItemsArray;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.cardItemsArray = val;
            this.cd.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} array
     * @return {?}
     */
    OCardMenuLayoutComponent.prototype.getItemsFilteredByParentId = /**
     * @param {?} array
     * @return {?}
     */
    function (array) {
        var _this = this;
        /** @type {?} */
        var result;
        /** @type {?} */
        var groups = array.filter(function (item) { return _this.appMenuService.isMenuGroup(item); });
        for (var i = 0, len = groups.length; i < len; i++) {
            /** @type {?} */
            var menuGroup = (/** @type {?} */ (groups[i]));
            if (menuGroup.id === this.parentMenuId) {
                result = menuGroup.items;
                break;
            }
            else {
                result = this.getItemsFilteredByParentId(menuGroup.items);
            }
        }
        return result;
    };
    OCardMenuLayoutComponent.DEFAULT_INPUTS_O_MENU_LAYOUT = DEFAULT_INPUTS_O_MENU_LAYOUT;
    OCardMenuLayoutComponent.DEFAULT_OUTPUTS_O_MENU_LAYOUT = DEFAULT_OUTPUTS_O_MENU_LAYOUT;
    OCardMenuLayoutComponent.decorators = [
        { type: core.Component, args: [{
                    moduleId: module.id,
                    selector: 'o-card-menu-layout',
                    template: "\n    <div fxLayout=\"row wrap\" fxLayout.lt-md=\"column\" fxLayoutAlign=\"space-around center\" fxLayoutGap.gt-sm=\"8px\" fxFill>\n      <ng-container *ngFor=\"let item of cardItems\">\n        <o-card-menu-item *ngIf=\"item['show-in-card-menu'] !== false\" button-text=\"CARD_MENU_LAYOUT.BUTTON_TEXT\" [route]=\"item.route\"\n          [title]=\"item.name\" [tooltip]=\"item.tooltip\" [icon]=\"item.icon\" [image]=\"item.image\" [detail-component]=\"item.component\"\n          [detail-component-inputs]=\"item['component-inputs']\" [ngClass]=\"item.class\">\n        </o-card-menu-item>\n      </ng-container>\n      <ng-content select=\"o-card-menu-item\"></ng-content>\n    </div>\n  ",
                    styles: ["\n    .o-menu-layout{display:block;height:100%;width:100%}.o-menu-layout .o-card-menu-item{height:45%;margin:16px 0;max-width:290px;min-height:180px;min-width:290px}.o-menu-layout .o-card-menu-item.compact{height:30%;max-height:250px}\n  "],
                    inputs: DEFAULT_INPUTS_O_MENU_LAYOUT,
                    outputs: DEFAULT_OUTPUTS_O_MENU_LAYOUT,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        '[class.o-menu-layout]': 'true'
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    OCardMenuLayoutComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: core.ChangeDetectorRef }
    ]; };
    return OCardMenuLayoutComponent;
}());
var OCardMenuLayoutModule = /** @class */ (function () {
    function OCardMenuLayoutModule() {
    }
    OCardMenuLayoutModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [OCardMenuLayoutComponent],
                    imports: [common.CommonModule, OCardMenuItemModule, OSharedModule],
                    exports: [OCardMenuLayoutComponent]
                },] },
    ];
    return OCardMenuLayoutModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var mergeAuthToken = function (options) {
    /** @type {?} */
    var newOptions = new http$1.RequestOptions({}).merge(options);
    /** @type {?} */
    var newHeaders = new http$1.Headers(newOptions.headers);
    /*newHeaders.set('X-AUTH-TOKEN', localStorage.getItem('jwt'));
      newHeaders.set('Accept', 'application/json');
      newHeaders.set('Content-Type', 'application/json');
      */
    newHeaders.set('Access-Control-Allow-Origin', '*');
    newHeaders.set('Accept', 'application/json');
    newHeaders.set('Content-Type', 'application/json;charset=UTF-8');
    newOptions.headers = newHeaders;
    return newOptions;
};
var OHttp = /** @class */ (function (_super) {
    __extends(OHttp, _super);
    function OHttp(_backend, _defaultOptions) {
        return _super.call(this, _backend, _defaultOptions) || this;
    }
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    OHttp.prototype.get = /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        return _super.prototype.get.call(this, url, mergeAuthToken(options));
    };
    /**
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    OHttp.prototype.post = /**
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    function (url, body, options) {
        return _super.prototype.post.call(this, url, body, mergeAuthToken(options));
    };
    /**
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    OHttp.prototype.put = /**
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    function (url, body, options) {
        return _super.prototype.put.call(this, url, body, mergeAuthToken(options));
    };
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    OHttp.prototype.delete = /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        return _super.prototype.delete.call(this, url, mergeAuthToken(options));
    };
    /**
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    OHttp.prototype.patch = /**
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    function (url, body, options) {
        return _super.prototype.patch.call(this, url, body, mergeAuthToken(options));
    };
    /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    OHttp.prototype.head = /**
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    function (url, options) {
        return _super.prototype.head.call(this, url, mergeAuthToken(options));
    };
    OHttp.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    OHttp.ctorParameters = function () { return [
        { type: http$1.ConnectionBackend },
        { type: http$1.RequestOptions }
    ]; };
    return OHttp;
}(http$1.Http));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @param {?} injector
 * @return {?}
 */
function addPermissionsRouteGuard(injector) {
    /** @type {?} */
    var route = injector.get(router.Router);
    /** @type {?} */
    var exists403 = route.config.find(function (route) { return route.path === Codes.FORBIDDEN_ROUTE; });
    if (!exists403) {
        route.config.push({ path: Codes.FORBIDDEN_ROUTE, component: Error403Component });
    }
}
/**
 * @param {?} injector
 * @param {?} config
 * @param {?} oTranslate
 * @return {?}
 */
function appInitializerFactory(injector, config$$1, oTranslate) {
    return function () { return new Promise(function (resolve) {
        /** @type {?} */
        var observableArray = [];
        /** @type {?} */
        var locationInitialized = injector.get(common.LOCATION_INITIALIZED, Promise.resolve(null));
        locationInitialized.then(function () {
            oTranslate.setDefaultLang('en');
            /** @type {?} */
            var userLang = config$$1['locale'];
            if (!userLang) {
                // use navigator lang if available
                userLang = oTranslate.getBrowserLang();
            }
            // initialize available locales array if needed
            if (!config$$1.applicationLocales) {
                config$$1.applicationLocales = [];
            }
            if (config$$1.applicationLocales.indexOf('en') === -1) {
                config$$1.applicationLocales.push('en');
            }
            if (userLang && config$$1.applicationLocales.indexOf(userLang) === -1) {
                config$$1.applicationLocales.push(userLang);
            }
            if (config$$1['uuid'] === undefined || config$$1['uuid'] === null || config$$1['uuid'] === '') {
                console.error('Your app must have an \'uuid\' property defined on your app.config file. Otherwise, your application will not work correctly.');
                alert('Your app must have an \'uuid\' property defined on your app.config file. Otherwise, your application will not work correctly.');
            }
            injector.get(NavigationService).initialize();
            injector.get(OntimizeMatIconRegistry).initialize();
            injector.get(LocalStorageService).setBackwardCompatibility();
            addPermissionsRouteGuard(injector);
            observableArray.push(oTranslate.setAppLang(userLang));
            /** @type {?} */
            var remoteConfigService = injector.get(ORemoteConfigurationService);
            observableArray.push(remoteConfigService.initialize());
            combineLatest(observableArray).subscribe(function () {
                resolve();
            });
        });
    }); };
}
/**
 * Bind some global events and publish on the 'app' channel
 * @param {?} window
 * @return {?}
 */
function bindEvents(window) {
    /** @type {?} */
    var events = new Events();
    /**
     * @param {?} channel
     * @return {?}
     */
    function publishEventWrapper(channel) {
        return {
            handleEvent: function (ev) {
                events.publish(channel, ev);
            }
        };
    }
    window.addEventListener('online', publishEventWrapper('app:online'), false);
    window.addEventListener('offline', publishEventWrapper('app:offline'), false);
    window.addEventListener('orientationchange', publishEventWrapper('app:rotated'));
    // When that status taps, we respond
    window.addEventListener('statusTap', publishEventWrapper('app:statusTap'));
    // start listening for resizes XXms after the app starts
    setTimeout(function () {
        window.addEventListener('resize', publishEventWrapper('app:resize'));
    }, 2000);
    return events;
}
/**
 * @return {?}
 */
function getEvents() {
    return bindEvents(window);
}
/**
 * @param {?} backend
 * @param {?} defaultOptions
 * @return {?}
 */
function getOntimizeServiceProvider(backend, defaultOptions) {
    return new OHttp(backend, defaultOptions);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getOntimizeFileServiceProvider(injector) {
    return new OntimizeFileService$$1(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getOntimizeExportServiceProvider(injector) {
    return new OntimizeExportService$$1(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getLoginServiceProvider(injector) {
    return new LoginService$$1(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getNavigationServiceProvider(injector) {
    return new NavigationService(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getMomentServiceProvider(injector) {
    return new MomentService(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getCurrencyServiceProvider(injector) {
    return new CurrencyService(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getNumberServiceProvider(injector) {
    return new NumberService(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getDialogServiceProvider(injector) {
    return new DialogService(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getSnackBarServiceProvider(injector) {
    return new SnackBarService(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getTranslateServiceProvider(injector) {
    return new OTranslateService$$1(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getLocalStorageServiceProvider(injector) {
    return new LocalStorageService(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getAppMenuServiceProvider(injector) {
    return new AppMenuService(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getOUserInfoServiceProvider(injector) {
    return new OUserInfoService(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getOModulesInfoServiceProvider(injector) {
    return new OModulesInfoService$$1(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getOntimizeServiceResponseParser(injector) {
    return new OntimizeServiceResponseParser(injector);
}
/**
 * @param {?} injector
 * @return {?}
 */
function getORemoteConfigurationService(injector) {
    return new ORemoteConfigurationService(injector);
}
/** @type {?} */
var ONTIMIZE_PROVIDERS = [
    { provide: Events, useValue: getEvents },
    {
        provide: AppConfig,
        useFactory: appConfigFactory,
        deps: [core.Injector]
    },
    http$1.XHRBackend,
    http$1.BaseRequestOptions,
    {
        provide: OHttp,
        useFactory: getOntimizeServiceProvider,
        deps: [http$1.XHRBackend, http$1.BaseRequestOptions]
    },
    {
        provide: OntimizeService$$1,
        useFactory: dataServiceFactory,
        deps: [core.Injector]
    },
    {
        provide: OntimizeServiceResponseParser,
        useFactory: getOntimizeServiceResponseParser,
        deps: [core.Injector]
    },
    {
        provide: OntimizeFileService$$1,
        useFactory: getOntimizeFileServiceProvider,
        deps: [core.Injector]
    },
    {
        provide: OntimizeExportService$$1,
        useFactory: getOntimizeExportServiceProvider,
        deps: [core.Injector]
    },
    // getLoginServiceProvider
    {
        provide: LoginService$$1,
        useFactory: getLoginServiceProvider,
        deps: [core.Injector]
    },
    //getNavigationServiceProvider
    {
        provide: NavigationService,
        useFactory: getNavigationServiceProvider,
        deps: [core.Injector]
    },
    // getMomentServiceProvider
    {
        provide: MomentService,
        useFactory: getMomentServiceProvider,
        deps: [core.Injector]
    },
    // getCurrencyServiceProvider
    {
        provide: CurrencyService,
        useFactory: getCurrencyServiceProvider,
        deps: [core.Injector]
    },
    //getNumberServiceProvider
    {
        provide: NumberService,
        useFactory: getNumberServiceProvider,
        deps: [core.Injector]
    },
    // getDialogServiceProvider
    {
        provide: DialogService,
        useFactory: getDialogServiceProvider,
        deps: [core.Injector]
    },
    // getSnackbarServiceProvider
    {
        provide: SnackBarService,
        useFactory: getSnackBarServiceProvider,
        deps: [core.Injector]
    },
    // getTranslateServiceProvider
    {
        provide: OTranslateService$$1,
        useFactory: getTranslateServiceProvider,
        deps: [core.Injector]
    },
    // getLocalStorageServiceProvider
    {
        provide: LocalStorageService,
        useFactory: getLocalStorageServiceProvider,
        deps: [core.Injector]
    },
    {
        provide: AuthGuardService$$1,
        useClass: AuthGuardService$$1,
        deps: [core.Injector]
    },
    {
        provide: AppMenuService,
        useFactory: getAppMenuServiceProvider,
        deps: [core.Injector]
    },
    {
        provide: OUserInfoService,
        useFactory: getOUserInfoServiceProvider,
        deps: [core.Injector]
    },
    {
        provide: OModulesInfoService$$1,
        useFactory: getOModulesInfoServiceProvider,
        deps: [core.Injector]
    },
    {
        provide: OFormLayoutManagerService,
        useClass: OFormLayoutManagerService
    },
    {
        provide: OContextMenuService,
        useClass: OContextMenuService
    },
    {
        provide: ShareCanActivateChildService,
        useClass: ShareCanActivateChildService
    },
    {
        provide: ORemoteConfigurationService,
        useFactory: getORemoteConfigurationService,
        deps: [core.Injector]
    },
    // disabled global ripple
    { provide: material.MAT_RIPPLE_GLOBAL_OPTIONS, useValue: { disabled: true } }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var INTERNAL_ONTIMIZE_MODULES_EXPORTED = [
    http$1.HttpModule,
    http.HttpClientModule,
    OSharedModule,
    OBarMenuModule,
    OBarMenuGroupModule,
    OBarMenuItemModule,
    OLocaleBarMenuItemModule,
    OBarMenuSeparatorModule,
    OBarMenuNestedModule,
    OBreadcrumbModule$$1,
    OButtonModule,
    OButtonToggleModule,
    OCheckboxModule,
    OComboModule,
    OColumnModule,
    OColumnCollapsibleModule,
    OContextMenuModule,
    ORowModule,
    ORowCollapsibleModule,
    ODialogModule,
    OSnackBarModule,
    OFilterBuilderModule$$1,
    OFormModule,
    OFormContainerModule$$1,
    OImageModule,
    OCurrencyInputModule,
    ODateInputModule,
    OEmailInputModule,
    OFileInputModule,
    OHTMLInputModule,
    OIntegerInputModule,
    OListPickerModule,
    ONIFInputModule,
    OPasswordInputModule,
    OPercentInputModule,
    ORealInputModule,
    OTextInputModule,
    OTextareaInputModule,
    OValidatorModule,
    OErrorModule,
    OListModule,
    OListItemModule,
    OListItemAvatarModule,
    OListItemTextModule,
    OListItemCardModule,
    OListItemCardImageModule,
    OSearchInputModule,
    OTableModule,
    OAppLayoutModule,
    OFormLayoutManagerModule,
    OUserInfoModule,
    OLanguageSelectorModule,
    OCardMenuItemModule,
    OCardMenuLayoutModule,
    OHourInputModule,
    OTimeInputModule,
    OGridModule$$1,
    ORadioModule,
    OSlideToggleModule,
    OSliderModule$$1,
    ODateRangeInputModule
];
/**
 * @param {?} http
 * @param {?} injector
 * @param {?} appConfig
 * @return {?}
 */
function OHttpLoaderFactory(http$$1, injector, appConfig) {
    /** @type {?} */
    var i18nConf = appConfig.getI18nAssetsConfiguration();
    /** @type {?} */
    var i18nPath = undefined;
    /** @type {?} */
    var i18nExtension = undefined;
    if (Util.isDefined(i18nConf)) {
        if (Util.isDefined(i18nConf.path)) {
            i18nPath = i18nConf.path;
        }
        if (Util.isDefined(i18nConf.extension)) {
            i18nExtension = i18nConf.extension;
        }
    }
    return new OTranslateHttpLoader(http$$1, i18nPath, i18nExtension, injector);
}
/**
 * @return {?}
 */
function OTranslateParserFactory() {
    return new OTranslateParser();
}
/** @type {?} */
var INTERNAL_ONTIMIZE_MODULES = [
    http$1.HttpModule,
    http.HttpClientModule,
    // Ngx-translate
    core$1.TranslateModule.forRoot({
        loader: {
            provide: core$1.TranslateLoader,
            useFactory: OHttpLoaderFactory,
            deps: [http.HttpClient, core.Injector, AppConfig]
        },
        parser: {
            provide: core$1.TranslateParser,
            useFactory: OTranslateParserFactory
        }
    }),
    DndModule.forRoot(),
    NgxMaterialTimepickerModule.forRoot(),
    OSharedModule,
    OBarMenuModule,
    OBarMenuGroupModule,
    OBarMenuItemModule,
    OLocaleBarMenuItemModule,
    OBarMenuSeparatorModule,
    OBarMenuNestedModule,
    OBreadcrumbModule$$1,
    OButtonModule,
    OButtonToggleModule,
    OCheckboxModule,
    OComboModule,
    OColumnModule,
    OColumnCollapsibleModule,
    OContextMenuModule,
    ORowModule,
    ORowCollapsibleModule,
    ODialogModule,
    OSnackBarModule,
    OFilterBuilderModule$$1,
    OFormModule,
    OFormContainerModule$$1,
    OImageModule,
    OCurrencyInputModule,
    ODateInputModule,
    OEmailInputModule,
    OFileInputModule,
    OHTMLInputModule,
    OIntegerInputModule,
    OListPickerModule,
    ONIFInputModule,
    OPasswordInputModule,
    OPercentInputModule,
    ORealInputModule,
    OTextInputModule,
    OTextareaInputModule,
    OValidatorModule,
    OErrorModule,
    OListModule,
    OListItemModule,
    OListItemAvatarModule,
    OListItemTextModule,
    OListItemCardModule,
    OListItemCardImageModule,
    OSearchInputModule,
    OTableModule,
    OAppLayoutModule,
    OFormLayoutManagerModule,
    OUserInfoModule,
    OLanguageSelectorModule,
    OCardMenuItemModule,
    OCardMenuLayoutModule,
    OHourInputModule,
    OTimeInputModule,
    OGridModule$$1,
    ORadioModule,
    OSlideToggleModule,
    ODateRangeInputModule
];
var 0$13 = appInitializerFactory;
var OntimizeWebTranslateModule = /** @class */ (function () {
    function OntimizeWebTranslateModule() {
    }
    OntimizeWebTranslateModule.decorators = [
        { type: core.NgModule, args: [{
                    providers: [{
                            provide: core.APP_INITIALIZER,
                            useFactory: 0$13,
                            deps: [core.Injector, APP_CONFIG, OTranslateService$$1],
                            multi: true
                        }]
                },] },
    ];
    return OntimizeWebTranslateModule;
}());
/** @type {?} */
var ONTIMIZE_MODULES = [
    platformBrowser.BrowserModule,
    animations.BrowserAnimationsModule,
    OntimizeWebTranslateModule,
    OPermissionsModule
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @param {?} appModule
 * @param {?=} config
 * @return {?}
 */
function ontimizeBootstrap(appModule, config$$1) {
    /** @type {?} */
    var promise = platformBrowserDynamic.platformBrowserDynamic().bootstrapModule(appModule);
    promise.then(function (moduleRef) {
        console.log('Bootstrap Successful');
        return ontimizePostBootstrap(moduleRef);
    }).catch(function (err) {
        console.error(err.message);
    });
    return promise;
}
/**
 * @param {?} ngModuleRef
 * @return {?}
 */
function ontimizePostBootstrap(ngModuleRef) {
    /** @type {?} */
    var loader = document && document.getElementById('loader-wrapper');
    if (loader && loader.parentNode) {
        loader.parentNode.removeChild(loader);
    }
    return ngModuleRef;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OntimizeWebModule = /** @class */ (function () {
    function OntimizeWebModule() {
    }
    OntimizeWebModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: INTERNAL_ONTIMIZE_MODULES,
                    exports: INTERNAL_ONTIMIZE_MODULES_EXPORTED,
                    entryComponents: [
                        ODialogComponent,
                        OSnackBarComponent
                    ],
                    schemas: [core.CUSTOM_ELEMENTS_SCHEMA]
                },] },
    ];
    return OntimizeWebModule;
}());

exports.ONTIMIZE_MODULES = ONTIMIZE_MODULES;
exports.ONTIMIZE_PROVIDERS = ONTIMIZE_PROVIDERS;
exports.OntimizeWebModule = OntimizeWebModule;
exports.O_INPUTS_OPTIONS = O_INPUTS_OPTIONS;
exports.APP_CONFIG = APP_CONFIG;
exports.AppConfig = AppConfig;
exports.ontimizeBootstrap = ontimizeBootstrap;
exports.ontimizePostBootstrap = ontimizePostBootstrap;
exports.OrderByPipe = OrderByPipe;
exports.OTranslatePipe = OTranslatePipe;
exports.OTranslateModule = OTranslateModule;
exports.ColumnsFilterPipe = ColumnsFilterPipe;
exports.OIntegerPipe = OIntegerPipe;
exports.ORealPipe = ORealPipe;
exports.OMomentPipe = OMomentPipe;
exports.OCurrencyPipe = OCurrencyPipe;
exports.OPercentPipe = OPercentPipe;
exports.LoginService = LoginService$$1;
exports.ONavigationItem = ONavigationItem;
exports.NavigationService = NavigationService;
exports.OntimizeService = OntimizeService$$1;
exports.OntimizeEEService = OntimizeEEService$$1;
exports.EXPORT_PATH_DEFAULT = EXPORT_PATH_DEFAULT$$1;
exports.DOWNLOAD_PATH_DEFAULT = DOWNLOAD_PATH_DEFAULT$$1;
exports.OExportExtension = OExportExtension$$1;
exports.OntimizeExportService = OntimizeExportService$$1;
exports.OntimizeFileService = OntimizeFileService$$1;
exports.MomentService = MomentService;
exports.CurrencyService = CurrencyService;
exports.NumberService = NumberService;
exports.DialogService = DialogService;
exports.SnackBarService = SnackBarService;
exports.OTranslateService = OTranslateService$$1;
exports.dataServiceFactory = dataServiceFactory;
exports.DataServiceFactory = DataServiceFactory;
exports.AuthGuardService = AuthGuardService$$1;
exports.LocalStorageService = LocalStorageService;
exports.appConfigFactory = appConfigFactory;
exports.AppConfigFactory = AppConfigFactory;
exports.AppMenuService = AppMenuService;
exports.OUserInfoService = OUserInfoService;
exports.OModulesInfoService = OModulesInfoService$$1;
exports.dateFormatFactory = dateFormatFactory;
exports.OntimizeMatDateFormats = OntimizeMatDateFormats;
exports.OTranslateHttpLoader = OTranslateHttpLoader;
exports.OTranslateParser = OTranslateParser;
exports.OntimizeServiceResponseParser = OntimizeServiceResponseParser;
exports.OntimizeMatIconRegistry = OntimizeMatIconRegistry;
exports.getPermissionsServiceProvider = getPermissionsServiceProvider;
exports.OPermissionsModule = OPermissionsModule;
exports.Error403Component = Error403Component;
exports.OntimizeEEPermissionsService = OntimizeEEPermissionsService$$1;
exports.OntimizePermissionsService = OntimizePermissionsService$$1;
exports.PermissionsGuardService = PermissionsGuardService;
exports.permissionsServiceFactory = permissionsServiceFactory;
exports.PermissionsServiceFactory = PermissionsServiceFactory;
exports.PermissionsService = PermissionsService;
exports.ORemoteConfigurationService = ORemoteConfigurationService;
exports.StringConverter = StringConverter;
exports.BooleanConverter = BooleanConverter;
exports.NumberConverter = NumberConverter;
exports.InputConverter = InputConverter;
exports.OComponent = OComponent;
exports.OListItemDirective = OListItemDirective;
exports.OKeyboardListenerDirective = OKeyboardListenerDirective;
exports.OHiddenDirective = OHiddenDirective;
exports.DEFAULT_INPUTS_O_BAR_MENU = DEFAULT_INPUTS_O_BAR_MENU;
exports.OBarMenuComponent = OBarMenuComponent;
exports.OBarMenuModule = OBarMenuModule;
exports.DEFAULT_INPUTS_O_BASE_MENU_ITEM = DEFAULT_INPUTS_O_BASE_MENU_ITEM;
exports.OBaseMenuItemClass = OBaseMenuItemClass;
exports.DEFAULT_INPUTS_O_LOCALE_BAR_MENU_ITEM = DEFAULT_INPUTS_O_LOCALE_BAR_MENU_ITEM;
exports.OLocaleBarMenuItemComponent = OLocaleBarMenuItemComponent;
exports.OLocaleBarMenuItemModule = OLocaleBarMenuItemModule;
exports.DEFAULT_INPUTS_O_BAR_MENU_GROUP = DEFAULT_INPUTS_O_BAR_MENU_GROUP;
exports.OBarMenuGroupComponent = OBarMenuGroupComponent;
exports.OBarMenuGroupModule = OBarMenuGroupModule;
exports.DEFAULT_INPUTS_O_BAR_MENU_ITEM = DEFAULT_INPUTS_O_BAR_MENU_ITEM;
exports.OBarMenuItemComponent = OBarMenuItemComponent;
exports.OBarMenuItemModule = OBarMenuItemModule;
exports.DEFAULT_INPUTS_O_BAR_MENU_NESTED = DEFAULT_INPUTS_O_BAR_MENU_NESTED;
exports.OBarMenuNestedComponent = OBarMenuNestedComponent;
exports.OBarMenuNestedModule = OBarMenuNestedModule;
exports.OBarMenuSeparatorComponent = OBarMenuSeparatorComponent;
exports.OBarMenuSeparatorModule = OBarMenuSeparatorModule;
exports.DEFAULT_INPUTS_O_BREADCRUMB = DEFAULT_INPUTS_O_BREADCRUMB$$1;
exports.OBreadcrumbComponent = OBreadcrumbComponent$$1;
exports.OBreadcrumbModule = OBreadcrumbModule$$1;
exports.DEFAULT_INPUTS_O_BUTTON = DEFAULT_INPUTS_O_BUTTON;
exports.OButtonComponent = OButtonComponent;
exports.OButtonModule = OButtonModule;
exports.OButtonToggleModule = OButtonToggleModule;
exports.DEFAULT_INPUTS_O_BUTTON_TOGGLE_GROUP = DEFAULT_INPUTS_O_BUTTON_TOGGLE_GROUP;
exports.DEFAULT_OUTPUTS_O_BUTTON_TOGGLE_GROUP = DEFAULT_OUTPUTS_O_BUTTON_TOGGLE_GROUP;
exports.OButtonToggleGroupComponent = OButtonToggleGroupComponent;
exports.DEFAULT_INPUTS_O_COLUMN = DEFAULT_INPUTS_O_COLUMN;
exports.OColumnComponent = OColumnComponent;
exports.OColumnModule = OColumnModule;
exports.DEFAULT_INPUTS_O_ROW = DEFAULT_INPUTS_O_ROW;
exports.ORowComponent = ORowComponent;
exports.ORowModule = ORowModule;
exports.DEFAULT_INPUTS_O_COLUMN_COLLAPSIBLE = DEFAULT_INPUTS_O_COLUMN_COLLAPSIBLE;
exports.OColumnCollapsibleComponent = OColumnCollapsibleComponent;
exports.OColumnCollapsibleModule = OColumnCollapsibleModule;
exports.DEFAULT_INPUTS_O_ROW_COLLAPSIBLE = DEFAULT_INPUTS_O_ROW_COLLAPSIBLE;
exports.ORowCollapsibleComponent = ORowCollapsibleComponent;
exports.ORowCollapsibleModule = ORowCollapsibleModule;
exports.OContextMenuModule = OContextMenuModule;
exports.ODialogComponent = ODialogComponent;
exports.ODialogModule = ODialogModule;
exports.ODialogConfig = ODialogConfig;
exports.OSnackBarConfig = OSnackBarConfig;
exports.OSnackBarComponent = OSnackBarComponent;
exports.OSnackBarModule = OSnackBarModule;
exports.DEFAULT_INPUTS_O_FILTER_BUILDER = DEFAULT_INPUTS_O_FILTER_BUILDER$$1;
exports.DEFAULT_OUTPUTS_O_FILTER_BUILDER = DEFAULT_OUTPUTS_O_FILTER_BUILDER$$1;
exports.OFilterBuilderComponent = OFilterBuilderComponent$$1;
exports.OFilterBuilderModule = OFilterBuilderModule$$1;
exports.OFilterBuilderClearDirective = OFilterBuilderClearDirective$$1;
exports.OFilterBuilderQueryDirective = OFilterBuilderQueryDirective$$1;
exports.DEFAULT_INPUTS_O_FORM = DEFAULT_INPUTS_O_FORM;
exports.DEFAULT_OUTPUTS_O_FORM = DEFAULT_OUTPUTS_O_FORM;
exports.OFormComponent = OFormComponent;
exports.OFormModule = OFormModule;
exports.DEFAULT_INPUTS_O_FORM_TOOLBAR = DEFAULT_INPUTS_O_FORM_TOOLBAR;
exports.OFormToolbarComponent = OFormToolbarComponent;
exports.OFormToolbarModule = OFormToolbarModule;
exports.OFormValue = OFormValue;
exports.DEFAULT_INPUTS_O_FORM_CONTAINER = DEFAULT_INPUTS_O_FORM_CONTAINER$$1;
exports.OFormContainerComponent = OFormContainerComponent$$1;
exports.OFormContainerModule = OFormContainerModule$$1;
exports.OFormCacheClass = OFormCacheClass;
exports.OFormNavigationComponent = OFormNavigationComponent;
exports.OFormNavigationClass = OFormNavigationClass;
exports.DEFAULT_INPUTS_O_IMAGE = DEFAULT_INPUTS_O_IMAGE;
exports.DEFAULT_OUTPUTS_O_IMAGE = DEFAULT_OUTPUTS_O_IMAGE;
exports.OImageComponent = OImageComponent;
exports.OImageModule = OImageModule;
exports.DEFAULT_INPUTS_O_CHECKBOX = DEFAULT_INPUTS_O_CHECKBOX;
exports.DEFAULT_OUTPUTS_O_CHECKBOX = DEFAULT_OUTPUTS_O_CHECKBOX;
exports.OCheckboxComponent = OCheckboxComponent;
exports.OCheckboxModule = OCheckboxModule;
exports.DEFAULT_INPUTS_O_COMBO = DEFAULT_INPUTS_O_COMBO;
exports.DEFAULT_OUTPUTS_O_COMBO = DEFAULT_OUTPUTS_O_COMBO;
exports.OComboComponent = OComboComponent;
exports.OComboModule = OComboModule;
exports.OComboSearchComponent = OComboSearchComponent;
exports.DEFAULT_INPUTS_O_CURRENCY_INPUT = DEFAULT_INPUTS_O_CURRENCY_INPUT;
exports.DEFAULT_OUTPUTS_O_CURRENCY_INPUT = DEFAULT_OUTPUTS_O_CURRENCY_INPUT;
exports.OCurrencyInputComponent = OCurrencyInputComponent;
exports.OCurrencyInputModule = OCurrencyInputModule;
exports.DEFAULT_OUTPUTS_O_DATE_INPUT = DEFAULT_OUTPUTS_O_DATE_INPUT;
exports.DEFAULT_INPUTS_O_DATE_INPUT = DEFAULT_INPUTS_O_DATE_INPUT;
exports.ODateInputComponent = ODateInputComponent;
exports.ODateInputModule = ODateInputModule;
exports.DEFAULT_INPUTS_O_EMAIL_INPUT = DEFAULT_INPUTS_O_EMAIL_INPUT;
exports.DEFAULT_OUTPUTS_O_EMAIL_INPUT = DEFAULT_OUTPUTS_O_EMAIL_INPUT;
exports.OEmailInputComponent = OEmailInputComponent;
exports.OEmailInputModule = OEmailInputModule;
exports.DEFAULT_INPUTS_O_FILE_INPUT = DEFAULT_INPUTS_O_FILE_INPUT;
exports.DEFAULT_OUTPUTS_O_FILE_INPUT = DEFAULT_OUTPUTS_O_FILE_INPUT;
exports.OFileInputComponent = OFileInputComponent;
exports.OFileInputModule = OFileInputModule;
exports.OFileItem = OFileItem;
exports.OFileUploader = OFileUploader;
exports.DEFAULT_INPUTS_O_HTML_INPUT = DEFAULT_INPUTS_O_HTML_INPUT;
exports.DEFAULT_OUTPUTS_O_HTML_INPUT = DEFAULT_OUTPUTS_O_HTML_INPUT;
exports.OHTMLInputComponent = OHTMLInputComponent;
exports.OHTMLInputModule = OHTMLInputModule;
exports.DEFAULT_INPUTS_O_INTEGER_INPUT = DEFAULT_INPUTS_O_INTEGER_INPUT;
exports.DEFAULT_OUTPUTS_O_INTEGER_INPUT = DEFAULT_OUTPUTS_O_INTEGER_INPUT;
exports.OIntegerInputComponent = OIntegerInputComponent;
exports.OIntegerInputModule = OIntegerInputModule;
exports.DEFAULT_INPUTS_O_LIST_PICKER = DEFAULT_INPUTS_O_LIST_PICKER$1;
exports.DEFAULT_OUTPUTS_O_LIST_PICKER = DEFAULT_OUTPUTS_O_LIST_PICKER;
exports.OListPickerComponent = OListPickerComponent;
exports.OListPickerModule = OListPickerModule;
exports.DEFAULT_INPUTS_O_NIF_INPUT = DEFAULT_INPUTS_O_NIF_INPUT;
exports.DEFAULT_OUTPUTS_O_NIF_INPUT = DEFAULT_OUTPUTS_O_NIF_INPUT;
exports.ONIFInputComponent = ONIFInputComponent;
exports.ONIFInputModule = ONIFInputModule;
exports.DEFAULT_INPUTS_O_PASSWORD_INPUT = DEFAULT_INPUTS_O_PASSWORD_INPUT;
exports.DEFAULT_OUTPUTS_O_PASSWORD_INPUT = DEFAULT_OUTPUTS_O_PASSWORD_INPUT;
exports.OPasswordInputComponent = OPasswordInputComponent;
exports.OPasswordInputModule = OPasswordInputModule;
exports.DEFAULT_INPUTS_O_PERCENT_INPUT = DEFAULT_INPUTS_O_PERCENT_INPUT;
exports.DEFAULT_OUTPUTS_O_PERCENT_INPUT = DEFAULT_OUTPUTS_O_PERCENT_INPUT;
exports.OPercentInputComponent = OPercentInputComponent;
exports.OPercentInputModule = OPercentInputModule;
exports.DEFAULT_INPUTS_O_REAL_INPUT = DEFAULT_INPUTS_O_REAL_INPUT;
exports.DEFAULT_OUTPUTS_O_REAL_INPUT = DEFAULT_OUTPUTS_O_REAL_INPUT;
exports.ORealInputComponent = ORealInputComponent;
exports.ORealInputModule = ORealInputModule;
exports.DEFAULT_INPUTS_O_SEARCH_INPUT = DEFAULT_INPUTS_O_SEARCH_INPUT;
exports.DEFAULT_OUTPUTS_O_SEARCH_INPUT = DEFAULT_OUTPUTS_O_SEARCH_INPUT;
exports.OSearchInputComponent = OSearchInputComponent;
exports.OSearchInputModule = OSearchInputModule;
exports.DEFAULT_INPUTS_O_TEXT_INPUT = DEFAULT_INPUTS_O_TEXT_INPUT;
exports.DEFAULT_OUTPUTS_O_TEXT_INPUT = DEFAULT_OUTPUTS_O_TEXT_INPUT;
exports.OTextInputComponent = OTextInputComponent;
exports.OTextInputModule = OTextInputModule;
exports.DEFAULT_INPUTS_O_TEXTAREA_INPUT = DEFAULT_INPUTS_O_TEXTAREA_INPUT;
exports.DEFAULT_OUTPUTS_O_TEXTAREA_INPUT = DEFAULT_OUTPUTS_O_TEXTAREA_INPUT;
exports.OTextareaInputComponent = OTextareaInputComponent;
exports.OTextareaInputModule = OTextareaInputModule;
exports.DEFAULT_INPUTS_O_ERROR = DEFAULT_INPUTS_O_ERROR;
exports.OErrorComponent = OErrorComponent;
exports.OErrorModule = OErrorModule;
exports.DEFAULT_INPUTS_O_VALIDATOR = DEFAULT_INPUTS_O_VALIDATOR;
exports.OValidatorComponent = OValidatorComponent;
exports.OValidatorModule = OValidatorModule;
exports.DEFAULT_INPUTS_O_FORM_SERVICE_COMPONENT = DEFAULT_INPUTS_O_FORM_SERVICE_COMPONENT;
exports.DEFAULT_OUTPUTS_O_FORM_SERVICE_COMPONENT = DEFAULT_OUTPUTS_O_FORM_SERVICE_COMPONENT;
exports.OFormServiceComponent = OFormServiceComponent;
exports.DEFAULT_INPUTS_O_HOUR_INPUT = DEFAULT_INPUTS_O_HOUR_INPUT;
exports.DEFAULT_OUTPUTS_O_HOUR_INPUT = DEFAULT_OUTPUTS_O_HOUR_INPUT;
exports.OHourInputComponent = OHourInputComponent;
exports.OHourInputModule = OHourInputModule;
exports.DEFAULT_INPUTS_O_TIME_INPUT = DEFAULT_INPUTS_O_TIME_INPUT;
exports.DEFAULT_OUTPUTS_O_TIME_INPUT = DEFAULT_OUTPUTS_O_TIME_INPUT;
exports.OTimeInputComponent = OTimeInputComponent;
exports.OTimeInputModule = OTimeInputModule;
exports.DEFAULT_INPUTS_O_RADIO = DEFAULT_INPUTS_O_RADIO;
exports.DEFAULT_OUTPUTS_O_RADIO = DEFAULT_OUTPUTS_O_RADIO;
exports.ORadioComponent = ORadioComponent;
exports.ORadioModule = ORadioModule;
exports.DEFAULT_INPUTS_O_SLIDETOGGLE = DEFAULT_INPUTS_O_SLIDETOGGLE;
exports.DEFAULT_OUTPUTS_O_SLIDETOGGLE = DEFAULT_OUTPUTS_O_SLIDETOGGLE;
exports.OSlideToggleComponent = OSlideToggleComponent;
exports.OSlideToggleModule = OSlideToggleModule;
exports.DEFAULT_INPUTS_O_SLIDER_INPUT = DEFAULT_INPUTS_O_SLIDER_INPUT$$1;
exports.DEFAULT_OUTPUTS_O_SLIDER_INPUT = DEFAULT_OUTPUTS_O_SLIDER_INPUT$$1;
exports.OSliderComponent = OSliderComponent$$1;
exports.OSliderModule = OSliderModule$$1;
exports.DEFAULT_OUTPUTS_O_DATERANGE_INPUT = DEFAULT_OUTPUTS_O_DATERANGE_INPUT;
exports.DEFAULT_INPUTS_O_DATERANGE_INPUT = DEFAULT_INPUTS_O_DATERANGE_INPUT;
exports.ODateRangeInputComponent = ODateRangeInputComponent;
exports.ODateRangeInputModule = ODateRangeInputModule;
exports.OFormControl = OFormControl;
exports.DEFAULT_INPUTS_O_LIST = DEFAULT_INPUTS_O_LIST;
exports.DEFAULT_OUTPUTS_O_LIST = DEFAULT_OUTPUTS_O_LIST;
exports.OListComponent = OListComponent;
exports.OListModule = OListModule;
exports.OListItemComponent = OListItemComponent;
exports.OListItemModule = OListItemModule;
exports.DEFAULT_INPUTS_O_LIST_ITEM_AVATAR = DEFAULT_INPUTS_O_LIST_ITEM_AVATAR;
exports.DEFAULT_OUTPUTS_O_LIST_ITEM_AVATAR = DEFAULT_OUTPUTS_O_LIST_ITEM_AVATAR;
exports.OListItemAvatarComponent = OListItemAvatarComponent;
exports.OListItemAvatarModule = OListItemAvatarModule;
exports.DEFAULT_INPUTS_O_LIST_ITEM_TEXT = DEFAULT_INPUTS_O_LIST_ITEM_TEXT;
exports.DEFAULT_OUTPUTS_O_LIST_ITEM_TEXT = DEFAULT_OUTPUTS_O_LIST_ITEM_TEXT;
exports.OListItemTextComponent = OListItemTextComponent;
exports.OListItemTextModule = OListItemTextModule;
exports.DEFAULT_INPUTS_O_LIST_ITEM_CARD = DEFAULT_INPUTS_O_LIST_ITEM_CARD;
exports.DEFAULT_OUTPUTS_O_LIST_ITEM_CARD = DEFAULT_OUTPUTS_O_LIST_ITEM_CARD;
exports.OListItemCardComponent = OListItemCardComponent;
exports.OListItemCardModule = OListItemCardModule;
exports.DEFAULT_INPUTS_O_LIST_ITEM_CARD_IMAGE = DEFAULT_INPUTS_O_LIST_ITEM_CARD_IMAGE;
exports.DEFAULT_OUTPUTS_O_LIST_ITEM_CARD_IMAGE = DEFAULT_OUTPUTS_O_LIST_ITEM_CARD_IMAGE;
exports.OListItemCardImageComponent = OListItemCardImageComponent;
exports.OListItemCardImageModule = OListItemCardImageModule;
exports.NAME_COLUMN_SELECT = NAME_COLUMN_SELECT;
exports.DEFAULT_INPUTS_O_TABLE = DEFAULT_INPUTS_O_TABLE;
exports.DEFAULT_OUTPUTS_O_TABLE = DEFAULT_OUTPUTS_O_TABLE;
exports.OColumn = OColumn;
exports.OTableOptions = OTableOptions;
exports.OTableComponent = OTableComponent;
exports.OTableModule = OTableModule;
exports.OTableDao = OTableDao;
exports.SCROLLVIRTUAL = SCROLLVIRTUAL;
exports.OTableScrollEvent = OTableScrollEvent;
exports.OTableDataSource = OTableDataSource;
exports.DEFAULT_INPUTS_O_TABLE_COLUMN = DEFAULT_INPUTS_O_TABLE_COLUMN;
exports.DEFAULT_OUTPUTS_O_TABLE_COLUMN = DEFAULT_OUTPUTS_O_TABLE_COLUMN;
exports.OTableColumnComponent = OTableColumnComponent;
exports.O_TABLE_CELL_RENDERERS = O_TABLE_CELL_RENDERERS;
exports.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_ACTION = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_ACTION;
exports.DEFAULT_OUTPUTS_O_TABLE_CELL_RENDERER_ACTION = DEFAULT_OUTPUTS_O_TABLE_CELL_RENDERER_ACTION;
exports.OTableCellRendererActionComponent = OTableCellRendererActionComponent;
exports.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_BOOLEAN = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_BOOLEAN;
exports.OTableCellRendererBooleanComponent = OTableCellRendererBooleanComponent;
exports.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_CURRENCY = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_CURRENCY;
exports.OTableCellRendererCurrencyComponent = OTableCellRendererCurrencyComponent;
exports.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_DATE = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_DATE;
exports.OTableCellRendererDateComponent = OTableCellRendererDateComponent;
exports.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_IMAGE = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_IMAGE;
exports.DEFAULT_OUTPUTS_O_TABLE_CELL_RENDERER_IMAGE = DEFAULT_OUTPUTS_O_TABLE_CELL_RENDERER_IMAGE;
exports.OTableCellRendererImageComponent = OTableCellRendererImageComponent;
exports.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_INTEGER = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_INTEGER;
exports.OTableCellRendererIntegerComponent = OTableCellRendererIntegerComponent;
exports.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_PERCENTAGE = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_PERCENTAGE;
exports.OTableCellRendererPercentageComponent = OTableCellRendererPercentageComponent;
exports.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_REAL = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_REAL;
exports.OTableCellRendererRealComponent = OTableCellRendererRealComponent;
exports.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_SERVICE = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_SERVICE;
exports.OTableCellRendererServiceComponent = OTableCellRendererServiceComponent;
exports.OBaseTableCellRenderer = OBaseTableCellRenderer;
exports.DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_TIME = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_TIME;
exports.OTableCellRendererTimeComponent = OTableCellRendererTimeComponent;
exports.O_TABLE_CELL_EDITORS = O_TABLE_CELL_EDITORS;
exports.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_BOOLEAN = DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_BOOLEAN;
exports.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_BOOLEAN = DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_BOOLEAN;
exports.OTableCellEditorBooleanComponent = OTableCellEditorBooleanComponent;
exports.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_DATE = DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_DATE;
exports.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_DATE = DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_DATE;
exports.OTableCellEditorDateComponent = OTableCellEditorDateComponent;
exports.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_INTEGER = DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_INTEGER;
exports.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_INTEGER = DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_INTEGER;
exports.OTableCellEditorIntegerComponent = OTableCellEditorIntegerComponent;
exports.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_REAL = DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_REAL;
exports.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_REAL = DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_REAL;
exports.OTableCellEditorRealComponent = OTableCellEditorRealComponent;
exports.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TEXT = DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TEXT;
exports.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TEXT = DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TEXT;
exports.OTableCellEditorTextComponent = OTableCellEditorTextComponent;
exports.OBaseTableCellEditor = OBaseTableCellEditor;
exports.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TIME = DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TIME;
exports.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TIME = DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TIME;
exports.OTableCellEditorTimeComponent = OTableCellEditorTimeComponent;
exports.O_TABLE_DIALOGS = O_TABLE_DIALOGS;
exports.OTableApplyConfigurationDialogComponent = OTableApplyConfigurationDialogComponent;
exports.OTableExportConfiguration = OTableExportConfiguration;
exports.OTableExportDialogComponent = OTableExportDialogComponent;
exports.OTableStoreConfigurationDialogComponent = OTableStoreConfigurationDialogComponent;
exports.OTableLoadFilterDialogComponent = OTableLoadFilterDialogComponent;
exports.OTableStoreFilterDialogComponent = OTableStoreFilterDialogComponent;
exports.OTableVisibleColumnsDialogComponent = OTableVisibleColumnsDialogComponent;
exports.OTableFilterByColumnDataDialogComponent = OTableFilterByColumnDataDialogComponent;
exports.O_TABLE_FOOTER_COMPONENTS = O_TABLE_FOOTER_COMPONENTS;
exports.DEFAULT_PAGINATOR_TABLE = DEFAULT_PAGINATOR_TABLE;
exports.OTablePaginatorComponent = OTablePaginatorComponent;
exports.OTableMatPaginatorIntl = OTableMatPaginatorIntl;
exports.OColumnAggregate = OColumnAggregate;
exports.DEFAULT_TABLE_COLUMN_AGGREGATE = DEFAULT_TABLE_COLUMN_AGGREGATE;
exports.OTableColumnAggregateComponent = OTableColumnAggregateComponent;
exports.O_TABLE_HEADER_COMPONENTS = O_TABLE_HEADER_COMPONENTS;
exports.DEFAULT_INPUTS_O_TABLE_BUTTON = DEFAULT_INPUTS_O_TABLE_BUTTON;
exports.DEFAULT_OUTPUTS_O_TABLE_BUTTON = DEFAULT_OUTPUTS_O_TABLE_BUTTON;
exports.OTableButtonComponent = OTableButtonComponent;
exports.DEFAULT_INPUTS_O_TABLE_BUTTONS = DEFAULT_INPUTS_O_TABLE_BUTTONS;
exports.DEFAULT_OUTPUTS_O_TABLE_BUTTONS = DEFAULT_OUTPUTS_O_TABLE_BUTTONS;
exports.OTableButtonsComponent = OTableButtonsComponent;
exports.DEFAULT_INPUTS_O_TABLE_COLUMN_RESIZER = DEFAULT_INPUTS_O_TABLE_COLUMN_RESIZER;
exports.DEFAULT_OUTPUTS_O_TABLE_COLUMN_RESIZER = DEFAULT_OUTPUTS_O_TABLE_COLUMN_RESIZER;
exports.OTableColumnResizerComponent = OTableColumnResizerComponent;
exports.DEFAULT_INPUTS_O_TABLE_COLUMN_FILTER = DEFAULT_INPUTS_O_TABLE_COLUMN_FILTER;
exports.DEFAULT_OUTPUTS_O_TABLE_COLUMN_FILTER = DEFAULT_OUTPUTS_O_TABLE_COLUMN_FILTER;
exports.ColumnValueFilterOperator = ColumnValueFilterOperator;
exports.OTableColumnsFilterComponent = OTableColumnsFilterComponent;
exports.DEFAULT_INPUTS_O_TABLE_MENU = DEFAULT_INPUTS_O_TABLE_MENU$$1;
exports.DEFAULT_OUTPUTS_O_TABLE_MENU = DEFAULT_OUTPUTS_O_TABLE_MENU$$1;
exports.OTableMenuComponent = OTableMenuComponent$$1;
exports.DEFAULT_INPUTS_O_TABLE_OPTION = DEFAULT_INPUTS_O_TABLE_OPTION;
exports.DEFAULT_OUTPUTS_O_TABLE_OPTION = DEFAULT_OUTPUTS_O_TABLE_OPTION;
exports.OTableOptionComponent = OTableOptionComponent;
exports.DEFAULT_INPUTS_O_TABLE_INSERTABLE_ROW = DEFAULT_INPUTS_O_TABLE_INSERTABLE_ROW;
exports.DEFAULT_OUTPUTS_O_TABLE_INSERTABLE_ROW = DEFAULT_OUTPUTS_O_TABLE_INSERTABLE_ROW;
exports.OTableInsertableRowComponent = OTableInsertableRowComponent;
exports.DEFAULT_INPUTS_O_TABLE_QUICKFILTER = DEFAULT_INPUTS_O_TABLE_QUICKFILTER;
exports.DEFAULT_OUTPUTS_O_TABLE_QUICKFILTER = DEFAULT_OUTPUTS_O_TABLE_QUICKFILTER;
exports.OTableQuickfilterComponent = OTableQuickfilterComponent;
exports.FilterExpressionUtils = FilterExpressionUtils;
exports.OBaseComponent = OBaseComponent;
exports.OValueChangeEvent = OValueChangeEvent;
exports.DEFAULT_INPUTS_O_FORM_DATA_COMPONENT = DEFAULT_INPUTS_O_FORM_DATA_COMPONENT;
exports.DEFAULT_OUTPUTS_O_FORM_DATA_COMPONENT = DEFAULT_OUTPUTS_O_FORM_DATA_COMPONENT;
exports.OFormDataComponent = OFormDataComponent;
exports.DEFAULT_INPUTS_O_SERVICE_BASE_COMPONENT = DEFAULT_INPUTS_O_SERVICE_BASE_COMPONENT;
exports.OServiceBaseComponent = OServiceBaseComponent;
exports.DEFAULT_INPUTS_O_SERVICE_COMPONENT = DEFAULT_INPUTS_O_SERVICE_COMPONENT$$1;
exports.OServiceComponent = OServiceComponent$$1;
exports.DEFAULT_INPUTS_O_CONTAINER = DEFAULT_INPUTS_O_CONTAINER;
exports.OContainerComponent = OContainerComponent;
exports.DEFAULT_INPUTS_O_USER_INFO = DEFAULT_INPUTS_O_USER_INFO;
exports.DEFAULT_OUTPUTS_O_USER_INFO = DEFAULT_OUTPUTS_O_USER_INFO;
exports.OUserInfoComponent = OUserInfoComponent;
exports.OUserInfoModule = OUserInfoModule;
exports.DEFAULT_INPUTS_O_LANGUAGE_SELECTOR = DEFAULT_INPUTS_O_LANGUAGE_SELECTOR;
exports.DEFAULT_OUTPUTS_LANGUAGE_SELECTOR = DEFAULT_OUTPUTS_LANGUAGE_SELECTOR;
exports.OLanguageSelectorComponent = OLanguageSelectorComponent;
exports.OLanguageSelectorModule = OLanguageSelectorModule;
exports.DEFAULT_INPUTS_O_MENU_CARD = DEFAULT_INPUTS_O_MENU_CARD;
exports.DEFAULT_OUTPUTS_O_MENU_CARD = DEFAULT_OUTPUTS_O_MENU_CARD;
exports.OCardMenuItemComponent = OCardMenuItemComponent;
exports.OCardMenuItemModule = OCardMenuItemModule;
exports.DEFAULT_INPUTS_O_GRID = DEFAULT_INPUTS_O_GRID$$1;
exports.DEFAULT_OUTPUTS_O_GRID = DEFAULT_OUTPUTS_O_GRID$$1;
exports.OGridComponent = OGridComponent$$1;
exports.OGridModule = OGridModule$$1;
exports.DEFAULT_INPUTS_O_APP_LAYOUT = DEFAULT_INPUTS_O_APP_LAYOUT;
exports.DEFAULT_OUTPUTS_O_APP_LAYOUT = DEFAULT_OUTPUTS_O_APP_LAYOUT;
exports.OAppLayoutComponent = OAppLayoutComponent;
exports.OAppLayoutModule = OAppLayoutModule;
exports.OAppLayoutHeaderComponent = OAppLayoutHeaderComponent;
exports.DEFAULT_INPUTS_O_APP_LAYOUT_SIDENAV = DEFAULT_INPUTS_O_APP_LAYOUT_SIDENAV;
exports.OAppLayoutSidenavComponent = OAppLayoutSidenavComponent;
exports.DEFAULT_INPUTS_O_APP_HEADER = DEFAULT_INPUTS_O_APP_HEADER;
exports.DEFAULT_OUTPUTS_O_APP_HEADER = DEFAULT_OUTPUTS_O_APP_HEADER;
exports.OAppHeaderComponent = OAppHeaderComponent;
exports.OAppHeaderModule = OAppHeaderModule;
exports.DEFAULT_INPUTS_O_APP_SIDENAV = DEFAULT_INPUTS_O_APP_SIDENAV;
exports.DEFAULT_OUTPUTS_O_APP_SIDENAV = DEFAULT_OUTPUTS_O_APP_SIDENAV;
exports.OAppSidenavComponent = OAppSidenavComponent;
exports.OAppSidenavModule = OAppSidenavModule;
exports.DEFAULT_INPUTS_O_MENU_LAYOUT = DEFAULT_INPUTS_O_MENU_LAYOUT;
exports.DEFAULT_OUTPUTS_O_MENU_LAYOUT = DEFAULT_OUTPUTS_O_MENU_LAYOUT;
exports.OCardMenuLayoutComponent = OCardMenuLayoutComponent;
exports.OCardMenuLayoutModule = OCardMenuLayoutModule;
exports.DEFAULT_INPUTS_O_FORM_LAYOUT_MANAGER = DEFAULT_INPUTS_O_FORM_LAYOUT_MANAGER;
exports.DEFAULT_OUTPUTS_O_FORM_LAYOUT_MANAGER = DEFAULT_OUTPUTS_O_FORM_LAYOUT_MANAGER;
exports.OFormLayoutManagerComponent = OFormLayoutManagerComponent;
exports.OFormLayoutManagerModule = OFormLayoutManagerModule;
exports.DEFAULT_INPUTS_O_FORM_LAYOUT_TABGROUP_OPTIONS = DEFAULT_INPUTS_O_FORM_LAYOUT_TABGROUP_OPTIONS;
exports.OFormLayoutTabGroupOptionsComponent = OFormLayoutTabGroupOptionsComponent;
exports.DEFAULT_INPUTS_O_FORM_LAYOUT_DIALOG_OPTIONS = DEFAULT_INPUTS_O_FORM_LAYOUT_DIALOG_OPTIONS;
exports.OFormLayoutDialogOptionsComponent = OFormLayoutDialogOptionsComponent;
exports.noop = noop$1;
exports.ObservableWrapper = ObservableWrapper;
exports.Base64 = Base64;
exports.Events = Events;
exports.PermissionsUtils = PermissionsUtils;
exports.SQLTypes = SQLTypes;
exports.Util = Util;
exports.ServiceUtils = ServiceUtils$$1;
exports.Codes = Codes;
exports.OntimizeMomentDateAdapter = OntimizeMomentDateAdapter;
exports.OCustomMaterialModule = OCustomMaterialModule;
exports.OSharedModule = OSharedModule;
exports.O_MAT_ERROR_OPTIONS = O_MAT_ERROR_OPTIONS;
exports.OMatErrorComponent = OMatErrorComponent;
exports.OMatErrorModule = OMatErrorModule;
exports.TWELVE_HOUR_FORMAT_PATTERN = TWELVE_HOUR_FORMAT_PATTERN;
exports.TWENTY_FOUR_HOUR_FORMAT_PATTERN = TWENTY_FOUR_HOUR_FORMAT_PATTERN;
exports.OValidators = OValidators;
exports.de = DEFAULT_INPUTS_O_APP_SIDENAV_IMAGE;
exports.df = DEFAULT_OUTPUTS_O_APP_SIDENAV_IMAGE;
exports.dg = OAppSidenavImageComponent;
exports.dh = OAppSidenavImageModule;
exports.cw = DEFAULT_INPUTS_O_APP_SIDENAV_MENU_GROUP;
exports.cx = DEFAULT_OUTPUTS_O_APP_SIDENAV_MENU_GROUP;
exports.cy = OAppSidenavMenuGroupComponent;
exports.cz = OAppSidenavMenuGroupModule;
exports.da = DEFAULT_INPUTS_O_APP_SIDENAV_MENU_ITEM;
exports.db = DEFAULT_OUTPUTS_O_APP_SIDENAV_MENU_ITEM;
exports.dc = OAppSidenavMenuItemComponent;
exports.dd = OAppSidenavMenuItemModule;
exports.bd = DEFAULT_INPUTS_O_BUTTON_TOGGLE;
exports.be = DEFAULT_OUTPUTS_O_BUTTON_TOGGLE;
exports.bf = OButtonToggleComponent;
exports.bg = OContainerCollapsibleComponent;
exports.bw = DEFAULT_CONTEXT_MENU_GROUP_INPUTS$$1;
exports.bx = OContextMenuGroupComponent$$1;
exports.bt = DEFAULT_CONTEXT_MENU_ITEM_OUTPUTS;
exports.bu = DEFAULT_INPUTS_O_CONTEXT_MENU_ITEM;
exports.bv = OContextMenuItemComponent;
exports.by = DEFAULT_CONTEXT_MENU_ITEM_INPUTS$$1;
exports.bz = OContextMenuSeparatorComponent$$1;
exports.bh = DEFAULT_CONTEXT_MENU_CONTENT_INPUTS;
exports.bi = DEFAULT_CONTEXT_MENU_CONTENT_OUTPUTS;
exports.bj = OContextMenuContentComponent;
exports.bm = DEFAULT_CONTEXT_MENU_CONTENT_ITEM_INPUTS;
exports.bn = OWrapperContentMenuComponent;
exports.bk = DEFAULT_INPUTS_O_CONTEXT_MENU_ITEMS;
exports.bl = OComponentMenuItems;
exports.bp = DEFAULT_OUTPUTS_O_CONTEXT_MENU;
exports.bq = OContextMenuComponent;
exports.br = DEFAULT_CONTEXT_MENU_DIRECTIVE_INPUTS;
exports.bs = OContextMenuDirective;
exports.bo = OContextMenuService;
exports.ca = CanDeactivateFormGuard;
exports.do = DEFAULT_INPUTS_O_GRID_ITEM;
exports.dp = OGridItemComponent;
exports.dq = OGridItemModule;
exports.dr = OGridItemDirective;
exports.cb = OFullScreenDialogComponent;
exports.dt = ODaterangepickerDirective;
exports.ds = DaterangepickerComponent;
exports.ce = DEFAULT_INPUTS_O_LIST_PICKER;
exports.cf = OListPickerDialogComponent;
exports.ch = OListItemCardRenderer;
exports.cg = OListItemTextRenderer;
exports.cc = CKEditorComponent;
exports.cd = CKEditorModule;
exports.cn = DEFAULT_INPUTS_O_TABLE_COLUMN_CALCULATED;
exports.co = OTableColumnCalculatedComponent;
exports.cl = DEFAULT_INPUTS_O_TABLE_CELL_RENDERER_TRANSLATE;
exports.cm = OTableCellRendererTranslateComponent;
exports.cp = DEFAULT_TABLE_CONTEXT_MENU_INPUTS;
exports.cq = OTableContextMenuComponent;
exports.cu = OTableBaseDialogClass;
exports.cr = OTableRowDirective;
exports.ci = OMatSort;
exports.cj = OMatSortHeader;
exports.cv = OMatSortModule;
exports.ck = OTableExpandedFooter;
exports.z = ONTIMIZE_DIRECTIVES;
exports.d = INTERNAL_ONTIMIZE_MODULES;
exports.a = INTERNAL_ONTIMIZE_MODULES_EXPORTED;
exports.b = OHttpLoaderFactory;
exports.c = OTranslateParserFactory;
exports.e = OntimizeWebTranslateModule;
exports.f = appInitializerFactory;
exports.g = bindEvents;
exports.u = getAppMenuServiceProvider;
exports.o = getCurrencyServiceProvider;
exports.q = getDialogServiceProvider;
exports.h = getEvents;
exports.t = getLocalStorageServiceProvider;
exports.l = getLoginServiceProvider;
exports.n = getMomentServiceProvider;
exports.m = getNavigationServiceProvider;
exports.p = getNumberServiceProvider;
exports.w = getOModulesInfoServiceProvider;
exports.y = getORemoteConfigurationService;
exports.v = getOUserInfoServiceProvider;
exports.k = getOntimizeExportServiceProvider;
exports.j = getOntimizeFileServiceProvider;
exports.i = getOntimizeServiceProvider;
exports.x = getOntimizeServiceResponseParser;
exports.r = getSnackBarServiceProvider;
exports.s = getTranslateServiceProvider;
exports.bb = DEFAULT_INPUTS_O_LOCKER;
exports.bc = OLockerDirective;
exports.ba = OTabGroupDirective;
exports.di = OFormLayoutDialogComponent;
exports.dj = OFormLayoutManagerContentDirective;
exports.dn = CanActivateFormLayoutChildGuard;
exports.dk = DEFAULT_INPUTS_O_FORM_LAYOUT_TABGROUP;
exports.dl = DEFAULT_OUTPUTS_O_FORM_LAYOUT_TABGROUP;
exports.dm = OFormLayoutTabGroupComponent;
exports.dv = OFormLayoutManagerService;
exports.dw = ShareCanActivateChildService;
exports.du = OHttp;
exports.Observable = Observable;
exports.Subject = Subject;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ontimize-web-ngx.umd.js.map
