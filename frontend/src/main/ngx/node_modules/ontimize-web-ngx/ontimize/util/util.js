import { Base64 } from './base64';
import { Codes } from './codes';
var Util = (function () {
    function Util() {
    }
    Util.isObject = function (val) {
        var valType = typeof val;
        return valType === 'object';
    };
    Util.isArray = function (val) {
        return val instanceof Array;
    };
    Util.parseBoolean = function (value, defaultValue) {
        if ((typeof value === 'string') && (value.toUpperCase() === 'TRUE' || value.toUpperCase() === 'YES')) {
            return true;
        }
        else if ((typeof value === 'string') && (value.toUpperCase() === 'FALSE' || value.toUpperCase() === 'NO')) {
            return false;
        }
        else if (Util.isDefined(defaultValue)) {
            return defaultValue;
        }
        return false;
    };
    Util.parseArray = function (value, excludeRepeated) {
        if (excludeRepeated === void 0) { excludeRepeated = false; }
        var result = [];
        if (value) {
            result = value.split(Codes.ARRAY_INPUT_SEPARATOR);
        }
        if (excludeRepeated && result.length > 0) {
            result = Array.from(new Set(result));
        }
        return result;
    };
    Util.parseParentKeysEquivalences = function (pKeysArray, separator) {
        if (separator === void 0) { separator = ':'; }
        var equivalences = {};
        if (pKeysArray && pKeysArray.length > 0) {
            pKeysArray.forEach(function (item) {
                var aux = item.split(separator);
                if (aux && aux.length === 2) {
                    if (/.+\[.+\]/.test(aux[1])) {
                        var equivKey = aux[1].substring(0, aux[1].indexOf('['));
                        var equivValue = aux[1].substring(aux[1].indexOf('[') + 1, aux[1].indexOf(']'));
                        var equiv = {};
                        equiv[equivKey] = equivValue;
                        equivalences[aux[0]] = equiv;
                    }
                    else {
                        equivalences[aux[0]] = aux[1];
                    }
                }
                else if (aux && aux.length === 1) {
                    equivalences[item] = item;
                }
            });
        }
        return equivalences;
    };
    Util.encodeParentKeys = function (parentKeys) {
        var encoded = '';
        if (parentKeys) {
            encoded = Base64.encode(JSON.stringify(parentKeys));
        }
        return encoded;
    };
    Util.decodeParentKeys = function (parentKeys) {
        var decoded = {};
        if (parentKeys && parentKeys.length > 0) {
            var d = Base64.decode(parentKeys);
            decoded = JSON.parse(d);
        }
        return decoded;
    };
    Util.isArrayEmpty = function (array) {
        if (array && array.length === 0) {
            return true;
        }
        return false;
    };
    Util.isDataService = function (arg) {
        if (arg === undefined || arg === null) {
            return false;
        }
        return (arg.getDefaultServiceConfiguration !== undefined &&
            arg.configureService !== undefined);
    };
    Util.isPermissionsService = function (arg) {
        if (arg === undefined || arg === null) {
            return false;
        }
        return (arg.loadPermissions !== undefined);
    };
    Util.isFormDataComponent = function (arg) {
        if (arg === undefined || arg === null) {
            return false;
        }
        return (arg.isAutomaticBinding !== undefined);
    };
    Util.isEquivalent = function (a, b) {
        var aProps = Object.getOwnPropertyNames(a);
        var bProps = Object.getOwnPropertyNames(b);
        if (aProps.length !== bProps.length) {
            return false;
        }
        for (var i = 0; i < aProps.length; i++) {
            var propName = aProps[i];
            var bValue = b[propName];
            if (typeof a[propName] === 'number') {
                var intB = parseInt(bValue);
                bValue = isNaN(intB) ? bValue : intB;
            }
            if (a[propName] !== bValue) {
                return false;
            }
        }
        return true;
    };
    Util.equals = function (o1, o2) {
        if (o1 === o2) {
            return true;
        }
        if (o1 === null || o2 === null) {
            return false;
        }
        if (o1 !== o1 && o2 !== o2) {
            return true;
        }
        var t1 = typeof o1;
        var t2 = typeof o2;
        var length;
        var key;
        var keySet;
        if (t1 === t2 && t1 === 'object') {
            if (Array.isArray(o1)) {
                if (!Array.isArray(o2)) {
                    return false;
                }
                length = o1.length;
                if (length === o2.length) {
                    for (key = 0; key < length; key++) {
                        if (!Util.equals(o1[key], o2[key])) {
                            return false;
                        }
                    }
                    return true;
                }
            }
            else {
                if (Array.isArray(o2)) {
                    return false;
                }
                keySet = Object.create(null);
                for (key in o1) {
                    if (!Util.equals(o1[key], o2[key])) {
                        return false;
                    }
                    keySet[key] = true;
                }
                for (key in o2) {
                    if (!(key in keySet) && typeof o2[key] !== 'undefined') {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    };
    Util.isDefined = function (value) {
        return typeof value !== 'undefined' && value !== null;
    };
    Util.normalizeString = function (value, toLowerCase) {
        if (toLowerCase === void 0) { toLowerCase = true; }
        if (value && value.length) {
            var result = value.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            if (toLowerCase) {
                result = result.toLowerCase();
            }
            return result;
        }
        return '';
    };
    Util.flatten = function (array) {
        return [].concat.apply([], array);
    };
    Util.getValuesFromObject = function (obj) {
        if (obj === void 0) { obj = {}; }
        var array = [];
        Object.keys(obj).forEach(function (key) {
            if (typeof obj[key] === 'object') {
                array.push(Util.getValuesFromObject(obj[key]));
            }
            array.push(obj[key]);
        });
        return Util.flatten(array);
    };
    Util.parseIconPosition = function (value, defaultValue) {
        var result = defaultValue || Codes.ICON_POSITION_LEFT;
        var availablePositions = [Codes.ICON_POSITION_LEFT, Codes.ICON_POSITION_RIGHT];
        if (value && value.length) {
            result = value.toLowerCase();
        }
        if (availablePositions.indexOf(result) === -1) {
            result = defaultValue || Codes.ICON_POSITION_LEFT;
        }
        return result;
    };
    Util.copyToClipboard = function (data) {
        document.addEventListener('copy', function (e) {
            e.clipboardData.setData('text/plain', data);
            e.preventDefault();
            document.removeEventListener('copy', null);
        });
        document.execCommand('copy');
    };
    Util.checkPixelsValueString = function (value) {
        return typeof value === 'string' ? value.toLowerCase().endsWith('px') : false;
    };
    Util.extractPixelsValue = function (value, defaultValue) {
        if (defaultValue === void 0) { defaultValue = undefined; }
        var result = typeof value === 'number' ? value : undefined;
        if (Util.checkPixelsValueString(value)) {
            var parsed = parseFloat(value.substr(0, value.length - 'px'.length));
            result = isNaN(parsed) ? defaultValue : parsed;
        }
        return Util.isDefined(result) ? result : defaultValue;
    };
    Util.parseOInputsOptions = function (elRef, oInputsOptions) {
        if (oInputsOptions.iconColor === Codes.O_INPUTS_OPTIONS_COLOR_ACCENT) {
            var matFormFieldEL = elRef.nativeElement.getElementsByTagName('mat-form-field')[0];
            if (Util.isDefined(matFormFieldEL)) {
                matFormFieldEL.classList.add('accent');
            }
        }
    };
    Util.escapeSpecialCharacter = function (S) {
        var str = String(S);
        var cpList = Array.from(str[Symbol.iterator]());
        var cuList = [];
        for (var _i = 0, cpList_1 = cpList; _i < cpList_1.length; _i++) {
            var c = cpList_1[_i];
            if ('^$\\.*+?()[]{}|'.indexOf(c) !== -1) {
                cuList.push('\\');
            }
            cuList.push(c);
        }
        var L = cuList.join('');
        return L;
    };
    Util.differenceArrays = function (array1, array2) {
        var _this = this;
        var difference = array1.filter(function (obj) {
            return !array2.some(function (obj2) {
                return _this.equals(obj, obj2);
            });
        });
        return difference;
    };
    return Util;
}());
export { Util };
//# sourceMappingURL=util.js.map