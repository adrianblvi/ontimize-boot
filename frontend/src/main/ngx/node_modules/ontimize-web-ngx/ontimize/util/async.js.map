{"version":3,"file":"async.js","sourceRoot":"","sources":["../../../tmp/ontimize/util/async.ts"],"names":[],"mappings":"AAOA,OAAO,EAAE,UAAU,EAAE,OAAO,EAAE,MAAM,MAAM,CAAC;AAE3C,MAAM;AAEN,CAAC;AAED;IAAA;IAgCA,CAAC;IA9BQ,2BAAS,GAAhB,UACE,OAAY,EAAE,MAA0B,EAAE,OAAkC,EAC5E,UAEC;QAFD,2BAAA,EAAA;QAEA,CAAC;QACD,OAAO,GAAG,CAAC,OAAO,OAAO,KAAK,UAAU,CAAC,IAAI,OAAO,IAAI,IAAI,CAAC;QAC7D,UAAU,GAAG,CAAC,OAAO,UAAU,KAAK,UAAU,CAAC,IAAI,UAAU,IAAI,IAAI,CAAC;QACtE,OAAO,OAAO,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,CAAC,CAAC;IACnF,CAAC;IAEM,8BAAY,GAAnB,UAAoB,GAAQ,IAAa,OAAO,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC;IAK3D,gCAAc,GAArB,UAAsB,GAAsB,IAAa,OAAO,GAAG,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;IAEpF,yBAAO,GAAd,UAAe,YAAiB,IAAI,YAAY,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;IAK1D,0BAAQ,GAAf,UAAgB,OAA0B,EAAE,KAAU,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAEzE,0BAAQ,GAAf,UAAgB,OAA0B,EAAE,KAAU,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAEzE,2BAAS,GAAhB,UAAiB,OAA0B,EAAE,KAAU,IAAI,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAE3E,8BAAY,GAAnB,UAAoB,OAA0B,IAAI,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;IAEzE,wBAAC;AAAD,CAAC,AAhCD,IAgCC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Code copied from '@angular/core/src/facade/async of RC4. On RC5 this classes are removed!!\n */\nimport { EventEmitter } from '@angular/core';\nexport { Observable, Subject } from 'rxjs';\n\nexport function noop() {\n  //nothing to do\n}\n\nexport class ObservableWrapper {\n  // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg\n  static subscribe<T>(\n    emitter: any, onNext: (value: T) => void, onError?: (exception: any) => void,\n    onComplete: () => void = () => {\n      //nothing to do\n    }): Object {\n    onError = (typeof onError === 'function') && onError || noop;\n    onComplete = (typeof onComplete === 'function') && onComplete || noop;\n    return emitter.subscribe({ next: onNext, error: onError, complete: onComplete });\n  }\n\n  static isObservable(obs: any): boolean { return !!obs.subscribe; }\n\n  /**\n   * Returns whether `obs` has any subscribers listening to events.\n   */\n  static hasSubscribers(obs: EventEmitter<any>): boolean { return obs.observers.length > 0; }\n\n  static dispose(subscription: any) { subscription.unsubscribe(); }\n\n  /**\n   * @deprecated - use callEmit() instead\n   */\n  static callNext(emitter: EventEmitter<any>, value: any) { emitter.emit(value); }\n\n  static callEmit(emitter: EventEmitter<any>, value: any) { emitter.emit(value); }\n\n  static callError(emitter: EventEmitter<any>, error: any) { emitter.error(error); }\n\n  static callComplete(emitter: EventEmitter<any>) { emitter.complete(); }\n\n}\n\n"]}