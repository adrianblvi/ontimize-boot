import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { Observable } from 'rxjs';
import { share } from 'rxjs/operators';
import { AppConfig } from '../config/app-config';
import { LoginService } from '../services';
import { Codes, ServiceUtils } from '../utils';
export var EXPORT_PATH_DEFAULT = '/export';
export var DOWNLOAD_PATH_DEFAULT = EXPORT_PATH_DEFAULT + '/download';
var OExportExtension = (function () {
    function OExportExtension() {
    }
    OExportExtension.Excel = 'xlsx';
    OExportExtension.HTML = 'html';
    OExportExtension.PDF = 'pdf';
    return OExportExtension;
}());
export { OExportExtension };
var OntimizeExportService = (function () {
    function OntimizeExportService(injector) {
        this.injector = injector;
        this.EXPORT_PATH_DEFAULT = EXPORT_PATH_DEFAULT;
        this.DOWNLOAD_PATH_DEFAULT = DOWNLOAD_PATH_DEFAULT;
        this.exportPath = EXPORT_PATH_DEFAULT;
        this.downloadPath = DOWNLOAD_PATH_DEFAULT;
        this.httpClient = this.injector.get(HttpClient);
        this._config = this.injector.get(AppConfig);
        this._appConfig = this._config.getConfiguration();
    }
    OntimizeExportService.prototype.getDefaultServiceConfiguration = function (serviceName) {
        var loginService = this.injector.get(LoginService);
        var configuration = this._config.getServiceConfiguration();
        var servConfig = {};
        if (serviceName && configuration.hasOwnProperty(serviceName)) {
            servConfig = configuration[serviceName];
        }
        servConfig[Codes.SESSION_KEY] = loginService.getSessionInfo();
        return servConfig;
    };
    OntimizeExportService.prototype.configureService = function (config) {
        this._urlBase = config.urlBase ? config.urlBase : this._appConfig['apiEndpoint'];
        this._sessionid = config.session ? config.session.id : -1;
        if (config.exportPath) {
            this.exportPath = config.exportPath;
        }
        if (config.downloadPath) {
            this.downloadPath = config.downloadPath;
        }
    };
    Object.defineProperty(OntimizeExportService.prototype, "urlBase", {
        get: function () {
            return this._urlBase;
        },
        set: function (value) {
            this._urlBase = value;
        },
        enumerable: true,
        configurable: true
    });
    OntimizeExportService.prototype.exportData = function (data, format) {
        var url = this._urlBase + this.exportPath + '/' + format;
        var options = {
            headers: new HttpHeaders({
                'Access-Control-Allow-Origin': '*',
                'Content-Type': 'application/json;charset=UTF-8',
                'Authorization': 'Bearer ' + this._sessionid
            })
        };
        var body = JSON.stringify(data);
        var _innerObserver;
        var dataObservable = new Observable(function (observer) { return _innerObserver = observer; }).pipe(share());
        var self = this;
        this.httpClient.post(url, body, options).subscribe(function (resp) {
            if (resp && resp.code === Codes.ONTIMIZE_UNAUTHORIZED_CODE) {
                self.redirectLogin(true);
            }
            else if (resp.code === Codes.ONTIMIZE_FAILED_CODE) {
                _innerObserver.error(resp.message);
            }
            else if (resp.code === Codes.ONTIMIZE_SUCCESSFUL_CODE) {
                _innerObserver.next(resp);
            }
            else {
                _innerObserver.error('Service unavailable');
            }
        }, function (error) { return _innerObserver.error(error); }, function () { return _innerObserver.complete(); });
        return dataObservable;
    };
    OntimizeExportService.prototype.downloadFile = function (fileId, fileExtension) {
        var url = this._urlBase + this.downloadPath + '/' + fileExtension + '/' + fileId;
        var _innerObserver;
        var dataObservable = new Observable(function (observer) { return _innerObserver = observer; }).pipe(share());
        var options = {
            headers: new HttpHeaders({
                'Access-Control-Allow-Origin': '*',
                'Authorization': 'Bearer ' + this._sessionid
            }),
            'observe': 'response',
            'responseType': 'blob'
        };
        this.httpClient.get(url, options).subscribe(function (resp) {
            var fileData = resp.body;
            var fileURL = URL.createObjectURL(fileData);
            var a = document.createElement('a');
            document.body.appendChild(a);
            a.href = fileURL;
            a.download = fileId + '.' + fileExtension;
            a.click();
            document.body.removeChild(a);
            _innerObserver.next(fileData);
            URL.revokeObjectURL(fileURL);
        }, function (error) { return _innerObserver.error(error); }, function () { return _innerObserver.complete(); });
        return dataObservable;
    };
    OntimizeExportService.prototype.redirectLogin = function (sessionExpired) {
        if (sessionExpired === void 0) { sessionExpired = false; }
        var router = this.injector.get(Router);
        var loginService = this.injector.get(LoginService);
        if (sessionExpired) {
            loginService.sessionExpired();
        }
        ServiceUtils.redirectLogin(router, sessionExpired);
    };
    OntimizeExportService.decorators = [
        { type: Injectable },
    ];
    OntimizeExportService.ctorParameters = function () { return [
        { type: Injector }
    ]; };
    return OntimizeExportService;
}());
export { OntimizeExportService };
//# sourceMappingURL=ontimize-export.service.js.map