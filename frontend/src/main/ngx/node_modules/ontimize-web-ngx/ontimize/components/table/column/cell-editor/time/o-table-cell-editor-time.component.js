var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { ChangeDetectionStrategy, Component, ElementRef, HostListener, Injector, TemplateRef, ViewChild, ViewEncapsulation } from '@angular/core';
import { FormControl } from '@angular/forms';
import { DateAdapter, MatDatepickerInput, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material';
import { MAT_MOMENT_DATE_FORMATS, MomentDateAdapter } from '@angular/material-moment-adapter';
import moment from 'moment';
import { MomentService } from '../../../../../services/moment.service';
import { Codes } from '../../../../../util/codes';
import { Util } from '../../../../../util/util';
import { OBaseTableCellEditor } from '../o-base-table-cell-editor.class';
export var DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TIME = OBaseTableCellEditor.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR.concat([
    'oDateFormat: date-format',
    'oDateLocale: date-locale',
    'oDateStartView: date-start-view',
    'oMinDate: date-min',
    'oMaxDate: date-max',
    'oDateTouchUi: date-touch-ui',
    'oDateStartAt: date-start-at',
    'oHourFormat: hour-format',
    'oHourMin: hour-min',
    'oHourMax: hour-max',
    'oHourPlaceholder: hour-placeholder',
    'oDatePlaceholder: date-placeholder'
]);
export var DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TIME = OBaseTableCellEditor.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR.slice();
var Éµ0 = MAT_MOMENT_DATE_FORMATS;
var OTableCellEditorTimeComponent = (function (_super) {
    __extends(OTableCellEditorTimeComponent, _super);
    function OTableCellEditorTimeComponent(injector, adapter) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.adapter = adapter;
        _this.oStartView = 'month';
        _this.oDateFormat = 'L';
        _this.oHourFormat = Codes.TWENTY_FOUR_HOUR_FORMAT;
        _this.onKeyboardInputDone = false;
        _this.enabledCommitOnTabPress = false;
        _this.activeKeys = {};
        _this.momentSrv = _this.injector.get(MomentService);
        return _this;
    }
    OTableCellEditorTimeComponent.prototype.onDocumentKeydown = function (event) {
        this.handleKeydown(event);
    };
    OTableCellEditorTimeComponent.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
        this.createInternalFormControl();
        if (!this._oDateLocale) {
            this.oDateLocale = this.momentSrv.getLocale();
        }
        if (this.oMinDate) {
            var date = new Date(this.oMinDate);
            var momentD = moment(date);
            if (momentD.isValid()) {
                this.minDateString = momentD.format(this.oDateFormat);
            }
        }
        if (this.oMaxDate) {
            var date = new Date(this.oMaxDate);
            var momentD = moment(date);
            if (momentD.isValid()) {
                this.maxDateString = momentD.format(this.oDateFormat);
            }
        }
    };
    OTableCellEditorTimeComponent.prototype.createInternalFormControl = function () {
        if (!this.formControlDate) {
            var validators = this.resolveValidators();
            var cfg = {
                value: undefined,
                disabled: !this.enabled
            };
            this.formControlDate = new FormControl(cfg, validators);
            this.formGroup.addControl('dateInput', this.formControlDate);
        }
        if (!this.formControlHour) {
            var validators = this.resolveValidators();
            var cfg = {
                value: undefined,
                disabled: !this.enabled
            };
            this.formControlHour = new FormControl(cfg, validators);
            this.formGroup.addControl('hourInput', this.formControlHour);
        }
    };
    OTableCellEditorTimeComponent.prototype.ngAfterViewChecked = function () {
        this.modifyPickerMethods();
    };
    OTableCellEditorTimeComponent.prototype.setTime = function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.picker.setTime();
    };
    OTableCellEditorTimeComponent.prototype.onDateChange = function (event) {
        var isValid = event.value && event.value.isValid && event.value.isValid();
        var val = isValid ? event.value.valueOf() : moment().startOf('day');
        this.formControlDate.setValue(val, {
            emitModelToViewChange: false,
            emitEvent: false
        });
        this.updateComponentValue();
    };
    OTableCellEditorTimeComponent.prototype.updateValeOnInputChange = function (blurEvent) {
        if (this.onKeyboardInputDone) {
            var value = blurEvent.currentTarget.value;
            value = this.parseHour(value);
            this.formControlHour.setValue(value);
        }
        this.onKeyboardInputDone = false;
    };
    OTableCellEditorTimeComponent.prototype.parseHour = function (value) {
        var strArray = value.split(':');
        var hour = strArray[0];
        if (Codes.TWELVE_FOUR_HOUR_FORMAT === this.oHourFormat) {
            if (hour) {
                hour = parseInt(hour);
                var period = hour <= 12 ? ' AM' : ' PM';
                if (hour > 12) {
                    hour = hour - 12;
                }
                strArray[0] = hour;
                value = strArray.join(':') + period;
            }
        }
        return value;
    };
    OTableCellEditorTimeComponent.prototype.onHourChange = function (event) {
        var value;
        if (event instanceof Event) {
            this.updateValeOnInputChange(event);
        }
        else {
            value = this.convertToFormatString(event);
            this.formControlHour.setValue(value, {
                emitEvent: false,
                emitModelToViewChange: false
            });
        }
        this.updateComponentValue();
    };
    OTableCellEditorTimeComponent.prototype.setTimestampValue = function (value, options) {
        var parsedValue;
        var momentV = Util.isDefined(value) ? moment(value) : value;
        if (momentV && momentV.isValid()) {
            parsedValue = momentV.utcOffset(0).format(this.formatString);
        }
        this.formControlHour.setValue(parsedValue, options);
    };
    OTableCellEditorTimeComponent.prototype.convertToFormatString = function (value) {
        if (value === '00:00' || !Util.isDefined(value)) {
            return value;
        }
        var formatStr = this.oHourFormat === Codes.TWENTY_FOUR_HOUR_FORMAT ? 'HH:mm' : 'hh:mm a';
        var result = value;
        if (typeof value === 'number') {
            result = moment(value).format(formatStr);
        }
        else {
            result = value ? moment(value, 'h:mm A').format(formatStr) : value;
        }
        return result;
    };
    OTableCellEditorTimeComponent.prototype.openDatepicker = function (d) {
        this.datepicker = d;
        d.open();
    };
    OTableCellEditorTimeComponent.prototype.getPlaceholderHour = function () {
        var placeholder = '';
        if (this.oHourPlaceholder) {
            placeholder = this.translateService.get(this.oHourPlaceholder);
        }
        else {
            placeholder = _super.prototype.getPlaceholder.call(this);
        }
        return placeholder;
    };
    OTableCellEditorTimeComponent.prototype.getPlaceholderDate = function () {
        var placeholder = '';
        if (this.oDatePlaceholder) {
            placeholder = this.translateService.get(this.oDatePlaceholder);
        }
        else {
            placeholder = _super.prototype.getPlaceholder.call(this);
        }
        return placeholder;
    };
    OTableCellEditorTimeComponent.prototype.open = function (e) {
        if (Util.isDefined(e)) {
            e.stopPropagation();
        }
        if (this.picker) {
            this.picker.open();
        }
    };
    OTableCellEditorTimeComponent.prototype.handleKeydown = function (e) {
        this.activeKeys[e.keyCode] = true;
    };
    OTableCellEditorTimeComponent.prototype.handleKeyup = function (e) {
        this.activeKeys[e.keyCode] = false;
        var oColumn = this.table.getOColumn(this.tableColumn.attr);
        if (!oColumn) {
            return;
        }
        if (e.keyCode === 9 && (this.activeKeys[16] || !this.enabledCommitOnTabPress)) {
            return;
        }
        if (!oColumn.editing && this.datepicker && this.datepicker.opened) {
            this.datepicker.close();
        }
        else {
            _super.prototype.handleKeyup.call(this, e);
        }
    };
    OTableCellEditorTimeComponent.prototype.updateComponentValue = function () {
        var timeValue;
        var values = this.formGroup.getRawValue();
        var mDate = (values['dateInput'] ? moment(values['dateInput']) : moment()).startOf('day');
        var mHour = moment(values['hourInput'], this.formatString);
        timeValue = mDate.clone()
            .set('hour', mHour.get('hour'))
            .set('minute', mHour.get('minutes'))
            .valueOf();
        if (this.formControl) {
            this.formControl.setValue(timeValue);
            this.formControl.markAsDirty();
        }
    };
    OTableCellEditorTimeComponent.prototype.modifyPickerMethods = function () {
        var _this = this;
        if (this.picker) {
            var ngxTimepicker = this.picker.timepickerInput;
            if (ngxTimepicker && ngxTimepicker.onInput) {
                ngxTimepicker.onInput = function (value) { return _this.onKeyboardInputDone = true; };
            }
        }
    };
    OTableCellEditorTimeComponent.prototype.hasErrorDate = function (error) {
        return this.formControlDate && this.formControlDate.touched && this.hasErrorExclusive(error);
    };
    OTableCellEditorTimeComponent.prototype.hasErrorExclusive = function (error) {
        var hasError = false;
        var errorsOrder = ['matDatepickerMax', 'matDatepickerMin', 'matDatepickerFilter', 'matDatepickerParse', 'required'];
        var errors = this.formControlDate.errors;
        if (Util.isDefined(errors)) {
            if (Object.keys(errors).length === 1) {
                return errors.hasOwnProperty(error);
            }
            else {
                for (var i = 0, len = errorsOrder.length; i < len; i++) {
                    hasError = errors.hasOwnProperty(errorsOrder[i]);
                    if (hasError) {
                        hasError = (errorsOrder[i] === error);
                        break;
                    }
                }
            }
        }
        return hasError;
    };
    OTableCellEditorTimeComponent.prototype.hasErrorHour = function (error) {
        return this.formControlHour && this.formControlHour.touched;
    };
    OTableCellEditorTimeComponent.prototype.getCellDataDate = function () {
        var value = _super.prototype.getCellData.call(this);
        if (Util.isDefined(value)) {
            var m = moment(value);
            var result = value;
            if (Util.isDefined(m)) {
                result = m.toDate();
            }
            return result;
        }
        return value;
    };
    OTableCellEditorTimeComponent.prototype.getCellDataHour = function () {
        var value = _super.prototype.getCellData.call(this);
        if (Util.isDefined(value)) {
            var m = moment(value);
            var result = value;
            if (Util.isDefined(m)) {
                result = m.format(Codes.formatString(this.oHourFormat));
            }
            return result;
        }
        return value;
    };
    OTableCellEditorTimeComponent.prototype.startEdition = function (data) {
        _super.prototype.startEdition.call(this, data);
        var cellDataDate = this.getCellDataDate();
        this.formControlDate.setValue(cellDataDate);
        var cellDataHour = this.getCellDataHour();
        this.formControlHour.setValue(cellDataHour);
        this.formGroup.markAsTouched();
    };
    Object.defineProperty(OTableCellEditorTimeComponent.prototype, "formatString", {
        get: function () {
            return Codes.formatString(this.oHourFormat);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableCellEditorTimeComponent.prototype, "minDateString", {
        get: function () {
            return this._minDateString;
        },
        set: function (val) {
            this._minDateString = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableCellEditorTimeComponent.prototype, "maxDateString", {
        get: function () {
            return this._maxDateString;
        },
        set: function (val) {
            this._maxDateString = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableCellEditorTimeComponent.prototype, "oDateLocale", {
        set: function (value) {
            this._oDateLocale = value;
            if (Util.isDefined(this._oDateLocale)) {
                this.adapter.setLocale(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableCellEditorTimeComponent.prototype, "minDate", {
        get: function () {
            return new Date(this.oMinDate);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OTableCellEditorTimeComponent.prototype, "maxDate", {
        get: function () {
            return new Date(this.oMaxDate);
        },
        enumerable: true,
        configurable: true
    });
    OTableCellEditorTimeComponent.prototype.onDatepickerClosed = function () {
        this.dateInput.nativeElement.focus();
    };
    OTableCellEditorTimeComponent.prototype.onTimepickerClosed = function () {
        this.hourInput.nativeElement.focus();
    };
    OTableCellEditorTimeComponent.prototype.commitEdition = function () {
        if (!this.formGroup.invalid) {
            _super.prototype.commitEdition.call(this);
        }
    };
    OTableCellEditorTimeComponent.prototype.onKeyDown = function (e) {
        if (!Codes.isHourInputAllowed(e)) {
            e.preventDefault();
        }
    };
    OTableCellEditorTimeComponent.DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TIME = DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TIME;
    OTableCellEditorTimeComponent.DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TIME = DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TIME;
    OTableCellEditorTimeComponent.decorators = [
        { type: Component, args: [{
                    moduleId: module.id,
                    selector: 'o-table-cell-editor-time',
                    template: "\n    <ng-template #templateref let-cellvalue=\"cellvalue\" let-rowvalue=\"rowvalue\">\n      <div [formGroup]=\"formGroup\" class=\"o-table-cell-editor-time\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\"\n        fxLayoutGap=\"8px\">\n        <mat-form-field floatLabel=\"never\">\n\n          <input #dateInput matInput [placeholder]=\"getPlaceholderDate()\" [formControl]=\"formControlDate\"\n            [required]=\"orequired\" [matDatepicker]=\"d\" (dateChange)=\"onDateChange($event)\" [min]=\"minDate\" [max]=\"maxDate\"\n            (focus)=\"enabledCommitOnTabPress = false\">\n\n          <mat-datepicker #d [startView]=\"oStartView\" [startAt]=\"oStartAt\" [touchUi]=\"oTouchUi\" (closed)=\"onDatepickerClosed()\">\n          </mat-datepicker>\n\n          <span class=\"icon-btn\" (click)=\"openDatepicker(d)\" matSuffix>\n            <mat-icon svgIcon=\"ontimize:today\"></mat-icon>\n          </span>\n\n          <mat-error *ngIf=\"hasErrorDate('required') || hasErrorHour('required')\"\n            text=\"{{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\"></mat-error>\n          <mat-error *ngIf=\"hasErrorDate('matDatepickerParse')\"\n            text=\"{{ 'FORM_VALIDATION.DATE_PARSE' | oTranslate }} {{ format }}\"></mat-error>\n\n          <mat-error *ngIf=\"hasErrorDate('matDatepickerFilter')\" text=\"{{ 'FORM_VALIDATION.DATE_FILTER' | oTranslate }}\">\n          </mat-error>\n          <mat-error *ngIf=\"hasErrorDate('matDatepickerMin')\"\n            text=\"{{ 'FORM_VALIDATION.DATE_MIN' | oTranslate }} {{ minDateString }}\"></mat-error>\n\n          <mat-error *ngIf=\"hasErrorDate('matDatepickerMax')\"\n            text=\"{{ 'FORM_VALIDATION.DATE_MAX' | oTranslate }} {{ maxDateString }}\"></mat-error>\n\n        </mat-form-field>\n\n        <span class=\"separator\">&ndash;</span>\n\n        <mat-form-field floatLabel=\"never\">\n\n          <input #hourInput matInput [ngxTimepicker]=\"picker\" [placeholder]=\"getPlaceholderHour()\"\n            [formControl]=\"formControlHour\" [required]=\"orequired\" (change)=\"onHourChange($event)\" [min]=\"oHourMin\"\n            [max]=\"oHourMax\" (keydown)=\"onKeyDown($event)\" [disableClick]=\"true\" [format]=\"oHourFormat\"\n            (blur)=\"enabledCommitOnTabPress = true\">\n\n          <button type=\"button\" matSuffix mat-icon-button (click)=\"open($event)\">\n            <mat-icon ngxMaterialTimepickerToggleIcon svgIcon=\"ontimize:clock\"></mat-icon>\n          </button>\n\n          <mat-error *ngIf=\"hasErrorHour('invalidFormatHour')\"\n            text=\"{{ 'FORM_VALIDATION.HOUR_FORMAT' | oTranslate }} {{ formatString }}\"></mat-error>\n\n        </mat-form-field>\n\n        <ngx-material-timepicker #picker (timeSet)=\"onHourChange($event)\" [confirmBtnTmpl]=\"confirmBtn\"\n          [cancelBtnTmpl]=\"cancelBtn\" (closed)=\"onTimepickerClosed($event)\"></ngx-material-timepicker>\n        <ng-template #confirmBtn>\n          <button mat-stroked-button type=\"button\" (click)=\"setTime($event)\"><span>{{'OK' | oTranslate}}</span></button>\n        </ng-template>\n        <ng-template #cancelBtn>\n          <button mat-stroked-button type=\"button\" (click)=\"picker.close()\"><span>{{'CANCEL' | oTranslate}}</span></button>\n        </ng-template>\n      </div>\n\n    </ng-template>\n  ",
                    styles: ["\n    .separator{cursor:default}.mat-form-field:not(.custom-width) .mat-form-field-infix{width:84px}button.mat-stroked-button{margin:0 6px}\n  "],
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_TIME,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_TIME,
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        { provide: DateAdapter, useClass: MomentDateAdapter, deps: [MAT_DATE_LOCALE] },
                        { provide: MAT_DATE_FORMATS, useValue: Éµ0 },
                    ],
                },] },
    ];
    OTableCellEditorTimeComponent.ctorParameters = function () { return [
        { type: Injector },
        { type: DateAdapter }
    ]; };
    OTableCellEditorTimeComponent.propDecorators = {
        templateref: [{ type: ViewChild, args: ['templateref', { read: TemplateRef },] }],
        dateInput: [{ type: ViewChild, args: ['dateInput',] }],
        hourInput: [{ type: ViewChild, args: ['hourInput',] }],
        picker: [{ type: ViewChild, args: ['picker',] }],
        datepickerInput: [{ type: ViewChild, args: [MatDatepickerInput,] }],
        onDocumentKeydown: [{ type: HostListener, args: ['document:keydown', ['$event'],] }]
    };
    return OTableCellEditorTimeComponent;
}(OBaseTableCellEditor));
export { OTableCellEditorTimeComponent };
export { Éµ0 };
//# sourceMappingURL=o-table-cell-editor-time.component.js.map