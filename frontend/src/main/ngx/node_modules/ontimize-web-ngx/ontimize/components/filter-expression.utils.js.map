{"version":3,"file":"filter-expression.utils.js","sourceRoot":"","sources":["../../../tmp/ontimize/components/filter-expression.utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Defines an operation between two operands.\n */\nexport interface IExpression {\n  /** The left operand. */\n  lop: string | IExpression;\n  /** The operator. */\n  op: string;\n  /** The right operand. */\n  rop?: string | any[] | IExpression;\n}\n\nexport interface IBasicExpression {\n  '@basic_expression': IExpression;\n}\n\nexport interface IFilterExpression {\n  '@filter_expression': IExpression;\n}\n\n/**\n * Utility class for building basic and filter expressions.\n */\nexport class FilterExpressionUtils {\n\n  /**\n   * The basic expresion key.\n   */\n  static BASIC_EXPRESSION_KEY = '@basic_expression';\n\n  /**\n   * The filter expresion key.\n   */\n  static FILTER_EXPRESSION_KEY = '@filter_expression';\n\n  /**\n   * The `OR` operator.\n   */\n  static OP_OR: string = 'OR';\n\n  /**\n   * The `AND` operator.\n   */\n  static OP_AND: string = 'AND';\n\n  /**\n   * The `LIKE` operator\n   */\n  static OP_LIKE: string = 'LIKE';\n\n  /**\n   * The `NOT LIKE` operator.\n   */\n  static OP_NOT_LIKE: string = 'NOT LIKE';\n\n  /**\n   * The `EQUAL` operator.\n   */\n  static OP_EQUAL: string = '=';\n\n  /**\n   * The `NOT EQUAL` operator.\n   */\n  static OP_NOT_EQUAL: string = '<>';\n\n  /**\n   * The `IS NULL` operator.\n   */\n  static OP_NULL: string = 'IS NULL';\n\n  /**\n   * The `IS NOT NULL` operator.\n   */\n  static OP_NOT_NULL: string = 'IS NOT NULL';\n\n  /**\n   * The `LESS` operator.\n   */\n  static OP_LESS: string = '<';\n\n  /**\n   * The `LES EQUAL` operator.\n   */\n  static OP_LESS_EQUAL: string = '<=';\n\n  /**\n   * The `MORE` operator.\n   */\n  static OP_MORE: string = '>';\n\n  /**\n   * The `MORE EQUAL` operator.\n   */\n  static OP_MORE_EQUAL: string = '>=';\n\n  /**\n   * The `IN` operator.\n   */\n  static OP_IN: string = 'IN';\n\n  /**\n   * Evaluates if the the expression provided is an instance of `IBasicExpression`..\n   * @param arg the expression to evaluate.\n   * @returns `true` if the provided expression is an instance of `IBasicExpression`, `false` otherwise.\n   */\n  static instanceofBasicExpression(arg: any): boolean {\n    return arg.hasOwnProperty(FilterExpressionUtils.BASIC_EXPRESSION_KEY)\n      && FilterExpressionUtils.instanceofExpression(arg[FilterExpressionUtils.BASIC_EXPRESSION_KEY]);\n  }\n\n  /**\n   * Builds a `BasicExpression` instance from the filtering expression (`IExpression`) provided.\n   * @param exp the filtering expression.\n   * @returns the basic expression.\n   */\n  static buildBasicExpression(exp: IExpression): IBasicExpression {\n    if (exp) {\n      if (!FilterExpressionUtils.instanceofExpression(exp)) {\n        console.error('The expression provided is not an instance of \\'IExpression\\'');\n      }\n      let be: IBasicExpression = {\n        '@basic_expression': exp\n      };\n      return be;\n    }\n    return undefined;\n  }\n\n  /**\n   * Evaluates if an expresion is instance of `IFilterExpression`.\n   * @param exp the expression to evaluate.\n   * @returns `true` if the provided expression is an instance of `IFilterExpression`, `false` otherwise.\n   */\n  static instanceofFilterExpression(exp: any): boolean {\n    return exp.hasOwnProperty(FilterExpressionUtils.FILTER_EXPRESSION_KEY)\n      && FilterExpressionUtils.instanceofExpression(exp[FilterExpressionUtils.FILTER_EXPRESSION_KEY]);\n  }\n\n  /**\n   * Builds an `IFilterExpression` instance from the filtering expression (`IExpression`) provided.\n   * @param exp the filtering expression.\n   * @returns the `IFilterExpression`.\n   */\n  static buildFilterExpression(exp: IExpression): IFilterExpression {\n    if (exp) {\n      if (!FilterExpressionUtils.instanceofExpression(exp)) {\n        console.error('The expression provided is not an instance of \\'IExpression\\'');\n      }\n      let be: IFilterExpression = {\n        '@filter_expression': exp\n      };\n      return be;\n    }\n    return undefined;\n  }\n\n  /**\n   * Evaluates if an expresion is instance of `IExpression`.\n   * @param exp the expression to evaluate.\n   * @returns `true` if the provided expression is an instance of `IExpression`, `false` otherwise.\n   */\n  static instanceofExpression(exp: any): boolean {\n    return exp.hasOwnProperty('lop') && exp.hasOwnProperty('op');\n  }\n\n  /**\n   * Builds a complex `IExpression` instance joining two expressions with the provided operator.\n   * @param expr1 the first `IExpression` to join.\n   * @param expr2 the second `IExpression` to join.\n   * @param op the joining operator.\n   * @returns the complex `IExpression`.\n   */\n  static buildComplexExpression(expr1: IExpression, expr2: IExpression, op: string): IExpression {\n    if (expr1.lop === undefined && expr1.op === undefined) {\n      return expr2;\n    }\n    if (expr2.lop === undefined && expr2.op === undefined) {\n      return expr1;\n    }\n    let expr: IExpression = {\n      lop: expr1,\n      op: op,\n      rop: expr2\n    };\n    return expr;\n  }\n\n  /**\n   * Builds an `IExpression` instance for filtering the provided key EQUAL to the provided value.\n   * @param key the key.\n   * @param value the value.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionEquals(key: string, value: any): IExpression {\n    let expr: IExpression = {\n      lop: key,\n      op: FilterExpressionUtils.OP_EQUAL,\n      rop: value\n    };\n    return expr;\n  }\n\n  /**\n   * Builds an `IExpression` instance for filtering the provided key with a NOT NULL value.\n   * @param key the key.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionIsNotNull(key: string): IExpression {\n    let expr: IExpression = {\n      lop: key,\n      op: FilterExpressionUtils.OP_NOT_NULL\n    };\n    return expr;\n  }\n\n  /**\n   * Builds an `IExpression` instance for filtering the provided key with a NULL value.\n   * @param key the key.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionIsNull(key: string): IExpression {\n    let expr: IExpression = {\n      lop: key,\n      op: FilterExpressionUtils.OP_NULL\n    };\n    return expr;\n  }\n\n  /**\n   * Builds an `IExpression` instance for filtering the provided key LESS than the provided value.\n   * @param key the key.\n   * @param value the value.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionLess(key: string, value: any): IExpression {\n    let expr: IExpression = {\n      lop: key,\n      op: FilterExpressionUtils.OP_LESS,\n      rop: value\n    };\n    return expr;\n  }\n\n  /**\n   * Builds an `IExpression` instance for filtering the provided key LESS OR EQUAL to the provided value.\n   * @param key the key.\n   * @param value the value.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionLessEqual(key: string, value: any): IExpression {\n    let expr: IExpression = {\n      lop: key,\n      op: FilterExpressionUtils.OP_LESS_EQUAL,\n      rop: value\n    };\n    return expr;\n  }\n\n  /**\n   * Builds an `IExpression` instance for filtering the provided key MORE than the provided value.\n   * @param key the key.\n   * @param value the value.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionMore(key: string, value: any): IExpression {\n    let expr: IExpression = {\n      lop: key,\n      op: FilterExpressionUtils.OP_MORE,\n      rop: value\n    };\n    return expr;\n  }\n\n  /**\n   * Builds an `IExpression` instance for filtering the provided key MORE OR EQUAL to the provided value.\n   * @param key the key.\n   * @param value the value.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionMoreEqual(key: string, value: any): IExpression {\n    let expr: IExpression = {\n      lop: key,\n      op: FilterExpressionUtils.OP_MORE_EQUAL,\n      rop: value\n    };\n    return expr;\n  }\n\n  static buildExpressionIn(key: string, values: any[]): IExpression {\n    let expr: IExpression = {\n      lop: key,\n      op: FilterExpressionUtils.OP_IN,\n      rop: values\n    };\n    return expr;\n  }\n\n  /**\n   * Builds an `IExpression` instance for filtering the provided key NOT LIKE the provided value.\n   * @param key the key.\n   * @param value the value.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionNotLike(key: string, value: string): IExpression {\n    if (value !== undefined) {\n      value = value.replace(new RegExp('\\\\*', 'g'), '%');\n      if (value.indexOf('%') === -1) {\n        value = '%' + value + '%';\n      }\n    }\n    let expr: IExpression = {\n      lop: key,\n      op: FilterExpressionUtils.OP_NOT_LIKE,\n      rop: value\n    };\n    return expr;\n  }\n\n  /**\n   * Builds an `IExpression` instance for filtering the provided key LIKE the provided value.\n   * @param key the key.\n   * @param value the value.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionLike(key: string, value: string): IExpression {\n    if (value !== undefined) {\n      value = value.replace(new RegExp('\\\\*', 'g'), '%');\n      if (value.indexOf('%') === -1) {\n        value = '%' + value + '%';\n      }\n    }\n    let expr: IExpression = {\n      lop: key,\n      op: FilterExpressionUtils.OP_LIKE,\n      rop: value\n    };\n    return expr;\n  }\n\n  /**\n   * Builds an `IExpression` instance for filtering the provided key ENDS LIKE the provided value.\n   * @param key the key.\n   * @param value the value.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionLikeEnd(key: string, value: string): IExpression {\n    if (value !== undefined) {\n      value = '%' + value;\n    }\n    let expr: IExpression = {\n      lop: key,\n      op: FilterExpressionUtils.OP_LIKE,\n      rop: value\n    };\n    return expr;\n  }\n\n  /**\n   * Builds an `IExpression` instance for filtering the provided key STARTS LIKE the provided value.\n   * @param key the key.\n   * @param value the value.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionLikeStart(key: string, value: string): IExpression {\n    if (value !== undefined) {\n      value = value + '%';\n    }\n    let expr: IExpression = {\n      lop: key,\n      op: FilterExpressionUtils.OP_LIKE,\n      rop: value\n    };\n    return expr;\n  }\n\n  /**\n   * Builds an `IExpression` instance for filtering the provided key NOT EQUAL the provided value.\n   * @param key the key.\n   * @param value the value.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionNotEquals(key: string, value: any): IExpression {\n    let expr: IExpression = {\n      lop: key,\n      op: FilterExpressionUtils.OP_NOT_EQUAL,\n      rop: value\n    };\n    return expr;\n  }\n\n  /**\n   * Builds a complex `IExpression` for filtering the provided key with two conditions:\n   * * The first filter the provided key with a NULL value.\n   * * The second filter the provided key EQUAL to the provided value.\n   *\n   * Both expressions are joined using the provided operator.\n   * @param key the key.\n   * @param value the value.\n   * @param op the operator.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionNullAndValue(key: string, value: any, op: string): IExpression {\n    const isNull: IExpression = FilterExpressionUtils.buildExpressionIsNull(key);\n    const equals: IExpression = FilterExpressionUtils.buildExpressionEquals(key, value);\n    let expr: IExpression = {\n      lop: isNull,\n      op: op,\n      rop: equals\n    };\n    return expr;\n  }\n\n  /**\n   * Builds a complex `IExpression` for filtering the provided keys LIKE the value provided.\n   * @param keys the keys.\n   * @param value the value.\n   * @returns the `IExpression`.\n   */\n  static buildArrayExpressionLike(keys: any[], value: any): IExpression {\n    let result: IExpression = {\n      lop: undefined,\n      op: undefined\n    };\n    keys.forEach((col) => {\n      result = FilterExpressionUtils.stackExpressionLikeOR(col, value, result);\n    });\n    return result;\n  }\n\n  /**\n   * Builds an `IExpression` instance from the provided object.\n   * @param obj the object.\n   * @returns the `IExpression`.\n   */\n  static buildExpressionFromObject(obj: any): IExpression {\n    let result: IExpression = {\n      lop: undefined,\n      op: undefined\n    };\n    Object.keys(obj || {}).forEach((key) => {\n      result = FilterExpressionUtils.stackExpressionEqualsAND(key, obj[key], result);\n    });\n    return result;\n  }\n\n  private static stackExpressionLikeOR(key: string, value: any, expr: IExpression): IExpression {\n    const likeExpr = FilterExpressionUtils.buildExpressionLike(key, value);\n    if (expr.lop === undefined && expr.op === undefined) {\n      return likeExpr;\n    } else {\n      expr = FilterExpressionUtils.buildComplexExpression(expr, likeExpr, FilterExpressionUtils.OP_OR);\n    }\n    return expr;\n  }\n\n  private static stackExpressionEqualsAND(key: string, value: any, expr: IExpression): IExpression {\n    const equalsExpr = FilterExpressionUtils.buildExpressionEquals(key, value);\n    if (expr.lop === undefined && expr.op === undefined) {\n      return equalsExpr;\n    } else {\n      expr = FilterExpressionUtils.buildComplexExpression(expr, equalsExpr, FilterExpressionUtils.OP_AND);\n    }\n    return expr;\n  }\n\n}\n"]}